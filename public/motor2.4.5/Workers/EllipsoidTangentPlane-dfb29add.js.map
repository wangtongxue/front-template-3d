{"version":3,"file":"EllipsoidTangentPlane-dfb29add.js","sources":["../../../../Source/Core/AxisAlignedBoundingBox.js","../../../../Source/Core/EllipsoidTangentPlane.js"],"sourcesContent":["import Cartesian3 from './Cartesian3.js';\r\nimport Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport Intersect from './Intersect.js';\r\n\r\n    /**\r\n     * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.\r\n     * @alias AxisAlignedBoundingBox\r\n     * @constructor\r\n     *\r\n     * @param {Cartesian3} [minimum=Cartesian3.ZERO] The minimum point along the x, y, and z axes.\r\n     * @param {Cartesian3} [maximum=Cartesian3.ZERO] The maximum point along the x, y, and z axes.\r\n     * @param {Cartesian3} [center] The center of the box; automatically computed if not supplied.\r\n     *\r\n     * @see BoundingSphere\r\n     * @see BoundingRectangle\r\n     */\r\n    function AxisAlignedBoundingBox(minimum, maximum, center) {\r\n        /**\r\n         * The minimum point defining the bounding box.\r\n         * @type {Cartesian3}\r\n         * @default {@link Cartesian3.ZERO}\r\n         */\r\n        this.minimum = Cartesian3.clone(defaultValue(minimum, Cartesian3.ZERO));\r\n\r\n        /**\r\n         * The maximum point defining the bounding box.\r\n         * @type {Cartesian3}\r\n         * @default {@link Cartesian3.ZERO}\r\n         */\r\n        this.maximum = Cartesian3.clone(defaultValue(maximum, Cartesian3.ZERO));\r\n\r\n        //If center was not defined, compute it.\r\n        if (!defined(center)) {\r\n            center = Cartesian3.midpoint(this.minimum, this.maximum, new Cartesian3());\r\n        } else {\r\n            center = Cartesian3.clone(center);\r\n        }\r\n\r\n        /**\r\n         * The center point of the bounding box.\r\n         * @type {Cartesian3}\r\n         */\r\n        this.center = center;\r\n    }\r\n\r\n    /**\r\n     * Computes an instance of an AxisAlignedBoundingBox. The box is determined by\r\n     * finding the points spaced the farthest apart on the x, y, and z axes.\r\n     *\r\n     * @param {Cartesian3[]} positions List of points that the bounding box will enclose.  Each point must have a <code>x</code>, <code>y</code>, and <code>z</code> properties.\r\n     * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\r\n     * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\r\n     *\r\n     * @example\r\n     * // Compute an axis aligned bounding box enclosing two points.\r\n     * var box = Cesium.AxisAlignedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);\r\n     */\r\n    AxisAlignedBoundingBox.fromPoints = function(positions, result) {\r\n        if (!defined(result)) {\r\n            result = new AxisAlignedBoundingBox();\r\n        }\r\n\r\n        if (!defined(positions) || positions.length === 0) {\r\n            result.minimum = Cartesian3.clone(Cartesian3.ZERO, result.minimum);\r\n            result.maximum = Cartesian3.clone(Cartesian3.ZERO, result.maximum);\r\n            result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\r\n            return result;\r\n        }\r\n\r\n        var minimumX = positions[0].x;\r\n        var minimumY = positions[0].y;\r\n        var minimumZ = positions[0].z;\r\n\r\n        var maximumX = positions[0].x;\r\n        var maximumY = positions[0].y;\r\n        var maximumZ = positions[0].z;\r\n\r\n        var length = positions.length;\r\n        for ( var i = 1; i < length; i++) {\r\n            var p = positions[i];\r\n            var x = p.x;\r\n            var y = p.y;\r\n            var z = p.z;\r\n\r\n            minimumX = Math.min(x, minimumX);\r\n            maximumX = Math.max(x, maximumX);\r\n            minimumY = Math.min(y, minimumY);\r\n            maximumY = Math.max(y, maximumY);\r\n            minimumZ = Math.min(z, minimumZ);\r\n            maximumZ = Math.max(z, maximumZ);\r\n        }\r\n\r\n        var minimum = result.minimum;\r\n        minimum.x = minimumX;\r\n        minimum.y = minimumY;\r\n        minimum.z = minimumZ;\r\n\r\n        var maximum = result.maximum;\r\n        maximum.x = maximumX;\r\n        maximum.y = maximumY;\r\n        maximum.z = maximumZ;\r\n\r\n        result.center = Cartesian3.midpoint(minimum, maximum, result.center);\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Duplicates a AxisAlignedBoundingBox instance.\r\n     *\r\n     * @param {AxisAlignedBoundingBox} box The bounding box to duplicate.\r\n     * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\r\n     * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if none was provided. (Returns undefined if box is undefined)\r\n     */\r\n    AxisAlignedBoundingBox.clone = function(box, result) {\r\n        if (!defined(box)) {\r\n            return undefined;\r\n        }\r\n\r\n        if (!defined(result)) {\r\n            return new AxisAlignedBoundingBox(box.minimum, box.maximum, box.center);\r\n        }\r\n\r\n        result.minimum = Cartesian3.clone(box.minimum, result.minimum);\r\n        result.maximum = Cartesian3.clone(box.maximum, result.maximum);\r\n        result.center = Cartesian3.clone(box.center, result.center);\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Compares the provided AxisAlignedBoundingBox componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {AxisAlignedBoundingBox} [left] The first AxisAlignedBoundingBox.\r\n     * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox.\r\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n     */\r\n    AxisAlignedBoundingBox.equals = function(left, right) {\r\n        return (left === right) ||\r\n               ((defined(left)) &&\r\n                (defined(right)) &&\r\n                Cartesian3.equals(left.center, right.center) &&\r\n                Cartesian3.equals(left.minimum, right.minimum) &&\r\n                Cartesian3.equals(left.maximum, right.maximum));\r\n    };\r\n\r\n    var intersectScratch = new Cartesian3();\r\n    /**\r\n     * Determines which side of a plane a box is located.\r\n     *\r\n     * @param {AxisAlignedBoundingBox} box The bounding box to test.\r\n     * @param {Plane} plane The plane to test against.\r\n     * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\r\n     *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\r\n     *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\r\n     *                      intersects the plane.\r\n     */\r\n    AxisAlignedBoundingBox.intersectPlane = function(box, plane) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('box', box);\r\n        Check.defined('plane', plane);\r\n        //>>includeEnd('debug');\r\n\r\n        intersectScratch = Cartesian3.subtract(box.maximum, box.minimum, intersectScratch);\r\n        var h = Cartesian3.multiplyByScalar(intersectScratch, 0.5, intersectScratch); //The positive half diagonal\r\n        var normal = plane.normal;\r\n        var e = h.x * Math.abs(normal.x) + h.y * Math.abs(normal.y) + h.z * Math.abs(normal.z);\r\n        var s = Cartesian3.dot(box.center, normal) + plane.distance; //signed distance from center\r\n\r\n        if (s - e > 0) {\r\n            return Intersect.INSIDE;\r\n        }\r\n\r\n        if (s + e < 0) {\r\n            //Not in front because normals point inward\r\n            return Intersect.OUTSIDE;\r\n        }\r\n\r\n        return Intersect.INTERSECTING;\r\n    };\r\n\r\n    /**\r\n     * Duplicates this AxisAlignedBoundingBox instance.\r\n     *\r\n     * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\r\n     * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\r\n     */\r\n    AxisAlignedBoundingBox.prototype.clone = function(result) {\r\n        return AxisAlignedBoundingBox.clone(this, result);\r\n    };\r\n\r\n    /**\r\n     * Determines which side of a plane this box is located.\r\n     *\r\n     * @param {Plane} plane The plane to test against.\r\n     * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\r\n     *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\r\n     *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\r\n     *                      intersects the plane.\r\n     */\r\n    AxisAlignedBoundingBox.prototype.intersectPlane = function(plane) {\r\n        return AxisAlignedBoundingBox.intersectPlane(this, plane);\r\n    };\r\n\r\n    /**\r\n     * Compares this AxisAlignedBoundingBox against the provided AxisAlignedBoundingBox componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {AxisAlignedBoundingBox} [right] The right hand side AxisAlignedBoundingBox.\r\n     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     */\r\n    AxisAlignedBoundingBox.prototype.equals = function(right) {\r\n        return AxisAlignedBoundingBox.equals(this, right);\r\n    };\r\nexport default AxisAlignedBoundingBox;\r\n","import AxisAlignedBoundingBox from './AxisAlignedBoundingBox.js';\r\nimport Cartesian2 from './Cartesian2.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport Cartesian4 from './Cartesian4.js';\r\nimport Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport IntersectionTests from './IntersectionTests.js';\r\nimport Matrix4 from './Matrix4.js';\r\nimport Plane from './Plane.js';\r\nimport Ray from './Ray.js';\r\nimport Transforms from './Transforms.js';\r\n\r\n    var scratchCart4 = new Cartesian4();\r\n    /**\r\n     * A plane tangent to the provided ellipsoid at the provided origin.\r\n     * If origin is not on the surface of the ellipsoid, it's surface projection will be used.\r\n     * If origin is at the center of the ellipsoid, an exception will be thrown.\r\n     * @alias EllipsoidTangentPlane\r\n     * @constructor\r\n     *\r\n     * @param {Cartesian3} origin The point on the surface of the ellipsoid where the tangent plane touches.\r\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.\r\n     *\r\n     * @exception {DeveloperError} origin must not be at the center of the ellipsoid.\r\n     */\r\n    function EllipsoidTangentPlane(origin, ellipsoid) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('origin', origin);\r\n        //>>includeEnd('debug');\r\n\r\n        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n        origin = ellipsoid.scaleToGeodeticSurface(origin);\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(origin)) {\r\n            throw new DeveloperError('origin must not be at the center of the ellipsoid.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var eastNorthUp = Transforms.eastNorthUpToFixedFrame(origin, ellipsoid);\r\n        this._ellipsoid = ellipsoid;\r\n        this._origin = origin;\r\n        this._xAxis = Cartesian3.fromCartesian4(Matrix4.getColumn(eastNorthUp, 0, scratchCart4));\r\n        this._yAxis = Cartesian3.fromCartesian4(Matrix4.getColumn(eastNorthUp, 1, scratchCart4));\r\n\r\n        var normal = Cartesian3.fromCartesian4(Matrix4.getColumn(eastNorthUp, 2, scratchCart4));\r\n        this._plane = Plane.fromPointNormal(origin, normal);\r\n    }\r\n\r\n    Object.defineProperties(EllipsoidTangentPlane.prototype, {\r\n        /**\r\n         * Gets the ellipsoid.\r\n         * @memberof EllipsoidTangentPlane.prototype\r\n         * @type {Ellipsoid}\r\n         */\r\n        ellipsoid : {\r\n            get : function() {\r\n                return this._ellipsoid;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Gets the origin.\r\n         * @memberof EllipsoidTangentPlane.prototype\r\n         * @type {Cartesian3}\r\n         */\r\n        origin : {\r\n            get : function() {\r\n                return this._origin;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Gets the plane which is tangent to the ellipsoid.\r\n         * @memberof EllipsoidTangentPlane.prototype\r\n         * @readonly\r\n         * @type {Plane}\r\n         */\r\n        plane : {\r\n            get : function() {\r\n                return this._plane;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Gets the local X-axis (east) of the tangent plane.\r\n         * @memberof EllipsoidTangentPlane.prototype\r\n         * @readonly\r\n         * @type {Cartesian3}\r\n         */\r\n        xAxis : {\r\n            get : function() {\r\n                return this._xAxis;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Gets the local Y-axis (north) of the tangent plane.\r\n         * @memberof EllipsoidTangentPlane.prototype\r\n         * @readonly\r\n         * @type {Cartesian3}\r\n         */\r\n        yAxis : {\r\n            get : function() {\r\n                return this._yAxis;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Gets the local Z-axis (up) of the tangent plane.\r\n         * @member EllipsoidTangentPlane.prototype\r\n         * @readonly\r\n         * @type {Cartesian3}\r\n         */\r\n        zAxis : {\r\n            get : function() {\r\n                return this._plane.normal;\r\n            }\r\n        }\r\n    });\r\n\r\n    var tmp = new AxisAlignedBoundingBox();\r\n    /**\r\n     * Creates a new instance from the provided ellipsoid and the center\r\n     * point of the provided Cartesians.\r\n     *\r\n     * @param {Cartesian3} cartesians The list of positions surrounding the center point.\r\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.\r\n     */\r\n    EllipsoidTangentPlane.fromPoints = function(cartesians, ellipsoid) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('cartesians', cartesians);\r\n        //>>includeEnd('debug');\r\n\r\n        var box = AxisAlignedBoundingBox.fromPoints(cartesians, tmp);\r\n        return new EllipsoidTangentPlane(box.center, ellipsoid);\r\n    };\r\n\r\n    var scratchProjectPointOntoPlaneRay = new Ray();\r\n    var scratchProjectPointOntoPlaneCartesian3 = new Cartesian3();\r\n\r\n    /**\r\n     * Computes the projection of the provided 3D position onto the 2D plane, radially outward from the {@link EllipsoidTangentPlane.ellipsoid} coordinate system origin.\r\n     *\r\n     * @param {Cartesian3} cartesian The point to project.\r\n     * @param {Cartesian2} [result] The object onto which to store the result.\r\n     * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided. Undefined if there is no intersection point\r\n     */\r\n    EllipsoidTangentPlane.prototype.projectPointOntoPlane = function(cartesian, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('cartesian', cartesian);\r\n        //>>includeEnd('debug');\r\n\r\n        var ray = scratchProjectPointOntoPlaneRay;\r\n        ray.origin = cartesian;\r\n        Cartesian3.normalize(cartesian, ray.direction);\r\n\r\n        var intersectionPoint = IntersectionTests.rayPlane(ray, this._plane, scratchProjectPointOntoPlaneCartesian3);\r\n        if (!defined(intersectionPoint)) {\r\n            Cartesian3.negate(ray.direction, ray.direction);\r\n            intersectionPoint = IntersectionTests.rayPlane(ray, this._plane, scratchProjectPointOntoPlaneCartesian3);\r\n        }\r\n\r\n        if (defined(intersectionPoint)) {\r\n            var v = Cartesian3.subtract(intersectionPoint, this._origin, intersectionPoint);\r\n            var x = Cartesian3.dot(this._xAxis, v);\r\n            var y = Cartesian3.dot(this._yAxis, v);\r\n\r\n            if (!defined(result)) {\r\n                return new Cartesian2(x, y);\r\n            }\r\n            result.x = x;\r\n            result.y = y;\r\n            return result;\r\n        }\r\n        return undefined;\r\n    };\r\n\r\n    /**\r\n     * Computes the projection of the provided 3D positions onto the 2D plane (where possible), radially outward from the global origin.\r\n     * The resulting array may be shorter than the input array - if a single projection is impossible it will not be included.\r\n     *\r\n     * @see EllipsoidTangentPlane.projectPointOntoPlane\r\n     *\r\n     * @param {Cartesian3[]} cartesians The array of points to project.\r\n     * @param {Cartesian2[]} [result] The array of Cartesian2 instances onto which to store results.\r\n     * @returns {Cartesian2[]} The modified result parameter or a new array of Cartesian2 instances if none was provided.\r\n     */\r\n    EllipsoidTangentPlane.prototype.projectPointsOntoPlane = function(cartesians, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('cartesians', cartesians);\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            result = [];\r\n        }\r\n\r\n        var count = 0;\r\n        var length = cartesians.length;\r\n        for ( var i = 0; i < length; i++) {\r\n            var p = this.projectPointOntoPlane(cartesians[i], result[count]);\r\n            if (defined(p)) {\r\n                result[count] = p;\r\n                count++;\r\n            }\r\n        }\r\n        result.length = count;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the projection of the provided 3D position onto the 2D plane, along the plane normal.\r\n     *\r\n     * @param {Cartesian3} cartesian The point to project.\r\n     * @param {Cartesian2} [result] The object onto which to store the result.\r\n     * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.\r\n     */\r\n    EllipsoidTangentPlane.prototype.projectPointToNearestOnPlane = function(cartesian, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('cartesian', cartesian);\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            result = new Cartesian2();\r\n        }\r\n\r\n        var ray = scratchProjectPointOntoPlaneRay;\r\n        ray.origin = cartesian;\r\n        Cartesian3.clone(this._plane.normal, ray.direction);\r\n\r\n        var intersectionPoint = IntersectionTests.rayPlane(ray, this._plane, scratchProjectPointOntoPlaneCartesian3);\r\n        if (!defined(intersectionPoint)) {\r\n            Cartesian3.negate(ray.direction, ray.direction);\r\n            intersectionPoint = IntersectionTests.rayPlane(ray, this._plane, scratchProjectPointOntoPlaneCartesian3);\r\n        }\r\n\r\n        var v = Cartesian3.subtract(intersectionPoint, this._origin, intersectionPoint);\r\n        var x = Cartesian3.dot(this._xAxis, v);\r\n        var y = Cartesian3.dot(this._yAxis, v);\r\n\r\n        result.x = x;\r\n        result.y = y;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the projection of the provided 3D positions onto the 2D plane, along the plane normal.\r\n     *\r\n     * @see EllipsoidTangentPlane.projectPointToNearestOnPlane\r\n     *\r\n     * @param {Cartesian3[]} cartesians The array of points to project.\r\n     * @param {Cartesian2[]} [result] The array of Cartesian2 instances onto which to store results.\r\n     * @returns {Cartesian2[]} The modified result parameter or a new array of Cartesian2 instances if none was provided. This will have the same length as <code>cartesians</code>.\r\n     */\r\n    EllipsoidTangentPlane.prototype.projectPointsToNearestOnPlane = function(cartesians, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('cartesians', cartesians);\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            result = [];\r\n        }\r\n\r\n        var length = cartesians.length;\r\n        result.length = length;\r\n        for (var i = 0; i < length; i++) {\r\n            result[i] = this.projectPointToNearestOnPlane(cartesians[i], result[i]);\r\n        }\r\n        return result;\r\n    };\r\n\r\n    var projectPointsOntoEllipsoidScratch = new Cartesian3();\r\n    /**\r\n     * Computes the projection of the provided 2D position onto the 3D ellipsoid.\r\n     *\r\n     * @param {Cartesian2} cartesian The points to project.\r\n     * @param {Cartesian3} [result] The Cartesian3 instance to store result.\r\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\r\n     */\r\n    EllipsoidTangentPlane.prototype.projectPointOntoEllipsoid = function(cartesian, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('cartesian', cartesian);\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n\r\n        var ellipsoid = this._ellipsoid;\r\n        var origin = this._origin;\r\n        var xAxis = this._xAxis;\r\n        var yAxis = this._yAxis;\r\n        var tmp = projectPointsOntoEllipsoidScratch;\r\n\r\n        Cartesian3.multiplyByScalar(xAxis, cartesian.x, tmp);\r\n        result = Cartesian3.add(origin, tmp, result);\r\n        Cartesian3.multiplyByScalar(yAxis, cartesian.y, tmp);\r\n        Cartesian3.add(result, tmp, result);\r\n        ellipsoid.scaleToGeocentricSurface(result, result);\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the projection of the provided 2D positions onto the 3D ellipsoid.\r\n     *\r\n     * @param {Cartesian2[]} cartesians The array of points to project.\r\n     * @param {Cartesian3[]} [result] The array of Cartesian3 instances onto which to store results.\r\n     * @returns {Cartesian3[]} The modified result parameter or a new array of Cartesian3 instances if none was provided.\r\n     */\r\n    EllipsoidTangentPlane.prototype.projectPointsOntoEllipsoid = function(cartesians, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('cartesians', cartesians);\r\n        //>>includeEnd('debug');\r\n\r\n        var length = cartesians.length;\r\n        if (!defined(result)) {\r\n            result = new Array(length);\r\n        } else {\r\n            result.length = length;\r\n        }\r\n\r\n        for ( var i = 0; i < length; ++i) {\r\n            result[i] = this.projectPointOntoEllipsoid(cartesians[i], result[i]);\r\n        }\r\n\r\n        return result;\r\n    };\r\nexport default EllipsoidTangentPlane;\r\n"],"names":["AxisAlignedBoundingBox","minimum","maximum","center","this","Cartesian3","clone","defaultValue","ZERO","defined","midpoint","fromPoints","positions","result","length","minimumX","x","minimumY","y","minimumZ","z","maximumX","maximumY","maximumZ","i","p","Math","min","max","box","equals","left","right","intersectScratch","intersectPlane","plane","Check","subtract","h","multiplyByScalar","normal","e","abs","s","dot","distance","Intersect","INSIDE","OUTSIDE","INTERSECTING","prototype","scratchCart4","Cartesian4","EllipsoidTangentPlane","origin","ellipsoid","Ellipsoid","WGS84","scaleToGeodeticSurface","DeveloperError","eastNorthUp","Transforms","eastNorthUpToFixedFrame","_ellipsoid","_origin","_xAxis","fromCartesian4","Matrix4","getColumn","_yAxis","_plane","Plane","fromPointNormal","Object","defineProperties","get","xAxis","yAxis","zAxis","tmp","cartesians","scratchProjectPointOntoPlaneRay","Ray","scratchProjectPointOntoPlaneCartesian3","projectPointOntoPlane","cartesian","ray","normalize","direction","intersectionPoint","IntersectionTests","rayPlane","negate","v","Cartesian2","projectPointsOntoPlane","count","projectPointToNearestOnPlane","projectPointsToNearestOnPlane","projectPointsOntoEllipsoidScratch","projectPointOntoEllipsoid","add","scaleToGeocentricSurface","projectPointsOntoEllipsoid","Array"],"mappings":"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"}