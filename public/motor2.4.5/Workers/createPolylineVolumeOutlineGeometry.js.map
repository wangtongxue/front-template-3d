{"version":3,"file":"createPolylineVolumeOutlineGeometry.js","sources":["../../../../Source/Core/PolylineVolumeOutlineGeometry.js","../../../../Source/WorkersES6/createPolylineVolumeOutlineGeometry.js"],"sourcesContent":["import arrayRemoveDuplicates from './arrayRemoveDuplicates.js';\r\nimport BoundingRectangle from './BoundingRectangle.js';\r\nimport BoundingSphere from './BoundingSphere.js';\r\nimport Cartesian2 from './Cartesian2.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport ComponentDatatype from './ComponentDatatype.js';\r\nimport CornerType from './CornerType.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport Geometry from './Geometry.js';\r\nimport GeometryAttribute from './GeometryAttribute.js';\r\nimport GeometryAttributes from './GeometryAttributes.js';\r\nimport IndexDatatype from './IndexDatatype.js';\r\nimport CesiumMath from './Math.js';\r\nimport PolygonPipeline from './PolygonPipeline.js';\r\nimport PolylineVolumeGeometryLibrary from './PolylineVolumeGeometryLibrary.js';\r\nimport PrimitiveType from './PrimitiveType.js';\r\nimport WindingOrder from './WindingOrder.js';\r\n\r\n    function computeAttributes(positions, shape) {\r\n        var attributes = new GeometryAttributes();\r\n        attributes.position = new GeometryAttribute({\r\n            componentDatatype : ComponentDatatype.DOUBLE,\r\n            componentsPerAttribute : 3,\r\n            values : positions\r\n        });\r\n\r\n        var shapeLength = shape.length;\r\n        var vertexCount = attributes.position.values.length / 3;\r\n        var positionLength = positions.length / 3;\r\n        var shapeCount = positionLength / shapeLength;\r\n        var indices = IndexDatatype.createTypedArray(vertexCount, 2 * shapeLength * (shapeCount + 1));\r\n        var i, j;\r\n        var index = 0;\r\n        i = 0;\r\n        var offset = i * shapeLength;\r\n        for (j = 0; j < shapeLength - 1; j++) {\r\n            indices[index++] = j + offset;\r\n            indices[index++] = j + offset + 1;\r\n        }\r\n        indices[index++] = shapeLength - 1 + offset;\r\n        indices[index++] = offset;\r\n\r\n        i = shapeCount - 1;\r\n        offset = i * shapeLength;\r\n        for (j = 0; j < shapeLength - 1; j++) {\r\n            indices[index++] = j + offset;\r\n            indices[index++] = j + offset + 1;\r\n        }\r\n        indices[index++] = shapeLength - 1 + offset;\r\n        indices[index++] = offset;\r\n\r\n        for (i = 0; i < shapeCount - 1; i++) {\r\n            var firstOffset = shapeLength * i;\r\n            var secondOffset = firstOffset + shapeLength;\r\n            for (j = 0; j < shapeLength; j++) {\r\n                indices[index++] = j + firstOffset;\r\n                indices[index++] = j + secondOffset;\r\n            }\r\n        }\r\n\r\n        var geometry = new Geometry({\r\n            attributes : attributes,\r\n            indices : IndexDatatype.createTypedArray(vertexCount, indices),\r\n            boundingSphere : BoundingSphere.fromVertices(positions),\r\n            primitiveType : PrimitiveType.LINES\r\n        });\r\n\r\n        return geometry;\r\n    }\r\n\r\n    /**\r\n     * A description of a polyline with a volume (a 2D shape extruded along a polyline).\r\n     *\r\n     * @alias PolylineVolumeOutlineGeometry\r\n     * @constructor\r\n     *\r\n     * @param {Object} options Object with the following properties:\r\n     * @param {Cartesian3[]} options.polylinePositions An array of positions that define the center of the polyline volume.\r\n     * @param {Cartesian2[]} options.shapePositions An array of positions that define the shape to be extruded along the polyline\r\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\r\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n     * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\r\n     *\r\n     * @see PolylineVolumeOutlineGeometry#createGeometry\r\n     *\r\n     * @example\r\n     * function computeCircle(radius) {\r\n     *   var positions = [];\r\n     *   for (var i = 0; i < 360; i++) {\r\n     *     var radians = Cesium.Math.toRadians(i);\r\n     *     positions.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));\r\n     *   }\r\n     *   return positions;\r\n     * }\r\n     *\r\n     * var volumeOutline = new Cesium.PolylineVolumeOutlineGeometry({\r\n     *   polylinePositions : Cesium.Cartesian3.fromDegreesArray([\r\n     *     -72.0, 40.0,\r\n     *     -70.0, 35.0\r\n     *   ]),\r\n     *   shapePositions : computeCircle(100000.0)\r\n     * });\r\n     */\r\n    function PolylineVolumeOutlineGeometry(options) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n        var positions = options.polylinePositions;\r\n        var shape = options.shapePositions;\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(positions)) {\r\n            throw new DeveloperError('options.polylinePositions is required.');\r\n        }\r\n        if (!defined(shape)) {\r\n            throw new DeveloperError('options.shapePositions is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        this._positions = positions;\r\n        this._shape = shape;\r\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\r\n        this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\r\n        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\r\n        this._workerName = 'createPolylineVolumeOutlineGeometry';\r\n\r\n        var numComponents = 1 + positions.length * Cartesian3.packedLength;\r\n        numComponents += 1 + shape.length * Cartesian2.packedLength;\r\n\r\n        /**\r\n         * The number of elements used to pack the object into an array.\r\n         * @type {Number}\r\n         */\r\n        this.packedLength = numComponents + Ellipsoid.packedLength + 2;\r\n    }\r\n\r\n    /**\r\n     * Stores the provided instance into the provided array.\r\n     *\r\n     * @param {PolylineVolumeOutlineGeometry} value The value to pack.\r\n     * @param {Number[]} array The array to pack into.\r\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n     *\r\n     * @returns {Number[]} The array that was packed into\r\n     */\r\n    PolylineVolumeOutlineGeometry.pack = function(value, array, startingIndex) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(value)) {\r\n            throw new DeveloperError('value is required');\r\n        }\r\n        if (!defined(array)) {\r\n            throw new DeveloperError('array is required');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        var i;\r\n\r\n        var positions = value._positions;\r\n        var length = positions.length;\r\n        array[startingIndex++] = length;\r\n\r\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\r\n            Cartesian3.pack(positions[i], array, startingIndex);\r\n        }\r\n\r\n        var shape = value._shape;\r\n        length = shape.length;\r\n        array[startingIndex++] = length;\r\n\r\n        for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\r\n            Cartesian2.pack(shape[i], array, startingIndex);\r\n        }\r\n\r\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\r\n        startingIndex += Ellipsoid.packedLength;\r\n\r\n        array[startingIndex++] = value._cornerType;\r\n        array[startingIndex]   = value._granularity;\r\n\r\n        return array;\r\n    };\r\n\r\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\r\n    var scratchOptions = {\r\n        polylinePositions : undefined,\r\n        shapePositions : undefined,\r\n        ellipsoid : scratchEllipsoid,\r\n        height : undefined,\r\n        cornerType : undefined,\r\n        granularity : undefined\r\n    };\r\n\r\n    /**\r\n     * Retrieves an instance from a packed array.\r\n     *\r\n     * @param {Number[]} array The packed array.\r\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n     * @param {PolylineVolumeOutlineGeometry} [result] The object into which to store the result.\r\n     * @returns {PolylineVolumeOutlineGeometry} The modified result parameter or a new PolylineVolumeOutlineGeometry instance if one was not provided.\r\n     */\r\n    PolylineVolumeOutlineGeometry.unpack = function(array, startingIndex, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(array)) {\r\n            throw new DeveloperError('array is required');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        var i;\r\n\r\n        var length = array[startingIndex++];\r\n        var positions = new Array(length);\r\n\r\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\r\n            positions[i] = Cartesian3.unpack(array, startingIndex);\r\n        }\r\n\r\n        length = array[startingIndex++];\r\n        var shape = new Array(length);\r\n\r\n        for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\r\n            shape[i] = Cartesian2.unpack(array, startingIndex);\r\n        }\r\n\r\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\r\n        startingIndex += Ellipsoid.packedLength;\r\n\r\n        var cornerType = array[startingIndex++];\r\n        var granularity = array[startingIndex];\r\n\r\n        if (!defined(result)) {\r\n            scratchOptions.polylinePositions = positions;\r\n            scratchOptions.shapePositions = shape;\r\n            scratchOptions.cornerType = cornerType;\r\n            scratchOptions.granularity = granularity;\r\n            return new PolylineVolumeOutlineGeometry(scratchOptions);\r\n        }\r\n\r\n        result._positions = positions;\r\n        result._shape = shape;\r\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\r\n        result._cornerType = cornerType;\r\n        result._granularity = granularity;\r\n\r\n        return result;\r\n    };\r\n\r\n    var brScratch = new BoundingRectangle();\r\n\r\n    /**\r\n     * Computes the geometric representation of the outline of a polyline with a volume, including its vertices, indices, and a bounding sphere.\r\n     *\r\n     * @param {PolylineVolumeOutlineGeometry} polylineVolumeOutlineGeometry A description of the polyline volume outline.\r\n     * @returns {Geometry|undefined} The computed vertices and indices.\r\n     */\r\n    PolylineVolumeOutlineGeometry.createGeometry = function(polylineVolumeOutlineGeometry) {\r\n        var positions = polylineVolumeOutlineGeometry._positions;\r\n        var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\r\n        var shape2D = polylineVolumeOutlineGeometry._shape;\r\n        shape2D = PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(shape2D);\r\n\r\n        if (cleanPositions.length < 2 || shape2D.length < 3) {\r\n            return undefined;\r\n        }\r\n\r\n        if (PolygonPipeline.computeWindingOrder2D(shape2D) === WindingOrder.CLOCKWISE) {\r\n            shape2D.reverse();\r\n        }\r\n        var boundingRectangle = BoundingRectangle.fromPoints(shape2D, brScratch);\r\n\r\n        var computedPositions = PolylineVolumeGeometryLibrary.computePositions(cleanPositions, shape2D, boundingRectangle, polylineVolumeOutlineGeometry, false);\r\n        return computeAttributes(computedPositions, shape2D);\r\n    };\r\nexport default PolylineVolumeOutlineGeometry;\r\n","import defined from '../Core/defined.js';\r\nimport Ellipsoid from '../Core/Ellipsoid.js';\r\nimport PolylineVolumeOutlineGeometry from '../Core/PolylineVolumeOutlineGeometry.js';\r\n\r\n    function createPolylineVolumeOutlineGeometry(polylineVolumeOutlineGeometry, offset) {\r\n        if (defined(offset)) {\r\n            polylineVolumeOutlineGeometry = PolylineVolumeOutlineGeometry.unpack(polylineVolumeOutlineGeometry, offset);\r\n        }\r\n        polylineVolumeOutlineGeometry._ellipsoid = Ellipsoid.clone(polylineVolumeOutlineGeometry._ellipsoid);\r\n        return PolylineVolumeOutlineGeometry.createGeometry(polylineVolumeOutlineGeometry);\r\n    }\r\nexport default createPolylineVolumeOutlineGeometry;\r\n"],"names":["PolylineVolumeOutlineGeometry","options","positions","defaultValue","EMPTY_OBJECT","polylinePositions","shape","shapePositions","defined","DeveloperError","this","_positions","_shape","_ellipsoid","Ellipsoid","clone","ellipsoid","WGS84","_cornerType","cornerType","CornerType","ROUNDED","_granularity","granularity","CesiumMath","RADIANS_PER_DEGREE","_workerName","numComponents","length","Cartesian3","packedLength","Cartesian2","pack","value","array","startingIndex","i","scratchEllipsoid","UNIT_SPHERE","scratchOptions","undefined","height","unpack","result","Array","brScratch","BoundingRectangle","createGeometry","polylineVolumeOutlineGeometry","cleanPositions","arrayRemoveDuplicates","equalsEpsilon","shape2D","PolylineVolumeGeometryLibrary","removeDuplicatesFromShape","PolygonPipeline","computeWindingOrder2D","WindingOrder","CLOCKWISE","reverse","boundingRectangle","fromPoints","attributes","GeometryAttributes","position","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","j","shapeLength","vertexCount","shapeCount","indices","IndexDatatype","createTypedArray","index","offset","firstOffset","secondOffset","Geometry","boundingSphere","BoundingSphere","fromVertices","primitiveType","PrimitiveType","LINES","computeAttributes","computePositions"],"mappings":"srBA0GI,SAASA,EAA8BC,GAEnC,IAAIC,GADJD,EAAUE,eAAaF,EAASE,eAAaC,eACrBC,kBACpBC,EAAQL,EAAQM,eAGpB,IAAKC,UAAQN,GACT,MAAM,IAAIO,iBAAe,0CAE7B,IAAKD,UAAQF,GACT,MAAM,IAAIG,iBAAe,uCAI7BC,KAAKC,WAAaT,EAClBQ,KAAKE,OAASN,EACdI,KAAKG,WAAaC,YAAUC,MAAMZ,eAAaF,EAAQe,UAAWF,YAAUG,QAC5EP,KAAKQ,YAAcf,eAAaF,EAAQkB,WAAYC,aAAWC,SAC/DX,KAAKY,aAAenB,eAAaF,EAAQsB,YAAaC,aAAWC,oBACjEf,KAAKgB,YAAc,sCAEnB,IAAIC,EAAgB,EAAIzB,EAAU0B,OAASC,aAAWC,aACtDH,GAAiB,EAAIrB,EAAMsB,OAASG,aAAWD,aAM/CpB,KAAKoB,aAAeH,EAAgBb,YAAUgB,aAAe,EAYjE9B,EAA8BgC,KAAO,SAASC,EAAOC,EAAOC,GAExD,IAAK3B,UAAQyB,GACT,MAAM,IAAIxB,iBAAe,qBAE7B,IAAKD,UAAQ0B,GACT,MAAM,IAAIzB,iBAAe,qBAM7B,IAAI2B,EAFJD,EAAgBhC,eAAagC,EAAe,GAI5C,IAAIjC,EAAY+B,EAAMtB,WAClBiB,EAAS1B,EAAU0B,OAGvB,IAFAM,EAAMC,KAAmBP,EAEpBQ,EAAI,EAAGA,EAAIR,IAAUQ,EAAGD,GAAiBN,aAAWC,aACrDD,aAAWG,KAAK9B,EAAUkC,GAAIF,EAAOC,GAGzC,IAAI7B,EAAQ2B,EAAMrB,OAIlB,IAHAgB,EAAStB,EAAMsB,OACfM,EAAMC,KAAmBP,EAEpBQ,EAAI,EAAGA,EAAIR,IAAUQ,EAAGD,GAAiBJ,aAAWD,aACrDC,aAAWC,KAAK1B,EAAM8B,GAAIF,EAAOC,GASrC,OANArB,YAAUkB,KAAKC,EAAMpB,WAAYqB,EAAOC,GACxCA,GAAiBrB,YAAUgB,aAE3BI,EAAMC,KAAmBF,EAAMf,YAC/BgB,EAAMC,GAAmBF,EAAMX,aAExBY,GAGX,IAAIG,EAAmBvB,YAAUC,MAAMD,YAAUwB,aAC7CC,EAAiB,CACjBlC,uBAAoBmC,EACpBjC,oBAAiBiC,EACjBxB,UAAYqB,EACZI,YAASD,EACTrB,gBAAaqB,EACbjB,iBAAciB,GAWlBxC,EAA8B0C,OAAS,SAASR,EAAOC,EAAeQ,GAElE,IAAKnC,UAAQ0B,GACT,MAAM,IAAIzB,iBAAe,qBAM7B,IAAI2B,EAFJD,EAAgBhC,eAAagC,EAAe,GAI5C,IAAIP,EAASM,EAAMC,KACfjC,EAAY,IAAI0C,MAAMhB,GAE1B,IAAKQ,EAAI,EAAGA,EAAIR,IAAUQ,EAAGD,GAAiBN,aAAWC,aACrD5B,EAAUkC,GAAKP,aAAWa,OAAOR,EAAOC,GAG5CP,EAASM,EAAMC,KACf,IAAI7B,EAAQ,IAAIsC,MAAMhB,GAEtB,IAAKQ,EAAI,EAAGA,EAAIR,IAAUQ,EAAGD,GAAiBJ,aAAWD,aACrDxB,EAAM8B,GAAKL,aAAWW,OAAOR,EAAOC,GAGxC,IAAInB,EAAYF,YAAU4B,OAAOR,EAAOC,EAAeE,GACvDF,GAAiBrB,YAAUgB,aAE3B,IAAIX,EAAae,EAAMC,KACnBZ,EAAcW,EAAMC,GAExB,OAAK3B,UAAQmC,IAQbA,EAAOhC,WAAaT,EACpByC,EAAO/B,OAASN,EAChBqC,EAAO9B,WAAaC,YAAUC,MAAMC,EAAW2B,EAAO9B,YACtD8B,EAAOzB,YAAcC,EACrBwB,EAAOrB,aAAeC,EAEfoB,IAbHJ,EAAelC,kBAAoBH,EACnCqC,EAAehC,eAAiBD,EAChCiC,EAAepB,WAAaA,EAC5BoB,EAAehB,YAAcA,EACtB,IAAIvB,EAA8BuC,KAYjD,IAAIM,EAAY,IAAIC,2BAQpB9C,EAA8B+C,eAAiB,SAASC,GACpD,IAAI9C,EAAY8C,EAA8BrC,WAC1CsC,EAAiBC,wBAAsBhD,EAAW2B,aAAWsB,eAC7DC,EAAUJ,EAA8BpC,OAG5C,GAFAwC,EAAUC,gCAA8BC,0BAA0BF,KAE9DH,EAAerB,OAAS,GAAKwB,EAAQxB,OAAS,GAAlD,CAII2B,kBAAgBC,sBAAsBJ,KAAaK,eAAaC,WAChEN,EAAQO,UAEZ,IAAIC,EAAoBd,oBAAkBe,WAAWT,EAASP,GAG9D,OA9PJ,SAA2B3C,EAAWI,GAClC,IAAIwD,EAAa,IAAIC,qBACrBD,EAAWE,SAAW,IAAIC,oBAAkB,CACxCC,kBAAoBC,oBAAkBC,OACtCC,uBAAyB,EACzBC,OAASpE,IAGb,IAKIkC,EAAGmC,EALHC,EAAclE,EAAMsB,OACpB6C,EAAcX,EAAWE,SAASM,OAAO1C,OAAS,EAElD8C,EADiBxE,EAAU0B,OAAS,EACN4C,EAC9BG,EAAUC,gBAAcC,iBAAiBJ,EAAa,EAAID,GAAeE,EAAa,IAEtFI,EAAQ,EAERC,GADJ3C,EAAI,GACaoC,EACjB,IAAKD,EAAI,EAAGA,EAAIC,EAAc,EAAGD,IAC7BI,EAAQG,KAAWP,EAAIQ,EACvBJ,EAAQG,KAAWP,EAAIQ,EAAS,EAOpC,IALAJ,EAAQG,KAAWN,EAAc,EAAIO,EACrCJ,EAAQG,KAAWC,EAGnBA,GADA3C,EAAIsC,EAAa,GACJF,EACRD,EAAI,EAAGA,EAAIC,EAAc,EAAGD,IAC7BI,EAAQG,KAAWP,EAAIQ,EACvBJ,EAAQG,KAAWP,EAAIQ,EAAS,EAKpC,IAHAJ,EAAQG,KAAWN,EAAc,EAAIO,EACrCJ,EAAQG,KAAWC,EAEd3C,EAAI,EAAGA,EAAIsC,EAAa,EAAGtC,IAAK,CACjC,IAAI4C,EAAcR,EAAcpC,EAC5B6C,EAAeD,EAAcR,EACjC,IAAKD,EAAI,EAAGA,EAAIC,EAAaD,IACzBI,EAAQG,KAAWP,EAAIS,EACvBL,EAAQG,KAAWP,EAAIU,EAW/B,OAPe,IAAIC,WAAS,CACxBpB,WAAaA,EACba,QAAUC,gBAAcC,iBAAiBJ,EAAaE,GACtDQ,eAAiBC,iBAAeC,aAAanF,GAC7CoF,cAAgBC,gBAAcC,QAgN3BC,CADiBpC,gCAA8BqC,iBAAiBzC,EAAgBG,EAASQ,EAAmBZ,GAA+B,GACtGI,KC/QhD,SAA6CJ,EAA+B+B,GAKxE,OAJIvE,UAAQuE,KACR/B,EAAgChD,EAA8B0C,OAAOM,EAA+B+B,IAExG/B,EAA8BnC,WAAaC,YAAUC,MAAMiC,EAA8BnC,YAClFb,EAA8B+C,eAAeC"}