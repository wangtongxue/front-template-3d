{"version":3,"file":"createRectangleOutlineGeometry.js","sources":["../../../../Source/Core/RectangleOutlineGeometry.js","../../../../Source/WorkersES6/createRectangleOutlineGeometry.js"],"sourcesContent":["import arrayFill from './arrayFill.js';\r\nimport BoundingSphere from './BoundingSphere.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport Cartographic from './Cartographic.js';\r\nimport ComponentDatatype from './ComponentDatatype.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport Geometry from './Geometry.js';\r\nimport GeometryAttribute from './GeometryAttribute.js';\r\nimport GeometryAttributes from './GeometryAttributes.js';\r\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\r\nimport IndexDatatype from './IndexDatatype.js';\r\nimport CesiumMath from './Math.js';\r\nimport PolygonPipeline from './PolygonPipeline.js';\r\nimport PrimitiveType from './PrimitiveType.js';\r\nimport Rectangle from './Rectangle.js';\r\nimport RectangleGeometryLibrary from './RectangleGeometryLibrary.js';\r\n\r\n    var bottomBoundingSphere = new BoundingSphere();\r\n    var topBoundingSphere = new BoundingSphere();\r\n    var positionScratch = new Cartesian3();\r\n    var rectangleScratch = new Rectangle();\r\n\r\n    function constructRectangle(geometry, computedOptions) {\r\n        var ellipsoid = geometry._ellipsoid;\r\n        var height = computedOptions.height;\r\n        var width = computedOptions.width;\r\n        var northCap = computedOptions.northCap;\r\n        var southCap = computedOptions.southCap;\r\n\r\n        var rowHeight = height;\r\n        var widthMultiplier = 2;\r\n        var size = 0;\r\n        var corners = 4;\r\n        if (northCap) {\r\n            widthMultiplier -= 1;\r\n            rowHeight -= 1;\r\n            size += 1;\r\n            corners -= 2;\r\n        }\r\n        if (southCap) {\r\n            widthMultiplier -= 1;\r\n            rowHeight -= 1;\r\n            size += 1;\r\n            corners -= 2;\r\n        }\r\n        size += (widthMultiplier * width + 2 * rowHeight - corners);\r\n\r\n        var positions = new Float64Array(size * 3);\r\n\r\n        var posIndex = 0;\r\n        var row = 0;\r\n        var col;\r\n        var position = positionScratch;\r\n        if (northCap) {\r\n            RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, row, 0, position);\r\n            positions[posIndex++] = position.x;\r\n            positions[posIndex++] = position.y;\r\n            positions[posIndex++] = position.z;\r\n        } else {\r\n            for (col = 0; col < width; col++) {\r\n                RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, row, col, position);\r\n                positions[posIndex++] = position.x;\r\n                positions[posIndex++] = position.y;\r\n                positions[posIndex++] = position.z;\r\n            }\r\n        }\r\n\r\n        col = width - 1;\r\n        for (row = 1; row < height; row++) {\r\n            RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, row, col, position);\r\n            positions[posIndex++] = position.x;\r\n            positions[posIndex++] = position.y;\r\n            positions[posIndex++] = position.z;\r\n        }\r\n\r\n        row = height - 1;\r\n        if (!southCap) {  // if southCap is true, we dont need to add any more points because the south pole point was added by the iteration above\r\n            for (col = width - 2; col >= 0; col--) {\r\n                RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, row, col, position);\r\n                positions[posIndex++] = position.x;\r\n                positions[posIndex++] = position.y;\r\n                positions[posIndex++] = position.z;\r\n            }\r\n        }\r\n\r\n        col = 0;\r\n        for (row = height - 2; row > 0; row--) {\r\n            RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, row, col, position);\r\n            positions[posIndex++] = position.x;\r\n            positions[posIndex++] = position.y;\r\n            positions[posIndex++] = position.z;\r\n        }\r\n\r\n        var indicesSize = positions.length / 3 * 2;\r\n        var indices = IndexDatatype.createTypedArray(positions.length / 3, indicesSize);\r\n\r\n        var index = 0;\r\n        for (var i = 0; i < (positions.length / 3) - 1; i++) {\r\n            indices[index++] = i;\r\n            indices[index++] = i + 1;\r\n        }\r\n        indices[index++] = (positions.length / 3) - 1;\r\n        indices[index++] = 0;\r\n\r\n        var geo = new Geometry({\r\n            attributes : new GeometryAttributes(),\r\n            primitiveType : PrimitiveType.LINES\r\n        });\r\n\r\n        geo.attributes.position = new GeometryAttribute({\r\n            componentDatatype : ComponentDatatype.DOUBLE,\r\n            componentsPerAttribute : 3,\r\n            values : positions\r\n        });\r\n        geo.indices = indices;\r\n\r\n        return geo;\r\n    }\r\n\r\n    function constructExtrudedRectangle(rectangleGeometry, computedOptions) {\r\n        var surfaceHeight = rectangleGeometry._surfaceHeight;\r\n        var extrudedHeight = rectangleGeometry._extrudedHeight;\r\n        var ellipsoid = rectangleGeometry._ellipsoid;\r\n        var minHeight = extrudedHeight;\r\n        var maxHeight = surfaceHeight;\r\n        var geo = constructRectangle(rectangleGeometry, computedOptions);\r\n\r\n        var height = computedOptions.height;\r\n        var width = computedOptions.width;\r\n\r\n        var topPositions = PolygonPipeline.scaleToGeodeticHeight(geo.attributes.position.values, maxHeight, ellipsoid, false);\r\n        var length = topPositions.length;\r\n        var positions = new Float64Array(length * 2);\r\n        positions.set(topPositions);\r\n        var bottomPositions = PolygonPipeline.scaleToGeodeticHeight(geo.attributes.position.values, minHeight, ellipsoid);\r\n        positions.set(bottomPositions, length);\r\n        geo.attributes.position.values = positions;\r\n\r\n        var northCap = computedOptions.northCap;\r\n        var southCap = computedOptions.southCap;\r\n        var corners = 4;\r\n        if (northCap) {\r\n            corners -= 1;\r\n        }\r\n        if (southCap) {\r\n            corners -= 1;\r\n        }\r\n\r\n        var indicesSize = (positions.length / 3 + corners) * 2;\r\n        var indices = IndexDatatype.createTypedArray(positions.length / 3, indicesSize);\r\n        length = positions.length / 6;\r\n        var index = 0;\r\n        for (var i = 0; i < length - 1; i++) {\r\n            indices[index++] = i;\r\n            indices[index++] = i + 1;\r\n            indices[index++] = i + length;\r\n            indices[index++] = i + length + 1;\r\n        }\r\n        indices[index++] = length - 1;\r\n        indices[index++] = 0;\r\n        indices[index++] = length + length - 1;\r\n        indices[index++] = length;\r\n\r\n        indices[index++] = 0;\r\n        indices[index++] = length;\r\n\r\n        var bottomCorner;\r\n        if (northCap) {\r\n            bottomCorner = height - 1;\r\n        } else {\r\n            var topRightCorner = width - 1;\r\n            indices[index++] = topRightCorner;\r\n            indices[index++] = topRightCorner + length;\r\n            bottomCorner = width + height - 2;\r\n        }\r\n\r\n        indices[index++] = bottomCorner;\r\n        indices[index++] = bottomCorner + length;\r\n\r\n        if (!southCap) {\r\n            var bottomLeftCorner = width + bottomCorner - 1;\r\n            indices[index++] = bottomLeftCorner;\r\n            indices[index] = bottomLeftCorner + length;\r\n        }\r\n\r\n        geo.indices = indices;\r\n\r\n        return geo;\r\n    }\r\n\r\n    /**\r\n     * A description of the outline of a a cartographic rectangle on an ellipsoid centered at the origin.\r\n     *\r\n     * @alias RectangleOutlineGeometry\r\n     * @constructor\r\n     *\r\n     * @param {Object} options Object with the following properties:\r\n     * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\r\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle lies.\r\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n     * @param {Number} [options.height=0.0] The distance in meters between the rectangle and the ellipsoid surface.\r\n     * @param {Number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\r\n     * @param {Number} [options.extrudedHeight] The distance in meters between the rectangle's extruded face and the ellipsoid surface.\r\n     *\r\n     * @exception {DeveloperError} <code>options.rectangle.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\r\n     * @exception {DeveloperError} <code>options.rectangle.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\r\n     * @exception {DeveloperError} <code>options.rectangle.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\r\n     * @exception {DeveloperError} <code>options.rectangle.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\r\n     * @exception {DeveloperError} <code>options.rectangle.north</code> must be greater than <code>rectangle.south</code>.\r\n     *\r\n     * @see RectangleOutlineGeometry#createGeometry\r\n     *\r\n     * @example\r\n     * var rectangle = new Cesium.RectangleOutlineGeometry({\r\n     *   ellipsoid : Cesium.Ellipsoid.WGS84,\r\n     *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\r\n     *   height : 10000.0\r\n     * });\r\n     * var geometry = Cesium.RectangleOutlineGeometry.createGeometry(rectangle);\r\n     */\r\n    function RectangleOutlineGeometry(options) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n        var rectangle = options.rectangle;\r\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\r\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n        var rotation = defaultValue(options.rotation, 0.0);\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(rectangle)) {\r\n            throw new DeveloperError('rectangle is required.');\r\n        }\r\n        Rectangle.validate(rectangle);\r\n        if (rectangle.north < rectangle.south) {\r\n            throw new DeveloperError('options.rectangle.north must be greater than options.rectangle.south');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var height = defaultValue(options.height, 0.0);\r\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\r\n\r\n        this._rectangle = Rectangle.clone(rectangle);\r\n        this._granularity = granularity;\r\n        this._ellipsoid = ellipsoid;\r\n        this._surfaceHeight = Math.max(height, extrudedHeight);\r\n        this._rotation = rotation;\r\n        this._extrudedHeight = Math.min(height, extrudedHeight);\r\n        this._offsetAttribute = options.offsetAttribute;\r\n        this._workerName = 'createRectangleOutlineGeometry';\r\n    }\r\n\r\n    /**\r\n     * The number of elements used to pack the object into an array.\r\n     * @type {Number}\r\n     */\r\n    RectangleOutlineGeometry.packedLength = Rectangle.packedLength + Ellipsoid.packedLength + 5;\r\n\r\n    /**\r\n     * Stores the provided instance into the provided array.\r\n     *\r\n     * @param {RectangleOutlineGeometry} value The value to pack.\r\n     * @param {Number[]} array The array to pack into.\r\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n     *\r\n     * @returns {Number[]} The array that was packed into\r\n     */\r\n    RectangleOutlineGeometry.pack = function(value, array, startingIndex) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(value)) {\r\n            throw new DeveloperError('value is required');\r\n        }\r\n\r\n        if (!defined(array)) {\r\n            throw new DeveloperError('array is required');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        Rectangle.pack(value._rectangle, array, startingIndex);\r\n        startingIndex += Rectangle.packedLength;\r\n\r\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\r\n        startingIndex += Ellipsoid.packedLength;\r\n\r\n        array[startingIndex++] = value._granularity;\r\n        array[startingIndex++] = value._surfaceHeight;\r\n        array[startingIndex++] = value._rotation;\r\n        array[startingIndex++] = value._extrudedHeight;\r\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\r\n\r\n        return array;\r\n    };\r\n\r\n    var scratchRectangle = new Rectangle();\r\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\r\n    var scratchOptions = {\r\n        rectangle : scratchRectangle,\r\n        ellipsoid : scratchEllipsoid,\r\n        granularity : undefined,\r\n        height : undefined,\r\n        rotation : undefined,\r\n        extrudedHeight : undefined,\r\n        offsetAttribute : undefined\r\n    };\r\n\r\n    /**\r\n     * Retrieves an instance from a packed array.\r\n     *\r\n     * @param {Number[]} array The packed array.\r\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n     * @param {RectangleOutlineGeometry} [result] The object into which to store the result.\r\n     * @returns {RectangleOutlineGeometry} The modified result parameter or a new Quaternion instance if one was not provided.\r\n     */\r\n    RectangleOutlineGeometry.unpack = function(array, startingIndex, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(array)) {\r\n            throw new DeveloperError('array is required');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        var rectangle = Rectangle.unpack(array, startingIndex, scratchRectangle);\r\n        startingIndex += Rectangle.packedLength;\r\n\r\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\r\n        startingIndex += Ellipsoid.packedLength;\r\n\r\n        var granularity = array[startingIndex++];\r\n        var height = array[startingIndex++];\r\n        var rotation = array[startingIndex++];\r\n        var extrudedHeight = array[startingIndex++];\r\n        var offsetAttribute = array[startingIndex];\r\n\r\n        if (!defined(result)) {\r\n            scratchOptions.granularity = granularity;\r\n            scratchOptions.height = height;\r\n            scratchOptions.rotation = rotation;\r\n            scratchOptions.extrudedHeight = extrudedHeight;\r\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\r\n\r\n            return new RectangleOutlineGeometry(scratchOptions);\r\n        }\r\n\r\n        result._rectangle = Rectangle.clone(rectangle, result._rectangle);\r\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\r\n        result._surfaceHeight = height;\r\n        result._rotation = rotation;\r\n        result._extrudedHeight = extrudedHeight;\r\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\r\n\r\n        return result;\r\n    };\r\n\r\n    var nwScratch = new Cartographic();\r\n    /**\r\n     * Computes the geometric representation of an outline of a rectangle, including its vertices, indices, and a bounding sphere.\r\n     *\r\n     * @param {RectangleOutlineGeometry} rectangleGeometry A description of the rectangle outline.\r\n     * @returns {Geometry|undefined} The computed vertices and indices.\r\n     *\r\n     * @exception {DeveloperError} Rotated rectangle is invalid.\r\n     */\r\n    RectangleOutlineGeometry.createGeometry = function(rectangleGeometry) {\r\n        var rectangle = rectangleGeometry._rectangle;\r\n        var ellipsoid = rectangleGeometry._ellipsoid;\r\n        var computedOptions = RectangleGeometryLibrary.computeOptions(rectangle, rectangleGeometry._granularity, rectangleGeometry._rotation, 0, rectangleScratch, nwScratch);\r\n\r\n        var geometry;\r\n        var boundingSphere;\r\n\r\n        if ((CesiumMath.equalsEpsilon(rectangle.north, rectangle.south, CesiumMath.EPSILON10) ||\r\n             (CesiumMath.equalsEpsilon(rectangle.east, rectangle.west, CesiumMath.EPSILON10)))) {\r\n            return undefined;\r\n        }\r\n\r\n        var surfaceHeight = rectangleGeometry._surfaceHeight;\r\n        var extrudedHeight = rectangleGeometry._extrudedHeight;\r\n        var extrude = !CesiumMath.equalsEpsilon(surfaceHeight, extrudedHeight, 0, CesiumMath.EPSILON2);\r\n        var offsetValue;\r\n        if (extrude) {\r\n            geometry = constructExtrudedRectangle(rectangleGeometry, computedOptions);\r\n            if (defined(rectangleGeometry._offsetAttribute)) {\r\n                var size = geometry.attributes.position.values.length / 3;\r\n                var offsetAttribute = new Uint8Array(size);\r\n                if (rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.TOP) {\r\n                    offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\r\n                } else {\r\n                    offsetValue = rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\r\n                    offsetAttribute = arrayFill(offsetAttribute, offsetValue);\r\n                }\r\n\r\n                geometry.attributes.applyOffset = new GeometryAttribute({\r\n                    componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\r\n                    componentsPerAttribute : 1,\r\n                    values : offsetAttribute\r\n                });\r\n            }\r\n            var topBS = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, surfaceHeight, topBoundingSphere);\r\n            var bottomBS = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, extrudedHeight, bottomBoundingSphere);\r\n            boundingSphere = BoundingSphere.union(topBS, bottomBS);\r\n        } else {\r\n            geometry = constructRectangle(rectangleGeometry, computedOptions);\r\n            geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(geometry.attributes.position.values, surfaceHeight, ellipsoid, false);\r\n\r\n            if (defined(rectangleGeometry._offsetAttribute)) {\r\n                var length = geometry.attributes.position.values.length;\r\n                var applyOffset = new Uint8Array(length / 3);\r\n                offsetValue = rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\r\n                arrayFill(applyOffset, offsetValue);\r\n                geometry.attributes.applyOffset = new GeometryAttribute({\r\n                    componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\r\n                    componentsPerAttribute : 1,\r\n                    values : applyOffset\r\n                });\r\n            }\r\n\r\n            boundingSphere = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, surfaceHeight);\r\n        }\r\n\r\n        return new Geometry({\r\n            attributes : geometry.attributes,\r\n            indices : geometry.indices,\r\n            primitiveType : PrimitiveType.LINES,\r\n            boundingSphere : boundingSphere,\r\n            offsetAttribute : rectangleGeometry._offsetAttribute\r\n        });\r\n    };\r\nexport default RectangleOutlineGeometry;\r\n","import defined from '../Core/defined.js';\r\nimport Ellipsoid from '../Core/Ellipsoid.js';\r\nimport Rectangle from '../Core/Rectangle.js';\r\nimport RectangleOutlineGeometry from '../Core/RectangleOutlineGeometry.js';\r\n\r\n    function createRectangleOutlineGeometry(rectangleGeometry, offset) {\r\n        if (defined(offset)) {\r\n            rectangleGeometry = RectangleOutlineGeometry.unpack(rectangleGeometry, offset);\r\n        }\r\n        rectangleGeometry._ellipsoid = Ellipsoid.clone(rectangleGeometry._ellipsoid);\r\n        rectangleGeometry._rectangle = Rectangle.clone(rectangleGeometry._rectangle);\r\n        return RectangleOutlineGeometry.createGeometry(rectangleGeometry);\r\n    }\r\nexport default createRectangleOutlineGeometry;\r\n"],"names":["bottomBoundingSphere","BoundingSphere","topBoundingSphere","positionScratch","Cartesian3","rectangleScratch","Rectangle","constructRectangle","geometry","computedOptions","ellipsoid","_ellipsoid","height","width","northCap","southCap","rowHeight","widthMultiplier","size","corners","col","positions","Float64Array","posIndex","row","position","RectangleGeometryLibrary","computePosition","x","y","z","indicesSize","length","indices","IndexDatatype","createTypedArray","index","i","geo","Geometry","attributes","GeometryAttributes","primitiveType","PrimitiveType","LINES","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","RectangleOutlineGeometry","options","rectangle","defaultValue","EMPTY_OBJECT","granularity","CesiumMath","RADIANS_PER_DEGREE","Ellipsoid","WGS84","rotation","defined","DeveloperError","validate","north","south","extrudedHeight","this","_rectangle","clone","_granularity","_surfaceHeight","Math","max","_rotation","_extrudedHeight","min","_offsetAttribute","offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","scratchRectangle","scratchEllipsoid","UNIT_SPHERE","scratchOptions","undefined","unpack","result","nwScratch","Cartographic","createGeometry","rectangleGeometry","boundingSphere","computeOptions","equalsEpsilon","EPSILON10","east","west","offsetValue","surfaceHeight","EPSILON2","minHeight","maxHeight","topPositions","PolygonPipeline","scaleToGeodeticHeight","set","bottomPositions","bottomCorner","topRightCorner","bottomLeftCorner","constructExtrudedRectangle","Uint8Array","GeometryOffsetAttribute","TOP","arrayFill","NONE","applyOffset","UNSIGNED_BYTE","topBS","fromRectangle3D","bottomBS","union","offset"],"mappings":"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"}