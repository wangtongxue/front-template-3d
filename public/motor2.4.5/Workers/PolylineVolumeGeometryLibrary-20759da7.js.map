{"version":3,"file":"PolylineVolumeGeometryLibrary-20759da7.js","sources":["../../../../Source/Core/CornerType.js","../../../../Source/Core/PolylineVolumeGeometryLibrary.js"],"sourcesContent":["\r\n    /**\r\n     * Style options for corners.\r\n     *\r\n     * @demo The {@link https://sandcastle.cesium.com/index.html?src=Corridor.html&label=Geometries|Corridor Demo}\r\n     * demonstrates the three corner types, as used by {@link CorridorGraphics}.\r\n     *\r\n     * @exports CornerType\r\n     */\r\n    var CornerType = {\r\n        /**\r\n         * <img src=\"Images/CornerTypeRounded.png\" style=\"vertical-align: middle;\" width=\"186\" height=\"189\" />\r\n         *\r\n         * Corner has a smooth edge.\r\n         * @type {Number}\r\n         * @constant\r\n         */\r\n        ROUNDED : 0,\r\n\r\n        /**\r\n         * <img src=\"Images/CornerTypeMitered.png\" style=\"vertical-align: middle;\" width=\"186\" height=\"189\" />\r\n         *\r\n         * Corner point is the intersection of adjacent edges.\r\n         * @type {Number}\r\n         * @constant\r\n         */\r\n        MITERED : 1,\r\n\r\n        /**\r\n         * <img src=\"Images/CornerTypeBeveled.png\" style=\"vertical-align: middle;\" width=\"186\" height=\"189\" />\r\n         *\r\n         * Corner is clipped.\r\n         * @type {Number}\r\n         * @constant\r\n         */\r\n        BEVELED : 2\r\n    };\r\nexport default Object.freeze(CornerType);\r\n","import Cartesian2 from './Cartesian2.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport Cartesian4 from './Cartesian4.js';\r\nimport Cartographic from './Cartographic.js';\r\nimport CornerType from './CornerType.js';\r\nimport EllipsoidTangentPlane from './EllipsoidTangentPlane.js';\r\nimport CesiumMath from './Math.js';\r\nimport Matrix3 from './Matrix3.js';\r\nimport Matrix4 from './Matrix4.js';\r\nimport PolylinePipeline from './PolylinePipeline.js';\r\nimport Quaternion from './Quaternion.js';\r\nimport Transforms from './Transforms.js';\r\n\r\n    var scratch2Array = [new Cartesian3(), new Cartesian3()];\r\n    var scratchCartesian1 = new Cartesian3();\r\n    var scratchCartesian2 = new Cartesian3();\r\n    var scratchCartesian3 = new Cartesian3();\r\n    var scratchCartesian4 = new Cartesian3();\r\n    var scratchCartesian5 = new Cartesian3();\r\n    var scratchCartesian6 = new Cartesian3();\r\n    var scratchCartesian7 = new Cartesian3();\r\n    var scratchCartesian8 = new Cartesian3();\r\n    var scratchCartesian9 = new Cartesian3();\r\n\r\n    var scratch1 = new Cartesian3();\r\n    var scratch2 = new Cartesian3();\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    var PolylineVolumeGeometryLibrary = {};\r\n\r\n    var cartographic = new Cartographic();\r\n    function scaleToSurface(positions, ellipsoid) {\r\n        var heights = new Array(positions.length);\r\n        for (var i = 0; i < positions.length; i++) {\r\n            var pos = positions[i];\r\n            cartographic = ellipsoid.cartesianToCartographic(pos, cartographic);\r\n            heights[i] = cartographic.height;\r\n            positions[i] = ellipsoid.scaleToGeodeticSurface(pos, pos);\r\n        }\r\n        return heights;\r\n    }\r\n\r\n    function subdivideHeights(points, h0, h1, granularity) {\r\n        var p0 = points[0];\r\n        var p1 = points[1];\r\n        var angleBetween = Cartesian3.angleBetween(p0, p1);\r\n        var numPoints = Math.ceil(angleBetween / granularity);\r\n        var heights = new Array(numPoints);\r\n        var i;\r\n        if (h0 === h1) {\r\n            for (i = 0; i < numPoints; i++) {\r\n                heights[i] = h0;\r\n            }\r\n            heights.push(h1);\r\n            return heights;\r\n        }\r\n\r\n        var dHeight = h1 - h0;\r\n        var heightPerVertex = dHeight / (numPoints);\r\n\r\n        for (i = 1; i < numPoints; i++) {\r\n            var h = h0 + i * heightPerVertex;\r\n            heights[i] = h;\r\n        }\r\n\r\n        heights[0] = h0;\r\n        heights.push(h1);\r\n        return heights;\r\n    }\r\n\r\n    var nextScratch = new Cartesian3();\r\n    var prevScratch = new Cartesian3();\r\n\r\n    function computeRotationAngle(start, end, position, ellipsoid) {\r\n        var tangentPlane = new EllipsoidTangentPlane(position, ellipsoid);\r\n        var next = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, start, nextScratch), nextScratch);\r\n        var prev = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, end, prevScratch), prevScratch);\r\n        var angle = Cartesian2.angleBetween(next, prev);\r\n\r\n        return (prev.x * next.y - prev.y * next.x >= 0.0) ? -angle : angle;\r\n    }\r\n\r\n    var negativeX = new Cartesian3(-1, 0, 0);\r\n    var transform = new Matrix4();\r\n    var translation = new Matrix4();\r\n    var rotationZ = new Matrix3();\r\n    var scaleMatrix = Matrix3.IDENTITY.clone();\r\n    var westScratch = new Cartesian3();\r\n    var finalPosScratch = new Cartesian4();\r\n    var heightCartesian = new Cartesian3();\r\n    function addPosition(center, left, shape, finalPositions, ellipsoid, height, xScalar, repeat) {\r\n        var west = westScratch;\r\n        var finalPosition = finalPosScratch;\r\n        transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, transform);\r\n\r\n        west = Matrix4.multiplyByPointAsVector(transform, negativeX, west);\r\n        west = Cartesian3.normalize(west, west);\r\n        var angle = computeRotationAngle(west, left, center, ellipsoid);\r\n        rotationZ = Matrix3.fromRotationZ(angle, rotationZ);\r\n\r\n        heightCartesian.z = height;\r\n        transform = Matrix4.multiplyTransformation(transform, Matrix4.fromRotationTranslation(rotationZ, heightCartesian, translation), transform);\r\n        var scale = scaleMatrix;\r\n        scale[0] = xScalar;\r\n\r\n        for (var j = 0; j < repeat; j++) {\r\n            for (var i = 0; i < shape.length; i += 3) {\r\n                finalPosition = Cartesian3.fromArray(shape, i, finalPosition);\r\n                finalPosition = Matrix3.multiplyByVector(scale, finalPosition, finalPosition);\r\n                finalPosition = Matrix4.multiplyByPoint(transform, finalPosition, finalPosition);\r\n                finalPositions.push(finalPosition.x, finalPosition.y, finalPosition.z);\r\n            }\r\n        }\r\n\r\n        return finalPositions;\r\n    }\r\n\r\n    var centerScratch = new Cartesian3();\r\n    function addPositions(centers, left, shape, finalPositions, ellipsoid, heights, xScalar) {\r\n        for (var i = 0; i < centers.length; i += 3) {\r\n            var center = Cartesian3.fromArray(centers, i, centerScratch);\r\n            finalPositions = addPosition(center, left, shape, finalPositions, ellipsoid, heights[i / 3], xScalar, 1);\r\n        }\r\n        return finalPositions;\r\n    }\r\n\r\n    function convertShapeTo3DDuplicate(shape2D, boundingRectangle) { //orientate 2D shape to XZ plane center at (0, 0, 0), duplicate points\r\n        var length = shape2D.length;\r\n        var shape = new Array(length * 6);\r\n        var index = 0;\r\n        var xOffset = boundingRectangle.x + boundingRectangle.width / 2;\r\n        var yOffset = boundingRectangle.y + boundingRectangle.height / 2;\r\n\r\n        var point = shape2D[0];\r\n        shape[index++] = point.x - xOffset;\r\n        shape[index++] = 0.0;\r\n        shape[index++] = point.y - yOffset;\r\n        for (var i = 1; i < length; i++) {\r\n            point = shape2D[i];\r\n            var x = point.x - xOffset;\r\n            var z = point.y - yOffset;\r\n            shape[index++] = x;\r\n            shape[index++] = 0.0;\r\n            shape[index++] = z;\r\n\r\n            shape[index++] = x;\r\n            shape[index++] = 0.0;\r\n            shape[index++] = z;\r\n        }\r\n        point = shape2D[0];\r\n        shape[index++] = point.x - xOffset;\r\n        shape[index++] = 0.0;\r\n        shape[index++] = point.y - yOffset;\r\n\r\n        return shape;\r\n    }\r\n\r\n    function convertShapeTo3D(shape2D, boundingRectangle) { //orientate 2D shape to XZ plane center at (0, 0, 0)\r\n        var length = shape2D.length;\r\n        var shape = new Array(length * 3);\r\n        var index = 0;\r\n        var xOffset = boundingRectangle.x + boundingRectangle.width / 2;\r\n        var yOffset = boundingRectangle.y + boundingRectangle.height / 2;\r\n\r\n        for (var i = 0; i < length; i++) {\r\n            shape[index++] = shape2D[i].x - xOffset;\r\n            shape[index++] = 0;\r\n            shape[index++] = shape2D[i].y - yOffset;\r\n        }\r\n\r\n        return shape;\r\n    }\r\n\r\n    var quaterion = new Quaternion();\r\n    var startPointScratch = new Cartesian3();\r\n    var rotMatrix = new Matrix3();\r\n    function computeRoundCorner(pivot, startPoint, endPoint, cornerType, leftIsOutside, ellipsoid, finalPositions, shape, height, duplicatePoints) {\r\n        var angle = Cartesian3.angleBetween(Cartesian3.subtract(startPoint, pivot, scratch1), Cartesian3.subtract(endPoint, pivot, scratch2));\r\n        var granularity = (cornerType === CornerType.BEVELED) ? 0 : Math.ceil(angle / CesiumMath.toRadians(5));\r\n\r\n        var m;\r\n        if (leftIsOutside) {\r\n            m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(Cartesian3.negate(pivot, scratch1), angle / (granularity + 1), quaterion), rotMatrix);\r\n        } else {\r\n            m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(pivot, angle / (granularity + 1), quaterion), rotMatrix);\r\n        }\r\n\r\n        var left;\r\n        var surfacePoint;\r\n        startPoint = Cartesian3.clone(startPoint, startPointScratch);\r\n        if (granularity > 0) {\r\n            var repeat = duplicatePoints ? 2 : 1;\r\n            for (var i = 0; i < granularity; i++) {\r\n                startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);\r\n                left = Cartesian3.subtract(startPoint, pivot, scratch1);\r\n                left = Cartesian3.normalize(left, left);\r\n                if (!leftIsOutside) {\r\n                    left = Cartesian3.negate(left, left);\r\n                }\r\n                surfacePoint = ellipsoid.scaleToGeodeticSurface(startPoint, scratch2);\r\n                finalPositions = addPosition(surfacePoint, left, shape, finalPositions, ellipsoid, height, 1, repeat);\r\n            }\r\n        } else {\r\n            left = Cartesian3.subtract(startPoint, pivot, scratch1);\r\n            left = Cartesian3.normalize(left, left);\r\n            if (!leftIsOutside) {\r\n                left = Cartesian3.negate(left, left);\r\n            }\r\n            surfacePoint = ellipsoid.scaleToGeodeticSurface(startPoint, scratch2);\r\n            finalPositions = addPosition(surfacePoint, left, shape, finalPositions, ellipsoid, height, 1, 1);\r\n\r\n            endPoint = Cartesian3.clone(endPoint, startPointScratch);\r\n            left = Cartesian3.subtract(endPoint, pivot, scratch1);\r\n            left = Cartesian3.normalize(left, left);\r\n            if (!leftIsOutside) {\r\n                left = Cartesian3.negate(left, left);\r\n            }\r\n            surfacePoint = ellipsoid.scaleToGeodeticSurface(endPoint, scratch2);\r\n            finalPositions = addPosition(surfacePoint, left, shape, finalPositions, ellipsoid, height, 1, 1);\r\n        }\r\n\r\n        return finalPositions;\r\n    }\r\n\r\n    PolylineVolumeGeometryLibrary.removeDuplicatesFromShape = function(shapePositions) {\r\n        var length = shapePositions.length;\r\n        var cleanedPositions = [];\r\n        for (var i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {\r\n            var v0 = shapePositions[i0];\r\n            var v1 = shapePositions[i1];\r\n\r\n            if (!Cartesian2.equals(v0, v1)) {\r\n                cleanedPositions.push(v1); // Shallow copy!\r\n            }\r\n        }\r\n\r\n        return cleanedPositions;\r\n    };\r\n\r\n    PolylineVolumeGeometryLibrary.angleIsGreaterThanPi = function(forward, backward, position, ellipsoid) {\r\n        var tangentPlane = new EllipsoidTangentPlane(position, ellipsoid);\r\n        var next = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, forward, nextScratch), nextScratch);\r\n        var prev = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, backward, prevScratch), prevScratch);\r\n\r\n        return ((prev.x * next.y) - (prev.y * next.x)) >= 0.0;\r\n    };\r\n\r\n    var scratchForwardProjection = new Cartesian3();\r\n    var scratchBackwardProjection = new Cartesian3();\r\n\r\n    PolylineVolumeGeometryLibrary.computePositions = function(positions, shape2D, boundingRectangle, geometry, duplicatePoints) {\r\n        var ellipsoid = geometry._ellipsoid;\r\n        var heights = scaleToSurface(positions, ellipsoid);\r\n        var granularity = geometry._granularity;\r\n        var cornerType = geometry._cornerType;\r\n        var shapeForSides = duplicatePoints ? convertShapeTo3DDuplicate(shape2D, boundingRectangle) : convertShapeTo3D(shape2D, boundingRectangle);\r\n        var shapeForEnds = duplicatePoints ? convertShapeTo3D(shape2D, boundingRectangle) : undefined;\r\n        var heightOffset = boundingRectangle.height / 2;\r\n        var width = boundingRectangle.width / 2;\r\n        var length = positions.length;\r\n        var finalPositions = [];\r\n        var ends = duplicatePoints ? [] : undefined;\r\n\r\n        var forward = scratchCartesian1;\r\n        var backward = scratchCartesian2;\r\n        var cornerDirection = scratchCartesian3;\r\n        var surfaceNormal = scratchCartesian4;\r\n        var pivot = scratchCartesian5;\r\n        var start = scratchCartesian6;\r\n        var end = scratchCartesian7;\r\n        var left = scratchCartesian8;\r\n        var previousPosition = scratchCartesian9;\r\n\r\n        var position = positions[0];\r\n        var nextPosition = positions[1];\r\n        surfaceNormal = ellipsoid.geodeticSurfaceNormal(position, surfaceNormal);\r\n        forward = Cartesian3.subtract(nextPosition, position, forward);\r\n        forward = Cartesian3.normalize(forward, forward);\r\n        left = Cartesian3.cross(surfaceNormal, forward, left);\r\n        left = Cartesian3.normalize(left, left);\r\n        var h0 = heights[0];\r\n        var h1 = heights[1];\r\n        if (duplicatePoints) {\r\n            ends = addPosition(position, left, shapeForEnds, ends, ellipsoid, h0 + heightOffset, 1, 1);\r\n        }\r\n        previousPosition = Cartesian3.clone(position, previousPosition);\r\n        position = nextPosition;\r\n        backward = Cartesian3.negate(forward, backward);\r\n        var subdividedHeights;\r\n        var subdividedPositions;\r\n        for (var i = 1; i < length - 1; i++) {\r\n            var repeat = duplicatePoints ? 2 : 1;\r\n            nextPosition = positions[i + 1];\r\n            forward = Cartesian3.subtract(nextPosition, position, forward);\r\n            forward = Cartesian3.normalize(forward, forward);\r\n            cornerDirection = Cartesian3.add(forward, backward, cornerDirection);\r\n            cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\r\n            surfaceNormal = ellipsoid.geodeticSurfaceNormal(position, surfaceNormal);\r\n\r\n            var forwardProjection = Cartesian3.multiplyByScalar(surfaceNormal, Cartesian3.dot(forward, surfaceNormal), scratchForwardProjection);\r\n            Cartesian3.subtract(forward, forwardProjection, forwardProjection);\r\n            Cartesian3.normalize(forwardProjection, forwardProjection);\r\n\r\n            var backwardProjection = Cartesian3.multiplyByScalar(surfaceNormal, Cartesian3.dot(backward, surfaceNormal), scratchBackwardProjection);\r\n            Cartesian3.subtract(backward, backwardProjection, backwardProjection);\r\n            Cartesian3.normalize(backwardProjection, backwardProjection);\r\n\r\n            var doCorner = !CesiumMath.equalsEpsilon(Math.abs(Cartesian3.dot(forwardProjection, backwardProjection)), 1.0, CesiumMath.EPSILON7);\r\n\r\n            if (doCorner) {\r\n                cornerDirection = Cartesian3.cross(cornerDirection, surfaceNormal, cornerDirection);\r\n                cornerDirection = Cartesian3.cross(surfaceNormal, cornerDirection, cornerDirection);\r\n                cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\r\n                var scalar = 1 / Math.max(0.25, (Cartesian3.magnitude(Cartesian3.cross(cornerDirection, backward, scratch1))));\r\n                var leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(forward, backward, position, ellipsoid);\r\n                if (leftIsOutside) {\r\n                    pivot = Cartesian3.add(position, Cartesian3.multiplyByScalar(cornerDirection, scalar * width, cornerDirection), pivot);\r\n                    start = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, width, start), start);\r\n                    scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\r\n                    scratch2Array[1] = Cartesian3.clone(start, scratch2Array[1]);\r\n                    subdividedHeights = subdivideHeights(scratch2Array, h0 + heightOffset, h1 + heightOffset, granularity);\r\n                    subdividedPositions = PolylinePipeline.generateArc({\r\n                        positions: scratch2Array,\r\n                        granularity: granularity,\r\n                        ellipsoid: ellipsoid\r\n                    });\r\n                    finalPositions = addPositions(subdividedPositions, left, shapeForSides, finalPositions, ellipsoid, subdividedHeights, 1);\r\n                    left = Cartesian3.cross(surfaceNormal, forward, left);\r\n                    left = Cartesian3.normalize(left, left);\r\n                    end = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, width, end), end);\r\n                    if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {\r\n                        computeRoundCorner(pivot, start, end, cornerType, leftIsOutside, ellipsoid, finalPositions, shapeForSides, h1 + heightOffset, duplicatePoints);\r\n                    } else {\r\n                        cornerDirection = Cartesian3.negate(cornerDirection, cornerDirection);\r\n                        finalPositions = addPosition(position, cornerDirection, shapeForSides, finalPositions, ellipsoid, h1 + heightOffset, scalar, repeat);\r\n                    }\r\n                    previousPosition = Cartesian3.clone(end, previousPosition);\r\n                } else {\r\n                    pivot = Cartesian3.add(position, Cartesian3.multiplyByScalar(cornerDirection, scalar * width, cornerDirection), pivot);\r\n                    start = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, -width, start), start);\r\n                    scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\r\n                    scratch2Array[1] = Cartesian3.clone(start, scratch2Array[1]);\r\n                    subdividedHeights = subdivideHeights(scratch2Array, h0 + heightOffset, h1 + heightOffset, granularity);\r\n                    subdividedPositions = PolylinePipeline.generateArc({\r\n                        positions: scratch2Array,\r\n                        granularity: granularity,\r\n                        ellipsoid: ellipsoid\r\n                    });\r\n                    finalPositions = addPositions(subdividedPositions, left, shapeForSides, finalPositions, ellipsoid, subdividedHeights, 1);\r\n                    left = Cartesian3.cross(surfaceNormal, forward, left);\r\n                    left = Cartesian3.normalize(left, left);\r\n                    end = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, -width, end), end);\r\n                    if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {\r\n                        computeRoundCorner(pivot, start, end, cornerType, leftIsOutside, ellipsoid, finalPositions, shapeForSides, h1 + heightOffset, duplicatePoints);\r\n                    } else {\r\n                        finalPositions = addPosition(position, cornerDirection, shapeForSides, finalPositions, ellipsoid, h1 + heightOffset, scalar, repeat);\r\n                    }\r\n                    previousPosition = Cartesian3.clone(end, previousPosition);\r\n                }\r\n                backward = Cartesian3.negate(forward, backward);\r\n            } else {\r\n                finalPositions = addPosition(previousPosition, left, shapeForSides, finalPositions, ellipsoid, h0 + heightOffset, 1, 1);\r\n                previousPosition = position;\r\n            }\r\n            h0 = h1;\r\n            h1 = heights[i + 1];\r\n            position = nextPosition;\r\n        }\r\n\r\n        scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\r\n        scratch2Array[1] = Cartesian3.clone(position, scratch2Array[1]);\r\n        subdividedHeights = subdivideHeights(scratch2Array, h0 + heightOffset, h1 + heightOffset, granularity);\r\n        subdividedPositions = PolylinePipeline.generateArc({\r\n            positions: scratch2Array,\r\n            granularity: granularity,\r\n            ellipsoid: ellipsoid\r\n        });\r\n        finalPositions = addPositions(subdividedPositions, left, shapeForSides, finalPositions, ellipsoid, subdividedHeights, 1);\r\n        if (duplicatePoints) {\r\n            ends = addPosition(position, left, shapeForEnds, ends, ellipsoid, h1 + heightOffset, 1, 1);\r\n        }\r\n\r\n        length = finalPositions.length;\r\n        var posLength = duplicatePoints ? length + ends.length : length;\r\n        var combinedPositions = new Float64Array(posLength);\r\n        combinedPositions.set(finalPositions);\r\n        if (duplicatePoints) {\r\n            combinedPositions.set(ends, length);\r\n        }\r\n\r\n        return combinedPositions;\r\n    };\r\nexport default PolylineVolumeGeometryLibrary;\r\n"],"names":["Object","freeze","ROUNDED","MITERED","BEVELED","scratch2Array","Cartesian3","scratchCartesian1","scratchCartesian2","scratchCartesian3","scratchCartesian4","scratchCartesian5","scratchCartesian6","scratchCartesian7","scratchCartesian8","scratchCartesian9","scratch1","scratch2","PolylineVolumeGeometryLibrary","cartographic","Cartographic","subdivideHeights","points","h0","h1","granularity","i","p0","p1","angleBetween","numPoints","Math","ceil","heights","Array","push","heightPerVertex","h","nextScratch","prevScratch","negativeX","transform","Matrix4","translation","rotationZ","Matrix3","scaleMatrix","IDENTITY","clone","westScratch","finalPosScratch","Cartesian4","heightCartesian","addPosition","center","left","shape","finalPositions","ellipsoid","height","xScalar","repeat","west","finalPosition","Transforms","eastNorthUpToFixedFrame","multiplyByPointAsVector","angle","start","end","position","tangentPlane","EllipsoidTangentPlane","next","projectPointOntoPlane","add","prev","Cartesian2","x","y","computeRotationAngle","normalize","fromRotationZ","z","multiplyTransformation","fromRotationTranslation","scale","j","length","fromArray","multiplyByVector","multiplyByPoint","centerScratch","addPositions","centers","convertShapeTo3D","shape2D","boundingRectangle","index","xOffset","width","yOffset","quaterion","Quaternion","startPointScratch","rotMatrix","computeRoundCorner","pivot","startPoint","endPoint","cornerType","leftIsOutside","duplicatePoints","m","subtract","CornerType","CesiumMath","toRadians","fromQuaternion","fromAxisAngle","negate","scaleToGeodeticSurface","removeDuplicatesFromShape","shapePositions","cleanedPositions","i0","i1","v0","v1","equals","angleIsGreaterThanPi","forward","backward","scratchForwardProjection","scratchBackwardProjection","computePositions","positions","geometry","_ellipsoid","pos","cartesianToCartographic","scaleToSurface","_granularity","_cornerType","shapeForSides","point","convertShapeTo3DDuplicate","shapeForEnds","undefined","heightOffset","ends","cornerDirection","surfaceNormal","previousPosition","nextPosition","geodeticSurfaceNormal","cross","subdividedHeights","forwardProjection","multiplyByScalar","dot","backwardProjection","equalsEpsilon","abs","EPSILON7","scalar","max","magnitude","PolylinePipeline","generateArc","posLength","combinedPositions","Float64Array","set"],"mappings":"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"}