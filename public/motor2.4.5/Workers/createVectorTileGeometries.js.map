{"version":3,"file":"createVectorTileGeometries.js","sources":["../../../../Source/Scene/Vector3DTileBatch.js","../../../../Source/WorkersES6/createVectorTileGeometries.js"],"sourcesContent":["\r\n    /**\r\n     * Describes a renderable batch of geometry.\r\n     *\r\n     * @alias Vector3DTileBatch\r\n     * @constructor\r\n     *\r\n     * @param {Object} options An object with the following properties:\r\n     * @param {Number} options.offset The offset of the batch into the indices buffer.\r\n     * @param {Number} options.count The number of indices in the batch.\r\n     * @param {Color} options.color The color of the geometry in the batch.\r\n     * @param {Number[]} options.batchIds An array where each element is the batch id of the geometry in the batch.\r\n     *\r\n     * @private\r\n     */\r\n    function Vector3DTileBatch(options) {\r\n        /**\r\n         * The offset of the batch into the indices buffer.\r\n         * @type {Number}\r\n         */\r\n        this.offset = options.offset;\r\n        /**\r\n         * The number of indices in the batch.\r\n         * @type {Number}\r\n         */\r\n        this.count = options.count;\r\n        /**\r\n         * The color of the geometry in the batch.\r\n         * @type {Color}\r\n         */\r\n        this.color = options.color;\r\n        /**\r\n         * An array where each element is the batch id of the geometry in the batch.\r\n         * @type {Number[]}\r\n         */\r\n        this.batchIds = options.batchIds;\r\n    }\r\nexport default Vector3DTileBatch;\r\n","import BoundingSphere from '../Core/BoundingSphere.js';\r\nimport BoxGeometry from '../Core/BoxGeometry.js';\r\nimport Cartesian3 from '../Core/Cartesian3.js';\r\nimport Color from '../Core/Color.js';\r\nimport CylinderGeometry from '../Core/CylinderGeometry.js';\r\nimport defined from '../Core/defined.js';\r\nimport EllipsoidGeometry from '../Core/EllipsoidGeometry.js';\r\nimport IndexDatatype from '../Core/IndexDatatype.js';\r\nimport Matrix4 from '../Core/Matrix4.js';\r\nimport Vector3DTileBatch from '../Scene/Vector3DTileBatch.js';\r\nimport createTaskProcessorWorker from './createTaskProcessorWorker.js';\r\n\r\n    var scratchCartesian = new Cartesian3();\r\n\r\n    var packedBoxLength = Matrix4.packedLength + Cartesian3.packedLength;\r\n    var packedCylinderLength = Matrix4.packedLength + 2;\r\n    var packedEllipsoidLength = Matrix4.packedLength + Cartesian3.packedLength;\r\n    var packedSphereLength = Cartesian3.packedLength + 1;\r\n\r\n    var scratchModelMatrixAndBV = {\r\n        modelMatrix : new Matrix4(),\r\n        boundingVolume : new BoundingSphere()\r\n    };\r\n\r\n    function boxModelMatrixAndBoundingVolume(boxes, index) {\r\n        var boxIndex  = index * packedBoxLength;\r\n\r\n        var dimensions = Cartesian3.unpack(boxes, boxIndex, scratchCartesian);\r\n        boxIndex += Cartesian3.packedLength;\r\n\r\n        var boxModelMatrix = Matrix4.unpack(boxes, boxIndex, scratchModelMatrixAndBV.modelMatrix);\r\n        Matrix4.multiplyByScale(boxModelMatrix, dimensions, boxModelMatrix);\r\n\r\n        var boundingVolume = scratchModelMatrixAndBV.boundingVolume;\r\n        Cartesian3.clone(Cartesian3.ZERO, boundingVolume.center);\r\n        boundingVolume.radius = Math.sqrt(3.0);\r\n\r\n        return scratchModelMatrixAndBV;\r\n    }\r\n\r\n    function cylinderModelMatrixAndBoundingVolume(cylinders, index) {\r\n        var cylinderIndex = index * packedCylinderLength;\r\n\r\n        var cylinderRadius = cylinders[cylinderIndex++];\r\n        var length = cylinders[cylinderIndex++];\r\n        var scale = Cartesian3.fromElements(cylinderRadius, cylinderRadius, length, scratchCartesian);\r\n\r\n        var cylinderModelMatrix = Matrix4.unpack(cylinders, cylinderIndex, scratchModelMatrixAndBV.modelMatrix);\r\n        Matrix4.multiplyByScale(cylinderModelMatrix, scale, cylinderModelMatrix);\r\n\r\n        var boundingVolume = scratchModelMatrixAndBV.boundingVolume;\r\n        Cartesian3.clone(Cartesian3.ZERO, boundingVolume.center);\r\n        boundingVolume.radius = Math.sqrt(2.0);\r\n\r\n        return scratchModelMatrixAndBV;\r\n    }\r\n\r\n    function ellipsoidModelMatrixAndBoundingVolume(ellipsoids, index) {\r\n        var ellipsoidIndex = index * packedEllipsoidLength;\r\n\r\n        var radii = Cartesian3.unpack(ellipsoids, ellipsoidIndex, scratchCartesian);\r\n        ellipsoidIndex += Cartesian3.packedLength;\r\n\r\n        var ellipsoidModelMatrix = Matrix4.unpack(ellipsoids, ellipsoidIndex, scratchModelMatrixAndBV.modelMatrix);\r\n        Matrix4.multiplyByScale(ellipsoidModelMatrix, radii, ellipsoidModelMatrix);\r\n\r\n        var boundingVolume = scratchModelMatrixAndBV.boundingVolume;\r\n        Cartesian3.clone(Cartesian3.ZERO, boundingVolume.center);\r\n        boundingVolume.radius = 1.0;\r\n\r\n        return scratchModelMatrixAndBV;\r\n    }\r\n\r\n    function sphereModelMatrixAndBoundingVolume(spheres, index) {\r\n        var sphereIndex = index * packedSphereLength;\r\n\r\n        var sphereRadius = spheres[sphereIndex++];\r\n\r\n        var sphereTranslation = Cartesian3.unpack(spheres, sphereIndex, scratchCartesian);\r\n        var sphereModelMatrix = Matrix4.fromTranslation(sphereTranslation, scratchModelMatrixAndBV.modelMatrix);\r\n        Matrix4.multiplyByUniformScale(sphereModelMatrix, sphereRadius, sphereModelMatrix);\r\n\r\n        var boundingVolume = scratchModelMatrixAndBV.boundingVolume;\r\n        Cartesian3.clone(Cartesian3.ZERO, boundingVolume.center);\r\n        boundingVolume.radius = 1.0;\r\n\r\n        return scratchModelMatrixAndBV;\r\n    }\r\n\r\n    var scratchPosition = new Cartesian3();\r\n\r\n    function createPrimitive(options, primitive, primitiveBatchIds, geometry, getModelMatrixAndBoundingVolume) {\r\n        if (!defined(primitive)) {\r\n            return;\r\n        }\r\n\r\n        var numberOfPrimitives = primitiveBatchIds.length;\r\n        var geometryPositions = geometry.attributes.position.values;\r\n        var geometryIndices = geometry.indices;\r\n\r\n        var positions = options.positions;\r\n        var vertexBatchIds = options.vertexBatchIds;\r\n        var indices = options.indices;\r\n\r\n        var batchIds = options.batchIds;\r\n        var batchTableColors = options.batchTableColors;\r\n        var batchedIndices = options.batchedIndices;\r\n        var indexOffsets = options.indexOffsets;\r\n        var indexCounts = options.indexCounts;\r\n        var boundingVolumes = options.boundingVolumes;\r\n\r\n        var modelMatrix = options.modelMatrix;\r\n        var center = options.center;\r\n\r\n        var positionOffset = options.positionOffset;\r\n        var batchIdIndex = options.batchIdIndex;\r\n        var indexOffset = options.indexOffset;\r\n        var batchedIndicesOffset = options.batchedIndicesOffset;\r\n\r\n        for (var i = 0; i < numberOfPrimitives; ++i) {\r\n            var primitiveModelMatrixAndBV = getModelMatrixAndBoundingVolume(primitive, i);\r\n            var primitiveModelMatrix = primitiveModelMatrixAndBV.modelMatrix;\r\n            Matrix4.multiply(modelMatrix, primitiveModelMatrix, primitiveModelMatrix);\r\n\r\n            var batchId = primitiveBatchIds[i];\r\n\r\n            var positionsLength = geometryPositions.length;\r\n            for (var j = 0; j < positionsLength; j += 3) {\r\n                var position = Cartesian3.unpack(geometryPositions, j, scratchPosition);\r\n                Matrix4.multiplyByPoint(primitiveModelMatrix, position, position);\r\n                Cartesian3.subtract(position, center, position);\r\n\r\n                Cartesian3.pack(position, positions, positionOffset * 3 + j);\r\n                vertexBatchIds[batchIdIndex++] = batchId;\r\n            }\r\n\r\n            var indicesLength = geometryIndices.length;\r\n            for (var k = 0; k < indicesLength; ++k) {\r\n                indices[indexOffset + k] = geometryIndices[k] + positionOffset;\r\n            }\r\n\r\n            var offset = i + batchedIndicesOffset;\r\n            batchedIndices[offset] = new Vector3DTileBatch({\r\n                offset : indexOffset,\r\n                count : indicesLength,\r\n                color : Color.fromRgba(batchTableColors[batchId]),\r\n                batchIds : [batchId]\r\n            });\r\n            batchIds[offset] = batchId;\r\n            indexOffsets[offset] = indexOffset;\r\n            indexCounts[offset] = indicesLength;\r\n            boundingVolumes[offset] = BoundingSphere.transform(primitiveModelMatrixAndBV.boundingVolume, primitiveModelMatrix);\r\n\r\n            positionOffset += positionsLength / 3;\r\n            indexOffset += indicesLength;\r\n        }\r\n\r\n        options.positionOffset = positionOffset;\r\n        options.batchIdIndex = batchIdIndex;\r\n        options.indexOffset = indexOffset;\r\n        options.batchedIndicesOffset += numberOfPrimitives;\r\n    }\r\n\r\n    var scratchCenter = new Cartesian3();\r\n    var scratchMatrix4 = new Matrix4();\r\n\r\n    function unpackBuffer(buffer) {\r\n        var packedBuffer = new Float64Array(buffer);\r\n\r\n        var offset = 0;\r\n        Cartesian3.unpack(packedBuffer, offset, scratchCenter);\r\n        offset += Cartesian3.packedLength;\r\n\r\n        Matrix4.unpack(packedBuffer, offset, scratchMatrix4);\r\n    }\r\n\r\n    function packedBatchedIndicesLength(batchedIndices) {\r\n        var length = batchedIndices.length;\r\n        var count = 0;\r\n        for (var i = 0; i < length; ++i) {\r\n            count += Color.packedLength + 3 + batchedIndices[i].batchIds.length;\r\n        }\r\n        return count;\r\n    }\r\n\r\n    function packBuffer(indicesBytesPerElement, batchedIndices, boundingVolumes) {\r\n        var numBVs = boundingVolumes.length;\r\n        var length = 1 + 1 + numBVs * BoundingSphere.packedLength + 1 + packedBatchedIndicesLength(batchedIndices);\r\n\r\n        var packedBuffer = new Float64Array(length);\r\n\r\n        var offset = 0;\r\n        packedBuffer[offset++] = indicesBytesPerElement;\r\n        packedBuffer[offset++] = numBVs;\r\n\r\n        for (var i = 0; i < numBVs; ++i) {\r\n            BoundingSphere.pack(boundingVolumes[i], packedBuffer, offset);\r\n            offset += BoundingSphere.packedLength;\r\n        }\r\n\r\n        var indicesLength = batchedIndices.length;\r\n        packedBuffer[offset++] = indicesLength;\r\n\r\n        for (var j = 0; j < indicesLength; ++j) {\r\n            var batchedIndex = batchedIndices[j];\r\n\r\n            Color.pack(batchedIndex.color, packedBuffer, offset);\r\n            offset += Color.packedLength;\r\n\r\n            packedBuffer[offset++] = batchedIndex.offset;\r\n            packedBuffer[offset++] = batchedIndex.count;\r\n\r\n            var batchIds = batchedIndex.batchIds;\r\n            var batchIdsLength = batchIds.length;\r\n            packedBuffer[offset++] = batchIdsLength;\r\n\r\n            for (var k = 0; k < batchIdsLength; ++k) {\r\n                packedBuffer[offset++] = batchIds[k];\r\n            }\r\n        }\r\n\r\n        return packedBuffer;\r\n    }\r\n\r\n    function createVectorTileGeometries(parameters, transferableObjects) {\r\n        var boxes = defined(parameters.boxes) ? new Float32Array(parameters.boxes) : undefined;\r\n        var boxBatchIds = defined(parameters.boxBatchIds) ? new Uint16Array(parameters.boxBatchIds) : undefined;\r\n        var cylinders =  defined(parameters.cylinders) ? new Float32Array(parameters.cylinders) : undefined;\r\n        var cylinderBatchIds = defined(parameters.cylinderBatchIds) ? new Uint16Array(parameters.cylinderBatchIds) : undefined;\r\n        var ellipsoids =  defined(parameters.ellipsoids) ? new Float32Array(parameters.ellipsoids) : undefined;\r\n        var ellipsoidBatchIds = defined(parameters.ellipsoidBatchIds) ? new Uint16Array(parameters.ellipsoidBatchIds) : undefined;\r\n        var spheres = defined(parameters.spheres) ?  new Float32Array(parameters.spheres) : undefined;\r\n        var sphereBatchIds = defined(parameters.sphereBatchIds) ? new Uint16Array(parameters.sphereBatchIds) : undefined;\r\n\r\n        var numberOfBoxes = defined(boxes) ? boxBatchIds.length : 0;\r\n        var numberOfCylinders = defined(cylinders) ? cylinderBatchIds.length : 0;\r\n        var numberOfEllipsoids = defined(ellipsoids) ? ellipsoidBatchIds.length : 0;\r\n        var numberOfSpheres = defined(spheres) ? sphereBatchIds.length : 0;\r\n\r\n        var boxGeometry = BoxGeometry.getUnitBox();\r\n        var cylinderGeometry = CylinderGeometry.getUnitCylinder();\r\n        var ellipsoidGeometry = EllipsoidGeometry.getUnitEllipsoid();\r\n\r\n        var boxPositions = boxGeometry.attributes.position.values;\r\n        var cylinderPositions = cylinderGeometry.attributes.position.values;\r\n        var ellipsoidPositions = ellipsoidGeometry.attributes.position.values;\r\n\r\n        var numberOfPositions = boxPositions.length * numberOfBoxes;\r\n        numberOfPositions += cylinderPositions.length * numberOfCylinders;\r\n        numberOfPositions += ellipsoidPositions.length * (numberOfEllipsoids + numberOfSpheres);\r\n\r\n        var boxIndices = boxGeometry.indices;\r\n        var cylinderIndices = cylinderGeometry.indices;\r\n        var ellipsoidIndices = ellipsoidGeometry.indices;\r\n\r\n        var numberOfIndices = boxIndices.length * numberOfBoxes;\r\n        numberOfIndices += cylinderIndices.length * numberOfCylinders;\r\n        numberOfIndices += ellipsoidIndices.length * (numberOfEllipsoids + numberOfSpheres);\r\n\r\n        var positions = new Float32Array(numberOfPositions);\r\n        var vertexBatchIds = new Uint16Array(numberOfPositions / 3);\r\n        var indices = IndexDatatype.createTypedArray(numberOfPositions / 3, numberOfIndices);\r\n\r\n        var numberOfGeometries = numberOfBoxes + numberOfCylinders + numberOfEllipsoids + numberOfSpheres;\r\n        var batchIds = new Uint16Array(numberOfGeometries);\r\n        var batchedIndices = new Array(numberOfGeometries);\r\n        var indexOffsets = new Uint32Array(numberOfGeometries);\r\n        var indexCounts = new Uint32Array(numberOfGeometries);\r\n        var boundingVolumes = new Array(numberOfGeometries);\r\n\r\n        unpackBuffer(parameters.packedBuffer);\r\n\r\n        var options = {\r\n            batchTableColors : new Uint32Array(parameters.batchTableColors),\r\n            positions : positions,\r\n            vertexBatchIds : vertexBatchIds,\r\n            indices : indices,\r\n            batchIds : batchIds,\r\n            batchedIndices : batchedIndices,\r\n            indexOffsets : indexOffsets,\r\n            indexCounts : indexCounts,\r\n            boundingVolumes : boundingVolumes,\r\n            positionOffset : 0,\r\n            batchIdIndex : 0,\r\n            indexOffset : 0,\r\n            batchedIndicesOffset : 0,\r\n            modelMatrix : scratchMatrix4,\r\n            center : scratchCenter\r\n        };\r\n\r\n        createPrimitive(options, boxes, boxBatchIds, boxGeometry, boxModelMatrixAndBoundingVolume);\r\n        createPrimitive(options, cylinders, cylinderBatchIds, cylinderGeometry, cylinderModelMatrixAndBoundingVolume);\r\n        createPrimitive(options, ellipsoids, ellipsoidBatchIds, ellipsoidGeometry, ellipsoidModelMatrixAndBoundingVolume);\r\n        createPrimitive(options, spheres, sphereBatchIds, ellipsoidGeometry, sphereModelMatrixAndBoundingVolume);\r\n\r\n        var packedBuffer = packBuffer(indices.BYTES_PER_ELEMENT, batchedIndices, boundingVolumes);\r\n        transferableObjects.push(positions.buffer, vertexBatchIds.buffer, indices.buffer);\r\n        transferableObjects.push(batchIds.buffer, indexOffsets.buffer, indexCounts.buffer);\r\n        transferableObjects.push(packedBuffer.buffer);\r\n\r\n        return {\r\n            positions : positions.buffer,\r\n            vertexBatchIds : vertexBatchIds.buffer,\r\n            indices : indices.buffer,\r\n            indexOffsets : indexOffsets.buffer,\r\n            indexCounts : indexCounts.buffer,\r\n            batchIds : batchIds.buffer,\r\n            packedBuffer : packedBuffer.buffer\r\n        };\r\n    }\r\nexport default createTaskProcessorWorker(createVectorTileGeometries);\r\n"],"names":["Vector3DTileBatch","options","this","offset","count","color","batchIds","scratchCartesian","Cartesian3","packedBoxLength","Matrix4","packedLength","packedCylinderLength","packedEllipsoidLength","packedSphereLength","scratchModelMatrixAndBV","modelMatrix","boundingVolume","BoundingSphere","boxModelMatrixAndBoundingVolume","boxes","index","boxIndex","dimensions","unpack","boxModelMatrix","multiplyByScale","clone","ZERO","center","radius","Math","sqrt","cylinderModelMatrixAndBoundingVolume","cylinders","cylinderIndex","cylinderRadius","length","scale","fromElements","cylinderModelMatrix","ellipsoidModelMatrixAndBoundingVolume","ellipsoids","ellipsoidIndex","radii","ellipsoidModelMatrix","sphereModelMatrixAndBoundingVolume","spheres","sphereIndex","sphereRadius","sphereTranslation","sphereModelMatrix","fromTranslation","multiplyByUniformScale","scratchPosition","createPrimitive","primitive","primitiveBatchIds","geometry","getModelMatrixAndBoundingVolume","defined","numberOfPrimitives","geometryPositions","attributes","position","values","geometryIndices","indices","positions","vertexBatchIds","batchTableColors","batchedIndices","indexOffsets","indexCounts","boundingVolumes","positionOffset","batchIdIndex","indexOffset","batchedIndicesOffset","i","primitiveModelMatrixAndBV","primitiveModelMatrix","multiply","batchId","positionsLength","j","multiplyByPoint","subtract","pack","indicesLength","k","Color","fromRgba","transform","scratchCenter","scratchMatrix4","packBuffer","indicesBytesPerElement","numBVs","packedBatchedIndicesLength","packedBuffer","Float64Array","batchedIndex","batchIdsLength","createTaskProcessorWorker","parameters","transferableObjects","Float32Array","undefined","boxBatchIds","Uint16Array","cylinderBatchIds","ellipsoidBatchIds","sphereBatchIds","numberOfBoxes","numberOfCylinders","numberOfEllipsoids","numberOfSpheres","boxGeometry","BoxGeometry","getUnitBox","cylinderGeometry","CylinderGeometry","getUnitCylinder","ellipsoidGeometry","EllipsoidGeometry","getUnitEllipsoid","boxPositions","cylinderPositions","ellipsoidPositions","numberOfPositions","boxIndices","cylinderIndices","ellipsoidIndices","numberOfIndices","IndexDatatype","createTypedArray","numberOfGeometries","Array","Uint32Array","buffer","unpackBuffer","BYTES_PER_ELEMENT","push"],"mappings":"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"}