{"version":3,"file":"createVerticesFromHeightmap.js","sources":["../../../../Source/Core/HeightmapEncoding.js","../../../../Source/Core/HeightmapTessellator.js","../../../../Source/ThirdParty/LercDecode.js","../../../../Source/WorkersES6/createVerticesFromHeightmap.js"],"sourcesContent":["\r\n    /**\r\n     * The encoding that is used for a heightmap\r\n     *\r\n     * @exports HeightmapEncoding\r\n     */\r\n    var HeightmapEncoding = {\r\n        /**\r\n         * No encoding\r\n         *\r\n         * @type {Number}\r\n         * @constant\r\n         */\r\n        NONE: 0,\r\n\r\n        /**\r\n         * LERC encoding\r\n         *\r\n         * @type {Number}\r\n         * @constant\r\n         *\r\n         * @see {@link https://github.com/Esri/lerc|The LERC specification}\r\n         */\r\n        LERC: 1\r\n    };\r\nexport default Object.freeze(HeightmapEncoding);\r\n","import AxisAlignedBoundingBox from './AxisAlignedBoundingBox.js';\r\nimport BoundingSphere from './BoundingSphere.js';\r\nimport Cartesian2 from './Cartesian2.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport EllipsoidalOccluder from './EllipsoidalOccluder.js';\r\nimport CesiumMath from './Math.js';\r\nimport Matrix4 from './Matrix4.js';\r\nimport OrientedBoundingBox from './OrientedBoundingBox.js';\r\nimport Rectangle from './Rectangle.js';\r\nimport TerrainEncoding from './TerrainEncoding.js';\r\nimport Transforms from './Transforms.js';\r\nimport WebMercatorProjection from './WebMercatorProjection.js';\r\n\r\n    /**\r\n     * Contains functions to create a mesh from a heightmap image.\r\n     *\r\n     * @exports HeightmapTessellator\r\n     *\r\n     * @private\r\n     */\r\n    var HeightmapTessellator = {};\r\n\r\n    /**\r\n     * The default structure of a heightmap, as given to {@link HeightmapTessellator.computeVertices}.\r\n     *\r\n     * @constant\r\n     */\r\n    HeightmapTessellator.DEFAULT_STRUCTURE = Object.freeze({\r\n        heightScale : 1.0,\r\n        heightOffset : 0.0,\r\n        elementsPerHeight : 1,\r\n        stride : 1,\r\n        elementMultiplier : 256.0,\r\n        isBigEndian : false\r\n    });\r\n\r\n    var cartesian3Scratch = new Cartesian3();\r\n    var matrix4Scratch = new Matrix4();\r\n    var minimumScratch = new Cartesian3();\r\n    var maximumScratch = new Cartesian3();\r\n\r\n    /**\r\n     * Fills an array of vertices from a heightmap image.\r\n     *\r\n     * @param {Object} options Object with the following properties:\r\n     * @param {TypedArray} options.heightmap The heightmap to tessellate.\r\n     * @param {Number} options.width The width of the heightmap, in height samples.\r\n     * @param {Number} options.height The height of the heightmap, in height samples.\r\n     * @param {Number} options.skirtHeight The height of skirts to drape at the edges of the heightmap.\r\n     * @param {Rectangle} options.nativeRectangle A rectangle in the native coordinates of the heightmap's projection.  For\r\n     *                 a heightmap with a geographic projection, this is degrees.  For the web mercator\r\n     *                 projection, this is meters.\r\n     * @param {Number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\r\n     * @param {Rectangle} [options.rectangle] The rectangle covered by the heightmap, in geodetic coordinates with north, south, east and\r\n     *                 west properties in radians.  Either rectangle or nativeRectangle must be provided.  If both\r\n     *                 are provided, they're assumed to be consistent.\r\n     * @param {Boolean} [options.isGeographic=true] True if the heightmap uses a {@link GeographicProjection}, or false if it uses\r\n     *                  a {@link WebMercatorProjection}.\r\n     * @param {Cartesian3} [options.relativeToCenter=Cartesian3.ZERO] The positions will be computed as <code>Cartesian3.subtract(worldPosition, relativeToCenter)</code>.\r\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to which the heightmap applies.\r\n     * @param {Object} [options.structure] An object describing the structure of the height data.\r\n     * @param {Number} [options.structure.heightScale=1.0] The factor by which to multiply height samples in order to obtain\r\n     *                 the height above the heightOffset, in meters.  The heightOffset is added to the resulting\r\n     *                 height after multiplying by the scale.\r\n     * @param {Number} [options.structure.heightOffset=0.0] The offset to add to the scaled height to obtain the final\r\n     *                 height in meters.  The offset is added after the height sample is multiplied by the\r\n     *                 heightScale.\r\n     * @param {Number} [options.structure.elementsPerHeight=1] The number of elements in the buffer that make up a single height\r\n     *                 sample.  This is usually 1, indicating that each element is a separate height sample.  If\r\n     *                 it is greater than 1, that number of elements together form the height sample, which is\r\n     *                 computed according to the structure.elementMultiplier and structure.isBigEndian properties.\r\n     * @param {Number} [options.structure.stride=1] The number of elements to skip to get from the first element of\r\n     *                 one height to the first element of the next height.\r\n     * @param {Number} [options.structure.elementMultiplier=256.0] The multiplier used to compute the height value when the\r\n     *                 stride property is greater than 1.  For example, if the stride is 4 and the strideMultiplier\r\n     *                 is 256, the height is computed as follows:\r\n     *                 `height = buffer[index] + buffer[index + 1] * 256 + buffer[index + 2] * 256 * 256 + buffer[index + 3] * 256 * 256 * 256`\r\n     *                 This is assuming that the isBigEndian property is false.  If it is true, the order of the\r\n     *                 elements is reversed.\r\n     * @param {Number} [options.structure.lowestEncodedHeight] The lowest value that can be stored in the height buffer.  Any heights that are lower\r\n     *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\r\n     *                 buffer is a `Uint16Array`, this value should be 0 because a `Uint16Array` cannot store negative numbers.  If this parameter is\r\n     *                 not specified, no minimum value is enforced.\r\n     * @param {Number} [options.structure.highestEncodedHeight] The highest value that can be stored in the height buffer.  Any heights that are higher\r\n     *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\r\n     *                 buffer is a `Uint16Array`, this value should be `256 * 256 - 1` or 65535 because a `Uint16Array` cannot store numbers larger\r\n     *                 than 65535.  If this parameter is not specified, no maximum value is enforced.\r\n     * @param {Boolean} [options.structure.isBigEndian=false] Indicates endianness of the elements in the buffer when the\r\n     *                  stride property is greater than 1.  If this property is false, the first element is the\r\n     *                  low-order element.  If it is true, the first element is the high-order element.\r\n     *\r\n     * @example\r\n     * var width = 5;\r\n     * var height = 5;\r\n     * var statistics = Cesium.HeightmapTessellator.computeVertices({\r\n     *     heightmap : [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0],\r\n     *     width : width,\r\n     *     height : height,\r\n     *     skirtHeight : 0.0,\r\n     *     nativeRectangle : {\r\n     *         west : 10.0,\r\n     *         east : 20.0,\r\n     *         south : 30.0,\r\n     *         north : 40.0\r\n     *     }\r\n     * });\r\n     *\r\n     * var encoding = statistics.encoding;\r\n     * var position = encoding.decodePosition(statistics.vertices, index * encoding.getStride());\r\n     */\r\n    HeightmapTessellator.computeVertices = function(options) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(options) || !defined(options.heightmap)) {\r\n            throw new DeveloperError('options.heightmap is required.');\r\n        }\r\n        if (!defined(options.width) || !defined(options.height)) {\r\n            throw new DeveloperError('options.width and options.height are required.');\r\n        }\r\n        if (!defined(options.nativeRectangle)) {\r\n            throw new DeveloperError('options.nativeRectangle is required.');\r\n        }\r\n        if (!defined(options.skirtHeight)) {\r\n            throw new DeveloperError('options.skirtHeight is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        // This function tends to be a performance hotspot for terrain rendering,\r\n        // so it employs a lot of inlining and unrolling as an optimization.\r\n        // In particular, the functionality of Ellipsoid.cartographicToCartesian\r\n        // is inlined.\r\n\r\n        var cos = Math.cos;\r\n        var sin = Math.sin;\r\n        var sqrt = Math.sqrt;\r\n        var atan = Math.atan;\r\n        var exp = Math.exp;\r\n        var piOverTwo = CesiumMath.PI_OVER_TWO;\r\n        var toRadians = CesiumMath.toRadians;\r\n\r\n        var heightmap = options.heightmap;\r\n        var width = options.width;\r\n        var height = options.height;\r\n        var skirtHeight = options.skirtHeight;\r\n\r\n        var isGeographic = defaultValue(options.isGeographic, true);\r\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n\r\n        var oneOverGlobeSemimajorAxis = 1.0 / ellipsoid.maximumRadius;\r\n\r\n        var nativeRectangle = options.nativeRectangle;\r\n\r\n        var geographicWest;\r\n        var geographicSouth;\r\n        var geographicEast;\r\n        var geographicNorth;\r\n\r\n        var rectangle = options.rectangle;\r\n        if (!defined(rectangle)) {\r\n            if (isGeographic) {\r\n                geographicWest = toRadians(nativeRectangle.west);\r\n                geographicSouth = toRadians(nativeRectangle.south);\r\n                geographicEast = toRadians(nativeRectangle.east);\r\n                geographicNorth = toRadians(nativeRectangle.north);\r\n            } else {\r\n                geographicWest = nativeRectangle.west * oneOverGlobeSemimajorAxis;\r\n                geographicSouth = piOverTwo - (2.0 * atan(exp(-nativeRectangle.south * oneOverGlobeSemimajorAxis)));\r\n                geographicEast = nativeRectangle.east * oneOverGlobeSemimajorAxis;\r\n                geographicNorth = piOverTwo - (2.0 * atan(exp(-nativeRectangle.north * oneOverGlobeSemimajorAxis)));\r\n            }\r\n        } else {\r\n            geographicWest = rectangle.west;\r\n            geographicSouth = rectangle.south;\r\n            geographicEast = rectangle.east;\r\n            geographicNorth = rectangle.north;\r\n        }\r\n\r\n        var relativeToCenter = options.relativeToCenter;\r\n        var hasRelativeToCenter = defined(relativeToCenter);\r\n        relativeToCenter = hasRelativeToCenter ? relativeToCenter : Cartesian3.ZERO;\r\n        var exaggeration = defaultValue(options.exaggeration, 1.0);\r\n        var includeWebMercatorT = defaultValue(options.includeWebMercatorT, false);\r\n\r\n        var structure = defaultValue(options.structure, HeightmapTessellator.DEFAULT_STRUCTURE);\r\n        var heightScale = defaultValue(structure.heightScale, HeightmapTessellator.DEFAULT_STRUCTURE.heightScale);\r\n        var heightOffset = defaultValue(structure.heightOffset, HeightmapTessellator.DEFAULT_STRUCTURE.heightOffset);\r\n        var elementsPerHeight = defaultValue(structure.elementsPerHeight, HeightmapTessellator.DEFAULT_STRUCTURE.elementsPerHeight);\r\n        var stride = defaultValue(structure.stride, HeightmapTessellator.DEFAULT_STRUCTURE.stride);\r\n        var elementMultiplier = defaultValue(structure.elementMultiplier, HeightmapTessellator.DEFAULT_STRUCTURE.elementMultiplier);\r\n        var isBigEndian = defaultValue(structure.isBigEndian, HeightmapTessellator.DEFAULT_STRUCTURE.isBigEndian);\r\n\r\n        var rectangleWidth = Rectangle.computeWidth(nativeRectangle);\r\n        var rectangleHeight = Rectangle.computeHeight(nativeRectangle);\r\n\r\n        var granularityX = rectangleWidth / (width - 1);\r\n        var granularityY = rectangleHeight / (height - 1);\r\n\r\n        if (!isGeographic) {\r\n            rectangleWidth *= oneOverGlobeSemimajorAxis;\r\n            rectangleHeight *= oneOverGlobeSemimajorAxis;\r\n        }\r\n\r\n        var radiiSquared = ellipsoid.radiiSquared;\r\n        var radiiSquaredX = radiiSquared.x;\r\n        var radiiSquaredY = radiiSquared.y;\r\n        var radiiSquaredZ = radiiSquared.z;\r\n\r\n        var minimumHeight = 65536.0;\r\n        var maximumHeight = -65536.0;\r\n\r\n        var fromENU = Transforms.eastNorthUpToFixedFrame(relativeToCenter, ellipsoid);\r\n        var toENU = Matrix4.inverseTransformation(fromENU, matrix4Scratch);\r\n\r\n        var southMercatorY;\r\n        var oneOverMercatorHeight;\r\n        if (includeWebMercatorT) {\r\n            southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(geographicSouth);\r\n            oneOverMercatorHeight = 1.0 / (WebMercatorProjection.geodeticLatitudeToMercatorAngle(geographicNorth) - southMercatorY);\r\n        }\r\n\r\n        var minimum = minimumScratch;\r\n        minimum.x = Number.POSITIVE_INFINITY;\r\n        minimum.y = Number.POSITIVE_INFINITY;\r\n        minimum.z = Number.POSITIVE_INFINITY;\r\n\r\n        var maximum = maximumScratch;\r\n        maximum.x = Number.NEGATIVE_INFINITY;\r\n        maximum.y = Number.NEGATIVE_INFINITY;\r\n        maximum.z = Number.NEGATIVE_INFINITY;\r\n\r\n        var hMin = Number.POSITIVE_INFINITY;\r\n\r\n        var gridVertexCount = width * height;\r\n        var edgeVertexCount = skirtHeight > 0.0 ? (width * 2 + height * 2) : 0;\r\n        var vertexCount = gridVertexCount + edgeVertexCount;\r\n\r\n        var positions = new Array(vertexCount);\r\n        var heights = new Array(vertexCount);\r\n        var uvs = new Array(vertexCount);\r\n        var webMercatorTs = includeWebMercatorT ? new Array(vertexCount) : [];\r\n\r\n        var startRow = 0;\r\n        var endRow = height;\r\n        var startCol = 0;\r\n        var endCol = width;\r\n\r\n        if (skirtHeight > 0.0) {\r\n            --startRow;\r\n            ++endRow;\r\n            --startCol;\r\n            ++endCol;\r\n        }\r\n\r\n        var skirtOffsetPercentage = 0.00001;\r\n\r\n        for (var rowIndex = startRow; rowIndex < endRow; ++rowIndex) {\r\n            var row = rowIndex;\r\n            if (row < 0) {\r\n                row = 0;\r\n            }\r\n            if (row >= height) {\r\n                row = height - 1;\r\n            }\r\n\r\n            var latitude = nativeRectangle.north - granularityY * row;\r\n\r\n            if (!isGeographic) {\r\n                latitude = piOverTwo - (2.0 * atan(exp(-latitude * oneOverGlobeSemimajorAxis)));\r\n            } else {\r\n                latitude = toRadians(latitude);\r\n            }\r\n\r\n            var v = (latitude - geographicSouth) / (geographicNorth - geographicSouth);\r\n            v = CesiumMath.clamp(v, 0.0, 1.0);\r\n\r\n            var isNorthEdge = rowIndex === startRow;\r\n            var isSouthEdge = rowIndex === endRow - 1;\r\n            if (skirtHeight > 0.0) {\r\n                if (isNorthEdge) {\r\n                    latitude += skirtOffsetPercentage * rectangleHeight;\r\n                } else if (isSouthEdge) {\r\n                    latitude -= skirtOffsetPercentage * rectangleHeight;\r\n                }\r\n            }\r\n\r\n            var cosLatitude = cos(latitude);\r\n            var nZ = sin(latitude);\r\n            var kZ = radiiSquaredZ * nZ;\r\n\r\n            var webMercatorT;\r\n            if (includeWebMercatorT) {\r\n                webMercatorT = (WebMercatorProjection.geodeticLatitudeToMercatorAngle(latitude) - southMercatorY) * oneOverMercatorHeight;\r\n            }\r\n\r\n            for (var colIndex = startCol; colIndex < endCol; ++colIndex) {\r\n                var col = colIndex;\r\n                if (col < 0) {\r\n                    col = 0;\r\n                }\r\n                if (col >= width) {\r\n                    col = width - 1;\r\n                }\r\n\r\n                var terrainOffset = row * (width * stride) + col * stride;\r\n\r\n                var heightSample;\r\n                if (elementsPerHeight === 1) {\r\n                    heightSample = heightmap[terrainOffset];\r\n                } else {\r\n                    heightSample = 0;\r\n\r\n                    var elementOffset;\r\n                    if (isBigEndian) {\r\n                        for (elementOffset = 0; elementOffset < elementsPerHeight; ++elementOffset) {\r\n                            heightSample = (heightSample * elementMultiplier) + heightmap[terrainOffset + elementOffset];\r\n                        }\r\n                    } else {\r\n                        for (elementOffset = elementsPerHeight - 1; elementOffset >= 0; --elementOffset) {\r\n                            heightSample = (heightSample * elementMultiplier) + heightmap[terrainOffset + elementOffset];\r\n                        }\r\n                    }\r\n                }\r\n\r\n                heightSample = (heightSample * heightScale + heightOffset) * exaggeration;\r\n\r\n                maximumHeight = Math.max(maximumHeight, heightSample);\r\n                minimumHeight = Math.min(minimumHeight, heightSample);\r\n\r\n                var longitude = nativeRectangle.west + granularityX * col;\r\n\r\n                if (!isGeographic) {\r\n                    longitude = longitude * oneOverGlobeSemimajorAxis;\r\n                } else {\r\n                    longitude = toRadians(longitude);\r\n                }\r\n\r\n                var u = (longitude - geographicWest) / (geographicEast - geographicWest);\r\n                u = CesiumMath.clamp(u, 0.0, 1.0);\r\n\r\n                var index = row * width + col;\r\n\r\n                if (skirtHeight > 0.0) {\r\n                    var isWestEdge = colIndex === startCol;\r\n                    var isEastEdge = colIndex === endCol - 1;\r\n                    var isEdge = isNorthEdge || isSouthEdge || isWestEdge || isEastEdge;\r\n                    var isCorner = (isNorthEdge || isSouthEdge) && (isWestEdge || isEastEdge);\r\n                    if (isCorner) {\r\n                        // Don't generate skirts on the corners.\r\n                        continue;\r\n                    } else if (isEdge) {\r\n                        heightSample -= skirtHeight;\r\n\r\n                        if (isWestEdge) {\r\n                            // The outer loop iterates north to south but the indices are ordered south to north, hence the index flip below\r\n                            index = gridVertexCount + (height - row - 1);\r\n                            longitude -= skirtOffsetPercentage * rectangleWidth;\r\n                        } else if (isSouthEdge) {\r\n                            // Add after west indices. South indices are ordered east to west.\r\n                            index = gridVertexCount + height + (width - col - 1);\r\n                        } else if (isEastEdge) {\r\n                            // Add after west and south indices. East indices are ordered north to south. The index is flipped like above.\r\n                            index = gridVertexCount + height + width + row;\r\n                            longitude += skirtOffsetPercentage * rectangleWidth;\r\n                        } else if (isNorthEdge) {\r\n                            // Add after west, south, and east indices. North indices are ordered west to east.\r\n                            index = gridVertexCount + height + width + height + col;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                var nX = cosLatitude * cos(longitude);\r\n                var nY = cosLatitude * sin(longitude);\r\n\r\n                var kX = radiiSquaredX * nX;\r\n                var kY = radiiSquaredY * nY;\r\n\r\n                var gamma = sqrt((kX * nX) + (kY * nY) + (kZ * nZ));\r\n                var oneOverGamma = 1.0 / gamma;\r\n\r\n                var rSurfaceX = kX * oneOverGamma;\r\n                var rSurfaceY = kY * oneOverGamma;\r\n                var rSurfaceZ = kZ * oneOverGamma;\r\n\r\n                var position = new Cartesian3();\r\n                position.x = rSurfaceX + nX * heightSample;\r\n                position.y = rSurfaceY + nY * heightSample;\r\n                position.z = rSurfaceZ + nZ * heightSample;\r\n\r\n                positions[index] = position;\r\n                heights[index] = heightSample;\r\n                uvs[index] = new Cartesian2(u, v);\r\n\r\n                if (includeWebMercatorT) {\r\n                    webMercatorTs[index] = webMercatorT;\r\n                }\r\n\r\n                Matrix4.multiplyByPoint(toENU, position, cartesian3Scratch);\r\n\r\n                Cartesian3.minimumByComponent(cartesian3Scratch, minimum, minimum);\r\n                Cartesian3.maximumByComponent(cartesian3Scratch, maximum, maximum);\r\n                hMin = Math.min(hMin, heightSample);\r\n            }\r\n        }\r\n\r\n        var boundingSphere3D = BoundingSphere.fromPoints(positions);\r\n        var orientedBoundingBox;\r\n        if (defined(rectangle)) {\r\n            orientedBoundingBox = OrientedBoundingBox.fromRectangle(rectangle, minimumHeight, maximumHeight, ellipsoid);\r\n        }\r\n\r\n        var occludeePointInScaledSpace;\r\n        if (hasRelativeToCenter) {\r\n            var occluder = new EllipsoidalOccluder(ellipsoid);\r\n            occludeePointInScaledSpace = occluder.computeHorizonCullingPointPossiblyUnderEllipsoid(relativeToCenter, positions, minimumHeight);\r\n        }\r\n\r\n        var aaBox = new AxisAlignedBoundingBox(minimum, maximum, relativeToCenter);\r\n        var encoding = new TerrainEncoding(aaBox, hMin, maximumHeight, fromENU, false, includeWebMercatorT);\r\n        var vertices = new Float32Array(vertexCount * encoding.getStride());\r\n\r\n        var bufferIndex = 0;\r\n        for (var j = 0; j < vertexCount; ++j) {\r\n            bufferIndex = encoding.encode(vertices, bufferIndex, positions[j], uvs[j], heights[j], undefined, webMercatorTs[j]);\r\n        }\r\n\r\n        return {\r\n            vertices : vertices,\r\n            maximumHeight : maximumHeight,\r\n            minimumHeight : minimumHeight,\r\n            encoding : encoding,\r\n            boundingSphere3D : boundingSphere3D,\r\n            orientedBoundingBox : orientedBoundingBox,\r\n            occludeePointInScaledSpace : occludeePointInScaledSpace\r\n        };\r\n    };\r\nexport default HeightmapTessellator;\r\n","/* jshint forin: false, bitwise: false */\r\n/*\r\nCopyright 2015-2018 Esri\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\nhttp://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n\r\nA copy of the license and additional notices are located with the\r\nsource distribution at:\r\n\r\nhttp://github.com/Esri/lerc/\r\n\r\nContributors:  Johannes Schmid, (LERC v1)\r\n               Chayanika Khatua, (LERC v1)\r\n               Wenxue Ju (LERC v1, v2.x)\r\n*/\r\n\r\n/* Copyright 2015-2018 Esri. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 @preserve */\r\n\r\nvar tmp = {};\r\n\r\n/**\r\n * a module for decoding LERC blobs\r\n * @module Lerc\r\n */\r\n(function() {\r\n  //the original LercDecode for Version 1\r\n  var LercDecode = (function() {\r\n\r\n    // WARNING: This decoder version can only read old version 1 Lerc blobs. Use with caution.\r\n\r\n    // Note: currently, this module only has an implementation for decoding LERC data, not encoding. The name of\r\n    // the class was chosen to be future proof.\r\n\r\n    var CntZImage = {};\r\n\r\n    CntZImage.defaultNoDataValue = -3.4027999387901484e+38; // smallest Float32 value\r\n\r\n    /**\r\n     * Decode a LERC byte stream and return an object containing the pixel data and some required and optional\r\n     * information about it, such as the image's width and height.\r\n     *\r\n     * @param {ArrayBuffer} input The LERC input byte stream\r\n     * @param {object} [options] Decoding options, containing any of the following properties:\r\n     * @config {number} [inputOffset = 0]\r\n     *        Skip the first inputOffset bytes of the input byte stream. A valid LERC file is expected at that position.\r\n     * @config {Uint8Array} [encodedMask = null]\r\n     *        If specified, the decoder will not read mask information from the input and use the specified encoded\r\n     *        mask data instead. Mask header/data must not be present in the LERC byte stream in this case.\r\n     * @config {number} [noDataValue = LercCode.defaultNoDataValue]\r\n     *        Pixel value to use for masked pixels.\r\n     * @config {ArrayBufferView|Array} [pixelType = Float32Array]\r\n     *        The desired type of the pixelData array in the return value. Note that it is the caller's responsibility to\r\n     *        provide an appropriate noDataValue if the default pixelType is overridden.\r\n     * @config {boolean} [returnMask = false]\r\n     *        If true, the return value will contain a maskData property of type Uint8Array which has one element per\r\n     *        pixel, the value of which is 1 or 0 depending on whether that pixel's data is present or masked. If the\r\n     *        input LERC data does not contain a mask, maskData will not be returned.\r\n     * @config {boolean} [returnEncodedMask = false]\r\n     *        If true, the return value will contain a encodedMaskData property, which can be passed into encode() as\r\n     *        encodedMask.\r\n     * @config {boolean} [returnFileInfo = false]\r\n     *        If true, the return value will have a fileInfo property that contains metadata obtained from the\r\n     *        LERC headers and the decoding process.\r\n     * @config {boolean} [computeUsedBitDepths = false]\r\n     *        If true, the fileInfo property in the return value will contain the set of all block bit depths\r\n     *        encountered during decoding. Will only have an effect if returnFileInfo option is true.\r\n     * @returns {{width, height, pixelData, minValue, maxValue, noDataValue, maskData, encodedMaskData, fileInfo}}\r\n     */\r\n    CntZImage.decode = function(input, options) {\r\n      options = options || {};\r\n\r\n      var skipMask = options.encodedMaskData || (options.encodedMaskData === null);\r\n      var parsedData = parse(input, options.inputOffset || 0, skipMask);\r\n\r\n      var noDataValue = (options.noDataValue !== null) ? options.noDataValue : CntZImage.defaultNoDataValue;\r\n\r\n      var uncompressedData = uncompressPixelValues(parsedData, options.pixelType || Float32Array,\r\n        options.encodedMaskData, noDataValue, options.returnMask);\r\n\r\n      var result = {\r\n        width: parsedData.width,\r\n        height: parsedData.height,\r\n        pixelData: uncompressedData.resultPixels,\r\n        minValue: uncompressedData.minValue,\r\n        maxValue: parsedData.pixels.maxValue,\r\n        noDataValue: noDataValue\r\n      };\r\n\r\n      if (uncompressedData.resultMask) {\r\n        result.maskData = uncompressedData.resultMask;\r\n      }\r\n\r\n      if (options.returnEncodedMask && parsedData.mask) {\r\n        result.encodedMaskData = parsedData.mask.bitset ? parsedData.mask.bitset : null;\r\n      }\r\n\r\n      if (options.returnFileInfo) {\r\n        result.fileInfo = formatFileInfo(parsedData);\r\n        if (options.computeUsedBitDepths) {\r\n          result.fileInfo.bitDepths = computeUsedBitDepths(parsedData);\r\n        }\r\n      }\r\n\r\n      return result;\r\n    };\r\n\r\n    var uncompressPixelValues = function(data, TypedArrayClass, maskBitset, noDataValue, storeDecodedMask) {\r\n      var blockIdx = 0;\r\n      var numX = data.pixels.numBlocksX;\r\n      var numY = data.pixels.numBlocksY;\r\n      var blockWidth = Math.floor(data.width / numX);\r\n      var blockHeight = Math.floor(data.height / numY);\r\n      var scale = 2 * data.maxZError;\r\n      var minValue = Number.MAX_VALUE, currentValue;\r\n      maskBitset = maskBitset || ((data.mask) ? data.mask.bitset : null);\r\n\r\n      var resultPixels, resultMask;\r\n      resultPixels = new TypedArrayClass(data.width * data.height);\r\n      if (storeDecodedMask && maskBitset) {\r\n        resultMask = new Uint8Array(data.width * data.height);\r\n      }\r\n      var blockDataBuffer = new Float32Array(blockWidth * blockHeight);\r\n\r\n      var xx, yy;\r\n      for (var y = 0; y <= numY; y++) {\r\n        var thisBlockHeight = (y !== numY) ? blockHeight : (data.height % numY);\r\n        if (thisBlockHeight === 0) {\r\n          continue;\r\n        }\r\n        for (var x = 0; x <= numX; x++) {\r\n          var thisBlockWidth = (x !== numX) ? blockWidth : (data.width % numX);\r\n          if (thisBlockWidth === 0) {\r\n            continue;\r\n          }\r\n\r\n          var outPtr = y * data.width * blockHeight + x * blockWidth;\r\n          var outStride = data.width - thisBlockWidth;\r\n\r\n          var block = data.pixels.blocks[blockIdx];\r\n\r\n          var blockData, blockPtr, constValue;\r\n          if (block.encoding < 2) {\r\n            // block is either uncompressed or bit-stuffed (encodings 0 and 1)\r\n            if (block.encoding === 0) {\r\n              // block is uncompressed\r\n              blockData = block.rawData;\r\n            } else {\r\n              // block is bit-stuffed\r\n              unstuff(block.stuffedData, block.bitsPerPixel, block.numValidPixels, block.offset, scale, blockDataBuffer, data.pixels.maxValue);\r\n              blockData = blockDataBuffer;\r\n            }\r\n            blockPtr = 0;\r\n          }\r\n          else if (block.encoding === 2) {\r\n            // block is all 0\r\n            constValue = 0;\r\n          }\r\n          else {\r\n            // block has constant value (encoding === 3)\r\n            constValue = block.offset;\r\n          }\r\n\r\n          var maskByte;\r\n          if (maskBitset) {\r\n            for (yy = 0; yy < thisBlockHeight; yy++) {\r\n              if (outPtr & 7) {\r\n                //\r\n                maskByte = maskBitset[outPtr >> 3];\r\n                maskByte <<= outPtr & 7;\r\n              }\r\n              for (xx = 0; xx < thisBlockWidth; xx++) {\r\n                if (!(outPtr & 7)) {\r\n                  // read next byte from mask\r\n                  maskByte = maskBitset[outPtr >> 3];\r\n                }\r\n                if (maskByte & 128) {\r\n                  // pixel data present\r\n                  if (resultMask) {\r\n                    resultMask[outPtr] = 1;\r\n                  }\r\n                  currentValue = (block.encoding < 2) ? blockData[blockPtr++] : constValue;\r\n                  minValue = minValue > currentValue ? currentValue : minValue;\r\n                  resultPixels[outPtr++] = currentValue;\r\n                } else {\r\n                  // pixel data not present\r\n                  if (resultMask) {\r\n                    resultMask[outPtr] = 0;\r\n                  }\r\n                  resultPixels[outPtr++] = noDataValue;\r\n                }\r\n                maskByte <<= 1;\r\n              }\r\n              outPtr += outStride;\r\n            }\r\n          } else {\r\n            // mask not present, simply copy block over\r\n            if (block.encoding < 2) {\r\n              // duplicating this code block for performance reasons\r\n              // blockData case:\r\n              for (yy = 0; yy < thisBlockHeight; yy++) {\r\n                for (xx = 0; xx < thisBlockWidth; xx++) {\r\n                  currentValue = blockData[blockPtr++];\r\n                  minValue = minValue > currentValue ? currentValue : minValue;\r\n                  resultPixels[outPtr++] = currentValue;\r\n                }\r\n                outPtr += outStride;\r\n              }\r\n            }\r\n            else {\r\n              // constValue case:\r\n              minValue = minValue > constValue ? constValue : minValue;\r\n              for (yy = 0; yy < thisBlockHeight; yy++) {\r\n                for (xx = 0; xx < thisBlockWidth; xx++) {\r\n                  resultPixels[outPtr++] = constValue;\r\n                }\r\n                outPtr += outStride;\r\n              }\r\n            }\r\n          }\r\n          if ((block.encoding === 1) && (blockPtr !== block.numValidPixels)) {\r\n            throw \"Block and Mask do not match\";\r\n          }\r\n          blockIdx++;\r\n        }\r\n      }\r\n\r\n      return {\r\n        resultPixels: resultPixels,\r\n        resultMask: resultMask,\r\n        minValue: minValue\r\n      };\r\n    };\r\n\r\n    var formatFileInfo = function(data) {\r\n      return {\r\n        \"fileIdentifierString\": data.fileIdentifierString,\r\n        \"fileVersion\": data.fileVersion,\r\n        \"imageType\": data.imageType,\r\n        \"height\": data.height,\r\n        \"width\": data.width,\r\n        \"maxZError\": data.maxZError,\r\n        \"eofOffset\": data.eofOffset,\r\n        \"mask\": data.mask ? {\r\n          \"numBlocksX\": data.mask.numBlocksX,\r\n          \"numBlocksY\": data.mask.numBlocksY,\r\n          \"numBytes\": data.mask.numBytes,\r\n          \"maxValue\": data.mask.maxValue\r\n        } : null,\r\n        \"pixels\": {\r\n          \"numBlocksX\": data.pixels.numBlocksX,\r\n          \"numBlocksY\": data.pixels.numBlocksY,\r\n          \"numBytes\": data.pixels.numBytes,\r\n          \"maxValue\": data.pixels.maxValue,\r\n          \"noDataValue\": data.noDataValue\r\n        }\r\n      };\r\n    };\r\n\r\n    var computeUsedBitDepths = function(data) {\r\n      var numBlocks = data.pixels.numBlocksX * data.pixels.numBlocksY;\r\n      var bitDepths = {};\r\n      for (var i = 0; i < numBlocks; i++) {\r\n        var block = data.pixels.blocks[i];\r\n        if (block.encoding === 0) {\r\n          bitDepths.float32 = true;\r\n        } else if (block.encoding === 1) {\r\n          bitDepths[block.bitsPerPixel] = true;\r\n        } else {\r\n          bitDepths[0] = true;\r\n        }\r\n      }\r\n\r\n      return Object.keys(bitDepths);\r\n    };\r\n\r\n    var parse = function(input, fp, skipMask) {\r\n      var data = {};\r\n\r\n      // File header\r\n      var fileIdView = new Uint8Array(input, fp, 10);\r\n      data.fileIdentifierString = String.fromCharCode.apply(null, fileIdView);\r\n      if (data.fileIdentifierString.trim() !== \"CntZImage\") {\r\n        throw \"Unexpected file identifier string: \" + data.fileIdentifierString;\r\n      }\r\n      fp += 10;\r\n      var view = new DataView(input, fp, 24);\r\n      data.fileVersion = view.getInt32(0, true);\r\n      data.imageType = view.getInt32(4, true);\r\n      data.height = view.getUint32(8, true);\r\n      data.width = view.getUint32(12, true);\r\n      data.maxZError = view.getFloat64(16, true);\r\n      fp += 24;\r\n\r\n      // Mask Header\r\n      if (!skipMask) {\r\n        view = new DataView(input, fp, 16);\r\n        data.mask = {};\r\n        data.mask.numBlocksY = view.getUint32(0, true);\r\n        data.mask.numBlocksX = view.getUint32(4, true);\r\n        data.mask.numBytes = view.getUint32(8, true);\r\n        data.mask.maxValue = view.getFloat32(12, true);\r\n        fp += 16;\r\n\r\n        // Mask Data\r\n        if (data.mask.numBytes > 0) {\r\n          var bitset = new Uint8Array(Math.ceil(data.width * data.height / 8));\r\n          view = new DataView(input, fp, data.mask.numBytes);\r\n          var cnt = view.getInt16(0, true);\r\n          var ip = 2, op = 0;\r\n          do {\r\n            if (cnt > 0) {\r\n              while (cnt--) { bitset[op++] = view.getUint8(ip++); }\r\n            } else {\r\n              var val = view.getUint8(ip++);\r\n              cnt = -cnt;\r\n              while (cnt--) { bitset[op++] = val; }\r\n            }\r\n            cnt = view.getInt16(ip, true);\r\n            ip += 2;\r\n          } while (ip < data.mask.numBytes);\r\n          if ((cnt !== -32768) || (op < bitset.length)) {\r\n            throw \"Unexpected end of mask RLE encoding\";\r\n          }\r\n          data.mask.bitset = bitset;\r\n          fp += data.mask.numBytes;\r\n        }\r\n        else if ((data.mask.numBytes | data.mask.numBlocksY | data.mask.maxValue) === 0) {  // Special case, all nodata\r\n          data.mask.bitset = new Uint8Array(Math.ceil(data.width * data.height / 8));\r\n        }\r\n      }\r\n\r\n      // Pixel Header\r\n      view = new DataView(input, fp, 16);\r\n      data.pixels = {};\r\n      data.pixels.numBlocksY = view.getUint32(0, true);\r\n      data.pixels.numBlocksX = view.getUint32(4, true);\r\n      data.pixels.numBytes = view.getUint32(8, true);\r\n      data.pixels.maxValue = view.getFloat32(12, true);\r\n      fp += 16;\r\n\r\n      var numBlocksX = data.pixels.numBlocksX;\r\n      var numBlocksY = data.pixels.numBlocksY;\r\n      // the number of blocks specified in the header does not take into account the blocks at the end of\r\n      // each row/column with a special width/height that make the image complete in case the width is not\r\n      // evenly divisible by the number of blocks.\r\n      var actualNumBlocksX = numBlocksX + ((data.width % numBlocksX) > 0 ? 1 : 0);\r\n      var actualNumBlocksY = numBlocksY + ((data.height % numBlocksY) > 0 ? 1 : 0);\r\n      data.pixels.blocks = new Array(actualNumBlocksX * actualNumBlocksY);\r\n      var blockI = 0;\r\n      for (var blockY = 0; blockY < actualNumBlocksY; blockY++) {\r\n        for (var blockX = 0; blockX < actualNumBlocksX; blockX++) {\r\n\r\n          // Block\r\n          var size = 0;\r\n          var bytesLeft = input.byteLength - fp;\r\n          view = new DataView(input, fp, Math.min(10, bytesLeft));\r\n          var block = {};\r\n          data.pixels.blocks[blockI++] = block;\r\n          var headerByte = view.getUint8(0); size++;\r\n          block.encoding = headerByte & 63;\r\n          if (block.encoding > 3) {\r\n            throw \"Invalid block encoding (\" + block.encoding + \")\";\r\n          }\r\n          if (block.encoding === 2) {\r\n            fp++;\r\n            continue;\r\n          }\r\n          if ((headerByte !== 0) && (headerByte !== 2)) {\r\n            headerByte >>= 6;\r\n            block.offsetType = headerByte;\r\n            if (headerByte === 2) {\r\n              block.offset = view.getInt8(1); size++;\r\n            } else if (headerByte === 1) {\r\n              block.offset = view.getInt16(1, true); size += 2;\r\n            } else if (headerByte === 0) {\r\n              block.offset = view.getFloat32(1, true); size += 4;\r\n            } else {\r\n              throw \"Invalid block offset type\";\r\n            }\r\n\r\n            if (block.encoding === 1) {\r\n              headerByte = view.getUint8(size); size++;\r\n              block.bitsPerPixel = headerByte & 63;\r\n              headerByte >>= 6;\r\n              block.numValidPixelsType = headerByte;\r\n              if (headerByte === 2) {\r\n                block.numValidPixels = view.getUint8(size); size++;\r\n              } else if (headerByte === 1) {\r\n                block.numValidPixels = view.getUint16(size, true); size += 2;\r\n              } else if (headerByte === 0) {\r\n                block.numValidPixels = view.getUint32(size, true); size += 4;\r\n              } else {\r\n                throw \"Invalid valid pixel count type\";\r\n              }\r\n            }\r\n          }\r\n          fp += size;\r\n\r\n          if (block.encoding === 3) {\r\n            continue;\r\n          }\r\n\r\n          var arrayBuf, store8;\r\n          if (block.encoding === 0) {\r\n            var numPixels = (data.pixels.numBytes - 1) / 4;\r\n            if (numPixels !== Math.floor(numPixels)) {\r\n              throw \"uncompressed block has invalid length\";\r\n            }\r\n            arrayBuf = new ArrayBuffer(numPixels * 4);\r\n            store8 = new Uint8Array(arrayBuf);\r\n            store8.set(new Uint8Array(input, fp, numPixels * 4));\r\n            var rawData = new Float32Array(arrayBuf);\r\n            block.rawData = rawData;\r\n            fp += numPixels * 4;\r\n          } else if (block.encoding === 1) {\r\n            var dataBytes = Math.ceil(block.numValidPixels * block.bitsPerPixel / 8);\r\n            var dataWords = Math.ceil(dataBytes / 4);\r\n            arrayBuf = new ArrayBuffer(dataWords * 4);\r\n            store8 = new Uint8Array(arrayBuf);\r\n            store8.set(new Uint8Array(input, fp, dataBytes));\r\n            block.stuffedData = new Uint32Array(arrayBuf);\r\n            fp += dataBytes;\r\n          }\r\n        }\r\n      }\r\n      data.eofOffset = fp;\r\n      return data;\r\n    };\r\n\r\n    var unstuff = function(src, bitsPerPixel, numPixels, offset, scale, dest, maxValue) {\r\n      var bitMask = (1 << bitsPerPixel) - 1;\r\n      var i = 0, o;\r\n      var bitsLeft = 0;\r\n      var n, buffer;\r\n      var nmax = Math.ceil((maxValue - offset) / scale);\r\n      // get rid of trailing bytes that are already part of next block\r\n      var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\r\n      src[src.length - 1] <<= 8 * numInvalidTailBytes;\r\n\r\n      for (o = 0; o < numPixels; o++) {\r\n        if (bitsLeft === 0) {\r\n          buffer = src[i++];\r\n          bitsLeft = 32;\r\n        }\r\n        if (bitsLeft >= bitsPerPixel) {\r\n          n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\r\n          bitsLeft -= bitsPerPixel;\r\n        } else {\r\n          var missingBits = (bitsPerPixel - bitsLeft);\r\n          n = ((buffer & bitMask) << missingBits) & bitMask;\r\n          buffer = src[i++];\r\n          bitsLeft = 32 - missingBits;\r\n          n += (buffer >>> bitsLeft);\r\n        }\r\n        //pixel values may exceed max due to quantization\r\n        dest[o] = n < nmax ? offset + n * scale : maxValue;\r\n      }\r\n      return dest;\r\n    };\r\n\r\n    return CntZImage;\r\n  })();\r\n\r\n  //version 2. Supports 2.1, 2.2, 2.3\r\n  var Lerc2Decode = (function() {\r\n    \"use strict\";\r\n    // Note: currently, this module only has an implementation for decoding LERC data, not encoding. The name of\r\n    // the class was chosen to be future proof, following LercDecode.\r\n\r\n    /*****************************************\r\n    * private static class bitsutffer used by Lerc2Decode\r\n    *******************************************/\r\n    var BitStuffer = {\r\n      //methods ending with 2 are for the new byte order used by Lerc2.3 and above.\r\n      //originalUnstuff is used to unpack Huffman code table. code is duplicated to unstuffx for performance reasons.\r\n      unstuff: function(src, dest, bitsPerPixel, numPixels, lutArr, offset, scale, maxValue) {\r\n        var bitMask = (1 << bitsPerPixel) - 1;\r\n        var i = 0, o;\r\n        var bitsLeft = 0;\r\n        var n, buffer, missingBits, nmax;\r\n\r\n        // get rid of trailing bytes that are already part of next block\r\n        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\r\n        src[src.length - 1] <<= 8 * numInvalidTailBytes;\r\n        if (lutArr) {\r\n          for (o = 0; o < numPixels; o++) {\r\n            if (bitsLeft === 0) {\r\n              buffer = src[i++];\r\n              bitsLeft = 32;\r\n            }\r\n            if (bitsLeft >= bitsPerPixel) {\r\n              n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\r\n              bitsLeft -= bitsPerPixel;\r\n            }\r\n            else {\r\n              missingBits = (bitsPerPixel - bitsLeft);\r\n              n = ((buffer & bitMask) << missingBits) & bitMask;\r\n              buffer = src[i++];\r\n              bitsLeft = 32 - missingBits;\r\n              n += (buffer >>> bitsLeft);\r\n            }\r\n            dest[o] = lutArr[n];//offset + lutArr[n] * scale;\r\n          }\r\n        }\r\n        else {\r\n          nmax = Math.ceil((maxValue - offset) / scale);\r\n          for (o = 0; o < numPixels; o++) {\r\n            if (bitsLeft === 0) {\r\n              buffer = src[i++];\r\n              bitsLeft = 32;\r\n            }\r\n            if (bitsLeft >= bitsPerPixel) {\r\n              n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\r\n              bitsLeft -= bitsPerPixel;\r\n            }\r\n            else {\r\n              missingBits = (bitsPerPixel - bitsLeft);\r\n              n = ((buffer & bitMask) << missingBits) & bitMask;\r\n              buffer = src[i++];\r\n              bitsLeft = 32 - missingBits;\r\n              n += (buffer >>> bitsLeft);\r\n            }\r\n            //pixel values may exceed max due to quantization\r\n            dest[o] = n < nmax ? offset + n * scale : maxValue;\r\n          }\r\n        }\r\n      },\r\n\r\n      unstuffLUT: function(src, bitsPerPixel, numPixels, offset, scale, maxValue) {\r\n        var bitMask = (1 << bitsPerPixel) - 1;\r\n        var i = 0, o = 0, missingBits = 0, bitsLeft = 0, n = 0;\r\n        var buffer;\r\n        var dest = [];\r\n\r\n        // get rid of trailing bytes that are already part of next block\r\n        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\r\n        src[src.length - 1] <<= 8 * numInvalidTailBytes;\r\n\r\n        var nmax = Math.ceil((maxValue - offset) / scale);\r\n        for (o = 0; o < numPixels; o++) {\r\n          if (bitsLeft === 0) {\r\n            buffer = src[i++];\r\n            bitsLeft = 32;\r\n          }\r\n          if (bitsLeft >= bitsPerPixel) {\r\n            n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\r\n            bitsLeft -= bitsPerPixel;\r\n          } else {\r\n            missingBits = (bitsPerPixel - bitsLeft);\r\n            n = ((buffer & bitMask) << missingBits) & bitMask;\r\n            buffer = src[i++];\r\n            bitsLeft = 32 - missingBits;\r\n            n += (buffer >>> bitsLeft);\r\n          }\r\n          //dest.push(n);\r\n          dest[o] = n < nmax ? offset + n * scale : maxValue;\r\n        }\r\n        dest.unshift(offset);//1st one\r\n        return dest;\r\n      },\r\n\r\n      unstuff2: function(src, dest, bitsPerPixel, numPixels, lutArr, offset, scale, maxValue) {\r\n        var bitMask = (1 << bitsPerPixel) - 1;\r\n        var i = 0, o;\r\n        var bitsLeft = 0, bitPos = 0;\r\n        var n, buffer, missingBits;\r\n        if (lutArr) {\r\n          for (o = 0; o < numPixels; o++) {\r\n            if (bitsLeft === 0) {\r\n              buffer = src[i++];\r\n              bitsLeft = 32;\r\n              bitPos = 0;\r\n            }\r\n            if (bitsLeft >= bitsPerPixel) {\r\n              n = ((buffer >>> bitPos) & bitMask);\r\n              bitsLeft -= bitsPerPixel;\r\n              bitPos += bitsPerPixel;\r\n            } else {\r\n              missingBits = (bitsPerPixel - bitsLeft);\r\n              n = (buffer >>> bitPos) & bitMask;\r\n              buffer = src[i++];\r\n              bitsLeft = 32 - missingBits;\r\n              n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);\r\n              bitPos = missingBits;\r\n            }\r\n            dest[o] = lutArr[n];\r\n          }\r\n        }\r\n        else {\r\n          var nmax = Math.ceil((maxValue - offset) / scale);\r\n          for (o = 0; o < numPixels; o++) {\r\n            if (bitsLeft === 0) {\r\n              buffer = src[i++];\r\n              bitsLeft = 32;\r\n              bitPos = 0;\r\n            }\r\n            if (bitsLeft >= bitsPerPixel) {\r\n              //no unsigned left shift\r\n              n = ((buffer >>> bitPos) & bitMask);\r\n              bitsLeft -= bitsPerPixel;\r\n              bitPos += bitsPerPixel;\r\n            } else {\r\n              missingBits = (bitsPerPixel - bitsLeft);\r\n              n = (buffer >>> bitPos) & bitMask;//((buffer & bitMask) << missingBits) & bitMask;\r\n              buffer = src[i++];\r\n              bitsLeft = 32 - missingBits;\r\n              n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);\r\n              bitPos = missingBits;\r\n            }\r\n            //pixel values may exceed max due to quantization\r\n            dest[o] = n < nmax ? offset + n * scale : maxValue;\r\n          }\r\n        }\r\n        return dest;\r\n      },\r\n\r\n      unstuffLUT2: function(src, bitsPerPixel, numPixels, offset, scale, maxValue) {\r\n        var bitMask = (1 << bitsPerPixel) - 1;\r\n        var i = 0, o = 0, missingBits = 0, bitsLeft = 0, n = 0, bitPos = 0;\r\n        var buffer;\r\n        var dest = [];\r\n        var nmax = Math.ceil((maxValue - offset) / scale);\r\n        for (o = 0; o < numPixels; o++) {\r\n          if (bitsLeft === 0) {\r\n            buffer = src[i++];\r\n            bitsLeft = 32;\r\n            bitPos = 0;\r\n          }\r\n          if (bitsLeft >= bitsPerPixel) {\r\n            //no unsigned left shift\r\n            n = ((buffer >>> bitPos) & bitMask);\r\n            bitsLeft -= bitsPerPixel;\r\n            bitPos += bitsPerPixel;\r\n          } else {\r\n            missingBits = (bitsPerPixel - bitsLeft);\r\n            n = (buffer >>> bitPos) & bitMask;//((buffer & bitMask) << missingBits) & bitMask;\r\n            buffer = src[i++];\r\n            bitsLeft = 32 - missingBits;\r\n            n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);\r\n            bitPos = missingBits;\r\n          }\r\n          //dest.push(n);\r\n          dest[o] = n < nmax ? offset + n * scale : maxValue;\r\n        }\r\n        dest.unshift(offset);\r\n        return dest;\r\n      },\r\n\r\n      originalUnstuff: function(src, dest, bitsPerPixel, numPixels) {\r\n        var bitMask = (1 << bitsPerPixel) - 1;\r\n        var i = 0, o;\r\n        var bitsLeft = 0;\r\n        var n, buffer, missingBits;\r\n\r\n        // get rid of trailing bytes that are already part of next block\r\n        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\r\n        src[src.length - 1] <<= 8 * numInvalidTailBytes;\r\n\r\n        for (o = 0; o < numPixels; o++) {\r\n          if (bitsLeft === 0) {\r\n            buffer = src[i++];\r\n            bitsLeft = 32;\r\n          }\r\n          if (bitsLeft >= bitsPerPixel) {\r\n            n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\r\n            bitsLeft -= bitsPerPixel;\r\n          }\r\n          else {\r\n            missingBits = (bitsPerPixel - bitsLeft);\r\n            n = ((buffer & bitMask) << missingBits) & bitMask;\r\n            buffer = src[i++];\r\n            bitsLeft = 32 - missingBits;\r\n            n += (buffer >>> bitsLeft);\r\n          }\r\n          dest[o] = n;\r\n        }\r\n        return dest;\r\n      },\r\n\r\n      originalUnstuff2: function(src, dest, bitsPerPixel, numPixels) {\r\n        var bitMask = (1 << bitsPerPixel) - 1;\r\n        var i = 0, o;\r\n        var bitsLeft = 0, bitPos = 0;\r\n        var n, buffer, missingBits;\r\n        //micro-optimizations\r\n        for (o = 0; o < numPixels; o++) {\r\n          if (bitsLeft === 0) {\r\n            buffer = src[i++];\r\n            bitsLeft = 32;\r\n            bitPos = 0;\r\n          }\r\n          if (bitsLeft >= bitsPerPixel) {\r\n            //no unsigned left shift\r\n            n = ((buffer >>> bitPos) & bitMask);\r\n            bitsLeft -= bitsPerPixel;\r\n            bitPos += bitsPerPixel;\r\n          } else {\r\n            missingBits = (bitsPerPixel - bitsLeft);\r\n            n = (buffer >>> bitPos) & bitMask;//((buffer & bitMask) << missingBits) & bitMask;\r\n            buffer = src[i++];\r\n            bitsLeft = 32 - missingBits;\r\n            n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);\r\n            bitPos = missingBits;\r\n          }\r\n          dest[o] = n;\r\n        }\r\n        return dest;\r\n      }\r\n    };\r\n\r\n    /*****************************************\r\n    *private static class used by Lerc2Decode\r\n    ******************************************/\r\n    var Lerc2Helpers = {\r\n      HUFFMAN_LUT_BITS_MAX: 12, //use 2^12 lut, treat it like constant\r\n      computeChecksumFletcher32: function(input) {\r\n\r\n        var sum1 = 0xffff, sum2 = 0xffff;\r\n        var len = input.length;\r\n        var words = Math.floor(len / 2);\r\n        var i = 0;\r\n        while (words) {\r\n          var tlen = (words >= 359) ? 359 : words;\r\n          words -= tlen;\r\n          do {\r\n            sum1 += (input[i++] << 8);\r\n            sum2 += sum1 += input[i++];\r\n          } while (--tlen);\r\n\r\n          sum1 = (sum1 & 0xffff) + (sum1 >>> 16);\r\n          sum2 = (sum2 & 0xffff) + (sum2 >>> 16);\r\n        }\r\n\r\n        // add the straggler byte if it exists\r\n        if (len & 1) {\r\n          sum2 += sum1 += (input[i] << 8);\r\n        }\r\n        // second reduction step to reduce sums to 16 bits\r\n        sum1 = (sum1 & 0xffff) + (sum1 >>> 16);\r\n        sum2 = (sum2 & 0xffff) + (sum2 >>> 16);\r\n\r\n        return (sum2 << 16 | sum1) >>> 0;\r\n      },\r\n\r\n      readHeaderInfo: function(input, data) {\r\n        var ptr = data.ptr;\r\n        var fileIdView = new Uint8Array(input, ptr, 6);\r\n        var headerInfo = {};\r\n        headerInfo.fileIdentifierString = String.fromCharCode.apply(null, fileIdView);\r\n        if (headerInfo.fileIdentifierString.lastIndexOf(\"Lerc2\", 0) !== 0) {\r\n          throw \"Unexpected file identifier string (expect Lerc2 ): \" + headerInfo.fileIdentifierString;\r\n        }\r\n        ptr += 6;\r\n        var view = new DataView(input, ptr, 8);\r\n        var fileVersion = view.getInt32(0, true);\r\n        headerInfo.fileVersion = fileVersion;\r\n        ptr += 4;\r\n        if (fileVersion >= 3) {\r\n          headerInfo.checksum = view.getUint32(4, true); //nrows\r\n          ptr += 4;\r\n        }\r\n\r\n        //keys start from here\r\n        view = new DataView(input, ptr, 12);\r\n        headerInfo.height = view.getUint32(0, true); //nrows\r\n        headerInfo.width = view.getUint32(4, true); //ncols\r\n        ptr += 8;\r\n        if (fileVersion >= 4) {\r\n          headerInfo.numDims = view.getUint32(8, true);\r\n          ptr += 4;\r\n        }\r\n        else {\r\n          headerInfo.numDims = 1;\r\n        }\r\n\r\n        view = new DataView(input, ptr, 40);\r\n        headerInfo.numValidPixel = view.getUint32(0, true);\r\n        headerInfo.microBlockSize = view.getInt32(4, true);\r\n        headerInfo.blobSize = view.getInt32(8, true);\r\n        headerInfo.imageType = view.getInt32(12, true);\r\n\r\n        headerInfo.maxZError = view.getFloat64(16, true);\r\n        headerInfo.zMin = view.getFloat64(24, true);\r\n        headerInfo.zMax = view.getFloat64(32, true);\r\n        ptr += 40;\r\n        data.headerInfo = headerInfo;\r\n        data.ptr = ptr;\r\n\r\n        var checksum, keyLength;\r\n        if (fileVersion >= 3) {\r\n          keyLength = fileVersion >= 4 ? 52 : 48;\r\n          checksum = this.computeChecksumFletcher32(new Uint8Array(input, ptr - keyLength, headerInfo.blobSize - 14));\r\n          if (checksum !== headerInfo.checksum) {\r\n            throw \"Checksum failed.\";\r\n          }\r\n        }\r\n        return true;\r\n      },\r\n\r\n      checkMinMaxRanges: function(input, data) {\r\n        var headerInfo = data.headerInfo;\r\n        var OutPixelTypeArray = this.getDataTypeArray(headerInfo.imageType);\r\n        var rangeBytes = headerInfo.numDims * this.getDataTypeSize(headerInfo.imageType);\r\n        var minValues = this.readSubArray(input, data.ptr, OutPixelTypeArray, rangeBytes);\r\n        var maxValues = this.readSubArray(input, data.ptr + rangeBytes, OutPixelTypeArray, rangeBytes);\r\n        data.ptr += (2 * rangeBytes);\r\n        var i, equal = true;\r\n        for (i = 0; i < headerInfo.numDims; i++) {\r\n          if (minValues[i] !== maxValues[i]) {\r\n            equal = false;\r\n            break;\r\n          }\r\n        }\r\n        headerInfo.minValues = minValues;\r\n        headerInfo.maxValues = maxValues;\r\n        return equal;\r\n      },\r\n\r\n      readSubArray: function(input, ptr, OutPixelTypeArray, numBytes) {\r\n        var rawData;\r\n        if (OutPixelTypeArray === Uint8Array) {\r\n          rawData = new Uint8Array(input, ptr, numBytes);\r\n        }\r\n        else {\r\n          var arrayBuf = new ArrayBuffer(numBytes);\r\n          var store8 = new Uint8Array(arrayBuf);\r\n          store8.set(new Uint8Array(input, ptr, numBytes));\r\n          rawData = new OutPixelTypeArray(arrayBuf);\r\n        }\r\n        return rawData;\r\n      },\r\n\r\n      readMask: function(input, data) {\r\n        var ptr = data.ptr;\r\n        var headerInfo = data.headerInfo;\r\n        var numPixels = headerInfo.width * headerInfo.height;\r\n        var numValidPixel = headerInfo.numValidPixel;\r\n\r\n        var view = new DataView(input, ptr, 4);\r\n        var mask = {};\r\n        mask.numBytes = view.getUint32(0, true);\r\n        ptr += 4;\r\n\r\n        // Mask Data\r\n        if ((0 === numValidPixel || numPixels === numValidPixel) && 0 !== mask.numBytes) {\r\n          throw (\"invalid mask\");\r\n        }\r\n        var bitset, resultMask;\r\n        if (numValidPixel === 0) {\r\n          bitset = new Uint8Array(Math.ceil(numPixels / 8));\r\n          mask.bitset = bitset;\r\n          resultMask = new Uint8Array(numPixels);\r\n          data.pixels.resultMask = resultMask;\r\n          ptr += mask.numBytes;\r\n        }// ????? else if (data.mask.numBytes > 0 && data.mask.numBytes< data.numValidPixel) {\r\n        else if (mask.numBytes > 0) {\r\n          bitset = new Uint8Array(Math.ceil(numPixels / 8));\r\n          view = new DataView(input, ptr, mask.numBytes);\r\n          var cnt = view.getInt16(0, true);\r\n          var ip = 2, op = 0, val = 0;\r\n          do {\r\n            if (cnt > 0) {\r\n              while (cnt--) { bitset[op++] = view.getUint8(ip++); }\r\n            } else {\r\n              val = view.getUint8(ip++);\r\n              cnt = -cnt;\r\n              while (cnt--) { bitset[op++] = val; }\r\n            }\r\n            cnt = view.getInt16(ip, true);\r\n            ip += 2;\r\n          } while (ip < mask.numBytes);\r\n          if ((cnt !== -32768) || (op < bitset.length)) {\r\n            throw \"Unexpected end of mask RLE encoding\";\r\n          }\r\n\r\n          resultMask = new Uint8Array(numPixels);\r\n          var mb = 0, k = 0;\r\n\r\n          for (k = 0; k < numPixels; k++) {\r\n            if (k & 7) {\r\n              mb = bitset[k >> 3];\r\n              mb <<= k & 7;\r\n            }\r\n            else {\r\n              mb = bitset[k >> 3];\r\n            }\r\n            if (mb & 128) {\r\n              resultMask[k] = 1;\r\n            }\r\n          }\r\n          data.pixels.resultMask = resultMask;\r\n\r\n          mask.bitset = bitset;\r\n          ptr += mask.numBytes;\r\n        }\r\n        data.ptr = ptr;\r\n        data.mask = mask;\r\n        return true;\r\n      },\r\n\r\n      readDataOneSweep: function(input, data, OutPixelTypeArray) {\r\n        var ptr = data.ptr;\r\n        var headerInfo = data.headerInfo;\r\n        var numDims = headerInfo.numDims;\r\n        var numPixels = headerInfo.width * headerInfo.height;\r\n        var imageType = headerInfo.imageType;\r\n        var numBytes = headerInfo.numValidPixel * Lerc2Helpers.getDataTypeSize(imageType) * numDims;\r\n        //data.pixels.numBytes = numBytes;\r\n        var rawData;\r\n        var mask = data.pixels.resultMask;\r\n        if (OutPixelTypeArray === Uint8Array) {\r\n          rawData = new Uint8Array(input, ptr, numBytes);\r\n        }\r\n        else {\r\n          var arrayBuf = new ArrayBuffer(numBytes);\r\n          var store8 = new Uint8Array(arrayBuf);\r\n          store8.set(new Uint8Array(input, ptr, numBytes));\r\n          rawData = new OutPixelTypeArray(arrayBuf);\r\n        }\r\n        if (rawData.length === numPixels * numDims) {\r\n          data.pixels.resultPixels = rawData;\r\n        }\r\n        else  //mask\r\n        {\r\n          data.pixels.resultPixels = new OutPixelTypeArray(numPixels * numDims);\r\n          var z = 0, k = 0, i = 0, nStart = 0;\r\n          if (numDims > 1) {\r\n            for (i=0; i < numDims; i++) {\r\n              nStart = i * numPixels;\r\n              for (k = 0; k < numPixels; k++) {\r\n                if (mask[k]) {\r\n                  data.pixels.resultPixels[nStart + k] = rawData[z++];\r\n                }\r\n              }\r\n            }\r\n          }\r\n          else {\r\n            for (k = 0; k < numPixels; k++) {\r\n              if (mask[k]) {\r\n                data.pixels.resultPixels[k] = rawData[z++];\r\n              }\r\n            }\r\n          }\r\n        }\r\n        ptr += numBytes;\r\n        data.ptr = ptr;       //return data;\r\n        return true;\r\n      },\r\n\r\n      readHuffmanTree: function(input, data) {\r\n        var BITS_MAX = this.HUFFMAN_LUT_BITS_MAX; //8 is slow for the large test image\r\n        //var size_max = 1 << BITS_MAX;\r\n        /* ************************\r\n         * reading code table\r\n         *************************/\r\n        var view = new DataView(input, data.ptr, 16);\r\n        data.ptr += 16;\r\n        var version = view.getInt32(0, true);\r\n        if (version < 2) {\r\n          throw \"unsupported Huffman version\";\r\n        }\r\n        var size = view.getInt32(4, true);\r\n        var i0 = view.getInt32(8, true);\r\n        var i1 = view.getInt32(12, true);\r\n        if (i0 >= i1) {\r\n          return false;\r\n        }\r\n        var blockDataBuffer = new Uint32Array(i1 - i0);\r\n        Lerc2Helpers.decodeBits(input, data, blockDataBuffer);\r\n        var codeTable = []; //size\r\n        var i, j, k, len;\r\n\r\n        for (i = i0; i < i1; i++) {\r\n          j = i - (i < size ? 0 : size);//wrap around\r\n          codeTable[j] = { first: blockDataBuffer[i - i0], second: null };\r\n        }\r\n\r\n        var dataBytes = input.byteLength - data.ptr;\r\n        var dataWords = Math.ceil(dataBytes / 4);\r\n        var arrayBuf = new ArrayBuffer(dataWords * 4);\r\n        var store8 = new Uint8Array(arrayBuf);\r\n        store8.set(new Uint8Array(input, data.ptr, dataBytes));\r\n        var stuffedData = new Uint32Array(arrayBuf); //must start from x*4\r\n        var bitPos = 0, word, srcPtr = 0;\r\n        word = stuffedData[0];\r\n        for (i = i0; i < i1; i++) {\r\n          j = i - (i < size ? 0 : size);//wrap around\r\n          len = codeTable[j].first;\r\n          if (len > 0) {\r\n            codeTable[j].second = (word << bitPos) >>> (32 - len);\r\n\r\n            if (32 - bitPos >= len) {\r\n              bitPos += len;\r\n              if (bitPos === 32) {\r\n                bitPos = 0;\r\n                srcPtr++;\r\n                word = stuffedData[srcPtr];\r\n              }\r\n            }\r\n            else {\r\n              bitPos += len - 32;\r\n              srcPtr++;\r\n              word = stuffedData[srcPtr];\r\n              codeTable[j].second |= word >>> (32 - bitPos);\r\n            }\r\n          }\r\n        }\r\n\r\n        //finished reading code table\r\n\r\n        /* ************************\r\n         * building lut\r\n         *************************/\r\n        var numBitsLUT = 0, numBitsLUTQick = 0;\r\n        var tree = new TreeNode();\r\n        for (i = 0; i < codeTable.length; i++) {\r\n          if (codeTable[i] !== undefined) {\r\n            numBitsLUT = Math.max(numBitsLUT, codeTable[i].first);\r\n          }\r\n        }\r\n        if (numBitsLUT >= BITS_MAX) {\r\n          numBitsLUTQick = BITS_MAX;\r\n        }\r\n        else {\r\n          numBitsLUTQick = numBitsLUT;\r\n        }\r\n        if (numBitsLUT >= 30) {\r\n          console.log(\"WARning, large NUM LUT BITS IS \" + numBitsLUT);\r\n        }\r\n        var decodeLut = [], entry, code, numEntries, jj, currentBit, node;\r\n        for (i = i0; i < i1; i++) {\r\n          j = i - (i < size ? 0 : size);//wrap around\r\n          len = codeTable[j].first;\r\n          if (len > 0) {\r\n            entry = [len, j];\r\n            if (len <= numBitsLUTQick) {\r\n              code = codeTable[j].second << (numBitsLUTQick - len);\r\n              numEntries = 1 << (numBitsLUTQick - len);\r\n              for (k = 0; k < numEntries; k++) {\r\n                decodeLut[code | k] = entry;\r\n              }\r\n            }\r\n            else {\r\n              //build tree\r\n              code = codeTable[j].second;\r\n              node = tree;\r\n              for (jj = len - 1; jj >= 0; jj--) {\r\n                currentBit = code >>> jj & 1; //no left shift as length could be 30,31\r\n                if (currentBit) {\r\n                  if (!node.right) {\r\n                    node.right = new TreeNode();\r\n                  }\r\n                  node = node.right;\r\n                }\r\n                else {\r\n                  if (!node.left) {\r\n                    node.left = new TreeNode();\r\n                  }\r\n                  node = node.left;\r\n                }\r\n                if (jj === 0 && !node.val) {\r\n                  node.val = entry[1];\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n        return {\r\n          decodeLut: decodeLut,\r\n          numBitsLUTQick: numBitsLUTQick,\r\n          numBitsLUT: numBitsLUT,\r\n          tree: tree,\r\n          stuffedData: stuffedData,\r\n          srcPtr: srcPtr,\r\n          bitPos: bitPos\r\n        };\r\n      },\r\n\r\n      readHuffman: function(input, data, OutPixelTypeArray) {\r\n        var headerInfo = data.headerInfo;\r\n        var numDims = headerInfo.numDims;\r\n        var height = data.headerInfo.height;\r\n        var width = data.headerInfo.width;\r\n        var numPixels = width * height;\r\n        //var size_max = 1 << BITS_MAX;\r\n        /* ************************\r\n         * reading huffman structure info\r\n         *************************/\r\n        var huffmanInfo = this.readHuffmanTree(input, data);\r\n        var decodeLut = huffmanInfo.decodeLut;\r\n        var tree = huffmanInfo.tree;\r\n        //stuffedData includes huffman headers\r\n        var stuffedData = huffmanInfo.stuffedData;\r\n        var srcPtr = huffmanInfo.srcPtr;\r\n        var bitPos = huffmanInfo.bitPos;\r\n        var numBitsLUTQick = huffmanInfo.numBitsLUTQick;\r\n        var numBitsLUT = huffmanInfo.numBitsLUT;\r\n        var offset = data.headerInfo.imageType === 0 ? 128 : 0;\r\n        /*************************\r\n        *  decode\r\n        ***************************/\r\n        var node, val, delta, mask = data.pixels.resultMask, valTmp, valTmpQuick, currentBit;\r\n        var i, j, k, ii;\r\n        var prevVal = 0;\r\n        if (bitPos > 0) {\r\n          srcPtr++;\r\n          bitPos = 0;\r\n        }\r\n        var word = stuffedData[srcPtr];\r\n        var deltaEncode = data.encodeMode === 1;\r\n        var resultPixelsAllDim = new OutPixelTypeArray(numPixels * numDims);\r\n        var resultPixels = resultPixelsAllDim;\r\n        var iDim;\r\n        for (iDim = 0; iDim < headerInfo.numDims; iDim++) {\r\n          if (numDims > 1) {\r\n            //get the mem block of current dimension\r\n            resultPixels = new OutPixelTypeArray(resultPixelsAllDim.buffer, numPixels * iDim, numPixels);\r\n            prevVal = 0;\r\n          }\r\n          if (data.headerInfo.numValidPixel === width * height) { //all valid\r\n            for (k = 0, i = 0; i < height; i++) {\r\n              for (j = 0; j < width; j++, k++) {\r\n                val = 0;\r\n                valTmp = (word << bitPos) >>> (32 - numBitsLUTQick);\r\n                valTmpQuick = valTmp;// >>> deltaBits;\r\n                if (32 - bitPos < numBitsLUTQick) {\r\n                  valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUTQick));\r\n                  valTmpQuick = valTmp;// >>> deltaBits;\r\n                }\r\n                if (decodeLut[valTmpQuick])    // if there, move the correct number of bits and done\r\n                {\r\n                  val = decodeLut[valTmpQuick][1];\r\n                  bitPos += decodeLut[valTmpQuick][0];\r\n                }\r\n                else {\r\n                  valTmp = (word << bitPos) >>> (32 - numBitsLUT);\r\n                  valTmpQuick = valTmp;// >>> deltaBits;\r\n                  if (32 - bitPos < numBitsLUT) {\r\n                    valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUT));\r\n                    valTmpQuick = valTmp;// >>> deltaBits;\r\n                  }\r\n                  node = tree;\r\n                  for (ii = 0; ii < numBitsLUT; ii++) {\r\n                    currentBit = valTmp >>> (numBitsLUT - ii - 1) & 1;\r\n                    node = currentBit ? node.right : node.left;\r\n                    if (!(node.left || node.right)) {\r\n                      val = node.val;\r\n                      bitPos = bitPos + ii + 1;\r\n                      break;\r\n                    }\r\n                  }\r\n                }\r\n\r\n                if (bitPos >= 32) {\r\n                  bitPos -= 32;\r\n                  srcPtr++;\r\n                  word = stuffedData[srcPtr];\r\n                }\r\n\r\n                delta = val - offset;\r\n                if (deltaEncode) {\r\n                  if (j > 0) {\r\n                    delta += prevVal;    // use overflow\r\n                  }\r\n                  else if (i > 0) {\r\n                    delta += resultPixels[k - width];\r\n                  }\r\n                  else {\r\n                    delta += prevVal;\r\n                  }\r\n                  delta &= 0xFF; //overflow\r\n                  resultPixels[k] = delta;//overflow\r\n                  prevVal = delta;\r\n                }\r\n                else {\r\n                  resultPixels[k] = delta;\r\n                }\r\n              }\r\n            }\r\n          }\r\n          else { //not all valid, use mask\r\n            for (k = 0, i = 0; i < height; i++) {\r\n              for (j = 0; j < width; j++, k++) {\r\n                if (mask[k]) {\r\n                  val = 0;\r\n                  valTmp = (word << bitPos) >>> (32 - numBitsLUTQick);\r\n                  valTmpQuick = valTmp;// >>> deltaBits;\r\n                  if (32 - bitPos < numBitsLUTQick) {\r\n                    valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUTQick));\r\n                    valTmpQuick = valTmp;// >>> deltaBits;\r\n                  }\r\n                  if (decodeLut[valTmpQuick])    // if there, move the correct number of bits and done\r\n                  {\r\n                    val = decodeLut[valTmpQuick][1];\r\n                    bitPos += decodeLut[valTmpQuick][0];\r\n                  }\r\n                  else {\r\n                    valTmp = (word << bitPos) >>> (32 - numBitsLUT);\r\n                    valTmpQuick = valTmp;// >>> deltaBits;\r\n                    if (32 - bitPos < numBitsLUT) {\r\n                      valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUT));\r\n                      valTmpQuick = valTmp;// >>> deltaBits;\r\n                    }\r\n                    node = tree;\r\n                    for (ii = 0; ii < numBitsLUT; ii++) {\r\n                      currentBit = valTmp >>> (numBitsLUT - ii - 1) & 1;\r\n                      node = currentBit ? node.right : node.left;\r\n                      if (!(node.left || node.right)) {\r\n                        val = node.val;\r\n                        bitPos = bitPos + ii + 1;\r\n                        break;\r\n                      }\r\n                    }\r\n                  }\r\n\r\n                  if (bitPos >= 32) {\r\n                    bitPos -= 32;\r\n                    srcPtr++;\r\n                    word = stuffedData[srcPtr];\r\n                  }\r\n\r\n                  delta = val - offset;\r\n                  if (deltaEncode) {\r\n                    if (j > 0 && mask[k - 1]) {\r\n                      delta += prevVal;    // use overflow\r\n                    }\r\n                    else if (i > 0 && mask[k - width]) {\r\n                      delta += resultPixels[k - width];\r\n                    }\r\n                    else {\r\n                      delta += prevVal;\r\n                    }\r\n\r\n                    delta &= 0xFF; //overflow\r\n                    resultPixels[k] = delta;//overflow\r\n                    prevVal = delta;\r\n                  }\r\n                  else {\r\n                    resultPixels[k] = delta;\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n          data.ptr = data.ptr + (srcPtr + 1) * 4 + (bitPos > 0 ? 4 : 0);\r\n        }\r\n        data.pixels.resultPixels = resultPixelsAllDim;\r\n      },\r\n\r\n      decodeBits: function(input, data, blockDataBuffer, offset, iDim) {\r\n        {\r\n          //bitstuff encoding is 3\r\n          var headerInfo = data.headerInfo;\r\n          var fileVersion = headerInfo.fileVersion;\r\n          //var block = {};\r\n          var blockPtr = 0;\r\n          var viewByteLength = ((input.byteLength - data.ptr) >= 5) ? 5 : (input.byteLength - data.ptr);\r\n          var view = new DataView(input, data.ptr, viewByteLength);\r\n          var headerByte = view.getUint8(0);\r\n          blockPtr++;\r\n          var bits67 = headerByte >> 6;\r\n          var n = (bits67 === 0) ? 4 : 3 - bits67;\r\n          var doLut = (headerByte & 32) > 0 ? true : false;//5th bit\r\n          var numBits = headerByte & 31;\r\n          var numElements = 0;\r\n          if (n === 1) {\r\n            numElements = view.getUint8(blockPtr); blockPtr++;\r\n          } else if (n === 2) {\r\n            numElements = view.getUint16(blockPtr, true); blockPtr += 2;\r\n          } else if (n === 4) {\r\n            numElements = view.getUint32(blockPtr, true); blockPtr += 4;\r\n          } else {\r\n            throw \"Invalid valid pixel count type\";\r\n          }\r\n          //fix: huffman codes are bit stuffed, but not bound by data's max value, so need to use originalUnstuff\r\n          //offset = offset || 0;\r\n          var scale = 2 * headerInfo.maxZError;\r\n          var stuffedData, arrayBuf, store8, dataBytes, dataWords;\r\n          var lutArr, lutData, lutBytes, lutBitsPerElement, bitsPerPixel;\r\n          var zMax = headerInfo.numDims > 1 ? headerInfo.maxValues[iDim] : headerInfo.zMax;\r\n          if (doLut) {\r\n            data.counter.lut++;\r\n            lutBytes = view.getUint8(blockPtr);\r\n            lutBitsPerElement = numBits;\r\n            blockPtr++;\r\n            dataBytes = Math.ceil((lutBytes - 1) * numBits / 8);\r\n            dataWords = Math.ceil(dataBytes / 4);\r\n            arrayBuf = new ArrayBuffer(dataWords * 4);\r\n            store8 = new Uint8Array(arrayBuf);\r\n\r\n            data.ptr += blockPtr;\r\n            store8.set(new Uint8Array(input, data.ptr, dataBytes));\r\n\r\n            lutData = new Uint32Array(arrayBuf);\r\n            data.ptr += dataBytes;\r\n\r\n            bitsPerPixel = 0;\r\n            while ((lutBytes - 1) >>> bitsPerPixel) {\r\n              bitsPerPixel++;\r\n            }\r\n            dataBytes = Math.ceil(numElements * bitsPerPixel / 8);\r\n            dataWords = Math.ceil(dataBytes / 4);\r\n            arrayBuf = new ArrayBuffer(dataWords * 4);\r\n            store8 = new Uint8Array(arrayBuf);\r\n            store8.set(new Uint8Array(input, data.ptr, dataBytes));\r\n            stuffedData = new Uint32Array(arrayBuf);\r\n            data.ptr += dataBytes;\r\n            if (fileVersion >= 3) {\r\n              lutArr = BitStuffer.unstuffLUT2(lutData, numBits, lutBytes - 1, offset, scale, zMax);\r\n            }\r\n            else {\r\n              lutArr = BitStuffer.unstuffLUT(lutData, numBits, lutBytes - 1, offset, scale, zMax);\r\n            }\r\n            //lutArr.unshift(0);\r\n            if (fileVersion >= 3) {\r\n              //BitStuffer.unstuff2(block, blockDataBuffer, headerInfo.zMax);\r\n              BitStuffer.unstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements, lutArr);\r\n            }\r\n            else {\r\n              BitStuffer.unstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements, lutArr);\r\n            }\r\n          }\r\n          else {\r\n            //console.debug(\"bitstuffer\");\r\n            data.counter.bitstuffer++;\r\n            bitsPerPixel = numBits;\r\n            data.ptr += blockPtr;\r\n            if (bitsPerPixel > 0) {\r\n              dataBytes = Math.ceil(numElements * bitsPerPixel / 8);\r\n              dataWords = Math.ceil(dataBytes / 4);\r\n              arrayBuf = new ArrayBuffer(dataWords * 4);\r\n              store8 = new Uint8Array(arrayBuf);\r\n              store8.set(new Uint8Array(input, data.ptr, dataBytes));\r\n              stuffedData = new Uint32Array(arrayBuf);\r\n              data.ptr += dataBytes;\r\n              if (fileVersion >= 3) {\r\n                if (offset === null) {\r\n                  BitStuffer.originalUnstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements);\r\n                }\r\n                else {\r\n                  BitStuffer.unstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements, false, offset, scale, zMax);\r\n                }\r\n              }\r\n              else {\r\n                if (offset === null) {\r\n                  BitStuffer.originalUnstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements);\r\n                }\r\n                else {\r\n                  BitStuffer.unstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements, false, offset, scale, zMax);\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n      },\r\n\r\n      readTiles: function(input, data, OutPixelTypeArray) {\r\n        var headerInfo = data.headerInfo;\r\n        var width = headerInfo.width;\r\n        var height = headerInfo.height;\r\n        var microBlockSize = headerInfo.microBlockSize;\r\n        var imageType = headerInfo.imageType;\r\n        var dataTypeSize = Lerc2Helpers.getDataTypeSize(imageType);\r\n        var numBlocksX = Math.ceil(width / microBlockSize);\r\n        var numBlocksY = Math.ceil(height / microBlockSize);\r\n        data.pixels.numBlocksY = numBlocksY;\r\n        data.pixels.numBlocksX = numBlocksX;\r\n        data.pixels.ptr = 0;\r\n        var row = 0, col = 0, blockY = 0, blockX = 0, thisBlockHeight = 0, thisBlockWidth = 0, bytesLeft = 0, headerByte = 0, bits67 = 0, testCode = 0, outPtr = 0, outStride = 0, numBytes = 0, bytesleft = 0, z = 0, blockPtr = 0;\r\n        var view, block, arrayBuf, store8, rawData;\r\n        var blockEncoding;\r\n        var blockDataBuffer = new OutPixelTypeArray(microBlockSize * microBlockSize);\r\n        var lastBlockHeight = (height % microBlockSize) || microBlockSize;\r\n        var lastBlockWidth = (width % microBlockSize) || microBlockSize;\r\n        var offsetType, offset;\r\n        var numDims = headerInfo.numDims, iDim;\r\n        var mask = data.pixels.resultMask;\r\n        var resultPixels = data.pixels.resultPixels;\r\n        for (blockY = 0; blockY < numBlocksY; blockY++) {\r\n          thisBlockHeight = (blockY !== numBlocksY - 1) ? microBlockSize : lastBlockHeight;\r\n          for (blockX = 0; blockX < numBlocksX; blockX++) {\r\n            //console.debug(\"y\" + blockY + \" x\" + blockX);\r\n            thisBlockWidth = (blockX !== numBlocksX - 1) ? microBlockSize : lastBlockWidth;\r\n\r\n            outPtr = blockY * width * microBlockSize + blockX * microBlockSize;\r\n            outStride = width - thisBlockWidth;\r\n\r\n\r\n            for (iDim = 0; iDim < numDims; iDim++) {\r\n              if (numDims > 1) {\r\n                resultPixels = new OutPixelTypeArray(data.pixels.resultPixels.buffer, width * height * iDim * dataTypeSize, width * height);\r\n              }\r\n              bytesLeft = input.byteLength - data.ptr;\r\n              view = new DataView(input, data.ptr, Math.min(10, bytesLeft));\r\n              block = {};\r\n              blockPtr = 0;\r\n              headerByte = view.getUint8(0);\r\n              blockPtr++;\r\n              bits67 = (headerByte >> 6) & 0xFF;\r\n              testCode = (headerByte >> 2) & 15;    // use bits 2345 for integrity check\r\n              if (testCode !== (((blockX * microBlockSize) >> 3) & 15)) {\r\n                throw \"integrity issue\";\r\n                //return false;\r\n              }\r\n\r\n              blockEncoding = headerByte & 3;\r\n              if (blockEncoding > 3) {\r\n                data.ptr += blockPtr;\r\n                throw \"Invalid block encoding (\" + blockEncoding + \")\";\r\n              }\r\n              else if (blockEncoding === 2) { //constant 0\r\n                data.counter.constant++;\r\n                data.ptr += blockPtr;\r\n                continue;\r\n              }\r\n              else if (blockEncoding === 0) {  //uncompressed\r\n                data.counter.uncompressed++;\r\n                data.ptr += blockPtr;\r\n                numBytes = thisBlockHeight * thisBlockWidth * dataTypeSize;\r\n                bytesleft = input.byteLength - data.ptr;\r\n                numBytes = numBytes < bytesleft ? numBytes : bytesleft;\r\n                //bit alignment\r\n                arrayBuf = new ArrayBuffer((numBytes % dataTypeSize) === 0 ? numBytes : (numBytes + dataTypeSize - numBytes % dataTypeSize));\r\n                store8 = new Uint8Array(arrayBuf);\r\n                store8.set(new Uint8Array(input, data.ptr, numBytes));\r\n                rawData = new OutPixelTypeArray(arrayBuf);\r\n                z = 0;\r\n                if (mask) {\r\n                  for (row = 0; row < thisBlockHeight; row++) {\r\n                    for (col = 0; col < thisBlockWidth; col++) {\r\n                      if (mask[outPtr]) {\r\n                        resultPixels[outPtr] = rawData[z++];\r\n                      }\r\n                      outPtr++;\r\n                    }\r\n                    outPtr += outStride;\r\n                  }\r\n                }\r\n                else {//all valid\r\n                  for (row = 0; row < thisBlockHeight; row++) {\r\n                    for (col = 0; col < thisBlockWidth; col++) {\r\n                      resultPixels[outPtr++] = rawData[z++];\r\n                    }\r\n                    outPtr += outStride;\r\n                  }\r\n                }\r\n                data.ptr += z * dataTypeSize;\r\n              }\r\n              else { //1 or 3\r\n                offsetType = Lerc2Helpers.getDataTypeUsed(imageType, bits67);\r\n                offset = Lerc2Helpers.getOnePixel(block, blockPtr, offsetType, view);\r\n                blockPtr += Lerc2Helpers.getDataTypeSize(offsetType);\r\n                if (blockEncoding === 3) //constant offset value\r\n                {\r\n                  data.ptr += blockPtr;\r\n                  data.counter.constantoffset++;\r\n                  //you can delete the following resultMask case in favor of performance because val is constant and users use nodata mask, otherwise nodatavalue post processing handles it too.\r\n                  //while the above statement is true, we're not doing it as we want to keep invalid pixel value at 0 rather than arbitrary values\r\n                  if (mask) {\r\n                    for (row = 0; row < thisBlockHeight; row++) {\r\n                      for (col = 0; col < thisBlockWidth; col++) {\r\n                        if (mask[outPtr]) {\r\n                          resultPixels[outPtr] = offset;\r\n                        }\r\n                        outPtr++;\r\n                      }\r\n                      outPtr += outStride;\r\n                    }\r\n                  }\r\n                  else {\r\n                    for (row = 0; row < thisBlockHeight; row++) {\r\n                      for (col = 0; col < thisBlockWidth; col++) {\r\n                        resultPixels[outPtr++] = offset;\r\n                      }\r\n                      outPtr += outStride;\r\n                    }\r\n                  }\r\n                }\r\n                else { //bitstuff encoding is 3\r\n                  data.ptr += blockPtr;\r\n                  //heavy lifting\r\n                  Lerc2Helpers.decodeBits(input, data, blockDataBuffer, offset, iDim);\r\n                  blockPtr = 0;\r\n                  if (mask) {\r\n                    for (row = 0; row < thisBlockHeight; row++) {\r\n                      for (col = 0; col < thisBlockWidth; col++) {\r\n                        if (mask[outPtr]) {\r\n                          resultPixels[outPtr] = blockDataBuffer[blockPtr++];\r\n                        }\r\n                        outPtr++;\r\n                      }\r\n                      outPtr += outStride;\r\n                    }\r\n                  }\r\n                  else {\r\n                    for (row = 0; row < thisBlockHeight; row++) {\r\n                      for (col = 0; col < thisBlockWidth; col++) {\r\n                        resultPixels[outPtr++] = blockDataBuffer[blockPtr++];\r\n                      }\r\n                      outPtr += outStride;\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      },\r\n\r\n      /*****************\r\n      *  private methods (helper methods)\r\n      *****************/\r\n\r\n      formatFileInfo: function(data) {\r\n        return {\r\n          \"fileIdentifierString\": data.headerInfo.fileIdentifierString,\r\n          \"fileVersion\": data.headerInfo.fileVersion,\r\n          \"imageType\": data.headerInfo.imageType,\r\n          \"height\": data.headerInfo.height,\r\n          \"width\": data.headerInfo.width,\r\n          \"numValidPixel\": data.headerInfo.numValidPixel,\r\n          \"microBlockSize\": data.headerInfo.microBlockSize,\r\n          \"blobSize\": data.headerInfo.blobSize,\r\n          \"maxZError\": data.headerInfo.maxZError,\r\n          \"pixelType\": Lerc2Helpers.getPixelType(data.headerInfo.imageType),\r\n          \"eofOffset\": data.eofOffset,\r\n          \"mask\": data.mask ? {\r\n            \"numBytes\": data.mask.numBytes\r\n          } : null,\r\n          \"pixels\": {\r\n            \"numBlocksX\": data.pixels.numBlocksX,\r\n            \"numBlocksY\": data.pixels.numBlocksY,\r\n            //\"numBytes\": data.pixels.numBytes,\r\n            \"maxValue\": data.headerInfo.zMax,\r\n            \"minValue\": data.headerInfo.zMin,\r\n            \"noDataValue\": data.noDataValue\r\n          }\r\n        };\r\n      },\r\n\r\n      constructConstantSurface: function(data) {\r\n        var val = data.headerInfo.zMax;\r\n        var numDims =  data.headerInfo.numDims;\r\n        var numPixels = data.headerInfo.height * data.headerInfo.width;\r\n        var numPixelAllDims = numPixels * numDims;\r\n        var i=0, k = 0, nStart=0;\r\n        var mask = data.pixels.resultMask;\r\n        if (mask) {\r\n          if (numDims > 1) {\r\n            for (i=0; i < numDims; i++) {\r\n              nStart = i * numPixels;\r\n              for (k = 0; k < numPixels; k++) {\r\n                if (mask[k]) {\r\n                  data.pixels.resultPixels[nStart + k] = val;\r\n                }\r\n              }\r\n            }\r\n          }\r\n          else {\r\n            for (k = 0; k < numPixels; k++) {\r\n              if (mask[k]) {\r\n                data.pixels.resultPixels[k] = val;\r\n              }\r\n            }\r\n          }\r\n        }\r\n        else {\r\n          if (data.pixels.resultPixels.fill) {\r\n            data.pixels.resultPixels.fill(val);\r\n          }\r\n          else {\r\n            for (k = 0; k < numPixelAllDims; k++) {\r\n              data.pixels.resultPixels[k] = val;\r\n            }\r\n          }\r\n        }\r\n        return;\r\n      },\r\n\r\n      getDataTypeArray: function(t) {\r\n        var tp;\r\n        switch (t) {\r\n          case 0: //char\r\n            tp = Int8Array;\r\n            break;\r\n          case 1: //byte\r\n            tp = Uint8Array;\r\n            break;\r\n          case 2: //short\r\n            tp = Int16Array;\r\n            break;\r\n          case 3: //ushort\r\n            tp = Uint16Array;\r\n            break;\r\n          case 4:\r\n            tp = Int32Array;\r\n            break;\r\n          case 5:\r\n            tp = Uint32Array;\r\n            break;\r\n          case 6:\r\n            tp = Float32Array;\r\n            break;\r\n          case 7:\r\n            tp = Float64Array;\r\n            break;\r\n          default:\r\n            tp = Float32Array;\r\n        }\r\n        return tp;\r\n      },\r\n\r\n      getPixelType: function(t) {\r\n        var tp;\r\n        switch (t) {\r\n          case 0: //char\r\n            tp = \"S8\";\r\n            break;\r\n          case 1: //byte\r\n            tp = \"U8\";\r\n            break;\r\n          case 2: //short\r\n            tp = \"S16\";\r\n            break;\r\n          case 3: //ushort\r\n            tp = \"U16\";\r\n            break;\r\n          case 4:\r\n            tp = \"S32\";\r\n            break;\r\n          case 5:\r\n            tp = \"U32\";\r\n            break;\r\n          case 6:\r\n            tp = \"F32\";\r\n            break;\r\n          case 7:\r\n            tp = \"F64\"; //not supported\r\n            break;\r\n          default:\r\n            tp = \"F32\";\r\n        }\r\n        return tp;\r\n      },\r\n\r\n      isValidPixelValue: function(t, val) {\r\n        if (val === null) {\r\n          return false;\r\n        }\r\n        var isValid;\r\n        switch (t) {\r\n          case 0: //char\r\n            isValid = val >= -128 && val <= 127;\r\n            break;\r\n          case 1: //byte  (unsigned char)\r\n            isValid = val >= 0 && val <= 255;\r\n            break;\r\n          case 2: //short\r\n            isValid = val >= -32768 && val <= 32767;\r\n            break;\r\n          case 3: //ushort\r\n            isValid = val >= 0 && val <= 65536;\r\n            break;\r\n          case 4: //int 32\r\n            isValid = val >= -2147483648 && val <= 2147483647;\r\n            break;\r\n          case 5: //uinit 32\r\n            isValid = val >= 0 && val <= 4294967296;\r\n            break;\r\n          case 6:\r\n            isValid = val >= -3.4027999387901484e+38 && val <= 3.4027999387901484e+38;\r\n            break;\r\n          case 7:\r\n            isValid = val >= 5e-324 && val <= 1.7976931348623157e+308;\r\n            break;\r\n          default:\r\n            isValid = false;\r\n        }\r\n        return isValid;\r\n      },\r\n\r\n      getDataTypeSize: function(t) {\r\n        var s = 0;\r\n        switch (t) {\r\n          case 0: //ubyte\r\n          case 1: //byte\r\n            s = 1;\r\n            break;\r\n          case 2: //short\r\n          case 3: //ushort\r\n            s = 2;\r\n            break;\r\n          case 4:\r\n          case 5:\r\n          case 6:\r\n            s = 4;\r\n            break;\r\n          case 7:\r\n            s = 8;\r\n            break;\r\n          default:\r\n            s = t;\r\n        }\r\n        return s;\r\n      },\r\n\r\n      getDataTypeUsed: function(dt, tc) {\r\n        var t = dt;\r\n        switch (dt) {\r\n          case 2: //short\r\n          case 4: //long\r\n            t = dt - tc;\r\n            break;\r\n          case 3: //ushort\r\n          case 5: //ulong\r\n            t = dt - 2 * tc;\r\n            break;\r\n          case 6: //float\r\n            if (0 === tc) {\r\n              t = dt;\r\n            }\r\n            else if (1 === tc) {\r\n              t = 2;\r\n            }\r\n            else {\r\n              t = 1;//byte\r\n            }\r\n            break;\r\n          case 7: //double\r\n            if (0 === tc) {\r\n              t = dt;\r\n            }\r\n            else {\r\n              t = dt - 2 * tc + 1;\r\n            }\r\n            break;\r\n          default:\r\n            t = dt;\r\n            break;\r\n        }\r\n        return t;\r\n      },\r\n\r\n      getOnePixel: function(block, blockPtr, offsetType, view) {\r\n        var temp = 0;\r\n        switch (offsetType) {\r\n          case 0: //char\r\n            temp = view.getInt8(blockPtr);\r\n            break;\r\n          case 1: //byte\r\n            temp = view.getUint8(blockPtr);\r\n            break;\r\n          case 2:\r\n            temp = view.getInt16(blockPtr, true);\r\n            break;\r\n          case 3:\r\n            temp = view.getUint16(blockPtr, true);\r\n            break;\r\n          case 4:\r\n            temp = view.getInt32(blockPtr, true);\r\n            break;\r\n          case 5:\r\n            temp = view.getUInt32(blockPtr, true);\r\n            break;\r\n          case 6:\r\n            temp = view.getFloat32(blockPtr, true);\r\n            break;\r\n          case 7:\r\n            //temp = view.getFloat64(blockPtr, true);\r\n            //blockPtr += 8;\r\n            //lerc2 encoding doesnt handle float 64, force to float32???\r\n            temp = view.getFloat64(blockPtr, true);\r\n            break;\r\n          default:\r\n            throw (\"the decoder does not understand this pixel type\");\r\n        }\r\n        return temp;\r\n      }\r\n    };\r\n\r\n    /***************************************************\r\n    *private class for a tree node. Huffman code is in Lerc2Helpers\r\n    ****************************************************/\r\n    var TreeNode = function(val, left, right) {\r\n      this.val = val;\r\n      this.left = left;\r\n      this.right = right;\r\n    };\r\n\r\n    var Lerc2Decode = {\r\n      /*\r\n      * ********removed options compared to LERC1. We can bring some of them back if needed.\r\n       * removed pixel type. LERC2 is typed and doesn't require user to give pixel type\r\n       * changed encodedMaskData to maskData. LERC2 's js version make it faster to use maskData directly.\r\n       * removed returnMask. mask is used by LERC2 internally and is cost free. In case of user input mask, it's returned as well and has neglible cost.\r\n       * removed nodatavalue. Because LERC2 pixels are typed, nodatavalue will sacrify a useful value for many types (8bit, 16bit) etc,\r\n       *       user has to be knowledgable enough about raster and their data to avoid usability issues. so nodata value is simply removed now.\r\n       *       We can add it back later if their's a clear requirement.\r\n       * removed encodedMask. This option was not implemented in LercDecode. It can be done after decoding (less efficient)\r\n       * removed computeUsedBitDepths.\r\n       *\r\n       *\r\n       * response changes compared to LERC1\r\n       * 1. encodedMaskData is not available\r\n       * 2. noDataValue is optional (returns only if user's noDataValue is with in the valid data type range)\r\n       * 3. maskData is always available\r\n      */\r\n      /*****************\r\n      *  public properties\r\n      ******************/\r\n      //HUFFMAN_LUT_BITS_MAX: 12, //use 2^12 lut, not configurable\r\n\r\n      /*****************\r\n      *  public methods\r\n      *****************/\r\n\r\n      /**\r\n       * Decode a LERC2 byte stream and return an object containing the pixel data and optional metadata.\r\n       *\r\n       * @param {ArrayBuffer} input The LERC input byte stream\r\n       * @param {object} [options] options Decoding options\r\n       * @param {number} [options.inputOffset] The number of bytes to skip in the input byte stream. A valid LERC file is expected at that position\r\n       * @param {boolean} [options.returnFileInfo] If true, the return value will have a fileInfo property that contains metadata obtained from the LERC headers and the decoding process\r\n       */\r\n      decode: function(/*byte array*/ input, /*object*/ options) {\r\n        //currently there's a bug in the sparse array, so please do not set to false\r\n        options = options || {};\r\n        var noDataValue = options.noDataValue;\r\n\r\n        //initialize\r\n        var i = 0, data = {};\r\n        data.ptr = options.inputOffset || 0;\r\n        data.pixels = {};\r\n\r\n        // File header\r\n        if (!Lerc2Helpers.readHeaderInfo(input, data)) {\r\n          return;\r\n        }\r\n        var headerInfo = data.headerInfo;\r\n        var fileVersion = headerInfo.fileVersion;\r\n        var OutPixelTypeArray = Lerc2Helpers.getDataTypeArray(headerInfo.imageType);\r\n\r\n        // Mask Header\r\n        Lerc2Helpers.readMask(input, data);\r\n        if (headerInfo.numValidPixel !== headerInfo.width * headerInfo.height && !data.pixels.resultMask) {\r\n          data.pixels.resultMask = options.maskData;\r\n        }\r\n\r\n        var numPixels = headerInfo.width * headerInfo.height;\r\n        data.pixels.resultPixels = new OutPixelTypeArray(numPixels * headerInfo.numDims);\r\n\r\n        data.counter = {\r\n          onesweep: 0,\r\n          uncompressed: 0,\r\n          lut: 0,\r\n          bitstuffer: 0,\r\n          constant: 0,\r\n          constantoffset: 0\r\n        };\r\n        if (headerInfo.numValidPixel !== 0) {\r\n          //not tested\r\n          if (headerInfo.zMax === headerInfo.zMin) //constant surface\r\n          {\r\n            Lerc2Helpers.constructConstantSurface(data);\r\n          }\r\n          else if (fileVersion >= 4 && Lerc2Helpers.checkMinMaxRanges(input, data)) {\r\n            Lerc2Helpers.constructConstantSurface(data);\r\n          }\r\n          else {\r\n            var view = new DataView(input, data.ptr, 2);\r\n            var bReadDataOneSweep = view.getUint8(0);\r\n            data.ptr++;\r\n            if (bReadDataOneSweep) {\r\n              //console.debug(\"OneSweep\");\r\n              Lerc2Helpers.readDataOneSweep(input, data, OutPixelTypeArray);\r\n            }\r\n            else {\r\n              //lerc2.1: //bitstuffing + lut\r\n              //lerc2.2: //bitstuffing + lut + huffman\r\n              //lerc2.3: new bitstuffer\r\n              if (fileVersion > 1 && headerInfo.imageType <= 1 && Math.abs(headerInfo.maxZError - 0.5) < 0.00001) {\r\n                //this is 2.x plus 8 bit (unsigned and signed) data, possiblity of Huffman\r\n                var flagHuffman = view.getUint8(1);\r\n                data.ptr++;\r\n                data.encodeMode = flagHuffman;\r\n                if (flagHuffman > 2 || (fileVersion < 4 && flagHuffman > 1)) {\r\n                  throw \"Invalid Huffman flag \" + flagHuffman;\r\n                }\r\n                if (flagHuffman) {//1 - delta Huffman, 2 - Huffman\r\n                  //console.log(\"Huffman\");\r\n                  Lerc2Helpers.readHuffman(input, data, OutPixelTypeArray);\r\n                }\r\n                else {\r\n                  //console.log(\"Tiles\");\r\n                  Lerc2Helpers.readTiles(input, data, OutPixelTypeArray);\r\n                }\r\n              }\r\n              else { //lerc2.x non-8 bit data\r\n                //console.log(\"Tiles\");\r\n                Lerc2Helpers.readTiles(input, data, OutPixelTypeArray);\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        data.eofOffset = data.ptr;\r\n        var diff;\r\n        if (options.inputOffset) {\r\n          diff = data.headerInfo.blobSize + options.inputOffset - data.ptr;\r\n          if (Math.abs(diff) >= 1) {\r\n            //console.debug(\"incorrect eof: dataptr \" + data.ptr + \" offset \" + options.inputOffset + \" blobsize \" + data.headerInfo.blobSize + \" diff: \" + diff);\r\n            data.eofOffset = options.inputOffset + data.headerInfo.blobSize;\r\n          }\r\n        }\r\n        else {\r\n          diff = data.headerInfo.blobSize - data.ptr;\r\n          if (Math.abs(diff) >= 1) {\r\n            //console.debug(\"incorrect first band eof: dataptr \" + data.ptr + \" blobsize \" + data.headerInfo.blobSize + \" diff: \" + diff);\r\n            data.eofOffset = data.headerInfo.blobSize;\r\n          }\r\n        }\r\n\r\n        var result = {\r\n          width: headerInfo.width,\r\n          height: headerInfo.height,\r\n          pixelData: data.pixels.resultPixels,\r\n          minValue: headerInfo.zMin,\r\n          maxValue: headerInfo.zMax,\r\n          validPixelCount: headerInfo.numValidPixel,\r\n          dimCount: headerInfo.numDims,\r\n          dimStats: {\r\n            minValues: headerInfo.minValues,\r\n            maxValues: headerInfo.maxValues\r\n          },\r\n          maskData: data.pixels.resultMask\r\n          //noDataValue: noDataValue\r\n        };\r\n\r\n        //we should remove this if there's no existing client\r\n        //optional noDataValue processing, it's user's responsiblity\r\n        if (data.pixels.resultMask && Lerc2Helpers.isValidPixelValue(headerInfo.imageType, noDataValue)) {\r\n          var mask = data.pixels.resultMask;\r\n          for (i = 0; i < numPixels; i++) {\r\n            if (!mask[i]) {\r\n              result.pixelData[i] = noDataValue;\r\n            }\r\n          }\r\n          result.noDataValue = noDataValue;\r\n        }\r\n        data.noDataValue = noDataValue;\r\n        if (options.returnFileInfo) {\r\n          result.fileInfo = Lerc2Helpers.formatFileInfo(data);\r\n        }\r\n        return result;\r\n      },\r\n\r\n      getBandCount: function(/*byte array*/ input) {\r\n        var count = 0;\r\n        var i = 0;\r\n        var temp = {};\r\n        temp.ptr = 0;\r\n        temp.pixels = {};\r\n        while (i < input.byteLength - 58) {\r\n          Lerc2Helpers.readHeaderInfo(input, temp);\r\n          i += temp.headerInfo.blobSize;\r\n          count++;\r\n          temp.ptr = i;\r\n        }\r\n        return count;\r\n      }\r\n    };\r\n\r\n    return Lerc2Decode;\r\n  })();\r\n\r\n  var isPlatformLittleEndian = (function() {\r\n    var a = new ArrayBuffer(4);\r\n    var b = new Uint8Array(a);\r\n    var c = new Uint32Array(a);\r\n    c[0] = 1;\r\n    return b[0] === 1;\r\n  })();\r\n\r\n  var Lerc = {\r\n    /************wrapper**********************************************/\r\n    /**\r\n     * A wrapper for decoding both LERC1 and LERC2 byte streams capable of handling multiband pixel blocks for various pixel types.\r\n     *\r\n     * @alias module:Lerc\r\n     * @param {ArrayBuffer} input The LERC input byte stream\r\n     * @param {object} [options] The decoding options below are optional.\r\n     * @param {number} [options.inputOffset] The number of bytes to skip in the input byte stream. A valid Lerc file is expected at that position.\r\n     * @param {string} [options.pixelType] (LERC1 only) Default value is F32. Valid pixel types for input are U8/S8/S16/U16/S32/U32/F32.\r\n     * @param {number} [options.noDataValue] (LERC1 only). It is recommended to use the returned mask instead of setting this value.\r\n     * @returns {{width, height, pixels, pixelType, mask, statistics}}\r\n       * @property {number} width Width of decoded image.\r\n       * @property {number} height Height of decoded image.\r\n       * @property {array} pixels [band1, band2, …] Each band is a typed array of width*height.\r\n       * @property {string} pixelType The type of pixels represented in the output.\r\n       * @property {mask} mask Typed array with a size of width*height, or null if all pixels are valid.\r\n       * @property {array} statistics [statistics_band1, statistics_band2, …] Each element is a statistics object representing min and max values\r\n    **/\r\n    decode: function(encodedData, options) {\r\n      if (!isPlatformLittleEndian) {\r\n        throw \"Big endian system is not supported.\";\r\n      }\r\n      options = options || {};\r\n      var inputOffset = options.inputOffset || 0;\r\n      var fileIdView = new Uint8Array(encodedData, inputOffset, 10);\r\n      var fileIdentifierString = String.fromCharCode.apply(null, fileIdView);\r\n      var lerc, majorVersion;\r\n      if (fileIdentifierString.trim() === \"CntZImage\") {\r\n        lerc = LercDecode;\r\n        majorVersion = 1;\r\n      }\r\n      else if (fileIdentifierString.substring(0, 5) === \"Lerc2\") {\r\n        lerc = Lerc2Decode;\r\n        majorVersion = 2;\r\n      }\r\n      else {\r\n        throw \"Unexpected file identifier string: \" + fileIdentifierString;\r\n      }\r\n\r\n      var iPlane = 0, eof = encodedData.byteLength - 10, encodedMaskData, bandMasks = [], bandMask, maskData;\r\n      var decodedPixelBlock = {\r\n        width: 0,\r\n        height: 0,\r\n        pixels: [],\r\n        pixelType: options.pixelType,\r\n        mask: null,\r\n        statistics: []\r\n      };\r\n\r\n      while (inputOffset < eof) {\r\n        var result = lerc.decode(encodedData, {\r\n          inputOffset: inputOffset,//for both lerc1 and lerc2\r\n          encodedMaskData: encodedMaskData,//lerc1 only\r\n          maskData: maskData,//lerc2 only\r\n          returnMask: iPlane === 0 ? true : false,//lerc1 only\r\n          returnEncodedMask: iPlane === 0 ? true : false,//lerc1 only\r\n          returnFileInfo: true,//for both lerc1 and lerc2\r\n          pixelType: options.pixelType || null,//lerc1 only\r\n          noDataValue: options.noDataValue || null//lerc1 only\r\n        });\r\n\r\n        inputOffset = result.fileInfo.eofOffset;\r\n        if (iPlane === 0) {\r\n          encodedMaskData = result.encodedMaskData;//lerc1\r\n          maskData = result.maskData;//lerc2\r\n          decodedPixelBlock.width = result.width;\r\n          decodedPixelBlock.height = result.height;\r\n          decodedPixelBlock.dimCount = result.dimCount || 1;\r\n          //decodedPixelBlock.dimStats = decodedPixelBlock.dimStats;\r\n          decodedPixelBlock.pixelType = result.pixelType || result.fileInfo.pixelType;\r\n          decodedPixelBlock.mask = result.maskData;\r\n        }\r\n        if (majorVersion >1 && result.fileInfo.mask && result.fileInfo.mask.numBytes > 0) {\r\n          bandMasks.push(result.maskData);\r\n        }\r\n\r\n        iPlane++;\r\n        decodedPixelBlock.pixels.push(result.pixelData);\r\n        decodedPixelBlock.statistics.push({\r\n          minValue: result.minValue,\r\n          maxValue: result.maxValue,\r\n          noDataValue: result.noDataValue,\r\n          dimStats: result.dimStats\r\n        });\r\n      }\r\n      var i, j, numPixels;\r\n      if (majorVersion > 1 && bandMasks.length > 1) {\r\n        numPixels = decodedPixelBlock.width * decodedPixelBlock.height;\r\n        decodedPixelBlock.bandMasks = bandMasks;\r\n        maskData = new Uint8Array(numPixels);\r\n        maskData.set(bandMasks[0]);\r\n        for (i = 1; i < bandMasks.length; i++) {\r\n          bandMask = bandMasks[i];\r\n          for (j = 0; j < numPixels; j++) {\r\n            maskData[j] = maskData[j] & bandMask[j];\r\n          }\r\n        }\r\n        decodedPixelBlock.maskData = maskData;\r\n      }\r\n\r\n      return decodedPixelBlock;\r\n    }\r\n  };\r\n\r\n  tmp.Lerc = Lerc;\r\n})();\r\n\r\nexport default tmp.Lerc;\r\n","import Ellipsoid from '../Core/Ellipsoid.js';\r\nimport HeightmapEncoding from '../Core/HeightmapEncoding.js';\r\nimport HeightmapTessellator from '../Core/HeightmapTessellator.js';\r\nimport Rectangle from '../Core/Rectangle.js';\r\nimport RuntimeError from '../Core/RuntimeError.js';\r\nimport Lerc from '../ThirdParty/LercDecode.js';\r\nimport createTaskProcessorWorker from './createTaskProcessorWorker.js';\r\n\r\n    function createVerticesFromHeightmap(parameters, transferableObjects) {\r\n        // LERC encoded buffers must be decoded, then we can process them like normal\r\n        if (parameters.encoding === HeightmapEncoding.LERC) {\r\n            var result;\r\n            try {\r\n                result = Lerc.decode(parameters.heightmap);\r\n            } catch (error) {\r\n                throw new RuntimeError(error);\r\n            }\r\n\r\n            var lercStatistics = result.statistics[0];\r\n            if (lercStatistics.minValue === Number.MAX_VALUE) {\r\n                throw new RuntimeError('Invalid tile data');\r\n            }\r\n\r\n            parameters.heightmap = result.pixels[0];\r\n            parameters.width = result.width;\r\n            parameters.height = result.height;\r\n        }\r\n\r\n        parameters.ellipsoid = Ellipsoid.clone(parameters.ellipsoid);\r\n        parameters.rectangle = Rectangle.clone(parameters.rectangle);\r\n\r\n        var statistics = HeightmapTessellator.computeVertices(parameters);\r\n        var vertices = statistics.vertices;\r\n        transferableObjects.push(vertices.buffer);\r\n\r\n        return {\r\n            vertices : vertices.buffer,\r\n            numberOfAttributes : statistics.encoding.getStride(),\r\n            minimumHeight : statistics.minimumHeight,\r\n            maximumHeight : statistics.maximumHeight,\r\n            gridWidth : parameters.width,\r\n            gridHeight : parameters.height,\r\n            boundingSphere3D : statistics.boundingSphere3D,\r\n            orientedBoundingBox : statistics.orientedBoundingBox,\r\n            occludeePointInScaledSpace : statistics.occludeePointInScaledSpace,\r\n            encoding : statistics.encoding,\r\n            westIndicesSouthToNorth : statistics.westIndicesSouthToNorth,\r\n            southIndicesEastToWest : statistics.southIndicesEastToWest,\r\n            eastIndicesNorthToSouth : statistics.eastIndicesNorthToSouth,\r\n            northIndicesWestToEast : statistics.northIndicesWestToEast\r\n        };\r\n    }\r\nexport default createTaskProcessorWorker(createVerticesFromHeightmap);\r\n"],"names":["Object","freeze","NONE","LERC","HeightmapTessellator","DEFAULT_STRUCTURE","heightScale","heightOffset","elementsPerHeight","stride","elementMultiplier","isBigEndian","cartesian3Scratch","Cartesian3","matrix4Scratch","Matrix4","minimumScratch","maximumScratch","computeVertices","options","defined","heightmap","DeveloperError","width","height","nativeRectangle","skirtHeight","geographicWest","geographicSouth","geographicEast","geographicNorth","cos","Math","sin","sqrt","atan","exp","piOverTwo","CesiumMath","PI_OVER_TWO","toRadians","isGeographic","defaultValue","ellipsoid","Ellipsoid","WGS84","oneOverGlobeSemimajorAxis","maximumRadius","rectangle","west","south","east","north","relativeToCenter","hasRelativeToCenter","ZERO","exaggeration","includeWebMercatorT","structure","rectangleWidth","Rectangle","computeWidth","rectangleHeight","computeHeight","granularityX","granularityY","southMercatorY","oneOverMercatorHeight","radiiSquared","radiiSquaredX","x","radiiSquaredY","y","radiiSquaredZ","z","minimumHeight","maximumHeight","fromENU","Transforms","eastNorthUpToFixedFrame","toENU","inverseTransformation","WebMercatorProjection","geodeticLatitudeToMercatorAngle","minimum","Number","POSITIVE_INFINITY","maximum","NEGATIVE_INFINITY","hMin","gridVertexCount","vertexCount","positions","Array","heights","uvs","webMercatorTs","startRow","endRow","startCol","endCol","rowIndex","row","latitude","v","clamp","isNorthEdge","isSouthEdge","webMercatorT","cosLatitude","nZ","kZ","colIndex","col","heightSample","elementOffset","terrainOffset","max","min","longitude","u","index","isWestEdge","isEastEdge","isEdge","nX","nY","kX","kY","oneOverGamma","rSurfaceX","rSurfaceY","rSurfaceZ","position","Cartesian2","multiplyByPoint","minimumByComponent","maximumByComponent","orientedBoundingBox","occludeePointInScaledSpace","boundingSphere3D","BoundingSphere","fromPoints","OrientedBoundingBox","fromRectangle","EllipsoidalOccluder","computeHorizonCullingPointPossiblyUnderEllipsoid","aaBox","AxisAlignedBoundingBox","encoding","TerrainEncoding","vertices","Float32Array","getStride","bufferIndex","j","encode","undefined","tmp","CntZImage","uncompressPixelValues","formatFileInfo","computeUsedBitDepths","parse","unstuff","BitStuffer","Lerc2Helpers","TreeNode","a","b","LercDecode","defaultNoDataValue","decode","input","skipMask","encodedMaskData","parsedData","inputOffset","noDataValue","uncompressedData","pixelType","returnMask","result","pixelData","resultPixels","minValue","maxValue","pixels","resultMask","maskData","returnEncodedMask","mask","bitset","returnFileInfo","fileInfo","bitDepths","data","TypedArrayClass","maskBitset","storeDecodedMask","currentValue","blockIdx","numX","numBlocksX","numY","numBlocksY","blockWidth","floor","blockHeight","scale","maxZError","MAX_VALUE","Uint8Array","xx","yy","blockDataBuffer","thisBlockHeight","thisBlockWidth","blockData","blockPtr","constValue","maskByte","outPtr","outStride","block","blocks","rawData","stuffedData","bitsPerPixel","numValidPixels","offset","fileIdentifierString","fileVersion","imageType","eofOffset","numBytes","numBlocks","i","float32","keys","fp","fileIdView","String","fromCharCode","apply","trim","view","DataView","getInt32","getUint32","getFloat64","getFloat32","ceil","cnt","getInt16","ip","op","getUint8","val","length","actualNumBlocksX","actualNumBlocksY","blockI","blockY","blockX","size","bytesLeft","byteLength","headerByte","offsetType","getInt8","numValidPixelsType","getUint16","arrayBuf","numPixels","ArrayBuffer","set","dataBytes","dataWords","Uint32Array","src","dest","o","n","buffer","bitMask","bitsLeft","nmax","numInvalidTailBytes","missingBits","Lerc2Decode","lutArr","unshift","bitPos","HUFFMAN_LUT_BITS_MAX","computeChecksumFletcher32","sum1","sum2","len","words","tlen","readHeaderInfo","ptr","headerInfo","lastIndexOf","keyLength","checksum","numDims","numValidPixel","microBlockSize","blobSize","zMin","zMax","this","checkMinMaxRanges","OutPixelTypeArray","getDataTypeArray","rangeBytes","getDataTypeSize","minValues","readSubArray","maxValues","equal","readMask","mb","k","readDataOneSweep","nStart","readHuffmanTree","BITS_MAX","i0","i1","decodeBits","codeTable","first","second","word","srcPtr","numBitsLUT","numBitsLUTQick","tree","console","log","entry","code","numEntries","jj","node","decodeLut","right","left","readHuffman","delta","valTmp","valTmpQuick","ii","huffmanInfo","prevVal","iDim","deltaEncode","encodeMode","resultPixelsAllDim","viewByteLength","bits67","doLut","numBits","numElements","store8","lutData","lutBytes","counter","lut","bitstuffer","readTiles","dataTypeSize","blockEncoding","bytesleft","lastBlockHeight","lastBlockWidth","uncompressed","getDataTypeUsed","getOnePixel","constantoffset","constant","getPixelType","constructConstantSurface","numPixelAllDims","fill","t","tp","Int8Array","Int16Array","Uint16Array","Int32Array","Float64Array","isValidPixelValue","isValid","s","dt","tc","temp","getUInt32","diff","onesweep","bReadDataOneSweep","abs","flagHuffman","validPixelCount","dimCount","dimStats","getBandCount","count","isPlatformLittleEndian","Lerc","encodedData","lerc","majorVersion","substring","bandMask","iPlane","eof","bandMasks","decodedPixelBlock","statistics","push","createTaskProcessorWorker","parameters","transferableObjects","HeightmapEncoding","error","RuntimeError","clone","numberOfAttributes","gridWidth","gridHeight","westIndicesSouthToNorth","southIndicesEastToWest","eastIndicesNorthToSouth","northIndicesWestToEast"],"mappings":"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"}