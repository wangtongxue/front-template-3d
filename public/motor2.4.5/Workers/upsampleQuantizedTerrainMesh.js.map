{"version":3,"file":"upsampleQuantizedTerrainMesh.js","sources":["../../../../Source/Core/Intersections2D.js","../../../../Source/WorkersES6/upsampleQuantizedTerrainMesh.js"],"sourcesContent":["import Cartesian2 from './Cartesian2.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport Check from './Check.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\n\r\n    /**\r\n     * Contains functions for operating on 2D triangles.\r\n     *\r\n     * @exports Intersections2D\r\n     */\r\n    var Intersections2D = {};\r\n\r\n    /**\r\n     * Splits a 2D triangle at given axis-aligned threshold value and returns the resulting\r\n     * polygon on a given side of the threshold.  The resulting polygon may have 0, 1, 2,\r\n     * 3, or 4 vertices.\r\n     *\r\n     * @param {Number} threshold The threshold coordinate value at which to clip the triangle.\r\n     * @param {Boolean} keepAbove true to keep the portion of the triangle above the threshold, or false\r\n     *                            to keep the portion below.\r\n     * @param {Number} u0 The coordinate of the first vertex in the triangle, in counter-clockwise order.\r\n     * @param {Number} u1 The coordinate of the second vertex in the triangle, in counter-clockwise order.\r\n     * @param {Number} u2 The coordinate of the third vertex in the triangle, in counter-clockwise order.\r\n     * @param {Number[]} [result] The array into which to copy the result.  If this parameter is not supplied,\r\n     *                            a new array is constructed and returned.\r\n     * @returns {Number[]} The polygon that results after the clip, specified as a list of\r\n     *                     vertices.  The vertices are specified in counter-clockwise order.\r\n     *                     Each vertex is either an index from the existing list (identified as\r\n     *                     a 0, 1, or 2) or -1 indicating a new vertex not in the original triangle.\r\n     *                     For new vertices, the -1 is followed by three additional numbers: the\r\n     *                     index of each of the two original vertices forming the line segment that\r\n     *                     the new vertex lies on, and the fraction of the distance from the first\r\n     *                     vertex to the second one.\r\n     *\r\n     * @example\r\n     * var result = Cesium.Intersections2D.clipTriangleAtAxisAlignedThreshold(0.5, false, 0.2, 0.6, 0.4);\r\n     * // result === [2, 0, -1, 1, 0, 0.25, -1, 1, 2, 0.5]\r\n     */\r\n    Intersections2D.clipTriangleAtAxisAlignedThreshold = function(threshold, keepAbove, u0, u1, u2, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(threshold)) {\r\n            throw new DeveloperError('threshold is required.');\r\n        }\r\n        if (!defined(keepAbove)) {\r\n            throw new DeveloperError('keepAbove is required.');\r\n        }\r\n        if (!defined(u0)) {\r\n            throw new DeveloperError('u0 is required.');\r\n        }\r\n        if (!defined(u1)) {\r\n            throw new DeveloperError('u1 is required.');\r\n        }\r\n        if (!defined(u2)) {\r\n            throw new DeveloperError('u2 is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            result = [];\r\n        } else {\r\n            result.length = 0;\r\n        }\r\n\r\n        var u0Behind;\r\n        var u1Behind;\r\n        var u2Behind;\r\n        if (keepAbove) {\r\n            u0Behind = u0 < threshold;\r\n            u1Behind = u1 < threshold;\r\n            u2Behind = u2 < threshold;\r\n        } else {\r\n            u0Behind = u0 > threshold;\r\n            u1Behind = u1 > threshold;\r\n            u2Behind = u2 > threshold;\r\n        }\r\n\r\n        var numBehind = u0Behind + u1Behind + u2Behind;\r\n\r\n        var u01Ratio;\r\n        var u02Ratio;\r\n        var u12Ratio;\r\n        var u10Ratio;\r\n        var u20Ratio;\r\n        var u21Ratio;\r\n\r\n        if (numBehind === 1) {\r\n            if (u0Behind) {\r\n                u01Ratio = (threshold - u0) / (u1 - u0);\r\n                u02Ratio = (threshold - u0) / (u2 - u0);\r\n\r\n                result.push(1);\r\n\r\n                result.push(2);\r\n\r\n                if (u02Ratio !== 1.0) {\r\n                    result.push(-1);\r\n                    result.push(0);\r\n                    result.push(2);\r\n                    result.push(u02Ratio);\r\n                }\r\n\r\n                if (u01Ratio !== 1.0) {\r\n                    result.push(-1);\r\n                    result.push(0);\r\n                    result.push(1);\r\n                    result.push(u01Ratio);\r\n                }\r\n            } else if (u1Behind) {\r\n                u12Ratio = (threshold - u1) / (u2 - u1);\r\n                u10Ratio = (threshold - u1) / (u0 - u1);\r\n\r\n                result.push(2);\r\n\r\n                result.push(0);\r\n\r\n                if (u10Ratio !== 1.0) {\r\n                    result.push(-1);\r\n                    result.push(1);\r\n                    result.push(0);\r\n                    result.push(u10Ratio);\r\n                }\r\n\r\n                if (u12Ratio !== 1.0) {\r\n                    result.push(-1);\r\n                    result.push(1);\r\n                    result.push(2);\r\n                    result.push(u12Ratio);\r\n                }\r\n            } else if (u2Behind) {\r\n                u20Ratio = (threshold - u2) / (u0 - u2);\r\n                u21Ratio = (threshold - u2) / (u1 - u2);\r\n\r\n                result.push(0);\r\n\r\n                result.push(1);\r\n\r\n                if (u21Ratio !== 1.0) {\r\n                    result.push(-1);\r\n                    result.push(2);\r\n                    result.push(1);\r\n                    result.push(u21Ratio);\r\n                }\r\n\r\n                if (u20Ratio !== 1.0) {\r\n                    result.push(-1);\r\n                    result.push(2);\r\n                    result.push(0);\r\n                    result.push(u20Ratio);\r\n                }\r\n            }\r\n        } else if (numBehind === 2) {\r\n            if (!u0Behind && u0 !== threshold) {\r\n                u10Ratio = (threshold - u1) / (u0 - u1);\r\n                u20Ratio = (threshold - u2) / (u0 - u2);\r\n\r\n                result.push(0);\r\n\r\n                result.push(-1);\r\n                result.push(1);\r\n                result.push(0);\r\n                result.push(u10Ratio);\r\n\r\n                result.push(-1);\r\n                result.push(2);\r\n                result.push(0);\r\n                result.push(u20Ratio);\r\n            } else if (!u1Behind && u1 !== threshold) {\r\n                u21Ratio = (threshold - u2) / (u1 - u2);\r\n                u01Ratio = (threshold - u0) / (u1 - u0);\r\n\r\n                result.push(1);\r\n\r\n                result.push(-1);\r\n                result.push(2);\r\n                result.push(1);\r\n                result.push(u21Ratio);\r\n\r\n                result.push(-1);\r\n                result.push(0);\r\n                result.push(1);\r\n                result.push(u01Ratio);\r\n            } else if (!u2Behind && u2 !== threshold) {\r\n                u02Ratio = (threshold - u0) / (u2 - u0);\r\n                u12Ratio = (threshold - u1) / (u2 - u1);\r\n\r\n                result.push(2);\r\n\r\n                result.push(-1);\r\n                result.push(0);\r\n                result.push(2);\r\n                result.push(u02Ratio);\r\n\r\n                result.push(-1);\r\n                result.push(1);\r\n                result.push(2);\r\n                result.push(u12Ratio);\r\n            }\r\n        } else if (numBehind !== 3) {\r\n            // Completely in front of threshold\r\n            result.push(0);\r\n            result.push(1);\r\n            result.push(2);\r\n        }\r\n        // else Completely behind threshold\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Compute the barycentric coordinates of a 2D position within a 2D triangle.\r\n     *\r\n     * @param {Number} x The x coordinate of the position for which to find the barycentric coordinates.\r\n     * @param {Number} y The y coordinate of the position for which to find the barycentric coordinates.\r\n     * @param {Number} x1 The x coordinate of the triangle's first vertex.\r\n     * @param {Number} y1 The y coordinate of the triangle's first vertex.\r\n     * @param {Number} x2 The x coordinate of the triangle's second vertex.\r\n     * @param {Number} y2 The y coordinate of the triangle's second vertex.\r\n     * @param {Number} x3 The x coordinate of the triangle's third vertex.\r\n     * @param {Number} y3 The y coordinate of the triangle's third vertex.\r\n     * @param {Cartesian3} [result] The instance into to which to copy the result.  If this parameter\r\n     *                     is undefined, a new instance is created and returned.\r\n     * @returns {Cartesian3} The barycentric coordinates of the position within the triangle.\r\n     *\r\n     * @example\r\n     * var result = Cesium.Intersections2D.computeBarycentricCoordinates(0.0, 0.0, 0.0, 1.0, -1, -0.5, 1, -0.5);\r\n     * // result === new Cesium.Cartesian3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0);\r\n     */\r\n    Intersections2D.computeBarycentricCoordinates = function(x, y, x1, y1, x2, y2, x3, y3, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(x)) {\r\n            throw new DeveloperError('x is required.');\r\n        }\r\n        if (!defined(y)) {\r\n            throw new DeveloperError('y is required.');\r\n        }\r\n        if (!defined(x1)) {\r\n            throw new DeveloperError('x1 is required.');\r\n        }\r\n        if (!defined(y1)) {\r\n            throw new DeveloperError('y1 is required.');\r\n        }\r\n        if (!defined(x2)) {\r\n            throw new DeveloperError('x2 is required.');\r\n        }\r\n        if (!defined(y2)) {\r\n            throw new DeveloperError('y2 is required.');\r\n        }\r\n        if (!defined(x3)) {\r\n            throw new DeveloperError('x3 is required.');\r\n        }\r\n        if (!defined(y3)) {\r\n            throw new DeveloperError('y3 is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var x1mx3 = x1 - x3;\r\n        var x3mx2 = x3 - x2;\r\n        var y2my3 = y2 - y3;\r\n        var y1my3 = y1 - y3;\r\n        var inverseDeterminant = 1.0 / (y2my3 * x1mx3 + x3mx2 * y1my3);\r\n        var ymy3 = y - y3;\r\n        var xmx3 = x - x3;\r\n        var l1 = (y2my3 * xmx3 + x3mx2 * ymy3) * inverseDeterminant;\r\n        var l2 = (-y1my3 * xmx3 + x1mx3 * ymy3) * inverseDeterminant;\r\n        var l3 = 1.0 - l1 - l2;\r\n\r\n        if (defined(result)) {\r\n            result.x = l1;\r\n            result.y = l2;\r\n            result.z = l3;\r\n            return result;\r\n        }\r\n        return new Cartesian3(l1, l2, l3);\r\n    };\r\n\r\n    /**\r\n     * Compute the intersection between 2 line segments\r\n     *\r\n     * @param {Number} x00 The x coordinate of the first line's first vertex.\r\n     * @param {Number} y00 The y coordinate of the first line's first vertex.\r\n     * @param {Number} x01 The x coordinate of the first line's second vertex.\r\n     * @param {Number} y01 The y coordinate of the first line's second vertex.\r\n     * @param {Number} x10 The x coordinate of the second line's first vertex.\r\n     * @param {Number} y10 The y coordinate of the second line's first vertex.\r\n     * @param {Number} x11 The x coordinate of the second line's second vertex.\r\n     * @param {Number} y11 The y coordinate of the second line's second vertex.\r\n     * @param {Cartesian2} [result] The instance into to which to copy the result. If this parameter\r\n     *                     is undefined, a new instance is created and returned.\r\n     * @returns {Cartesian2} The intersection point, undefined if there is no intersection point or lines are coincident.\r\n     *\r\n     * @example\r\n     * var result = Cesium.Intersections2D.computeLineSegmentLineSegmentIntersection(0.0, 0.0, 0.0, 2.0, -1, 1, 1, 1);\r\n     * // result === new Cesium.Cartesian2(0.0, 1.0);\r\n     */\r\n    Intersections2D.computeLineSegmentLineSegmentIntersection = function(x00, y00, x01, y01, x10, y10, x11, y11, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.number('x00', x00);\r\n        Check.typeOf.number('y00', y00);\r\n        Check.typeOf.number('x01', x01);\r\n        Check.typeOf.number('y01', y01);\r\n        Check.typeOf.number('x10', x10);\r\n        Check.typeOf.number('y10', y10);\r\n        Check.typeOf.number('x11', x11);\r\n        Check.typeOf.number('y11', y11);\r\n        //>>includeEnd('debug');\r\n\r\n        var numerator1A = (x11 - x10) * (y00 - y10) - (y11 - y10) * (x00 - x10);\r\n        var numerator1B = (x01 - x00) * (y00 - y10) - (y01 - y00) * (x00 - x10);\r\n        var denominator1 = (y11 - y10) * (x01 - x00) - (x11 - x10) * (y01 - y00);\r\n\r\n        // If denominator = 0, then lines are parallel. If denominator = 0 and both numerators are 0, then coincident\r\n        if (denominator1 === 0) {\r\n            return;\r\n        }\r\n\r\n        var ua1 = numerator1A / denominator1;\r\n        var ub1 = numerator1B / denominator1;\r\n\r\n        if (ua1 >= 0 && ua1 <= 1 && ub1 >= 0 && ub1 <= 1) {\r\n            if (!defined(result)) {\r\n                result = new Cartesian2();\r\n            }\r\n\r\n            result.x = x00 + ua1 * (x01 - x00);\r\n            result.y = y00 + ua1 * (y01 - y00);\r\n\r\n            return result;\r\n        }\r\n    };\r\nexport default Intersections2D;\r\n","import AttributeCompression from '../Core/AttributeCompression.js';\r\nimport BoundingSphere from '../Core/BoundingSphere.js';\r\nimport Cartesian2 from '../Core/Cartesian2.js';\r\nimport Cartesian3 from '../Core/Cartesian3.js';\r\nimport Cartographic from '../Core/Cartographic.js';\r\nimport defined from '../Core/defined.js';\r\nimport Ellipsoid from '../Core/Ellipsoid.js';\r\nimport EllipsoidalOccluder from '../Core/EllipsoidalOccluder.js';\r\nimport IndexDatatype from '../Core/IndexDatatype.js';\r\nimport Intersections2D from '../Core/Intersections2D.js';\r\nimport CesiumMath from '../Core/Math.js';\r\nimport OrientedBoundingBox from '../Core/OrientedBoundingBox.js';\r\nimport Rectangle from '../Core/Rectangle.js';\r\nimport TerrainEncoding from '../Core/TerrainEncoding.js';\r\nimport createTaskProcessorWorker from './createTaskProcessorWorker.js';\r\n\r\n    var maxShort = 32767;\r\n    var halfMaxShort = (maxShort / 2) | 0;\r\n\r\n    var clipScratch = [];\r\n    var clipScratch2 = [];\r\n    var verticesScratch = [];\r\n    var cartographicScratch = new Cartographic();\r\n    var cartesian3Scratch = new Cartesian3();\r\n    var uScratch = [];\r\n    var vScratch = [];\r\n    var heightScratch = [];\r\n    var indicesScratch = [];\r\n    var normalsScratch = [];\r\n    var horizonOcclusionPointScratch = new Cartesian3();\r\n    var boundingSphereScratch = new BoundingSphere();\r\n    var orientedBoundingBoxScratch = new OrientedBoundingBox();\r\n    var decodeTexCoordsScratch = new Cartesian2();\r\n    var octEncodedNormalScratch = new Cartesian3();\r\n\r\n    function upsampleQuantizedTerrainMesh(parameters, transferableObjects) {\r\n        var isEastChild = parameters.isEastChild;\r\n        var isNorthChild = parameters.isNorthChild;\r\n\r\n        var minU = isEastChild ? halfMaxShort : 0;\r\n        var maxU = isEastChild ? maxShort : halfMaxShort;\r\n        var minV = isNorthChild ? halfMaxShort : 0;\r\n        var maxV = isNorthChild ? maxShort : halfMaxShort;\r\n\r\n        var uBuffer = uScratch;\r\n        var vBuffer = vScratch;\r\n        var heightBuffer = heightScratch;\r\n        var normalBuffer = normalsScratch;\r\n\r\n        uBuffer.length = 0;\r\n        vBuffer.length = 0;\r\n        heightBuffer.length = 0;\r\n        normalBuffer.length = 0;\r\n\r\n        var indices = indicesScratch;\r\n        indices.length = 0;\r\n\r\n        var vertexMap = {};\r\n\r\n        var parentVertices = parameters.vertices;\r\n        var parentIndices = parameters.indices;\r\n        parentIndices = parentIndices.subarray(0, parameters.indexCountWithoutSkirts);\r\n\r\n        var encoding = TerrainEncoding.clone(parameters.encoding);\r\n        var hasVertexNormals = encoding.hasVertexNormals;\r\n        var exaggeration = parameters.exaggeration;\r\n\r\n        var vertexCount = 0;\r\n        var quantizedVertexCount = parameters.vertexCountWithoutSkirts;\r\n\r\n        var parentMinimumHeight = parameters.minimumHeight;\r\n        var parentMaximumHeight = parameters.maximumHeight;\r\n\r\n        var parentUBuffer = new Array(quantizedVertexCount);\r\n        var parentVBuffer = new Array(quantizedVertexCount);\r\n        var parentHeightBuffer = new Array(quantizedVertexCount);\r\n        var parentNormalBuffer = hasVertexNormals ? new Array(quantizedVertexCount * 2) : undefined;\r\n\r\n        var threshold = 20;\r\n        var height;\r\n\r\n        var i, n;\r\n        var u, v;\r\n        for (i = 0, n = 0; i < quantizedVertexCount; ++i, n += 2) {\r\n            var texCoords = encoding.decodeTextureCoordinates(parentVertices, i, decodeTexCoordsScratch);\r\n            height  = encoding.decodeHeight(parentVertices, i) / exaggeration;\r\n\r\n            u = CesiumMath.clamp((texCoords.x * maxShort) | 0, 0, maxShort);\r\n            v = CesiumMath.clamp((texCoords.y * maxShort) | 0, 0, maxShort);\r\n            parentHeightBuffer[i] = CesiumMath.clamp((((height - parentMinimumHeight) / (parentMaximumHeight - parentMinimumHeight)) * maxShort) | 0, 0, maxShort);\r\n\r\n            if (u < threshold) {\r\n                u = 0;\r\n            }\r\n\r\n            if (v < threshold) {\r\n                v = 0;\r\n            }\r\n\r\n            if (maxShort - u < threshold) {\r\n                u = maxShort;\r\n            }\r\n\r\n            if (maxShort - v < threshold) {\r\n                v = maxShort;\r\n            }\r\n\r\n            parentUBuffer[i] = u;\r\n            parentVBuffer[i] = v;\r\n\r\n            if (hasVertexNormals) {\r\n                var encodedNormal = encoding.getOctEncodedNormal(parentVertices, i, octEncodedNormalScratch);\r\n                parentNormalBuffer[n] = encodedNormal.x;\r\n                parentNormalBuffer[n + 1] = encodedNormal.y;\r\n            }\r\n\r\n            if ((isEastChild && u >= halfMaxShort || !isEastChild && u <= halfMaxShort) &&\r\n                (isNorthChild && v >= halfMaxShort || !isNorthChild && v <= halfMaxShort)) {\r\n\r\n                vertexMap[i] = vertexCount;\r\n                uBuffer.push(u);\r\n                vBuffer.push(v);\r\n                heightBuffer.push(parentHeightBuffer[i]);\r\n                if (hasVertexNormals) {\r\n                    normalBuffer.push(parentNormalBuffer[n]);\r\n                    normalBuffer.push(parentNormalBuffer[n + 1]);\r\n                }\r\n\r\n                ++vertexCount;\r\n            }\r\n        }\r\n\r\n        var triangleVertices = [];\r\n        triangleVertices.push(new Vertex());\r\n        triangleVertices.push(new Vertex());\r\n        triangleVertices.push(new Vertex());\r\n\r\n        var clippedTriangleVertices = [];\r\n        clippedTriangleVertices.push(new Vertex());\r\n        clippedTriangleVertices.push(new Vertex());\r\n        clippedTriangleVertices.push(new Vertex());\r\n\r\n        var clippedIndex;\r\n        var clipped2;\r\n\r\n        for (i = 0; i < parentIndices.length; i += 3) {\r\n            var i0 = parentIndices[i];\r\n            var i1 = parentIndices[i + 1];\r\n            var i2 = parentIndices[i + 2];\r\n\r\n            var u0 = parentUBuffer[i0];\r\n            var u1 = parentUBuffer[i1];\r\n            var u2 = parentUBuffer[i2];\r\n\r\n            triangleVertices[0].initializeIndexed(parentUBuffer, parentVBuffer, parentHeightBuffer, parentNormalBuffer, i0);\r\n            triangleVertices[1].initializeIndexed(parentUBuffer, parentVBuffer, parentHeightBuffer, parentNormalBuffer, i1);\r\n            triangleVertices[2].initializeIndexed(parentUBuffer, parentVBuffer, parentHeightBuffer, parentNormalBuffer, i2);\r\n\r\n            // Clip triangle on the east-west boundary.\r\n            var clipped = Intersections2D.clipTriangleAtAxisAlignedThreshold(halfMaxShort, isEastChild, u0, u1, u2, clipScratch);\r\n\r\n            // Get the first clipped triangle, if any.\r\n            clippedIndex = 0;\r\n\r\n            if (clippedIndex >= clipped.length) {\r\n                continue;\r\n            }\r\n            clippedIndex = clippedTriangleVertices[0].initializeFromClipResult(clipped, clippedIndex, triangleVertices);\r\n\r\n            if (clippedIndex >= clipped.length) {\r\n                continue;\r\n            }\r\n            clippedIndex = clippedTriangleVertices[1].initializeFromClipResult(clipped, clippedIndex, triangleVertices);\r\n\r\n            if (clippedIndex >= clipped.length) {\r\n                continue;\r\n            }\r\n            clippedIndex = clippedTriangleVertices[2].initializeFromClipResult(clipped, clippedIndex, triangleVertices);\r\n\r\n            // Clip the triangle against the North-south boundary.\r\n            clipped2 = Intersections2D.clipTriangleAtAxisAlignedThreshold(halfMaxShort, isNorthChild, clippedTriangleVertices[0].getV(), clippedTriangleVertices[1].getV(), clippedTriangleVertices[2].getV(), clipScratch2);\r\n            addClippedPolygon(uBuffer, vBuffer, heightBuffer, normalBuffer, indices, vertexMap, clipped2, clippedTriangleVertices, hasVertexNormals);\r\n\r\n            // If there's another vertex in the original clipped result,\r\n            // it forms a second triangle.  Clip it as well.\r\n            if (clippedIndex < clipped.length) {\r\n                clippedTriangleVertices[2].clone(clippedTriangleVertices[1]);\r\n                clippedTriangleVertices[2].initializeFromClipResult(clipped, clippedIndex, triangleVertices);\r\n\r\n                clipped2 = Intersections2D.clipTriangleAtAxisAlignedThreshold(halfMaxShort, isNorthChild, clippedTriangleVertices[0].getV(), clippedTriangleVertices[1].getV(), clippedTriangleVertices[2].getV(), clipScratch2);\r\n                addClippedPolygon(uBuffer, vBuffer, heightBuffer, normalBuffer, indices, vertexMap, clipped2, clippedTriangleVertices, hasVertexNormals);\r\n            }\r\n        }\r\n\r\n        var uOffset = isEastChild ? -maxShort : 0;\r\n        var vOffset = isNorthChild ? -maxShort : 0;\r\n\r\n        var westIndices = [];\r\n        var southIndices = [];\r\n        var eastIndices = [];\r\n        var northIndices = [];\r\n\r\n        var minimumHeight = Number.MAX_VALUE;\r\n        var maximumHeight = -minimumHeight;\r\n\r\n        var cartesianVertices = verticesScratch;\r\n        cartesianVertices.length = 0;\r\n\r\n        var ellipsoid = Ellipsoid.clone(parameters.ellipsoid);\r\n        var rectangle = Rectangle.clone(parameters.childRectangle);\r\n\r\n        var north = rectangle.north;\r\n        var south = rectangle.south;\r\n        var east = rectangle.east;\r\n        var west = rectangle.west;\r\n\r\n        if (east < west) {\r\n            east += CesiumMath.TWO_PI;\r\n        }\r\n\r\n        for (i = 0; i < uBuffer.length; ++i) {\r\n            u = Math.round(uBuffer[i]);\r\n            if (u <= minU) {\r\n                westIndices.push(i);\r\n                u = 0;\r\n            } else if (u >= maxU) {\r\n                eastIndices.push(i);\r\n                u = maxShort;\r\n            } else {\r\n                u = u * 2 + uOffset;\r\n            }\r\n\r\n            uBuffer[i] = u;\r\n\r\n            v = Math.round(vBuffer[i]);\r\n            if (v <= minV) {\r\n                southIndices.push(i);\r\n                v = 0;\r\n            } else if (v >= maxV) {\r\n                northIndices.push(i);\r\n                v = maxShort;\r\n            } else {\r\n                v = v * 2 + vOffset;\r\n            }\r\n\r\n            vBuffer[i] = v;\r\n\r\n            height = CesiumMath.lerp(parentMinimumHeight, parentMaximumHeight, heightBuffer[i] / maxShort);\r\n            if (height < minimumHeight) {\r\n                minimumHeight = height;\r\n            }\r\n            if (height > maximumHeight) {\r\n                maximumHeight = height;\r\n            }\r\n\r\n            heightBuffer[i] = height;\r\n\r\n            cartographicScratch.longitude = CesiumMath.lerp(west, east, u / maxShort);\r\n            cartographicScratch.latitude = CesiumMath.lerp(south, north, v / maxShort);\r\n            cartographicScratch.height = height;\r\n\r\n            ellipsoid.cartographicToCartesian(cartographicScratch, cartesian3Scratch);\r\n\r\n            cartesianVertices.push(cartesian3Scratch.x);\r\n            cartesianVertices.push(cartesian3Scratch.y);\r\n            cartesianVertices.push(cartesian3Scratch.z);\r\n        }\r\n\r\n        var boundingSphere = BoundingSphere.fromVertices(cartesianVertices, Cartesian3.ZERO, 3, boundingSphereScratch);\r\n        var orientedBoundingBox = OrientedBoundingBox.fromRectangle(rectangle, minimumHeight, maximumHeight, ellipsoid, orientedBoundingBoxScratch);\r\n\r\n        var occluder = new EllipsoidalOccluder(ellipsoid);\r\n        var horizonOcclusionPoint = occluder.computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid(boundingSphere.center, cartesianVertices, 3, boundingSphere.center, minimumHeight, horizonOcclusionPointScratch);\r\n\r\n        var heightRange = maximumHeight - minimumHeight;\r\n\r\n        var vertices = new Uint16Array(uBuffer.length + vBuffer.length + heightBuffer.length);\r\n\r\n        for (i = 0; i < uBuffer.length; ++i) {\r\n            vertices[i] = uBuffer[i];\r\n        }\r\n\r\n        var start = uBuffer.length;\r\n\r\n        for (i = 0; i < vBuffer.length; ++i) {\r\n            vertices[start + i] = vBuffer[i];\r\n        }\r\n\r\n        start += vBuffer.length;\r\n\r\n        for (i = 0; i < heightBuffer.length; ++i) {\r\n            vertices[start + i] = maxShort * (heightBuffer[i] - minimumHeight) / heightRange;\r\n        }\r\n\r\n        var indicesTypedArray = IndexDatatype.createTypedArray(uBuffer.length, indices);\r\n\r\n        var encodedNormals;\r\n        if (hasVertexNormals) {\r\n            var normalArray = new Uint8Array(normalBuffer);\r\n            transferableObjects.push(vertices.buffer, indicesTypedArray.buffer, normalArray.buffer);\r\n            encodedNormals = normalArray.buffer;\r\n        } else {\r\n            transferableObjects.push(vertices.buffer, indicesTypedArray.buffer);\r\n        }\r\n\r\n        return {\r\n            vertices : vertices.buffer,\r\n            encodedNormals : encodedNormals,\r\n            indices : indicesTypedArray.buffer,\r\n            minimumHeight : minimumHeight,\r\n            maximumHeight : maximumHeight,\r\n            westIndices : westIndices,\r\n            southIndices : southIndices,\r\n            eastIndices : eastIndices,\r\n            northIndices : northIndices,\r\n            boundingSphere : boundingSphere,\r\n            orientedBoundingBox : orientedBoundingBox,\r\n            horizonOcclusionPoint : horizonOcclusionPoint\r\n        };\r\n    }\r\n\r\n    function Vertex() {\r\n        this.vertexBuffer = undefined;\r\n        this.index = undefined;\r\n        this.first = undefined;\r\n        this.second = undefined;\r\n        this.ratio = undefined;\r\n    }\r\n\r\n    Vertex.prototype.clone = function(result) {\r\n        if (!defined(result)) {\r\n            result = new Vertex();\r\n        }\r\n\r\n        result.uBuffer = this.uBuffer;\r\n        result.vBuffer = this.vBuffer;\r\n        result.heightBuffer = this.heightBuffer;\r\n        result.normalBuffer = this.normalBuffer;\r\n        result.index = this.index;\r\n        result.first = this.first;\r\n        result.second = this.second;\r\n        result.ratio = this.ratio;\r\n\r\n        return result;\r\n    };\r\n\r\n    Vertex.prototype.initializeIndexed = function(uBuffer, vBuffer, heightBuffer, normalBuffer, index) {\r\n        this.uBuffer = uBuffer;\r\n        this.vBuffer = vBuffer;\r\n        this.heightBuffer = heightBuffer;\r\n        this.normalBuffer = normalBuffer;\r\n        this.index = index;\r\n        this.first = undefined;\r\n        this.second = undefined;\r\n        this.ratio = undefined;\r\n    };\r\n\r\n    Vertex.prototype.initializeFromClipResult = function(clipResult, index, vertices) {\r\n        var nextIndex = index + 1;\r\n\r\n        if (clipResult[index] !== -1) {\r\n            vertices[clipResult[index]].clone(this);\r\n        } else {\r\n            this.vertexBuffer = undefined;\r\n            this.index = undefined;\r\n            this.first = vertices[clipResult[nextIndex]];\r\n            ++nextIndex;\r\n            this.second = vertices[clipResult[nextIndex]];\r\n            ++nextIndex;\r\n            this.ratio = clipResult[nextIndex];\r\n            ++nextIndex;\r\n        }\r\n\r\n        return nextIndex;\r\n    };\r\n\r\n    Vertex.prototype.getKey = function() {\r\n        if (this.isIndexed()) {\r\n            return this.index;\r\n        }\r\n        return JSON.stringify({\r\n            first : this.first.getKey(),\r\n            second : this.second.getKey(),\r\n            ratio : this.ratio\r\n        });\r\n    };\r\n\r\n    Vertex.prototype.isIndexed = function() {\r\n        return defined(this.index);\r\n    };\r\n\r\n    Vertex.prototype.getH = function() {\r\n        if (defined(this.index)) {\r\n            return this.heightBuffer[this.index];\r\n        }\r\n        return CesiumMath.lerp(this.first.getH(), this.second.getH(), this.ratio);\r\n    };\r\n\r\n    Vertex.prototype.getU = function() {\r\n        if (defined(this.index)) {\r\n            return this.uBuffer[this.index];\r\n        }\r\n        return CesiumMath.lerp(this.first.getU(), this.second.getU(), this.ratio);\r\n    };\r\n\r\n    Vertex.prototype.getV = function() {\r\n        if (defined(this.index)) {\r\n            return this.vBuffer[this.index];\r\n        }\r\n        return CesiumMath.lerp(this.first.getV(), this.second.getV(), this.ratio);\r\n    };\r\n\r\n    var encodedScratch = new Cartesian2();\r\n    // An upsampled triangle may be clipped twice before it is assigned an index\r\n    // In this case, we need a buffer to handle the recursion of getNormalX() and getNormalY().\r\n    var depth = -1;\r\n    var cartesianScratch1 = [new Cartesian3(), new Cartesian3()];\r\n    var cartesianScratch2 = [new Cartesian3(), new Cartesian3()];\r\n    function lerpOctEncodedNormal(vertex, result) {\r\n        ++depth;\r\n\r\n        var first = cartesianScratch1[depth];\r\n        var second = cartesianScratch2[depth];\r\n\r\n        first = AttributeCompression.octDecode(vertex.first.getNormalX(), vertex.first.getNormalY(), first);\r\n        second = AttributeCompression.octDecode(vertex.second.getNormalX(), vertex.second.getNormalY(), second);\r\n        cartesian3Scratch = Cartesian3.lerp(first, second, vertex.ratio, cartesian3Scratch);\r\n        Cartesian3.normalize(cartesian3Scratch, cartesian3Scratch);\r\n\r\n        AttributeCompression.octEncode(cartesian3Scratch, result);\r\n\r\n        --depth;\r\n\r\n        return result;\r\n    }\r\n\r\n    Vertex.prototype.getNormalX = function() {\r\n        if (defined(this.index)) {\r\n            return this.normalBuffer[this.index * 2];\r\n        }\r\n\r\n        encodedScratch = lerpOctEncodedNormal(this, encodedScratch);\r\n        return encodedScratch.x;\r\n    };\r\n\r\n    Vertex.prototype.getNormalY = function() {\r\n        if (defined(this.index)) {\r\n            return this.normalBuffer[this.index * 2 + 1];\r\n        }\r\n\r\n        encodedScratch = lerpOctEncodedNormal(this, encodedScratch);\r\n        return encodedScratch.y;\r\n    };\r\n\r\n    var polygonVertices = [];\r\n    polygonVertices.push(new Vertex());\r\n    polygonVertices.push(new Vertex());\r\n    polygonVertices.push(new Vertex());\r\n    polygonVertices.push(new Vertex());\r\n\r\n    function addClippedPolygon(uBuffer, vBuffer, heightBuffer, normalBuffer, indices, vertexMap, clipped, triangleVertices, hasVertexNormals) {\r\n        if (clipped.length === 0) {\r\n            return;\r\n        }\r\n\r\n        var numVertices = 0;\r\n        var clippedIndex = 0;\r\n        while (clippedIndex < clipped.length) {\r\n            clippedIndex = polygonVertices[numVertices++].initializeFromClipResult(clipped, clippedIndex, triangleVertices);\r\n        }\r\n\r\n        for (var i = 0; i < numVertices; ++i) {\r\n            var polygonVertex = polygonVertices[i];\r\n            if (!polygonVertex.isIndexed()) {\r\n                var key = polygonVertex.getKey();\r\n                if (defined(vertexMap[key])) {\r\n                    polygonVertex.newIndex = vertexMap[key];\r\n                } else {\r\n                    var newIndex = uBuffer.length;\r\n                    uBuffer.push(polygonVertex.getU());\r\n                    vBuffer.push(polygonVertex.getV());\r\n                    heightBuffer.push(polygonVertex.getH());\r\n                    if (hasVertexNormals) {\r\n                        normalBuffer.push(polygonVertex.getNormalX());\r\n                        normalBuffer.push(polygonVertex.getNormalY());\r\n                    }\r\n                    polygonVertex.newIndex = newIndex;\r\n                    vertexMap[key] = newIndex;\r\n                }\r\n            } else {\r\n                polygonVertex.newIndex = vertexMap[polygonVertex.index];\r\n                polygonVertex.uBuffer = uBuffer;\r\n                polygonVertex.vBuffer = vBuffer;\r\n                polygonVertex.heightBuffer = heightBuffer;\r\n                if (hasVertexNormals) {\r\n                    polygonVertex.normalBuffer = normalBuffer;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (numVertices === 3) {\r\n            // A triangle.\r\n            indices.push(polygonVertices[0].newIndex);\r\n            indices.push(polygonVertices[1].newIndex);\r\n            indices.push(polygonVertices[2].newIndex);\r\n        } else if (numVertices === 4) {\r\n            // A quad - two triangles.\r\n            indices.push(polygonVertices[0].newIndex);\r\n            indices.push(polygonVertices[1].newIndex);\r\n            indices.push(polygonVertices[2].newIndex);\r\n\r\n            indices.push(polygonVertices[0].newIndex);\r\n            indices.push(polygonVertices[2].newIndex);\r\n            indices.push(polygonVertices[3].newIndex);\r\n        }\r\n    }\r\nexport default createTaskProcessorWorker(upsampleQuantizedTerrainMesh);\r\n"],"names":["Intersections2D","clipTriangleAtAxisAlignedThreshold","threshold","keepAbove","u0","u1","u2","result","defined","DeveloperError","u0Behind","u1Behind","u2Behind","length","u01Ratio","u02Ratio","u12Ratio","u10Ratio","u20Ratio","u21Ratio","numBehind","push","computeBarycentricCoordinates","x","y","x1","y1","x2","y2","x3","y3","x1mx3","x3mx2","y2my3","y1my3","inverseDeterminant","ymy3","xmx3","l1","l2","l3","z","Cartesian3","computeLineSegmentLineSegmentIntersection","x00","y00","x01","y01","x10","y10","x11","y11","Check","typeOf","number","denominator1","ua1","ub1","Cartesian2","clipScratch","clipScratch2","verticesScratch","cartographicScratch","Cartographic","cartesian3Scratch","uScratch","vScratch","heightScratch","indicesScratch","normalsScratch","horizonOcclusionPointScratch","boundingSphereScratch","BoundingSphere","orientedBoundingBoxScratch","OrientedBoundingBox","decodeTexCoordsScratch","octEncodedNormalScratch","Vertex","this","vertexBuffer","undefined","index","first","second","ratio","prototype","clone","uBuffer","vBuffer","heightBuffer","normalBuffer","initializeIndexed","initializeFromClipResult","clipResult","vertices","nextIndex","getKey","isIndexed","JSON","stringify","getH","CesiumMath","lerp","getU","getV","encodedScratch","depth","cartesianScratch1","cartesianScratch2","lerpOctEncodedNormal","vertex","AttributeCompression","octDecode","getNormalX","getNormalY","normalize","octEncode","polygonVertices","addClippedPolygon","indices","vertexMap","clipped","triangleVertices","hasVertexNormals","numVertices","clippedIndex","i","polygonVertex","newIndex","key","createTaskProcessorWorker","parameters","transferableObjects","isEastChild","isNorthChild","minU","maxU","minV","maxV","parentVertices","parentIndices","subarray","indexCountWithoutSkirts","height","n","u","v","encoding","TerrainEncoding","exaggeration","vertexCount","quantizedVertexCount","vertexCountWithoutSkirts","parentMinimumHeight","minimumHeight","parentMaximumHeight","maximumHeight","parentUBuffer","Array","parentVBuffer","parentHeightBuffer","parentNormalBuffer","texCoords","decodeTextureCoordinates","decodeHeight","clamp","encodedNormal","getOctEncodedNormal","clippedTriangleVertices","i0","i1","i2","uOffset","vOffset","westIndices","southIndices","eastIndices","northIndices","Number","MAX_VALUE","cartesianVertices","ellipsoid","Ellipsoid","rectangle","Rectangle","childRectangle","north","south","east","west","TWO_PI","Math","round","longitude","latitude","cartographicToCartesian","boundingSphere","fromVertices","ZERO","orientedBoundingBox","fromRectangle","horizonOcclusionPoint","EllipsoidalOccluder","computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid","center","heightRange","Uint16Array","start","encodedNormals","indicesTypedArray","IndexDatatype","createTypedArray","normalArray","Uint8Array","buffer"],"mappings":"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"}