{"version":3,"file":"GeometryPipeline-5b30641c.js","sources":["../../../../Source/Core/barycentricCoordinates.js","../../../../Source/Core/Tipsify.js","../../../../Source/Core/GeometryPipeline.js"],"sourcesContent":["import Cartesian2 from './Cartesian2.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport Check from './Check.js';\r\nimport defined from './defined.js';\r\nimport CesiumMath from './Math.js';\r\n\r\n    var scratchCartesian1 = new Cartesian3();\r\n    var scratchCartesian2 = new Cartesian3();\r\n    var scratchCartesian3 = new Cartesian3();\r\n\r\n    /**\r\n     * Computes the barycentric coordinates for a point with respect to a triangle.\r\n     *\r\n     * @exports barycentricCoordinates\r\n     *\r\n     * @param {Cartesian2|Cartesian3} point The point to test.\r\n     * @param {Cartesian2|Cartesian3} p0 The first point of the triangle, corresponding to the barycentric x-axis.\r\n     * @param {Cartesian2|Cartesian3} p1 The second point of the triangle, corresponding to the barycentric y-axis.\r\n     * @param {Cartesian2|Cartesian3} p2 The third point of the triangle, corresponding to the barycentric z-axis.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\r\n     *\r\n     * @example\r\n     * // Returns Cartesian3.UNIT_X\r\n     * var p = new Cesium.Cartesian3(-1.0, 0.0, 0.0);\r\n     * var b = Cesium.barycentricCoordinates(p,\r\n     *   new Cesium.Cartesian3(-1.0, 0.0, 0.0),\r\n     *   new Cesium.Cartesian3( 1.0, 0.0, 0.0),\r\n     *   new Cesium.Cartesian3( 0.0, 1.0, 1.0));\r\n     */\r\n    function barycentricCoordinates(point, p0, p1, p2, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('point', point);\r\n        Check.defined('p0', p0);\r\n        Check.defined('p1', p1);\r\n        Check.defined('p2', p2);\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n\r\n        // Implementation based on http://www.blackpawn.com/texts/pointinpoly/default.html.\r\n        var v0;\r\n        var v1;\r\n        var v2;\r\n        var dot00;\r\n        var dot01;\r\n        var dot02;\r\n        var dot11;\r\n        var dot12;\r\n\r\n        if(!defined(p0.z)) {\r\n            if (Cartesian2.equalsEpsilon(point, p0, CesiumMath.EPSILON14)) {\r\n                return Cartesian3.clone(Cartesian3.UNIT_X, result);\r\n            }\r\n            if (Cartesian2.equalsEpsilon(point, p1, CesiumMath.EPSILON14)) {\r\n                return Cartesian3.clone(Cartesian3.UNIT_Y, result);\r\n            }\r\n            if (Cartesian2.equalsEpsilon(point, p2, CesiumMath.EPSILON14)) {\r\n                return Cartesian3.clone(Cartesian3.UNIT_Z, result);\r\n            }\r\n\r\n            v0 = Cartesian2.subtract(p1, p0, scratchCartesian1);\r\n            v1 = Cartesian2.subtract(p2, p0, scratchCartesian2);\r\n            v2 = Cartesian2.subtract(point, p0, scratchCartesian3);\r\n\r\n            dot00 = Cartesian2.dot(v0, v0);\r\n            dot01 = Cartesian2.dot(v0, v1);\r\n            dot02 = Cartesian2.dot(v0, v2);\r\n            dot11 = Cartesian2.dot(v1, v1);\r\n            dot12 = Cartesian2.dot(v1, v2);\r\n        } else {\r\n            if (Cartesian3.equalsEpsilon(point, p0, CesiumMath.EPSILON14)) {\r\n                return Cartesian3.clone(Cartesian3.UNIT_X, result);\r\n            }\r\n            if (Cartesian3.equalsEpsilon(point, p1, CesiumMath.EPSILON14)) {\r\n                return Cartesian3.clone(Cartesian3.UNIT_Y, result);\r\n            }\r\n            if (Cartesian3.equalsEpsilon(point, p2, CesiumMath.EPSILON14)) {\r\n                return Cartesian3.clone(Cartesian3.UNIT_Z, result);\r\n            }\r\n\r\n            v0 = Cartesian3.subtract(p1, p0, scratchCartesian1);\r\n            v1 = Cartesian3.subtract(p2, p0, scratchCartesian2);\r\n            v2 = Cartesian3.subtract(point, p0, scratchCartesian3);\r\n\r\n            dot00 = Cartesian3.dot(v0, v0);\r\n            dot01 = Cartesian3.dot(v0, v1);\r\n            dot02 = Cartesian3.dot(v0, v2);\r\n            dot11 = Cartesian3.dot(v1, v1);\r\n            dot12 = Cartesian3.dot(v1, v2);\r\n        }\r\n\r\n        result.y = (dot11 * dot02 - dot01 * dot12);\r\n        result.z = (dot00 * dot12 - dot01 * dot02);\r\n        var q = dot00 * dot11 - dot01 * dot01;\r\n\r\n        // This is done to avoid dividing by infinity causing a NaN\r\n        if (result.y !== 0) {\r\n            result.y /= q;\r\n        }\r\n        if (result.z !== 0) {\r\n            result.z /= q;\r\n        }\r\n\r\n        result.x = 1.0 - result.y - result.z;\r\n        return result;\r\n    }\r\nexport default barycentricCoordinates;\r\n","import defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\n\r\n    /**\r\n     * Encapsulates an algorithm to optimize triangles for the post\r\n     * vertex-shader cache.  This is based on the 2007 SIGGRAPH paper\r\n     * 'Fast Triangle Reordering for Vertex Locality and Reduced Overdraw.'\r\n     * The runtime is linear but several passes are made.\r\n     *\r\n     * @exports Tipsify\r\n     *\r\n     * @see <a href='http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf'>\r\n     * Fast Triangle Reordering for Vertex Locality and Reduced Overdraw</a>\r\n     * by Sander, Nehab, and Barczak\r\n     *\r\n     * @private\r\n     */\r\n    var Tipsify = {};\r\n\r\n    /**\r\n     * Calculates the average cache miss ratio (ACMR) for a given set of indices.\r\n     *\r\n     * @param {Object} options Object with the following properties:\r\n     * @param {Number[]} options.indices Lists triads of numbers corresponding to the indices of the vertices\r\n     *                        in the vertex buffer that define the geometry's triangles.\r\n     * @param {Number} [options.maximumIndex] The maximum value of the elements in <code>args.indices</code>.\r\n     *                                     If not supplied, this value will be computed.\r\n     * @param {Number} [options.cacheSize=24] The number of vertices that can be stored in the cache at any one time.\r\n     * @returns {Number} The average cache miss ratio (ACMR).\r\n     *\r\n     * @exception {DeveloperError} indices length must be a multiple of three.\r\n     * @exception {DeveloperError} cacheSize must be greater than two.\r\n     *\r\n     * @example\r\n     * var indices = [0, 1, 2, 3, 4, 5];\r\n     * var maxIndex = 5;\r\n     * var cacheSize = 3;\r\n     * var acmr = Cesium.Tipsify.calculateACMR({indices : indices, maxIndex : maxIndex, cacheSize : cacheSize});\r\n     */\r\n    Tipsify.calculateACMR = function(options) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n        var indices = options.indices;\r\n        var maximumIndex = options.maximumIndex;\r\n        var cacheSize = defaultValue(options.cacheSize, 24);\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(indices)) {\r\n            throw new DeveloperError('indices is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var numIndices = indices.length;\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (numIndices < 3 || numIndices % 3 !== 0) {\r\n            throw new DeveloperError('indices length must be a multiple of three.');\r\n        }\r\n        if (maximumIndex <= 0) {\r\n            throw new DeveloperError('maximumIndex must be greater than zero.');\r\n        }\r\n        if (cacheSize < 3) {\r\n            throw new DeveloperError('cacheSize must be greater than two.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        // Compute the maximumIndex if not given\r\n        if (!defined(maximumIndex)) {\r\n            maximumIndex = 0;\r\n            var currentIndex = 0;\r\n            var intoIndices = indices[currentIndex];\r\n            while (currentIndex < numIndices) {\r\n                if (intoIndices > maximumIndex) {\r\n                    maximumIndex = intoIndices;\r\n                }\r\n                ++currentIndex;\r\n                intoIndices = indices[currentIndex];\r\n            }\r\n        }\r\n\r\n        // Vertex time stamps\r\n        var vertexTimeStamps = [];\r\n        for ( var i = 0; i < maximumIndex + 1; i++) {\r\n            vertexTimeStamps[i] = 0;\r\n        }\r\n\r\n        // Cache processing\r\n        var s = cacheSize + 1;\r\n        for ( var j = 0; j < numIndices; ++j) {\r\n            if ((s - vertexTimeStamps[indices[j]]) > cacheSize) {\r\n                vertexTimeStamps[indices[j]] = s;\r\n                ++s;\r\n            }\r\n        }\r\n\r\n        return (s - cacheSize + 1) / (numIndices / 3);\r\n    };\r\n\r\n    /**\r\n     * Optimizes triangles for the post-vertex shader cache.\r\n     *\r\n     * @param {Object} options Object with the following properties:\r\n     * @param {Number[]} options.indices Lists triads of numbers corresponding to the indices of the vertices\r\n     *                        in the vertex buffer that define the geometry's triangles.\r\n     * @param {Number} [options.maximumIndex] The maximum value of the elements in <code>args.indices</code>.\r\n     *                                     If not supplied, this value will be computed.\r\n     * @param {Number} [options.cacheSize=24] The number of vertices that can be stored in the cache at any one time.\r\n     * @returns {Number[]} A list of the input indices in an optimized order.\r\n     *\r\n     * @exception {DeveloperError} indices length must be a multiple of three.\r\n     * @exception {DeveloperError} cacheSize must be greater than two.\r\n     *\r\n     * @example\r\n     * var indices = [0, 1, 2, 3, 4, 5];\r\n     * var maxIndex = 5;\r\n     * var cacheSize = 3;\r\n     * var reorderedIndices = Cesium.Tipsify.tipsify({indices : indices, maxIndex : maxIndex, cacheSize : cacheSize});\r\n     */\r\n    Tipsify.tipsify = function(options) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n        var indices = options.indices;\r\n        var maximumIndex = options.maximumIndex;\r\n        var cacheSize = defaultValue(options.cacheSize, 24);\r\n\r\n        var cursor;\r\n\r\n        function skipDeadEnd(vertices, deadEnd, indices, maximumIndexPlusOne) {\r\n            while (deadEnd.length >= 1) {\r\n                // while the stack is not empty\r\n                var d = deadEnd[deadEnd.length - 1]; // top of the stack\r\n                deadEnd.splice(deadEnd.length - 1, 1); // pop the stack\r\n\r\n                if (vertices[d].numLiveTriangles > 0) {\r\n                    return d;\r\n                }\r\n            }\r\n\r\n            while (cursor < maximumIndexPlusOne) {\r\n                if (vertices[cursor].numLiveTriangles > 0) {\r\n                    ++cursor;\r\n                    return cursor - 1;\r\n                }\r\n                ++cursor;\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        function getNextVertex(indices, cacheSize, oneRing, vertices, s, deadEnd, maximumIndexPlusOne) {\r\n            var n = -1;\r\n            var p;\r\n            var m = -1;\r\n            var itOneRing = 0;\r\n            while (itOneRing < oneRing.length) {\r\n                var index = oneRing[itOneRing];\r\n                if (vertices[index].numLiveTriangles) {\r\n                    p = 0;\r\n                    if ((s - vertices[index].timeStamp + (2 * vertices[index].numLiveTriangles)) <= cacheSize) {\r\n                        p = s - vertices[index].timeStamp;\r\n                    }\r\n                    if ((p > m) || (m === -1)) {\r\n                        m = p;\r\n                        n = index;\r\n                    }\r\n                }\r\n                ++itOneRing;\r\n            }\r\n            if (n === -1) {\r\n                return skipDeadEnd(vertices, deadEnd, indices, maximumIndexPlusOne);\r\n            }\r\n            return n;\r\n        }\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(indices)) {\r\n            throw new DeveloperError('indices is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var numIndices = indices.length;\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (numIndices < 3 || numIndices % 3 !== 0) {\r\n            throw new DeveloperError('indices length must be a multiple of three.');\r\n        }\r\n        if (maximumIndex <= 0) {\r\n            throw new DeveloperError('maximumIndex must be greater than zero.');\r\n        }\r\n        if (cacheSize < 3) {\r\n            throw new DeveloperError('cacheSize must be greater than two.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        // Determine maximum index\r\n        var maximumIndexPlusOne = 0;\r\n        var currentIndex = 0;\r\n        var intoIndices = indices[currentIndex];\r\n        var endIndex = numIndices;\r\n        if (defined(maximumIndex)) {\r\n            maximumIndexPlusOne = maximumIndex + 1;\r\n        } else {\r\n            while (currentIndex < endIndex) {\r\n                if (intoIndices > maximumIndexPlusOne) {\r\n                    maximumIndexPlusOne = intoIndices;\r\n                }\r\n                ++currentIndex;\r\n                intoIndices = indices[currentIndex];\r\n            }\r\n            if (maximumIndexPlusOne === -1) {\r\n                return 0;\r\n            }\r\n            ++maximumIndexPlusOne;\r\n        }\r\n\r\n        // Vertices\r\n        var vertices = [];\r\n        var i;\r\n        for (i = 0; i < maximumIndexPlusOne; i++) {\r\n            vertices[i] = {\r\n                numLiveTriangles : 0,\r\n                timeStamp : 0,\r\n                vertexTriangles : []\r\n            };\r\n        }\r\n        currentIndex = 0;\r\n        var triangle = 0;\r\n        while (currentIndex < endIndex) {\r\n            vertices[indices[currentIndex]].vertexTriangles.push(triangle);\r\n            ++(vertices[indices[currentIndex]]).numLiveTriangles;\r\n            vertices[indices[currentIndex + 1]].vertexTriangles.push(triangle);\r\n            ++(vertices[indices[currentIndex + 1]]).numLiveTriangles;\r\n            vertices[indices[currentIndex + 2]].vertexTriangles.push(triangle);\r\n            ++(vertices[indices[currentIndex + 2]]).numLiveTriangles;\r\n            ++triangle;\r\n            currentIndex += 3;\r\n        }\r\n\r\n        // Starting index\r\n        var f = 0;\r\n\r\n        // Time Stamp\r\n        var s = cacheSize + 1;\r\n        cursor = 1;\r\n\r\n        // Process\r\n        var oneRing = [];\r\n        var deadEnd = []; //Stack\r\n        var vertex;\r\n        var intoVertices;\r\n        var currentOutputIndex = 0;\r\n        var outputIndices = [];\r\n        var numTriangles = numIndices / 3;\r\n        var triangleEmitted = [];\r\n        for (i = 0; i < numTriangles; i++) {\r\n            triangleEmitted[i] = false;\r\n        }\r\n        var index;\r\n        var limit;\r\n        while (f !== -1) {\r\n            oneRing = [];\r\n            intoVertices = vertices[f];\r\n            limit = intoVertices.vertexTriangles.length;\r\n            for ( var k = 0; k < limit; ++k) {\r\n                triangle = intoVertices.vertexTriangles[k];\r\n                if (!triangleEmitted[triangle]) {\r\n                    triangleEmitted[triangle] = true;\r\n                    currentIndex = triangle + triangle + triangle;\r\n                    for ( var j = 0; j < 3; ++j) {\r\n                        // Set this index as a possible next index\r\n                        index = indices[currentIndex];\r\n                        oneRing.push(index);\r\n                        deadEnd.push(index);\r\n\r\n                        // Output index\r\n                        outputIndices[currentOutputIndex] = index;\r\n                        ++currentOutputIndex;\r\n\r\n                        // Cache processing\r\n                        vertex = vertices[index];\r\n                        --vertex.numLiveTriangles;\r\n                        if ((s - vertex.timeStamp) > cacheSize) {\r\n                            vertex.timeStamp = s;\r\n                            ++s;\r\n                        }\r\n                        ++currentIndex;\r\n                    }\r\n                }\r\n            }\r\n            f = getNextVertex(indices, cacheSize, oneRing, vertices, s, deadEnd, maximumIndexPlusOne);\r\n        }\r\n\r\n        return outputIndices;\r\n    };\r\nexport default Tipsify;\r\n","import AttributeCompression from './AttributeCompression.js';\r\nimport barycentricCoordinates from './barycentricCoordinates.js';\r\nimport BoundingSphere from './BoundingSphere.js';\r\nimport Cartesian2 from './Cartesian2.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport Cartesian4 from './Cartesian4.js';\r\nimport Cartographic from './Cartographic.js';\r\nimport ComponentDatatype from './ComponentDatatype.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport EncodedCartesian3 from './EncodedCartesian3.js';\r\nimport GeographicProjection from './GeographicProjection.js';\r\nimport Geometry from './Geometry.js';\r\nimport GeometryAttribute from './GeometryAttribute.js';\r\nimport GeometryType from './GeometryType.js';\r\nimport IndexDatatype from './IndexDatatype.js';\r\nimport Intersect from './Intersect.js';\r\nimport IntersectionTests from './IntersectionTests.js';\r\nimport CesiumMath from './Math.js';\r\nimport Matrix3 from './Matrix3.js';\r\nimport Matrix4 from './Matrix4.js';\r\nimport Plane from './Plane.js';\r\nimport PrimitiveType from './PrimitiveType.js';\r\nimport Tipsify from './Tipsify.js';\r\n\r\n    /**\r\n     * Content pipeline functions for geometries.\r\n     *\r\n     * @exports GeometryPipeline\r\n     *\r\n     * @see Geometry\r\n     */\r\n    var GeometryPipeline = {};\r\n\r\n    function addTriangle(lines, index, i0, i1, i2) {\r\n        lines[index++] = i0;\r\n        lines[index++] = i1;\r\n\r\n        lines[index++] = i1;\r\n        lines[index++] = i2;\r\n\r\n        lines[index++] = i2;\r\n        lines[index] = i0;\r\n    }\r\n\r\n    function trianglesToLines(triangles) {\r\n        var count = triangles.length;\r\n        var size = (count / 3) * 6;\r\n        var lines = IndexDatatype.createTypedArray(count, size);\r\n\r\n        var index = 0;\r\n        for ( var i = 0; i < count; i += 3, index += 6) {\r\n            addTriangle(lines, index, triangles[i], triangles[i + 1], triangles[i + 2]);\r\n        }\r\n\r\n        return lines;\r\n    }\r\n\r\n    function triangleStripToLines(triangles) {\r\n        var count = triangles.length;\r\n        if (count >= 3) {\r\n            var size = (count - 2) * 6;\r\n            var lines = IndexDatatype.createTypedArray(count, size);\r\n\r\n            addTriangle(lines, 0, triangles[0], triangles[1], triangles[2]);\r\n            var index = 6;\r\n\r\n            for ( var i = 3; i < count; ++i, index += 6) {\r\n                addTriangle(lines, index, triangles[i - 1], triangles[i], triangles[i - 2]);\r\n            }\r\n\r\n            return lines;\r\n        }\r\n\r\n        return new Uint16Array();\r\n    }\r\n\r\n    function triangleFanToLines(triangles) {\r\n        if (triangles.length > 0) {\r\n            var count = triangles.length - 1;\r\n            var size = (count - 1) * 6;\r\n            var lines = IndexDatatype.createTypedArray(count, size);\r\n\r\n            var base = triangles[0];\r\n            var index = 0;\r\n            for ( var i = 1; i < count; ++i, index += 6) {\r\n                addTriangle(lines, index, base, triangles[i], triangles[i + 1]);\r\n            }\r\n\r\n            return lines;\r\n        }\r\n\r\n        return new Uint16Array();\r\n    }\r\n\r\n    /**\r\n     * Converts a geometry's triangle indices to line indices.  If the geometry has an <code>indices</code>\r\n     * and its <code>primitiveType</code> is <code>TRIANGLES</code>, <code>TRIANGLE_STRIP</code>,\r\n     * <code>TRIANGLE_FAN</code>, it is converted to <code>LINES</code>; otherwise, the geometry is not changed.\r\n     * <p>\r\n     * This is commonly used to create a wireframe geometry for visual debugging.\r\n     * </p>\r\n     *\r\n     * @param {Geometry} geometry The geometry to modify.\r\n     * @returns {Geometry} The modified <code>geometry</code> argument, with its triangle indices converted to lines.\r\n     *\r\n     * @exception {DeveloperError} geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.\r\n     *\r\n     * @example\r\n     * geometry = Cesium.GeometryPipeline.toWireframe(geometry);\r\n     */\r\n    GeometryPipeline.toWireframe = function(geometry) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(geometry)) {\r\n            throw new DeveloperError('geometry is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var indices = geometry.indices;\r\n        if (defined(indices)) {\r\n            switch (geometry.primitiveType) {\r\n                case PrimitiveType.TRIANGLES:\r\n                    geometry.indices = trianglesToLines(indices);\r\n                    break;\r\n                case PrimitiveType.TRIANGLE_STRIP:\r\n                    geometry.indices = triangleStripToLines(indices);\r\n                    break;\r\n                case PrimitiveType.TRIANGLE_FAN:\r\n                    geometry.indices = triangleFanToLines(indices);\r\n                    break;\r\n                //>>includeStart('debug', pragmas.debug);\r\n                default:\r\n                    throw new DeveloperError('geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.');\r\n                //>>includeEnd('debug');\r\n            }\r\n\r\n            geometry.primitiveType = PrimitiveType.LINES;\r\n        }\r\n\r\n        return geometry;\r\n    };\r\n\r\n    /**\r\n     * Creates a new {@link Geometry} with <code>LINES</code> representing the provided\r\n     * attribute (<code>attributeName</code>) for the provided geometry.  This is used to\r\n     * visualize vector attributes like normals, tangents, and bitangents.\r\n     *\r\n     * @param {Geometry} geometry The <code>Geometry</code> instance with the attribute.\r\n     * @param {String} [attributeName='normal'] The name of the attribute.\r\n     * @param {Number} [length=10000.0] The length of each line segment in meters.  This can be negative to point the vector in the opposite direction.\r\n     * @returns {Geometry} A new <code>Geometry</code> instance with line segments for the vector.\r\n     *\r\n     * @exception {DeveloperError} geometry.attributes must have an attribute with the same name as the attributeName parameter.\r\n     *\r\n     * @example\r\n     * var geometry = Cesium.GeometryPipeline.createLineSegmentsForVectors(instance.geometry, 'bitangent', 100000.0);\r\n     */\r\n    GeometryPipeline.createLineSegmentsForVectors = function(geometry, attributeName, length) {\r\n        attributeName = defaultValue(attributeName, 'normal');\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(geometry)) {\r\n            throw new DeveloperError('geometry is required.');\r\n        }\r\n        if (!defined(geometry.attributes.position)) {\r\n            throw new DeveloperError('geometry.attributes.position is required.');\r\n        }\r\n        if (!defined(geometry.attributes[attributeName])) {\r\n            throw new DeveloperError('geometry.attributes must have an attribute with the same name as the attributeName parameter, ' + attributeName + '.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        length = defaultValue(length, 10000.0);\r\n\r\n        var positions = geometry.attributes.position.values;\r\n        var vectors = geometry.attributes[attributeName].values;\r\n        var positionsLength = positions.length;\r\n\r\n        var newPositions = new Float64Array(2 * positionsLength);\r\n\r\n        var j = 0;\r\n        for (var i = 0; i < positionsLength; i += 3) {\r\n            newPositions[j++] = positions[i];\r\n            newPositions[j++] = positions[i + 1];\r\n            newPositions[j++] = positions[i + 2];\r\n\r\n            newPositions[j++] = positions[i] + (vectors[i] * length);\r\n            newPositions[j++] = positions[i + 1] + (vectors[i + 1] * length);\r\n            newPositions[j++] = positions[i + 2] + (vectors[i + 2] * length);\r\n        }\r\n\r\n        var newBoundingSphere;\r\n        var bs = geometry.boundingSphere;\r\n        if (defined(bs)) {\r\n            newBoundingSphere = new BoundingSphere(bs.center, bs.radius + length);\r\n        }\r\n\r\n        return new Geometry({\r\n            attributes : {\r\n                position : new GeometryAttribute({\r\n                    componentDatatype : ComponentDatatype.DOUBLE,\r\n                    componentsPerAttribute : 3,\r\n                    values : newPositions\r\n                })\r\n            },\r\n            primitiveType : PrimitiveType.LINES,\r\n            boundingSphere : newBoundingSphere\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Creates an object that maps attribute names to unique locations (indices)\r\n     * for matching vertex attributes and shader programs.\r\n     *\r\n     * @param {Geometry} geometry The geometry, which is not modified, to create the object for.\r\n     * @returns {Object} An object with attribute name / index pairs.\r\n     *\r\n     * @example\r\n     * var attributeLocations = Cesium.GeometryPipeline.createAttributeLocations(geometry);\r\n     * // Example output\r\n     * // {\r\n     * //   'position' : 0,\r\n     * //   'normal' : 1\r\n     * // }\r\n     */\r\n    GeometryPipeline.createAttributeLocations = function(geometry) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(geometry)) {\r\n            throw new DeveloperError('geometry is required.');\r\n        }\r\n        //>>includeEnd('debug')\r\n\r\n        // There can be a WebGL performance hit when attribute 0 is disabled, so\r\n        // assign attribute locations to well-known attributes.\r\n        var semantics = [\r\n            'position',\r\n            'positionHigh',\r\n            'positionLow',\r\n\r\n            // From VertexFormat.position - after 2D projection and high-precision encoding\r\n            'position3DHigh',\r\n            'position3DLow',\r\n            'position2DHigh',\r\n            'position2DLow',\r\n\r\n            // From Primitive\r\n            'pickColor',\r\n\r\n            // From VertexFormat\r\n            'normal',\r\n            'st',\r\n            'tangent',\r\n            'bitangent',\r\n\r\n            // For shadow volumes\r\n            'extrudeDirection',\r\n\r\n            // From compressing texture coordinates and normals\r\n            'compressedAttributes'\r\n        ];\r\n\r\n        var attributes = geometry.attributes;\r\n        var indices = {};\r\n        var j = 0;\r\n        var i;\r\n        var len = semantics.length;\r\n\r\n        // Attribute locations for well-known attributes\r\n        for (i = 0; i < len; ++i) {\r\n            var semantic = semantics[i];\r\n\r\n            if (defined(attributes[semantic])) {\r\n                indices[semantic] = j++;\r\n            }\r\n        }\r\n\r\n        // Locations for custom attributes\r\n        for (var name in attributes) {\r\n            if (attributes.hasOwnProperty(name) && (!defined(indices[name]))) {\r\n                indices[name] = j++;\r\n            }\r\n        }\r\n\r\n        return indices;\r\n    };\r\n\r\n    /**\r\n     * Reorders a geometry's attributes and <code>indices</code> to achieve better performance from the GPU's pre-vertex-shader cache.\r\n     *\r\n     * @param {Geometry} geometry The geometry to modify.\r\n     * @returns {Geometry} The modified <code>geometry</code> argument, with its attributes and indices reordered for the GPU's pre-vertex-shader cache.\r\n     *\r\n     * @exception {DeveloperError} Each attribute array in geometry.attributes must have the same number of attributes.\r\n     *\r\n     *\r\n     * @example\r\n     * geometry = Cesium.GeometryPipeline.reorderForPreVertexCache(geometry);\r\n     *\r\n     * @see GeometryPipeline.reorderForPostVertexCache\r\n     */\r\n    GeometryPipeline.reorderForPreVertexCache = function(geometry) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(geometry)) {\r\n            throw new DeveloperError('geometry is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var numVertices = Geometry.computeNumberOfVertices(geometry);\r\n\r\n        var indices = geometry.indices;\r\n        if (defined(indices)) {\r\n            var indexCrossReferenceOldToNew = new Int32Array(numVertices);\r\n            for ( var i = 0; i < numVertices; i++) {\r\n                indexCrossReferenceOldToNew[i] = -1;\r\n            }\r\n\r\n            // Construct cross reference and reorder indices\r\n            var indicesIn = indices;\r\n            var numIndices = indicesIn.length;\r\n            var indicesOut = IndexDatatype.createTypedArray(numVertices, numIndices);\r\n\r\n            var intoIndicesIn = 0;\r\n            var intoIndicesOut = 0;\r\n            var nextIndex = 0;\r\n            var tempIndex;\r\n            while (intoIndicesIn < numIndices) {\r\n                tempIndex = indexCrossReferenceOldToNew[indicesIn[intoIndicesIn]];\r\n                if (tempIndex !== -1) {\r\n                    indicesOut[intoIndicesOut] = tempIndex;\r\n                } else {\r\n                    tempIndex = indicesIn[intoIndicesIn];\r\n                    indexCrossReferenceOldToNew[tempIndex] = nextIndex;\r\n\r\n                    indicesOut[intoIndicesOut] = nextIndex;\r\n                    ++nextIndex;\r\n                }\r\n                ++intoIndicesIn;\r\n                ++intoIndicesOut;\r\n            }\r\n            geometry.indices = indicesOut;\r\n\r\n            // Reorder attributes\r\n            var attributes = geometry.attributes;\r\n            for ( var property in attributes) {\r\n                if (attributes.hasOwnProperty(property) &&\r\n                        defined(attributes[property]) &&\r\n                        defined(attributes[property].values)) {\r\n\r\n                    var attribute = attributes[property];\r\n                    var elementsIn = attribute.values;\r\n                    var intoElementsIn = 0;\r\n                    var numComponents = attribute.componentsPerAttribute;\r\n                    var elementsOut = ComponentDatatype.createTypedArray(attribute.componentDatatype, nextIndex * numComponents);\r\n                    while (intoElementsIn < numVertices) {\r\n                        var temp = indexCrossReferenceOldToNew[intoElementsIn];\r\n                        if (temp !== -1) {\r\n                            for (var j = 0; j < numComponents; j++) {\r\n                                elementsOut[numComponents * temp + j] = elementsIn[numComponents * intoElementsIn + j];\r\n                            }\r\n                        }\r\n                        ++intoElementsIn;\r\n                    }\r\n                    attribute.values = elementsOut;\r\n                }\r\n            }\r\n        }\r\n\r\n        return geometry;\r\n    };\r\n\r\n    /**\r\n     * Reorders a geometry's <code>indices</code> to achieve better performance from the GPU's\r\n     * post vertex-shader cache by using the Tipsify algorithm.  If the geometry <code>primitiveType</code>\r\n     * is not <code>TRIANGLES</code> or the geometry does not have an <code>indices</code>, this function has no effect.\r\n     *\r\n     * @param {Geometry} geometry The geometry to modify.\r\n     * @param {Number} [cacheCapacity=24] The number of vertices that can be held in the GPU's vertex cache.\r\n     * @returns {Geometry} The modified <code>geometry</code> argument, with its indices reordered for the post-vertex-shader cache.\r\n     *\r\n     * @exception {DeveloperError} cacheCapacity must be greater than two.\r\n     *\r\n     *\r\n     * @example\r\n     * geometry = Cesium.GeometryPipeline.reorderForPostVertexCache(geometry);\r\n     *\r\n     * @see GeometryPipeline.reorderForPreVertexCache\r\n     * @see {@link http://gfx.cs.princ0eton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf|Fast Triangle Reordering for Vertex Locality and Reduced Overdraw}\r\n     * by Sander, Nehab, and Barczak\r\n     */\r\n    GeometryPipeline.reorderForPostVertexCache = function(geometry, cacheCapacity) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(geometry)) {\r\n            throw new DeveloperError('geometry is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var indices = geometry.indices;\r\n        if ((geometry.primitiveType === PrimitiveType.TRIANGLES) && (defined(indices))) {\r\n            var numIndices = indices.length;\r\n            var maximumIndex = 0;\r\n            for ( var j = 0; j < numIndices; j++) {\r\n                if (indices[j] > maximumIndex) {\r\n                    maximumIndex = indices[j];\r\n                }\r\n            }\r\n            geometry.indices = Tipsify.tipsify({\r\n                indices : indices,\r\n                maximumIndex : maximumIndex,\r\n                cacheSize : cacheCapacity\r\n            });\r\n        }\r\n\r\n        return geometry;\r\n    };\r\n\r\n    function copyAttributesDescriptions(attributes) {\r\n        var newAttributes = {};\r\n\r\n        for ( var attribute in attributes) {\r\n            if (attributes.hasOwnProperty(attribute) &&\r\n                    defined(attributes[attribute]) &&\r\n                    defined(attributes[attribute].values)) {\r\n\r\n                var attr = attributes[attribute];\r\n                newAttributes[attribute] = new GeometryAttribute({\r\n                    componentDatatype : attr.componentDatatype,\r\n                    componentsPerAttribute : attr.componentsPerAttribute,\r\n                    normalize : attr.normalize,\r\n                    values : []\r\n                });\r\n            }\r\n        }\r\n\r\n        return newAttributes;\r\n    }\r\n\r\n    function copyVertex(destinationAttributes, sourceAttributes, index) {\r\n        for ( var attribute in sourceAttributes) {\r\n            if (sourceAttributes.hasOwnProperty(attribute) &&\r\n                    defined(sourceAttributes[attribute]) &&\r\n                    defined(sourceAttributes[attribute].values)) {\r\n\r\n                var attr = sourceAttributes[attribute];\r\n\r\n                for ( var k = 0; k < attr.componentsPerAttribute; ++k) {\r\n                    destinationAttributes[attribute].values.push(attr.values[(index * attr.componentsPerAttribute) + k]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Splits a geometry into multiple geometries, if necessary, to ensure that indices in the\r\n     * <code>indices</code> fit into unsigned shorts.  This is used to meet the WebGL requirements\r\n     * when unsigned int indices are not supported.\r\n     * <p>\r\n     * If the geometry does not have any <code>indices</code>, this function has no effect.\r\n     * </p>\r\n     *\r\n     * @param {Geometry} geometry The geometry to be split into multiple geometries.\r\n     * @returns {Geometry[]} An array of geometries, each with indices that fit into unsigned shorts.\r\n     *\r\n     * @exception {DeveloperError} geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS\r\n     * @exception {DeveloperError} All geometry attribute lists must have the same number of attributes.\r\n     *\r\n     * @example\r\n     * var geometries = Cesium.GeometryPipeline.fitToUnsignedShortIndices(geometry);\r\n     */\r\n    GeometryPipeline.fitToUnsignedShortIndices = function(geometry) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(geometry)) {\r\n            throw new DeveloperError('geometry is required.');\r\n        }\r\n        if ((defined(geometry.indices)) &&\r\n            ((geometry.primitiveType !== PrimitiveType.TRIANGLES) &&\r\n             (geometry.primitiveType !== PrimitiveType.LINES) &&\r\n             (geometry.primitiveType !== PrimitiveType.POINTS))) {\r\n            throw new DeveloperError('geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var geometries = [];\r\n\r\n        // If there's an index list and more than 64K attributes, it is possible that\r\n        // some indices are outside the range of unsigned short [0, 64K - 1]\r\n        var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\r\n        if (defined(geometry.indices) && (numberOfVertices >= CesiumMath.SIXTY_FOUR_KILOBYTES)) {\r\n            var oldToNewIndex = [];\r\n            var newIndices = [];\r\n            var currentIndex = 0;\r\n            var newAttributes = copyAttributesDescriptions(geometry.attributes);\r\n\r\n            var originalIndices = geometry.indices;\r\n            var numberOfIndices = originalIndices.length;\r\n\r\n            var indicesPerPrimitive;\r\n\r\n            if (geometry.primitiveType === PrimitiveType.TRIANGLES) {\r\n                indicesPerPrimitive = 3;\r\n            } else if (geometry.primitiveType === PrimitiveType.LINES) {\r\n                indicesPerPrimitive = 2;\r\n            } else if (geometry.primitiveType === PrimitiveType.POINTS) {\r\n                indicesPerPrimitive = 1;\r\n            }\r\n\r\n            for ( var j = 0; j < numberOfIndices; j += indicesPerPrimitive) {\r\n                for (var k = 0; k < indicesPerPrimitive; ++k) {\r\n                    var x = originalIndices[j + k];\r\n                    var i = oldToNewIndex[x];\r\n                    if (!defined(i)) {\r\n                        i = currentIndex++;\r\n                        oldToNewIndex[x] = i;\r\n                        copyVertex(newAttributes, geometry.attributes, x);\r\n                    }\r\n                    newIndices.push(i);\r\n                }\r\n\r\n                if (currentIndex + indicesPerPrimitive >= CesiumMath.SIXTY_FOUR_KILOBYTES) {\r\n                    geometries.push(new Geometry({\r\n                        attributes : newAttributes,\r\n                        indices : newIndices,\r\n                        primitiveType : geometry.primitiveType,\r\n                        boundingSphere : geometry.boundingSphere,\r\n                        boundingSphereCV : geometry.boundingSphereCV\r\n                    }));\r\n\r\n                    // Reset for next vertex-array\r\n                    oldToNewIndex = [];\r\n                    newIndices = [];\r\n                    currentIndex = 0;\r\n                    newAttributes = copyAttributesDescriptions(geometry.attributes);\r\n                }\r\n            }\r\n\r\n            if (newIndices.length !== 0) {\r\n                geometries.push(new Geometry({\r\n                    attributes : newAttributes,\r\n                    indices : newIndices,\r\n                    primitiveType : geometry.primitiveType,\r\n                    boundingSphere : geometry.boundingSphere,\r\n                    boundingSphereCV : geometry.boundingSphereCV\r\n                }));\r\n            }\r\n        } else {\r\n            // No need to split into multiple geometries\r\n            geometries.push(geometry);\r\n        }\r\n\r\n        return geometries;\r\n    };\r\n\r\n    var scratchProjectTo2DCartesian3 = new Cartesian3();\r\n    var scratchProjectTo2DCartographic = new Cartographic();\r\n\r\n    /**\r\n     * Projects a geometry's 3D <code>position</code> attribute to 2D, replacing the <code>position</code>\r\n     * attribute with separate <code>position3D</code> and <code>position2D</code> attributes.\r\n     * <p>\r\n     * If the geometry does not have a <code>position</code>, this function has no effect.\r\n     * </p>\r\n     *\r\n     * @param {Geometry} geometry The geometry to modify.\r\n     * @param {String} attributeName The name of the attribute.\r\n     * @param {String} attributeName3D The name of the attribute in 3D.\r\n     * @param {String} attributeName2D The name of the attribute in 2D.\r\n     * @param {Object} [projection=new GeographicProjection()] The projection to use.\r\n     * @returns {Geometry} The modified <code>geometry</code> argument with <code>position3D</code> and <code>position2D</code> attributes.\r\n     *\r\n     * @exception {DeveloperError} geometry must have attribute matching the attributeName argument.\r\n     * @exception {DeveloperError} The attribute componentDatatype must be ComponentDatatype.DOUBLE.\r\n     * @exception {DeveloperError} Could not project a point to 2D.\r\n     *\r\n     * @example\r\n     * geometry = Cesium.GeometryPipeline.projectTo2D(geometry, 'position', 'position3D', 'position2D');\r\n     */\r\n    GeometryPipeline.projectTo2D = function(geometry, attributeName, attributeName3D, attributeName2D, projection) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(geometry)) {\r\n            throw new DeveloperError('geometry is required.');\r\n        }\r\n        if (!defined(attributeName)) {\r\n            throw new DeveloperError('attributeName is required.');\r\n        }\r\n        if (!defined(attributeName3D)) {\r\n            throw new DeveloperError('attributeName3D is required.');\r\n        }\r\n        if (!defined(attributeName2D)) {\r\n            throw new DeveloperError('attributeName2D is required.');\r\n        }\r\n        if (!defined(geometry.attributes[attributeName])) {\r\n            throw new DeveloperError('geometry must have attribute matching the attributeName argument: ' + attributeName + '.');\r\n        }\r\n        if (geometry.attributes[attributeName].componentDatatype !== ComponentDatatype.DOUBLE) {\r\n            throw new DeveloperError('The attribute componentDatatype must be ComponentDatatype.DOUBLE.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var attribute = geometry.attributes[attributeName];\r\n        projection = (defined(projection)) ? projection : new GeographicProjection();\r\n        var ellipsoid = projection.ellipsoid;\r\n\r\n        // Project original values to 2D.\r\n        var values3D = attribute.values;\r\n        var projectedValues = new Float64Array(values3D.length);\r\n        var index = 0;\r\n\r\n        for ( var i = 0; i < values3D.length; i += 3) {\r\n            var value = Cartesian3.fromArray(values3D, i, scratchProjectTo2DCartesian3);\r\n\r\n            var lonLat = ellipsoid.cartesianToCartographic(value, scratchProjectTo2DCartographic);\r\n            //>>includeStart('debug', pragmas.debug);\r\n            if (!defined(lonLat)) {\r\n                throw new DeveloperError('Could not project point (' + value.x + ', ' + value.y + ', ' + value.z + ') to 2D.');\r\n            }\r\n            //>>includeEnd('debug');\r\n\r\n            var projectedLonLat = projection.project(lonLat, scratchProjectTo2DCartesian3);\r\n\r\n            projectedValues[index++] = projectedLonLat.x;\r\n            projectedValues[index++] = projectedLonLat.y;\r\n            projectedValues[index++] = projectedLonLat.z;\r\n        }\r\n\r\n        // Rename original cartesians to WGS84 cartesians.\r\n        geometry.attributes[attributeName3D] = attribute;\r\n\r\n        // Replace original cartesians with 2D projected cartesians\r\n        geometry.attributes[attributeName2D] = new GeometryAttribute({\r\n            componentDatatype : ComponentDatatype.DOUBLE,\r\n            componentsPerAttribute : 3,\r\n            values : projectedValues\r\n        });\r\n        delete geometry.attributes[attributeName];\r\n\r\n        return geometry;\r\n    };\r\n\r\n    var encodedResult = {\r\n        high : 0.0,\r\n        low : 0.0\r\n    };\r\n\r\n    /**\r\n     * Encodes floating-point geometry attribute values as two separate attributes to improve\r\n     * rendering precision.\r\n     * <p>\r\n     * This is commonly used to create high-precision position vertex attributes.\r\n     * </p>\r\n     *\r\n     * @param {Geometry} geometry The geometry to modify.\r\n     * @param {String} attributeName The name of the attribute.\r\n     * @param {String} attributeHighName The name of the attribute for the encoded high bits.\r\n     * @param {String} attributeLowName The name of the attribute for the encoded low bits.\r\n     * @returns {Geometry} The modified <code>geometry</code> argument, with its encoded attribute.\r\n     *\r\n     * @exception {DeveloperError} geometry must have attribute matching the attributeName argument.\r\n     * @exception {DeveloperError} The attribute componentDatatype must be ComponentDatatype.DOUBLE.\r\n     *\r\n     * @example\r\n     * geometry = Cesium.GeometryPipeline.encodeAttribute(geometry, 'position3D', 'position3DHigh', 'position3DLow');\r\n     */\r\n    GeometryPipeline.encodeAttribute = function(geometry, attributeName, attributeHighName, attributeLowName) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(geometry)) {\r\n            throw new DeveloperError('geometry is required.');\r\n        }\r\n        if (!defined(attributeName)) {\r\n            throw new DeveloperError('attributeName is required.');\r\n        }\r\n        if (!defined(attributeHighName)) {\r\n            throw new DeveloperError('attributeHighName is required.');\r\n        }\r\n        if (!defined(attributeLowName)) {\r\n            throw new DeveloperError('attributeLowName is required.');\r\n        }\r\n        if (!defined(geometry.attributes[attributeName])) {\r\n            throw new DeveloperError('geometry must have attribute matching the attributeName argument: ' + attributeName + '.');\r\n        }\r\n        if (geometry.attributes[attributeName].componentDatatype !== ComponentDatatype.DOUBLE) {\r\n            throw new DeveloperError('The attribute componentDatatype must be ComponentDatatype.DOUBLE.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var attribute = geometry.attributes[attributeName];\r\n        var values = attribute.values;\r\n        var length = values.length;\r\n        var highValues = new Float32Array(length);\r\n        var lowValues = new Float32Array(length);\r\n\r\n        for (var i = 0; i < length; ++i) {\r\n            EncodedCartesian3.encode(values[i], encodedResult);\r\n            highValues[i] = encodedResult.high;\r\n            lowValues[i] = encodedResult.low;\r\n        }\r\n\r\n        var componentsPerAttribute = attribute.componentsPerAttribute;\r\n\r\n        geometry.attributes[attributeHighName] = new GeometryAttribute({\r\n            componentDatatype : ComponentDatatype.FLOAT,\r\n            componentsPerAttribute : componentsPerAttribute,\r\n            values : highValues\r\n        });\r\n        geometry.attributes[attributeLowName] = new GeometryAttribute({\r\n            componentDatatype : ComponentDatatype.FLOAT,\r\n            componentsPerAttribute : componentsPerAttribute,\r\n            values : lowValues\r\n        });\r\n        delete geometry.attributes[attributeName];\r\n\r\n        return geometry;\r\n    };\r\n\r\n    var scratchCartesian3 = new Cartesian3();\r\n\r\n    function transformPoint(matrix, attribute) {\r\n        if (defined(attribute)) {\r\n            var values = attribute.values;\r\n            var length = values.length;\r\n            for (var i = 0; i < length; i += 3) {\r\n                Cartesian3.unpack(values, i, scratchCartesian3);\r\n                Matrix4.multiplyByPoint(matrix, scratchCartesian3, scratchCartesian3);\r\n                Cartesian3.pack(scratchCartesian3, values, i);\r\n            }\r\n        }\r\n    }\r\n\r\n    function transformVector(matrix, attribute) {\r\n        if (defined(attribute)) {\r\n            var values = attribute.values;\r\n            var length = values.length;\r\n            for (var i = 0; i < length; i += 3) {\r\n                Cartesian3.unpack(values, i, scratchCartesian3);\r\n                Matrix3.multiplyByVector(matrix, scratchCartesian3, scratchCartesian3);\r\n                scratchCartesian3 = Cartesian3.normalize(scratchCartesian3, scratchCartesian3);\r\n                Cartesian3.pack(scratchCartesian3, values, i);\r\n            }\r\n        }\r\n    }\r\n\r\n    var inverseTranspose = new Matrix4();\r\n    var normalMatrix = new Matrix3();\r\n\r\n    /**\r\n     * Transforms a geometry instance to world coordinates.  This changes\r\n     * the instance's <code>modelMatrix</code> to {@link Matrix4.IDENTITY} and transforms the\r\n     * following attributes if they are present: <code>position</code>, <code>normal</code>,\r\n     * <code>tangent</code>, and <code>bitangent</code>.\r\n     *\r\n     * @param {GeometryInstance} instance The geometry instance to modify.\r\n     * @returns {GeometryInstance} The modified <code>instance</code> argument, with its attributes transforms to world coordinates.\r\n     *\r\n     * @example\r\n     * Cesium.GeometryPipeline.transformToWorldCoordinates(instance);\r\n     */\r\n    GeometryPipeline.transformToWorldCoordinates = function(instance) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(instance)) {\r\n            throw new DeveloperError('instance is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var modelMatrix = instance.modelMatrix;\r\n\r\n        if (Matrix4.equals(modelMatrix, Matrix4.IDENTITY)) {\r\n            // Already in world coordinates\r\n            return instance;\r\n        }\r\n\r\n        var attributes = instance.geometry.attributes;\r\n\r\n        // Transform attributes in known vertex formats\r\n        transformPoint(modelMatrix, attributes.position);\r\n        transformPoint(modelMatrix, attributes.prevPosition);\r\n        transformPoint(modelMatrix, attributes.nextPosition);\r\n\r\n        if ((defined(attributes.normal)) ||\r\n            (defined(attributes.tangent)) ||\r\n            (defined(attributes.bitangent))) {\r\n\r\n            Matrix4.inverse(modelMatrix, inverseTranspose);\r\n            Matrix4.transpose(inverseTranspose, inverseTranspose);\r\n            Matrix4.getMatrix3(inverseTranspose, normalMatrix);\r\n\r\n            transformVector(normalMatrix, attributes.normal);\r\n            transformVector(normalMatrix, attributes.tangent);\r\n            transformVector(normalMatrix, attributes.bitangent);\r\n        }\r\n\r\n        var boundingSphere = instance.geometry.boundingSphere;\r\n        if (defined(boundingSphere)) {\r\n            instance.geometry.boundingSphere = BoundingSphere.transform(boundingSphere, modelMatrix, boundingSphere);\r\n        }\r\n\r\n        instance.modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\r\n\r\n        return instance;\r\n    };\r\n\r\n    function findAttributesInAllGeometries(instances, propertyName) {\r\n        var length = instances.length;\r\n\r\n        var attributesInAllGeometries = {};\r\n\r\n        var attributes0 = instances[0][propertyName].attributes;\r\n        var name;\r\n\r\n        for (name in attributes0) {\r\n            if (attributes0.hasOwnProperty(name) &&\r\n                    defined(attributes0[name]) &&\r\n                    defined(attributes0[name].values)) {\r\n\r\n                var attribute = attributes0[name];\r\n                var numberOfComponents = attribute.values.length;\r\n                var inAllGeometries = true;\r\n\r\n                // Does this same attribute exist in all geometries?\r\n                for (var i = 1; i < length; ++i) {\r\n                    var otherAttribute = instances[i][propertyName].attributes[name];\r\n\r\n                    if ((!defined(otherAttribute)) ||\r\n                        (attribute.componentDatatype !== otherAttribute.componentDatatype) ||\r\n                        (attribute.componentsPerAttribute !== otherAttribute.componentsPerAttribute) ||\r\n                        (attribute.normalize !== otherAttribute.normalize)) {\r\n\r\n                        inAllGeometries = false;\r\n                        break;\r\n                    }\r\n\r\n                    numberOfComponents += otherAttribute.values.length;\r\n                }\r\n\r\n                if (inAllGeometries) {\r\n                    attributesInAllGeometries[name] = new GeometryAttribute({\r\n                        componentDatatype : attribute.componentDatatype,\r\n                        componentsPerAttribute : attribute.componentsPerAttribute,\r\n                        normalize : attribute.normalize,\r\n                        values : ComponentDatatype.createTypedArray(attribute.componentDatatype, numberOfComponents)\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        return attributesInAllGeometries;\r\n    }\r\n\r\n    var tempScratch = new Cartesian3();\r\n\r\n    function combineGeometries(instances, propertyName) {\r\n        var length = instances.length;\r\n\r\n        var name;\r\n        var i;\r\n        var j;\r\n        var k;\r\n\r\n        var m = instances[0].modelMatrix;\r\n        var haveIndices = (defined(instances[0][propertyName].indices));\r\n        var primitiveType = instances[0][propertyName].primitiveType;\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        for (i = 1; i < length; ++i) {\r\n            if (!Matrix4.equals(instances[i].modelMatrix, m)) {\r\n                throw new DeveloperError('All instances must have the same modelMatrix.');\r\n            }\r\n            if ((defined(instances[i][propertyName].indices)) !== haveIndices) {\r\n                throw new DeveloperError('All instance geometries must have an indices or not have one.');\r\n            }\r\n            if (instances[i][propertyName].primitiveType !== primitiveType) {\r\n                throw new DeveloperError('All instance geometries must have the same primitiveType.');\r\n            }\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        // Find subset of attributes in all geometries\r\n        var attributes = findAttributesInAllGeometries(instances, propertyName);\r\n        var values;\r\n        var sourceValues;\r\n        var sourceValuesLength;\r\n\r\n        // Combine attributes from each geometry into a single typed array\r\n        for (name in attributes) {\r\n            if (attributes.hasOwnProperty(name)) {\r\n                values = attributes[name].values;\r\n\r\n                k = 0;\r\n                for (i = 0; i < length; ++i) {\r\n                    sourceValues = instances[i][propertyName].attributes[name].values;\r\n                    sourceValuesLength = sourceValues.length;\r\n\r\n                    for (j = 0; j < sourceValuesLength; ++j) {\r\n                        values[k++] = sourceValues[j];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Combine index lists\r\n        var indices;\r\n\r\n        if (haveIndices) {\r\n            var numberOfIndices = 0;\r\n            for (i = 0; i < length; ++i) {\r\n                numberOfIndices += instances[i][propertyName].indices.length;\r\n            }\r\n\r\n            var numberOfVertices = Geometry.computeNumberOfVertices(new Geometry({\r\n                attributes : attributes,\r\n                primitiveType : PrimitiveType.POINTS\r\n            }));\r\n            var destIndices = IndexDatatype.createTypedArray(numberOfVertices, numberOfIndices);\r\n\r\n            var destOffset = 0;\r\n            var offset = 0;\r\n\r\n            for (i = 0; i < length; ++i) {\r\n                var sourceIndices = instances[i][propertyName].indices;\r\n                var sourceIndicesLen = sourceIndices.length;\r\n\r\n                for (k = 0; k < sourceIndicesLen; ++k) {\r\n                    destIndices[destOffset++] = offset + sourceIndices[k];\r\n                }\r\n\r\n                offset += Geometry.computeNumberOfVertices(instances[i][propertyName]);\r\n            }\r\n\r\n            indices = destIndices;\r\n        }\r\n\r\n        // Create bounding sphere that includes all instances\r\n        var center = new Cartesian3();\r\n        var radius = 0.0;\r\n        var bs;\r\n\r\n        for (i = 0; i < length; ++i) {\r\n            bs = instances[i][propertyName].boundingSphere;\r\n            if (!defined(bs)) {\r\n                // If any geometries have an undefined bounding sphere, then so does the combined geometry\r\n                center = undefined;\r\n                break;\r\n            }\r\n\r\n            Cartesian3.add(bs.center, center, center);\r\n        }\r\n\r\n        if (defined(center)) {\r\n            Cartesian3.divideByScalar(center, length, center);\r\n\r\n            for (i = 0; i < length; ++i) {\r\n                bs = instances[i][propertyName].boundingSphere;\r\n                var tempRadius = Cartesian3.magnitude(Cartesian3.subtract(bs.center, center, tempScratch)) + bs.radius;\r\n\r\n                if (tempRadius > radius) {\r\n                    radius = tempRadius;\r\n                }\r\n            }\r\n        }\r\n\r\n        return new Geometry({\r\n            attributes : attributes,\r\n            indices : indices,\r\n            primitiveType : primitiveType,\r\n            boundingSphere : (defined(center)) ? new BoundingSphere(center, radius) : undefined\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Combines geometry from several {@link GeometryInstance} objects into one geometry.\r\n     * This concatenates the attributes, concatenates and adjusts the indices, and creates\r\n     * a bounding sphere encompassing all instances.\r\n     * <p>\r\n     * If the instances do not have the same attributes, a subset of attributes common\r\n     * to all instances is used, and the others are ignored.\r\n     * </p>\r\n     * <p>\r\n     * This is used by {@link Primitive} to efficiently render a large amount of static data.\r\n     * </p>\r\n     *\r\n     * @private\r\n     *\r\n     * @param {GeometryInstance[]} [instances] The array of {@link GeometryInstance} objects whose geometry will be combined.\r\n     * @returns {Geometry} A single geometry created from the provided geometry instances.\r\n     *\r\n     * @exception {DeveloperError} All instances must have the same modelMatrix.\r\n     * @exception {DeveloperError} All instance geometries must have an indices or not have one.\r\n     * @exception {DeveloperError} All instance geometries must have the same primitiveType.\r\n     *\r\n     *\r\n     * @example\r\n     * for (var i = 0; i < instances.length; ++i) {\r\n     *   Cesium.GeometryPipeline.transformToWorldCoordinates(instances[i]);\r\n     * }\r\n     * var geometries = Cesium.GeometryPipeline.combineInstances(instances);\r\n     *\r\n     * @see GeometryPipeline.transformToWorldCoordinates\r\n     */\r\n    GeometryPipeline.combineInstances = function(instances) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if ((!defined(instances)) || (instances.length < 1)) {\r\n            throw new DeveloperError('instances is required and must have length greater than zero.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var instanceGeometry = [];\r\n        var instanceSplitGeometry = [];\r\n        var length = instances.length;\r\n        for (var i = 0; i < length; ++i) {\r\n            var instance = instances[i];\r\n\r\n            if (defined(instance.geometry)) {\r\n                instanceGeometry.push(instance);\r\n            } else if (defined(instance.westHemisphereGeometry) && defined(instance.eastHemisphereGeometry)) {\r\n                instanceSplitGeometry.push(instance);\r\n            }\r\n        }\r\n\r\n        var geometries = [];\r\n        if (instanceGeometry.length > 0) {\r\n            geometries.push(combineGeometries(instanceGeometry, 'geometry'));\r\n        }\r\n\r\n        if (instanceSplitGeometry.length > 0) {\r\n            geometries.push(combineGeometries(instanceSplitGeometry, 'westHemisphereGeometry'));\r\n            geometries.push(combineGeometries(instanceSplitGeometry, 'eastHemisphereGeometry'));\r\n        }\r\n\r\n        return geometries;\r\n    };\r\n\r\n    var normal = new Cartesian3();\r\n    var v0 = new Cartesian3();\r\n    var v1 = new Cartesian3();\r\n    var v2 = new Cartesian3();\r\n\r\n    /**\r\n     * Computes per-vertex normals for a geometry containing <code>TRIANGLES</code> by averaging the normals of\r\n     * all triangles incident to the vertex.  The result is a new <code>normal</code> attribute added to the geometry.\r\n     * This assumes a counter-clockwise winding order.\r\n     *\r\n     * @param {Geometry} geometry The geometry to modify.\r\n     * @returns {Geometry} The modified <code>geometry</code> argument with the computed <code>normal</code> attribute.\r\n     *\r\n     * @exception {DeveloperError} geometry.indices length must be greater than 0 and be a multiple of 3.\r\n     * @exception {DeveloperError} geometry.primitiveType must be {@link PrimitiveType.TRIANGLES}.\r\n     *\r\n     * @example\r\n     * Cesium.GeometryPipeline.computeNormal(geometry);\r\n     */\r\n    GeometryPipeline.computeNormal = function(geometry) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(geometry)) {\r\n            throw new DeveloperError('geometry is required.');\r\n        }\r\n        if (!defined(geometry.attributes.position) || !defined(geometry.attributes.position.values)) {\r\n            throw new DeveloperError('geometry.attributes.position.values is required.');\r\n        }\r\n        if (!defined(geometry.indices)) {\r\n            throw new DeveloperError('geometry.indices is required.');\r\n        }\r\n        if (geometry.indices.length < 2 || geometry.indices.length % 3 !== 0) {\r\n            throw new DeveloperError('geometry.indices length must be greater than 0 and be a multiple of 3.');\r\n        }\r\n        if (geometry.primitiveType !== PrimitiveType.TRIANGLES) {\r\n            throw new DeveloperError('geometry.primitiveType must be PrimitiveType.TRIANGLES.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var indices = geometry.indices;\r\n        var attributes = geometry.attributes;\r\n        var vertices = attributes.position.values;\r\n        var numVertices = attributes.position.values.length / 3;\r\n        var numIndices = indices.length;\r\n        var normalsPerVertex = new Array(numVertices);\r\n        var normalsPerTriangle = new Array(numIndices / 3);\r\n        var normalIndices = new Array(numIndices);\r\n        var i;\r\n        for ( i = 0; i < numVertices; i++) {\r\n            normalsPerVertex[i] = {\r\n                indexOffset : 0,\r\n                count : 0,\r\n                currentCount : 0\r\n            };\r\n        }\r\n\r\n        var j = 0;\r\n        for (i = 0; i < numIndices; i += 3) {\r\n            var i0 = indices[i];\r\n            var i1 = indices[i + 1];\r\n            var i2 = indices[i + 2];\r\n            var i03 = i0 * 3;\r\n            var i13 = i1 * 3;\r\n            var i23 = i2 * 3;\r\n\r\n            v0.x = vertices[i03];\r\n            v0.y = vertices[i03 + 1];\r\n            v0.z = vertices[i03 + 2];\r\n            v1.x = vertices[i13];\r\n            v1.y = vertices[i13 + 1];\r\n            v1.z = vertices[i13 + 2];\r\n            v2.x = vertices[i23];\r\n            v2.y = vertices[i23 + 1];\r\n            v2.z = vertices[i23 + 2];\r\n\r\n            normalsPerVertex[i0].count++;\r\n            normalsPerVertex[i1].count++;\r\n            normalsPerVertex[i2].count++;\r\n\r\n            Cartesian3.subtract(v1, v0, v1);\r\n            Cartesian3.subtract(v2, v0, v2);\r\n            normalsPerTriangle[j] = Cartesian3.cross(v1, v2, new Cartesian3());\r\n            j++;\r\n        }\r\n\r\n        var indexOffset = 0;\r\n        for (i = 0; i < numVertices; i++) {\r\n            normalsPerVertex[i].indexOffset += indexOffset;\r\n            indexOffset += normalsPerVertex[i].count;\r\n        }\r\n\r\n        j = 0;\r\n        var vertexNormalData;\r\n        for (i = 0; i < numIndices; i += 3) {\r\n            vertexNormalData = normalsPerVertex[indices[i]];\r\n            var index = vertexNormalData.indexOffset + vertexNormalData.currentCount;\r\n            normalIndices[index] = j;\r\n            vertexNormalData.currentCount++;\r\n\r\n            vertexNormalData = normalsPerVertex[indices[i + 1]];\r\n            index = vertexNormalData.indexOffset + vertexNormalData.currentCount;\r\n            normalIndices[index] = j;\r\n            vertexNormalData.currentCount++;\r\n\r\n            vertexNormalData = normalsPerVertex[indices[i + 2]];\r\n            index = vertexNormalData.indexOffset + vertexNormalData.currentCount;\r\n            normalIndices[index] = j;\r\n            vertexNormalData.currentCount++;\r\n\r\n            j++;\r\n        }\r\n\r\n        var normalValues = new Float32Array(numVertices * 3);\r\n        for (i = 0; i < numVertices; i++) {\r\n            var i3 = i * 3;\r\n            vertexNormalData = normalsPerVertex[i];\r\n            Cartesian3.clone(Cartesian3.ZERO, normal);\r\n            if (vertexNormalData.count > 0) {\r\n                for (j = 0; j < vertexNormalData.count; j++) {\r\n                    Cartesian3.add(normal, normalsPerTriangle[normalIndices[vertexNormalData.indexOffset + j]], normal);\r\n                }\r\n\r\n                // We can run into an issue where a vertex is used with 2 primitives that have opposite winding order.\r\n                if (Cartesian3.equalsEpsilon(Cartesian3.ZERO, normal, CesiumMath.EPSILON10)) {\r\n                    Cartesian3.clone(normalsPerTriangle[normalIndices[vertexNormalData.indexOffset]], normal);\r\n                }\r\n            }\r\n\r\n            // We end up with a zero vector probably because of a degenerate triangle\r\n            if (Cartesian3.equalsEpsilon(Cartesian3.ZERO, normal, CesiumMath.EPSILON10)) {\r\n                // Default to (0,0,1)\r\n                normal.z = 1.0;\r\n            }\r\n\r\n            Cartesian3.normalize(normal, normal);\r\n            normalValues[i3] = normal.x;\r\n            normalValues[i3 + 1] = normal.y;\r\n            normalValues[i3 + 2] = normal.z;\r\n        }\r\n\r\n        geometry.attributes.normal = new GeometryAttribute({\r\n            componentDatatype : ComponentDatatype.FLOAT,\r\n            componentsPerAttribute : 3,\r\n            values : normalValues\r\n        });\r\n\r\n        return geometry;\r\n    };\r\n\r\n    var normalScratch = new Cartesian3();\r\n    var normalScale = new Cartesian3();\r\n    var tScratch = new Cartesian3();\r\n\r\n    /**\r\n     * Computes per-vertex tangents and bitangents for a geometry containing <code>TRIANGLES</code>.\r\n     * The result is new <code>tangent</code> and <code>bitangent</code> attributes added to the geometry.\r\n     * This assumes a counter-clockwise winding order.\r\n     * <p>\r\n     * Based on <a href=\"http://www.terathon.com/code/tangent.html\">Computing Tangent Space Basis Vectors\r\n     * for an Arbitrary Mesh</a> by Eric Lengyel.\r\n     * </p>\r\n     *\r\n     * @param {Geometry} geometry The geometry to modify.\r\n     * @returns {Geometry} The modified <code>geometry</code> argument with the computed <code>tangent</code> and <code>bitangent</code> attributes.\r\n     *\r\n     * @exception {DeveloperError} geometry.indices length must be greater than 0 and be a multiple of 3.\r\n     * @exception {DeveloperError} geometry.primitiveType must be {@link PrimitiveType.TRIANGLES}.\r\n     *\r\n     * @example\r\n     * Cesium.GeometryPipeline.computeTangentAndBiTangent(geometry);\r\n     */\r\n    GeometryPipeline.computeTangentAndBitangent = function(geometry) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(geometry)) {\r\n            throw new DeveloperError('geometry is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var attributes = geometry.attributes;\r\n        var indices = geometry.indices;\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(attributes.position) || !defined(attributes.position.values)) {\r\n            throw new DeveloperError('geometry.attributes.position.values is required.');\r\n        }\r\n        if (!defined(attributes.normal) || !defined(attributes.normal.values)) {\r\n            throw new DeveloperError('geometry.attributes.normal.values is required.');\r\n        }\r\n        if (!defined(attributes.st) || !defined(attributes.st.values)) {\r\n            throw new DeveloperError('geometry.attributes.st.values is required.');\r\n        }\r\n        if (!defined(indices)) {\r\n            throw new DeveloperError('geometry.indices is required.');\r\n        }\r\n        if (indices.length < 2 || indices.length % 3 !== 0) {\r\n            throw new DeveloperError('geometry.indices length must be greater than 0 and be a multiple of 3.');\r\n        }\r\n        if (geometry.primitiveType !== PrimitiveType.TRIANGLES) {\r\n            throw new DeveloperError('geometry.primitiveType must be PrimitiveType.TRIANGLES.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var vertices = geometry.attributes.position.values;\r\n        var normals = geometry.attributes.normal.values;\r\n        var st = geometry.attributes.st.values;\r\n\r\n        var numVertices = geometry.attributes.position.values.length / 3;\r\n        var numIndices = indices.length;\r\n        var tan1 = new Array(numVertices * 3);\r\n\r\n        var i;\r\n        for ( i = 0; i < tan1.length; i++) {\r\n            tan1[i] = 0;\r\n        }\r\n\r\n        var i03;\r\n        var i13;\r\n        var i23;\r\n        for (i = 0; i < numIndices; i += 3) {\r\n            var i0 = indices[i];\r\n            var i1 = indices[i + 1];\r\n            var i2 = indices[i + 2];\r\n            i03 = i0 * 3;\r\n            i13 = i1 * 3;\r\n            i23 = i2 * 3;\r\n            var i02 = i0 * 2;\r\n            var i12 = i1 * 2;\r\n            var i22 = i2 * 2;\r\n\r\n            var ux = vertices[i03];\r\n            var uy = vertices[i03 + 1];\r\n            var uz = vertices[i03 + 2];\r\n\r\n            var wx = st[i02];\r\n            var wy = st[i02 + 1];\r\n            var t1 = st[i12 + 1] - wy;\r\n            var t2 = st[i22 + 1] - wy;\r\n\r\n            var r = 1.0 / ((st[i12] - wx) * t2 - (st[i22] - wx) * t1);\r\n            var sdirx = (t2 * (vertices[i13] - ux) - t1 * (vertices[i23] - ux)) * r;\r\n            var sdiry = (t2 * (vertices[i13 + 1] - uy) - t1 * (vertices[i23 + 1] - uy)) * r;\r\n            var sdirz = (t2 * (vertices[i13 + 2] - uz) - t1 * (vertices[i23 + 2] - uz)) * r;\r\n\r\n            tan1[i03] += sdirx;\r\n            tan1[i03 + 1] += sdiry;\r\n            tan1[i03 + 2] += sdirz;\r\n\r\n            tan1[i13] += sdirx;\r\n            tan1[i13 + 1] += sdiry;\r\n            tan1[i13 + 2] += sdirz;\r\n\r\n            tan1[i23] += sdirx;\r\n            tan1[i23 + 1] += sdiry;\r\n            tan1[i23 + 2] += sdirz;\r\n        }\r\n\r\n        var tangentValues = new Float32Array(numVertices * 3);\r\n        var bitangentValues = new Float32Array(numVertices * 3);\r\n\r\n        for (i = 0; i < numVertices; i++) {\r\n            i03 = i * 3;\r\n            i13 = i03 + 1;\r\n            i23 = i03 + 2;\r\n\r\n            var n = Cartesian3.fromArray(normals, i03, normalScratch);\r\n            var t = Cartesian3.fromArray(tan1, i03, tScratch);\r\n            var scalar = Cartesian3.dot(n, t);\r\n            Cartesian3.multiplyByScalar(n, scalar, normalScale);\r\n            Cartesian3.normalize(Cartesian3.subtract(t, normalScale, t), t);\r\n\r\n            tangentValues[i03] = t.x;\r\n            tangentValues[i13] = t.y;\r\n            tangentValues[i23] = t.z;\r\n\r\n            Cartesian3.normalize(Cartesian3.cross(n, t, t), t);\r\n\r\n            bitangentValues[i03] = t.x;\r\n            bitangentValues[i13] = t.y;\r\n            bitangentValues[i23] = t.z;\r\n        }\r\n\r\n        geometry.attributes.tangent = new GeometryAttribute({\r\n            componentDatatype : ComponentDatatype.FLOAT,\r\n            componentsPerAttribute : 3,\r\n            values : tangentValues\r\n        });\r\n\r\n        geometry.attributes.bitangent = new GeometryAttribute({\r\n            componentDatatype : ComponentDatatype.FLOAT,\r\n            componentsPerAttribute : 3,\r\n            values : bitangentValues\r\n        });\r\n\r\n        return geometry;\r\n    };\r\n\r\n    var scratchCartesian2 = new Cartesian2();\r\n    var toEncode1 = new Cartesian3();\r\n    var toEncode2 = new Cartesian3();\r\n    var toEncode3 = new Cartesian3();\r\n    var encodeResult2 = new Cartesian2();\r\n    /**\r\n     * Compresses and packs geometry normal attribute values to save memory.\r\n     *\r\n     * @param {Geometry} geometry The geometry to modify.\r\n     * @returns {Geometry} The modified <code>geometry</code> argument, with its normals compressed and packed.\r\n     *\r\n     * @example\r\n     * geometry = Cesium.GeometryPipeline.compressVertices(geometry);\r\n     */\r\n    GeometryPipeline.compressVertices = function(geometry) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(geometry)) {\r\n            throw new DeveloperError('geometry is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var extrudeAttribute = geometry.attributes.extrudeDirection;\r\n        var i;\r\n        var numVertices;\r\n        if (defined(extrudeAttribute)) {\r\n            //only shadow volumes use extrudeDirection, and shadow volumes use vertexFormat: POSITION_ONLY so we don't need to check other attributes\r\n            var extrudeDirections = extrudeAttribute.values;\r\n            numVertices = extrudeDirections.length / 3.0;\r\n            var compressedDirections = new Float32Array(numVertices * 2);\r\n\r\n            var i2 = 0;\r\n            for (i = 0; i < numVertices; ++i) {\r\n                Cartesian3.fromArray(extrudeDirections, i * 3.0, toEncode1);\r\n                if (Cartesian3.equals(toEncode1, Cartesian3.ZERO)) {\r\n                    i2 += 2;\r\n                    continue;\r\n                }\r\n                encodeResult2 = AttributeCompression.octEncodeInRange(toEncode1, 65535, encodeResult2);\r\n                compressedDirections[i2++] = encodeResult2.x;\r\n                compressedDirections[i2++] = encodeResult2.y;\r\n            }\r\n\r\n            geometry.attributes.compressedAttributes = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.FLOAT,\r\n                componentsPerAttribute : 2,\r\n                values : compressedDirections\r\n            });\r\n            delete geometry.attributes.extrudeDirection;\r\n            return geometry;\r\n        }\r\n\r\n        var normalAttribute = geometry.attributes.normal;\r\n        var stAttribute = geometry.attributes.st;\r\n\r\n        var hasNormal = defined(normalAttribute);\r\n        var hasSt = defined(stAttribute);\r\n        if (!hasNormal && !hasSt) {\r\n            return geometry;\r\n        }\r\n\r\n        var tangentAttribute = geometry.attributes.tangent;\r\n        var bitangentAttribute = geometry.attributes.bitangent;\r\n\r\n        var hasTangent = defined(tangentAttribute);\r\n        var hasBitangent = defined(bitangentAttribute);\r\n\r\n        var normals;\r\n        var st;\r\n        var tangents;\r\n        var bitangents;\r\n\r\n        if (hasNormal) {\r\n            normals = normalAttribute.values;\r\n        }\r\n        if (hasSt) {\r\n            st = stAttribute.values;\r\n        }\r\n        if (hasTangent) {\r\n            tangents = tangentAttribute.values;\r\n        }\r\n        if (hasBitangent) {\r\n            bitangents = bitangentAttribute.values;\r\n        }\r\n\r\n        var length = hasNormal ? normals.length : st.length;\r\n        var numComponents = hasNormal ? 3.0 : 2.0;\r\n        numVertices = length / numComponents;\r\n\r\n        var compressedLength = numVertices;\r\n        var numCompressedComponents = hasSt && hasNormal ? 2.0 : 1.0;\r\n        numCompressedComponents += hasTangent || hasBitangent ? 1.0 : 0.0;\r\n        compressedLength *= numCompressedComponents;\r\n\r\n        var compressedAttributes = new Float32Array(compressedLength);\r\n\r\n        var normalIndex = 0;\r\n        for (i = 0; i < numVertices; ++i) {\r\n            if (hasSt) {\r\n                Cartesian2.fromArray(st, i * 2.0, scratchCartesian2);\r\n                compressedAttributes[normalIndex++] = AttributeCompression.compressTextureCoordinates(scratchCartesian2);\r\n            }\r\n\r\n            var index = i * 3.0;\r\n            if (hasNormal && defined(tangents) && defined(bitangents)) {\r\n                Cartesian3.fromArray(normals, index, toEncode1);\r\n                Cartesian3.fromArray(tangents, index, toEncode2);\r\n                Cartesian3.fromArray(bitangents, index, toEncode3);\r\n\r\n                AttributeCompression.octPack(toEncode1, toEncode2, toEncode3, scratchCartesian2);\r\n                compressedAttributes[normalIndex++] = scratchCartesian2.x;\r\n                compressedAttributes[normalIndex++] = scratchCartesian2.y;\r\n            } else {\r\n                if (hasNormal) {\r\n                    Cartesian3.fromArray(normals, index, toEncode1);\r\n                    compressedAttributes[normalIndex++] = AttributeCompression.octEncodeFloat(toEncode1);\r\n                }\r\n\r\n                if (hasTangent) {\r\n                    Cartesian3.fromArray(tangents, index, toEncode1);\r\n                    compressedAttributes[normalIndex++] = AttributeCompression.octEncodeFloat(toEncode1);\r\n                }\r\n\r\n                if (hasBitangent) {\r\n                    Cartesian3.fromArray(bitangents, index, toEncode1);\r\n                    compressedAttributes[normalIndex++] = AttributeCompression.octEncodeFloat(toEncode1);\r\n                }\r\n            }\r\n        }\r\n\r\n        geometry.attributes.compressedAttributes = new GeometryAttribute({\r\n            componentDatatype : ComponentDatatype.FLOAT,\r\n            componentsPerAttribute : numCompressedComponents,\r\n            values : compressedAttributes\r\n        });\r\n\r\n        if (hasNormal) {\r\n            delete geometry.attributes.normal;\r\n        }\r\n        if (hasSt) {\r\n            delete geometry.attributes.st;\r\n        }\r\n        if (hasBitangent) {\r\n            delete geometry.attributes.bitangent;\r\n        }\r\n        if (hasTangent) {\r\n            delete geometry.attributes.tangent;\r\n        }\r\n\r\n        return geometry;\r\n    };\r\n\r\n    function indexTriangles(geometry) {\r\n        if (defined(geometry.indices)) {\r\n            return geometry;\r\n        }\r\n        var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (numberOfVertices < 3) {\r\n            throw new DeveloperError('The number of vertices must be at least three.');\r\n        }\r\n        if (numberOfVertices % 3 !== 0) {\r\n            throw new DeveloperError('The number of vertices must be a multiple of three.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var indices = IndexDatatype.createTypedArray(numberOfVertices, numberOfVertices);\r\n        for (var i = 0; i < numberOfVertices; ++i) {\r\n            indices[i] = i;\r\n        }\r\n\r\n        geometry.indices = indices;\r\n        return geometry;\r\n    }\r\n\r\n    function indexTriangleFan(geometry) {\r\n        var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (numberOfVertices < 3) {\r\n            throw new DeveloperError('The number of vertices must be at least three.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var indices = IndexDatatype.createTypedArray(numberOfVertices, (numberOfVertices - 2) * 3);\r\n        indices[0] = 1;\r\n        indices[1] = 0;\r\n        indices[2] = 2;\r\n\r\n        var indicesIndex = 3;\r\n        for (var i = 3; i < numberOfVertices; ++i) {\r\n            indices[indicesIndex++] = i - 1;\r\n            indices[indicesIndex++] = 0;\r\n            indices[indicesIndex++] = i;\r\n        }\r\n\r\n        geometry.indices = indices;\r\n        geometry.primitiveType = PrimitiveType.TRIANGLES;\r\n        return geometry;\r\n    }\r\n\r\n    function indexTriangleStrip(geometry) {\r\n        var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (numberOfVertices < 3) {\r\n            throw new DeveloperError('The number of vertices must be at least 3.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var indices = IndexDatatype.createTypedArray(numberOfVertices, (numberOfVertices - 2) * 3);\r\n        indices[0] = 0;\r\n        indices[1] = 1;\r\n        indices[2] = 2;\r\n\r\n        if (numberOfVertices > 3) {\r\n            indices[3] = 0;\r\n            indices[4] = 2;\r\n            indices[5] = 3;\r\n        }\r\n\r\n        var indicesIndex = 6;\r\n        for (var i = 3; i < numberOfVertices - 1; i += 2) {\r\n            indices[indicesIndex++] = i;\r\n            indices[indicesIndex++] = i - 1;\r\n            indices[indicesIndex++] = i + 1;\r\n\r\n            if (i + 2 < numberOfVertices) {\r\n                indices[indicesIndex++] = i;\r\n                indices[indicesIndex++] = i + 1;\r\n                indices[indicesIndex++] = i + 2;\r\n            }\r\n        }\r\n\r\n        geometry.indices = indices;\r\n        geometry.primitiveType = PrimitiveType.TRIANGLES;\r\n        return geometry;\r\n    }\r\n\r\n    function indexLines(geometry) {\r\n        if (defined(geometry.indices)) {\r\n            return geometry;\r\n        }\r\n        var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (numberOfVertices < 2) {\r\n            throw new DeveloperError('The number of vertices must be at least two.');\r\n        }\r\n        if (numberOfVertices % 2 !== 0) {\r\n            throw new DeveloperError('The number of vertices must be a multiple of 2.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var indices = IndexDatatype.createTypedArray(numberOfVertices, numberOfVertices);\r\n        for (var i = 0; i < numberOfVertices; ++i) {\r\n            indices[i] = i;\r\n        }\r\n\r\n        geometry.indices = indices;\r\n        return geometry;\r\n    }\r\n\r\n    function indexLineStrip(geometry) {\r\n        var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (numberOfVertices < 2) {\r\n            throw new DeveloperError('The number of vertices must be at least two.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var indices = IndexDatatype.createTypedArray(numberOfVertices, (numberOfVertices - 1) * 2);\r\n        indices[0] = 0;\r\n        indices[1] = 1;\r\n        var indicesIndex = 2;\r\n        for (var i = 2; i < numberOfVertices; ++i) {\r\n            indices[indicesIndex++] = i - 1;\r\n            indices[indicesIndex++] = i;\r\n        }\r\n\r\n        geometry.indices = indices;\r\n        geometry.primitiveType = PrimitiveType.LINES;\r\n        return geometry;\r\n    }\r\n\r\n    function indexLineLoop(geometry) {\r\n        var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (numberOfVertices < 2) {\r\n            throw new DeveloperError('The number of vertices must be at least two.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var indices = IndexDatatype.createTypedArray(numberOfVertices, numberOfVertices * 2);\r\n\r\n        indices[0] = 0;\r\n        indices[1] = 1;\r\n\r\n        var indicesIndex = 2;\r\n        for (var i = 2; i < numberOfVertices; ++i) {\r\n            indices[indicesIndex++] = i - 1;\r\n            indices[indicesIndex++] = i;\r\n        }\r\n\r\n        indices[indicesIndex++] = numberOfVertices - 1;\r\n        indices[indicesIndex] = 0;\r\n\r\n        geometry.indices = indices;\r\n        geometry.primitiveType = PrimitiveType.LINES;\r\n        return geometry;\r\n    }\r\n\r\n    function indexPrimitive(geometry) {\r\n        switch (geometry.primitiveType) {\r\n        case PrimitiveType.TRIANGLE_FAN:\r\n            return indexTriangleFan(geometry);\r\n        case PrimitiveType.TRIANGLE_STRIP:\r\n            return indexTriangleStrip(geometry);\r\n        case PrimitiveType.TRIANGLES:\r\n            return indexTriangles(geometry);\r\n        case PrimitiveType.LINE_STRIP:\r\n            return indexLineStrip(geometry);\r\n        case PrimitiveType.LINE_LOOP:\r\n            return indexLineLoop(geometry);\r\n        case PrimitiveType.LINES:\r\n            return indexLines(geometry);\r\n        }\r\n\r\n        return geometry;\r\n    }\r\n\r\n    function offsetPointFromXZPlane(p, isBehind) {\r\n        if (Math.abs(p.y) < CesiumMath.EPSILON6){\r\n            if (isBehind) {\r\n                p.y = -CesiumMath.EPSILON6;\r\n            } else {\r\n                p.y = CesiumMath.EPSILON6;\r\n            }\r\n        }\r\n    }\r\n\r\n    function offsetTriangleFromXZPlane(p0, p1, p2) {\r\n        if (p0.y !== 0.0 && p1.y !== 0.0 && p2.y !== 0.0) {\r\n            offsetPointFromXZPlane(p0, p0.y < 0.0);\r\n            offsetPointFromXZPlane(p1, p1.y < 0.0);\r\n            offsetPointFromXZPlane(p2, p2.y < 0.0);\r\n            return;\r\n        }\r\n\r\n        var p0y = Math.abs(p0.y);\r\n        var p1y = Math.abs(p1.y);\r\n        var p2y = Math.abs(p2.y);\r\n\r\n        var sign;\r\n        if (p0y > p1y) {\r\n            if (p0y > p2y) {\r\n                sign = CesiumMath.sign(p0.y);\r\n            } else {\r\n                sign = CesiumMath.sign(p2.y);\r\n            }\r\n        } else if (p1y > p2y) {\r\n            sign = CesiumMath.sign(p1.y);\r\n        } else {\r\n            sign = CesiumMath.sign(p2.y);\r\n        }\r\n\r\n        var isBehind = sign < 0.0;\r\n        offsetPointFromXZPlane(p0, isBehind);\r\n        offsetPointFromXZPlane(p1, isBehind);\r\n        offsetPointFromXZPlane(p2, isBehind);\r\n    }\r\n\r\n    var c3 = new Cartesian3();\r\n    function getXZIntersectionOffsetPoints(p, p1, u1, v1) {\r\n        Cartesian3.add(p, Cartesian3.multiplyByScalar(Cartesian3.subtract(p1, p, c3), p.y/(p.y-p1.y), c3), u1);\r\n        Cartesian3.clone(u1, v1);\r\n        offsetPointFromXZPlane(u1, true);\r\n        offsetPointFromXZPlane(v1, false);\r\n    }\r\n\r\n    var u1 = new Cartesian3();\r\n    var u2 = new Cartesian3();\r\n    var q1 = new Cartesian3();\r\n    var q2 = new Cartesian3();\r\n\r\n    var splitTriangleResult = {\r\n        positions : new Array(7),\r\n        indices : new Array(3 * 3)\r\n    };\r\n\r\n    function splitTriangle(p0, p1, p2) {\r\n        // In WGS84 coordinates, for a triangle approximately on the\r\n        // ellipsoid to cross the IDL, first it needs to be on the\r\n        // negative side of the plane x = 0.\r\n        if ((p0.x >= 0.0) || (p1.x >= 0.0) || (p2.x >= 0.0)) {\r\n            return undefined;\r\n        }\r\n\r\n        offsetTriangleFromXZPlane(p0, p1, p2);\r\n\r\n        var p0Behind = p0.y < 0.0;\r\n        var p1Behind = p1.y < 0.0;\r\n        var p2Behind = p2.y < 0.0;\r\n\r\n        var numBehind = 0;\r\n        numBehind += p0Behind ? 1 : 0;\r\n        numBehind += p1Behind ? 1 : 0;\r\n        numBehind += p2Behind ? 1 : 0;\r\n\r\n        var indices = splitTriangleResult.indices;\r\n\r\n        if (numBehind === 1) {\r\n            indices[1] = 3;\r\n            indices[2] = 4;\r\n            indices[5] = 6;\r\n            indices[7] = 6;\r\n            indices[8] = 5;\r\n\r\n            if (p0Behind) {\r\n                getXZIntersectionOffsetPoints(p0, p1, u1, q1);\r\n                getXZIntersectionOffsetPoints(p0, p2, u2, q2);\r\n\r\n                indices[0] = 0;\r\n                indices[3] = 1;\r\n                indices[4] = 2;\r\n                indices[6] = 1;\r\n            } else if (p1Behind) {\r\n                getXZIntersectionOffsetPoints(p1, p2, u1, q1);\r\n                getXZIntersectionOffsetPoints(p1, p0, u2, q2);\r\n\r\n                indices[0] = 1;\r\n                indices[3] = 2;\r\n                indices[4] = 0;\r\n                indices[6] = 2;\r\n            } else if (p2Behind) {\r\n                getXZIntersectionOffsetPoints(p2, p0, u1, q1);\r\n                getXZIntersectionOffsetPoints(p2, p1, u2, q2);\r\n\r\n                indices[0] = 2;\r\n                indices[3] = 0;\r\n                indices[4] = 1;\r\n                indices[6] = 0;\r\n            }\r\n        } else if (numBehind === 2) {\r\n            indices[2] = 4;\r\n            indices[4] = 4;\r\n            indices[5] = 3;\r\n            indices[7] = 5;\r\n            indices[8] = 6;\r\n\r\n            if (!p0Behind) {\r\n                getXZIntersectionOffsetPoints(p0, p1, u1, q1);\r\n                getXZIntersectionOffsetPoints(p0, p2, u2, q2);\r\n\r\n                indices[0] = 1;\r\n                indices[1] = 2;\r\n                indices[3] = 1;\r\n                indices[6] = 0;\r\n            } else if (!p1Behind) {\r\n                getXZIntersectionOffsetPoints(p1, p2, u1, q1);\r\n                getXZIntersectionOffsetPoints(p1, p0, u2, q2);\r\n\r\n                indices[0] = 2;\r\n                indices[1] = 0;\r\n                indices[3] = 2;\r\n                indices[6] = 1;\r\n            } else if (!p2Behind) {\r\n                getXZIntersectionOffsetPoints(p2, p0, u1, q1);\r\n                getXZIntersectionOffsetPoints(p2, p1, u2, q2);\r\n\r\n                indices[0] = 0;\r\n                indices[1] = 1;\r\n                indices[3] = 0;\r\n                indices[6] = 2;\r\n            }\r\n        }\r\n\r\n        var positions = splitTriangleResult.positions;\r\n        positions[0] = p0;\r\n        positions[1] = p1;\r\n        positions[2] = p2;\r\n        positions.length = 3;\r\n\r\n        if (numBehind === 1 || numBehind === 2) {\r\n            positions[3] = u1;\r\n            positions[4] = u2;\r\n            positions[5] = q1;\r\n            positions[6] = q2;\r\n            positions.length = 7;\r\n        }\r\n\r\n        return splitTriangleResult;\r\n    }\r\n\r\n    function updateGeometryAfterSplit(geometry, computeBoundingSphere) {\r\n        var attributes = geometry.attributes;\r\n\r\n        if (attributes.position.values.length === 0) {\r\n            return undefined;\r\n        }\r\n\r\n        for (var property in attributes) {\r\n            if (attributes.hasOwnProperty(property) &&\r\n                    defined(attributes[property]) &&\r\n                    defined(attributes[property].values)) {\r\n\r\n                var attribute = attributes[property];\r\n                attribute.values = ComponentDatatype.createTypedArray(attribute.componentDatatype, attribute.values);\r\n            }\r\n        }\r\n\r\n        var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\r\n        geometry.indices = IndexDatatype.createTypedArray(numberOfVertices, geometry.indices);\r\n\r\n        if (computeBoundingSphere) {\r\n            geometry.boundingSphere = BoundingSphere.fromVertices(attributes.position.values);\r\n        }\r\n\r\n        return geometry;\r\n    }\r\n\r\n    function copyGeometryForSplit(geometry) {\r\n        var attributes = geometry.attributes;\r\n        var copiedAttributes = {};\r\n\r\n        for (var property in attributes) {\r\n            if (attributes.hasOwnProperty(property) &&\r\n                    defined(attributes[property]) &&\r\n                    defined(attributes[property].values)) {\r\n\r\n                var attribute = attributes[property];\r\n                copiedAttributes[property] = new GeometryAttribute({\r\n                    componentDatatype : attribute.componentDatatype,\r\n                    componentsPerAttribute : attribute.componentsPerAttribute,\r\n                    normalize : attribute.normalize,\r\n                    values : []\r\n                });\r\n            }\r\n        }\r\n\r\n        return new Geometry({\r\n            attributes : copiedAttributes,\r\n            indices : [],\r\n            primitiveType : geometry.primitiveType\r\n        });\r\n    }\r\n\r\n    function updateInstanceAfterSplit(instance, westGeometry, eastGeometry) {\r\n        var computeBoundingSphere = defined(instance.geometry.boundingSphere);\r\n\r\n        westGeometry = updateGeometryAfterSplit(westGeometry, computeBoundingSphere);\r\n        eastGeometry = updateGeometryAfterSplit(eastGeometry, computeBoundingSphere);\r\n\r\n        if (defined(eastGeometry) && !defined(westGeometry)) {\r\n            instance.geometry = eastGeometry;\r\n        } else if (!defined(eastGeometry) && defined(westGeometry)) {\r\n            instance.geometry = westGeometry;\r\n        } else {\r\n            instance.westHemisphereGeometry = westGeometry;\r\n            instance.eastHemisphereGeometry = eastGeometry;\r\n            instance.geometry = undefined;\r\n        }\r\n    }\r\n\r\n    function generateBarycentricInterpolateFunction(CartesianType, numberOfComponents) {\r\n        var v0Scratch = new CartesianType();\r\n        var v1Scratch = new CartesianType();\r\n        var v2Scratch = new CartesianType();\r\n\r\n        return function(i0, i1, i2, coords, sourceValues, currentValues, insertedIndex, normalize) {\r\n            var v0 = CartesianType.fromArray(sourceValues, i0 * numberOfComponents, v0Scratch);\r\n            var v1 = CartesianType.fromArray(sourceValues, i1 * numberOfComponents, v1Scratch);\r\n            var v2 = CartesianType.fromArray(sourceValues, i2 * numberOfComponents, v2Scratch);\r\n\r\n            CartesianType.multiplyByScalar(v0, coords.x, v0);\r\n            CartesianType.multiplyByScalar(v1, coords.y, v1);\r\n            CartesianType.multiplyByScalar(v2, coords.z, v2);\r\n\r\n            var value = CartesianType.add(v0, v1, v0);\r\n            CartesianType.add(value, v2, value);\r\n\r\n            if (normalize) {\r\n                CartesianType.normalize(value, value);\r\n            }\r\n\r\n            CartesianType.pack(value, currentValues, insertedIndex * numberOfComponents);\r\n        };\r\n    }\r\n\r\n    var interpolateAndPackCartesian4 = generateBarycentricInterpolateFunction(Cartesian4, 4);\r\n    var interpolateAndPackCartesian3 = generateBarycentricInterpolateFunction(Cartesian3, 3);\r\n    var interpolateAndPackCartesian2 = generateBarycentricInterpolateFunction(Cartesian2, 2);\r\n    var interpolateAndPackBoolean = function(i0, i1, i2, coords, sourceValues, currentValues, insertedIndex) {\r\n        var v1 = sourceValues[i0] * coords.x;\r\n        var v2 = sourceValues[i1] * coords.y;\r\n        var v3 = sourceValues[i2] * coords.z;\r\n        currentValues[insertedIndex] = (v1 + v2 + v3) > CesiumMath.EPSILON6 ? 1 : 0;\r\n    };\r\n\r\n    var p0Scratch = new Cartesian3();\r\n    var p1Scratch = new Cartesian3();\r\n    var p2Scratch = new Cartesian3();\r\n    var barycentricScratch = new Cartesian3();\r\n\r\n    function computeTriangleAttributes(i0, i1, i2, point, positions, normals, tangents, bitangents, texCoords, extrudeDirections, applyOffset, currentAttributes, customAttributeNames, customAttributesLength, allAttributes, insertedIndex) {\r\n        if (!defined(normals) && !defined(tangents) && !defined(bitangents) && !defined(texCoords) && !defined(extrudeDirections) && customAttributesLength === 0) {\r\n            return;\r\n        }\r\n\r\n        var p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);\r\n        var p1 = Cartesian3.fromArray(positions, i1 * 3, p1Scratch);\r\n        var p2 = Cartesian3.fromArray(positions, i2 * 3, p2Scratch);\r\n        var coords = barycentricCoordinates(point, p0, p1, p2, barycentricScratch);\r\n\r\n        if (defined(normals)) {\r\n            interpolateAndPackCartesian3(i0, i1, i2, coords, normals, currentAttributes.normal.values, insertedIndex, true);\r\n        }\r\n\r\n        if (defined(extrudeDirections)) {\r\n            var d0 = Cartesian3.fromArray(extrudeDirections, i0 * 3, p0Scratch);\r\n            var d1 = Cartesian3.fromArray(extrudeDirections, i1 * 3, p1Scratch);\r\n            var d2 = Cartesian3.fromArray(extrudeDirections, i2 * 3, p2Scratch);\r\n\r\n            Cartesian3.multiplyByScalar(d0, coords.x, d0);\r\n            Cartesian3.multiplyByScalar(d1, coords.y, d1);\r\n            Cartesian3.multiplyByScalar(d2, coords.z, d2);\r\n\r\n            var direction;\r\n            if (!Cartesian3.equals(d0, Cartesian3.ZERO) || !Cartesian3.equals(d1, Cartesian3.ZERO) || !Cartesian3.equals(d2, Cartesian3.ZERO)) {\r\n                direction = Cartesian3.add(d0, d1, d0);\r\n                Cartesian3.add(direction, d2, direction);\r\n                Cartesian3.normalize(direction, direction);\r\n            } else {\r\n                direction = p0Scratch;\r\n                direction.x = 0;\r\n                direction.y = 0;\r\n                direction.z = 0;\r\n            }\r\n            Cartesian3.pack(direction, currentAttributes.extrudeDirection.values, insertedIndex * 3);\r\n        }\r\n\r\n        if (defined(applyOffset)) {\r\n            interpolateAndPackBoolean(i0, i1, i2, coords, applyOffset, currentAttributes.applyOffset.values, insertedIndex);\r\n        }\r\n\r\n        if (defined(tangents)) {\r\n            interpolateAndPackCartesian3(i0, i1, i2, coords, tangents, currentAttributes.tangent.values, insertedIndex, true);\r\n        }\r\n\r\n        if (defined(bitangents)) {\r\n            interpolateAndPackCartesian3(i0, i1, i2, coords, bitangents, currentAttributes.bitangent.values, insertedIndex, true);\r\n        }\r\n\r\n        if (defined(texCoords)) {\r\n            interpolateAndPackCartesian2(i0, i1, i2, coords, texCoords, currentAttributes.st.values, insertedIndex);\r\n        }\r\n\r\n        if (customAttributesLength > 0) {\r\n            for (var i = 0; i < customAttributesLength; i++) {\r\n                var attributeName = customAttributeNames[i];\r\n                genericInterpolate(i0, i1, i2, coords, insertedIndex, allAttributes[attributeName], currentAttributes[attributeName]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function genericInterpolate(i0, i1, i2, coords, insertedIndex, sourceAttribute, currentAttribute) {\r\n        var componentsPerAttribute = sourceAttribute.componentsPerAttribute;\r\n        var sourceValues = sourceAttribute.values;\r\n        var currentValues = currentAttribute.values;\r\n        switch(componentsPerAttribute) {\r\n            case 4:\r\n                interpolateAndPackCartesian4(i0, i1, i2, coords, sourceValues, currentValues, insertedIndex, false);\r\n                break;\r\n            case 3:\r\n                interpolateAndPackCartesian3(i0, i1, i2, coords, sourceValues, currentValues, insertedIndex, false);\r\n                break;\r\n            case 2:\r\n                interpolateAndPackCartesian2(i0, i1, i2, coords, sourceValues, currentValues, insertedIndex, false);\r\n                break;\r\n            default:\r\n                currentValues[insertedIndex] = sourceValues[i0] * coords.x + sourceValues[i1] * coords.y + sourceValues[i2] * coords.z;\r\n        }\r\n    }\r\n\r\n    function insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, currentIndex, point) {\r\n        var insertIndex = currentAttributes.position.values.length / 3;\r\n\r\n        if (currentIndex !== -1) {\r\n            var prevIndex = indices[currentIndex];\r\n            var newIndex = currentIndexMap[prevIndex];\r\n\r\n            if (newIndex === -1) {\r\n                currentIndexMap[prevIndex] = insertIndex;\r\n                currentAttributes.position.values.push(point.x, point.y, point.z);\r\n                currentIndices.push(insertIndex);\r\n                return insertIndex;\r\n            }\r\n\r\n            currentIndices.push(newIndex);\r\n            return newIndex;\r\n        }\r\n\r\n        currentAttributes.position.values.push(point.x, point.y, point.z);\r\n        currentIndices.push(insertIndex);\r\n        return insertIndex;\r\n    }\r\n\r\n    var NAMED_ATTRIBUTES = {\r\n        position : true,\r\n        normal : true,\r\n        bitangent : true,\r\n        tangent : true,\r\n        st : true,\r\n        extrudeDirection : true,\r\n        applyOffset: true\r\n    };\r\n    function splitLongitudeTriangles(instance) {\r\n        var geometry = instance.geometry;\r\n        var attributes = geometry.attributes;\r\n        var positions = attributes.position.values;\r\n        var normals = (defined(attributes.normal)) ? attributes.normal.values : undefined;\r\n        var bitangents = (defined(attributes.bitangent)) ? attributes.bitangent.values : undefined;\r\n        var tangents = (defined(attributes.tangent)) ? attributes.tangent.values : undefined;\r\n        var texCoords = (defined(attributes.st)) ? attributes.st.values : undefined;\r\n        var extrudeDirections = (defined(attributes.extrudeDirection)) ? attributes.extrudeDirection.values : undefined;\r\n        var applyOffset = defined(attributes.applyOffset) ? attributes.applyOffset.values : undefined;\r\n        var indices = geometry.indices;\r\n\r\n        var customAttributeNames = [];\r\n        for (var attributeName in attributes) {\r\n            if (attributes.hasOwnProperty(attributeName) && !NAMED_ATTRIBUTES[attributeName] && defined(attributes[attributeName])) {\r\n                customAttributeNames.push(attributeName);\r\n            }\r\n        }\r\n        var customAttributesLength = customAttributeNames.length;\r\n\r\n        var eastGeometry = copyGeometryForSplit(geometry);\r\n        var westGeometry = copyGeometryForSplit(geometry);\r\n\r\n        var currentAttributes;\r\n        var currentIndices;\r\n        var currentIndexMap;\r\n        var insertedIndex;\r\n        var i;\r\n\r\n        var westGeometryIndexMap = [];\r\n        westGeometryIndexMap.length = positions.length / 3;\r\n\r\n        var eastGeometryIndexMap = [];\r\n        eastGeometryIndexMap.length = positions.length / 3;\r\n\r\n        for (i = 0; i < westGeometryIndexMap.length; ++i) {\r\n            westGeometryIndexMap[i] = -1;\r\n            eastGeometryIndexMap[i] = -1;\r\n        }\r\n\r\n        var len = indices.length;\r\n        for (i = 0; i < len; i += 3) {\r\n            var i0 = indices[i];\r\n            var i1 = indices[i + 1];\r\n            var i2 = indices[i + 2];\r\n\r\n            var p0 = Cartesian3.fromArray(positions, i0 * 3);\r\n            var p1 = Cartesian3.fromArray(positions, i1 * 3);\r\n            var p2 = Cartesian3.fromArray(positions, i2 * 3);\r\n\r\n            var result = splitTriangle(p0, p1, p2);\r\n            if (defined(result) && result.positions.length > 3) {\r\n                var resultPositions = result.positions;\r\n                var resultIndices = result.indices;\r\n                var resultLength = resultIndices.length;\r\n\r\n                for (var j = 0; j < resultLength; ++j) {\r\n                    var resultIndex = resultIndices[j];\r\n                    var point = resultPositions[resultIndex];\r\n\r\n                    if (point.y < 0.0) {\r\n                        currentAttributes = westGeometry.attributes;\r\n                        currentIndices = westGeometry.indices;\r\n                        currentIndexMap = westGeometryIndexMap;\r\n                    } else {\r\n                        currentAttributes = eastGeometry.attributes;\r\n                        currentIndices = eastGeometry.indices;\r\n                        currentIndexMap = eastGeometryIndexMap;\r\n                    }\r\n\r\n                    insertedIndex = insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, resultIndex < 3 ? i + resultIndex : -1, point);\r\n                    computeTriangleAttributes(i0, i1, i2, point, positions, normals, tangents, bitangents, texCoords, extrudeDirections, applyOffset, currentAttributes, customAttributeNames, customAttributesLength, attributes, insertedIndex);\r\n                }\r\n            } else {\r\n                if (defined(result)) {\r\n                    p0 = result.positions[0];\r\n                    p1 = result.positions[1];\r\n                    p2 = result.positions[2];\r\n                }\r\n\r\n                if (p0.y < 0.0) {\r\n                    currentAttributes = westGeometry.attributes;\r\n                    currentIndices = westGeometry.indices;\r\n                    currentIndexMap = westGeometryIndexMap;\r\n                } else {\r\n                    currentAttributes = eastGeometry.attributes;\r\n                    currentIndices = eastGeometry.indices;\r\n                    currentIndexMap = eastGeometryIndexMap;\r\n                }\r\n\r\n                insertedIndex = insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, i, p0);\r\n                computeTriangleAttributes(i0, i1, i2, p0, positions, normals, tangents, bitangents, texCoords, extrudeDirections, applyOffset, currentAttributes, customAttributeNames, customAttributesLength, attributes, insertedIndex);\r\n\r\n                insertedIndex = insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, i + 1, p1);\r\n                computeTriangleAttributes(i0, i1, i2, p1, positions, normals, tangents, bitangents, texCoords, extrudeDirections, applyOffset, currentAttributes, customAttributeNames, customAttributesLength, attributes, insertedIndex);\r\n\r\n                insertedIndex = insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, i + 2, p2);\r\n                computeTriangleAttributes(i0, i1, i2, p2, positions, normals, tangents, bitangents, texCoords, extrudeDirections, applyOffset, currentAttributes, customAttributeNames, customAttributesLength, attributes, insertedIndex);\r\n            }\r\n        }\r\n\r\n        updateInstanceAfterSplit(instance, westGeometry, eastGeometry);\r\n    }\r\n\r\n    var xzPlane = Plane.fromPointNormal(Cartesian3.ZERO, Cartesian3.UNIT_Y);\r\n\r\n    var offsetScratch = new Cartesian3();\r\n    var offsetPointScratch = new Cartesian3();\r\n\r\n    function computeLineAttributes(i0, i1, point, positions, insertIndex, currentAttributes, applyOffset) {\r\n        if (!defined(applyOffset)) {\r\n            return;\r\n        }\r\n\r\n        var p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);\r\n        if (Cartesian3.equalsEpsilon(p0, point, CesiumMath.EPSILON10)) {\r\n            currentAttributes.applyOffset.values[insertIndex] = applyOffset[i0];\r\n        } else {\r\n            currentAttributes.applyOffset.values[insertIndex] = applyOffset[i1];\r\n        }\r\n\r\n    }\r\n\r\n    function splitLongitudeLines(instance) {\r\n        var geometry = instance.geometry;\r\n        var attributes = geometry.attributes;\r\n        var positions = attributes.position.values;\r\n        var applyOffset = defined(attributes.applyOffset) ? attributes.applyOffset.values : undefined;\r\n        var indices = geometry.indices;\r\n\r\n        var eastGeometry = copyGeometryForSplit(geometry);\r\n        var westGeometry = copyGeometryForSplit(geometry);\r\n\r\n        var i;\r\n        var length = indices.length;\r\n\r\n        var westGeometryIndexMap = [];\r\n        westGeometryIndexMap.length = positions.length / 3;\r\n\r\n        var eastGeometryIndexMap = [];\r\n        eastGeometryIndexMap.length = positions.length / 3;\r\n\r\n        for (i = 0; i < westGeometryIndexMap.length; ++i) {\r\n            westGeometryIndexMap[i] = -1;\r\n            eastGeometryIndexMap[i] = -1;\r\n        }\r\n\r\n        for (i = 0; i < length; i += 2) {\r\n            var i0 = indices[i];\r\n            var i1 = indices[i + 1];\r\n\r\n            var p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);\r\n            var p1 = Cartesian3.fromArray(positions, i1 * 3, p1Scratch);\r\n            var insertIndex;\r\n\r\n            if (Math.abs(p0.y) < CesiumMath.EPSILON6){\r\n                if (p0.y < 0.0) {\r\n                    p0.y = -CesiumMath.EPSILON6;\r\n                } else {\r\n                    p0.y = CesiumMath.EPSILON6;\r\n                }\r\n            }\r\n\r\n            if (Math.abs(p1.y) < CesiumMath.EPSILON6){\r\n                if (p1.y < 0.0) {\r\n                    p1.y = -CesiumMath.EPSILON6;\r\n                } else {\r\n                    p1.y = CesiumMath.EPSILON6;\r\n                }\r\n            }\r\n\r\n            var p0Attributes = eastGeometry.attributes;\r\n            var p0Indices = eastGeometry.indices;\r\n            var p0IndexMap = eastGeometryIndexMap;\r\n            var p1Attributes = westGeometry.attributes;\r\n            var p1Indices = westGeometry.indices;\r\n            var p1IndexMap = westGeometryIndexMap;\r\n\r\n            var intersection = IntersectionTests.lineSegmentPlane(p0, p1, xzPlane, p2Scratch);\r\n            if (defined(intersection)) {\r\n                // move point on the xz-plane slightly away from the plane\r\n                var offset = Cartesian3.multiplyByScalar(Cartesian3.UNIT_Y, 5.0 * CesiumMath.EPSILON9, offsetScratch);\r\n                if (p0.y < 0.0) {\r\n                    Cartesian3.negate(offset, offset);\r\n\r\n                    p0Attributes = westGeometry.attributes;\r\n                    p0Indices = westGeometry.indices;\r\n                    p0IndexMap = westGeometryIndexMap;\r\n                    p1Attributes = eastGeometry.attributes;\r\n                    p1Indices = eastGeometry.indices;\r\n                    p1IndexMap = eastGeometryIndexMap;\r\n                }\r\n\r\n                var offsetPoint = Cartesian3.add(intersection, offset, offsetPointScratch);\r\n\r\n                insertIndex = insertSplitPoint(p0Attributes, p0Indices, p0IndexMap, indices, i, p0);\r\n                computeLineAttributes(i0, i1, p0, positions, insertIndex, p0Attributes, applyOffset);\r\n\r\n                insertIndex = insertSplitPoint(p0Attributes, p0Indices, p0IndexMap, indices, -1, offsetPoint);\r\n                computeLineAttributes(i0, i1, offsetPoint, positions, insertIndex, p0Attributes, applyOffset);\r\n\r\n                Cartesian3.negate(offset, offset);\r\n                Cartesian3.add(intersection, offset, offsetPoint);\r\n                insertIndex = insertSplitPoint(p1Attributes, p1Indices, p1IndexMap, indices, -1, offsetPoint);\r\n                computeLineAttributes(i0, i1, offsetPoint, positions, insertIndex, p1Attributes, applyOffset);\r\n\r\n                insertIndex = insertSplitPoint(p1Attributes, p1Indices, p1IndexMap, indices, i + 1, p1);\r\n                computeLineAttributes(i0, i1, p1, positions, insertIndex, p1Attributes, applyOffset);\r\n            } else {\r\n                var currentAttributes;\r\n                var currentIndices;\r\n                var currentIndexMap;\r\n\r\n                if (p0.y < 0.0) {\r\n                    currentAttributes = westGeometry.attributes;\r\n                    currentIndices = westGeometry.indices;\r\n                    currentIndexMap = westGeometryIndexMap;\r\n                } else {\r\n                    currentAttributes = eastGeometry.attributes;\r\n                    currentIndices = eastGeometry.indices;\r\n                    currentIndexMap = eastGeometryIndexMap;\r\n                }\r\n\r\n                insertIndex = insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, i, p0);\r\n                computeLineAttributes(i0, i1, p0, positions, insertIndex, currentAttributes, applyOffset);\r\n\r\n                insertIndex = insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, i + 1, p1);\r\n                computeLineAttributes(i0, i1, p1, positions, insertIndex, currentAttributes, applyOffset);\r\n            }\r\n        }\r\n\r\n        updateInstanceAfterSplit(instance, westGeometry, eastGeometry);\r\n    }\r\n\r\n    var cartesian2Scratch0 = new Cartesian2();\r\n    var cartesian2Scratch1 = new Cartesian2();\r\n\r\n    var cartesian3Scratch0 = new Cartesian3();\r\n    var cartesian3Scratch2 = new Cartesian3();\r\n    var cartesian3Scratch3 = new Cartesian3();\r\n    var cartesian3Scratch4 = new Cartesian3();\r\n    var cartesian3Scratch5 = new Cartesian3();\r\n    var cartesian3Scratch6 = new Cartesian3();\r\n\r\n    var cartesian4Scratch0 = new Cartesian4();\r\n\r\n    function updateAdjacencyAfterSplit(geometry) {\r\n        var attributes = geometry.attributes;\r\n        var positions = attributes.position.values;\r\n        var prevPositions = attributes.prevPosition.values;\r\n        var nextPositions = attributes.nextPosition.values;\r\n\r\n        var length = positions.length;\r\n        for (var j = 0; j < length; j += 3) {\r\n            var position = Cartesian3.unpack(positions, j, cartesian3Scratch0);\r\n            if (position.x > 0.0) {\r\n                continue;\r\n            }\r\n\r\n            var prevPosition = Cartesian3.unpack(prevPositions, j, cartesian3Scratch2);\r\n            if ((position.y < 0.0 && prevPosition.y > 0.0) || (position.y > 0.0 && prevPosition.y < 0.0)) {\r\n                if (j - 3 > 0) {\r\n                    prevPositions[j] = positions[j - 3];\r\n                    prevPositions[j + 1] = positions[j - 2];\r\n                    prevPositions[j + 2] = positions[j - 1];\r\n                } else {\r\n                    Cartesian3.pack(position, prevPositions, j);\r\n                }\r\n            }\r\n\r\n            var nextPosition = Cartesian3.unpack(nextPositions, j, cartesian3Scratch3);\r\n            if ((position.y < 0.0 && nextPosition.y > 0.0) || (position.y > 0.0 && nextPosition.y < 0.0)) {\r\n                if (j + 3 < length) {\r\n                    nextPositions[j] = positions[j + 3];\r\n                    nextPositions[j + 1] = positions[j + 4];\r\n                    nextPositions[j + 2] = positions[j + 5];\r\n                } else {\r\n                    Cartesian3.pack(position, nextPositions, j);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    var offsetScalar = 5.0 * CesiumMath.EPSILON9;\r\n    var coplanarOffset = CesiumMath.EPSILON6;\r\n\r\n    function splitLongitudePolyline(instance) {\r\n        var geometry = instance.geometry;\r\n        var attributes = geometry.attributes;\r\n        var positions = attributes.position.values;\r\n        var prevPositions = attributes.prevPosition.values;\r\n        var nextPositions = attributes.nextPosition.values;\r\n        var expandAndWidths = attributes.expandAndWidth.values;\r\n\r\n        var texCoords = (defined(attributes.st)) ? attributes.st.values : undefined;\r\n        var colors = (defined(attributes.color)) ? attributes.color.values : undefined;\r\n\r\n        var eastGeometry = copyGeometryForSplit(geometry);\r\n        var westGeometry = copyGeometryForSplit(geometry);\r\n\r\n        var i;\r\n        var j;\r\n        var index;\r\n\r\n        var intersectionFound = false;\r\n\r\n        var length = positions.length / 3;\r\n        for (i = 0; i < length; i += 4) {\r\n            var i0 = i;\r\n            var i2 = i + 2;\r\n\r\n            var p0 = Cartesian3.fromArray(positions, i0 * 3, cartesian3Scratch0);\r\n            var p2 = Cartesian3.fromArray(positions, i2 * 3, cartesian3Scratch2);\r\n\r\n            // Offset points that are close to the 180 longitude and change the previous/next point\r\n            // to be the same offset point so it can be projected to 2D. There is special handling in the\r\n            // shader for when position == prevPosition || position == nextPosition.\r\n            if (Math.abs(p0.y) < coplanarOffset) {\r\n                p0.y = coplanarOffset * (p2.y < 0.0 ? -1.0 : 1.0);\r\n                positions[i * 3 + 1] = p0.y;\r\n                positions[(i + 1) * 3 + 1] = p0.y;\r\n\r\n                for (j = i0 * 3; j < i0 * 3 + 4 * 3; j += 3) {\r\n                    prevPositions[j] = positions[i * 3];\r\n                    prevPositions[j + 1] = positions[i * 3 + 1];\r\n                    prevPositions[j + 2] = positions[i * 3 + 2];\r\n                }\r\n            }\r\n\r\n            // Do the same but for when the line crosses 180 longitude in the opposite direction.\r\n            if (Math.abs(p2.y) < coplanarOffset) {\r\n                p2.y = coplanarOffset * (p0.y < 0.0 ? -1.0 : 1.0);\r\n                positions[(i + 2) * 3 + 1] = p2.y;\r\n                positions[(i + 3) * 3 + 1] = p2.y;\r\n\r\n                for (j = i0 * 3; j < i0 * 3 + 4 * 3; j += 3) {\r\n                    nextPositions[j] = positions[(i + 2) * 3];\r\n                    nextPositions[j + 1] = positions[(i + 2) * 3 + 1];\r\n                    nextPositions[j + 2] = positions[(i + 2) * 3 + 2];\r\n                }\r\n            }\r\n\r\n            var p0Attributes = eastGeometry.attributes;\r\n            var p0Indices = eastGeometry.indices;\r\n            var p2Attributes = westGeometry.attributes;\r\n            var p2Indices = westGeometry.indices;\r\n\r\n            var intersection = IntersectionTests.lineSegmentPlane(p0, p2, xzPlane, cartesian3Scratch4);\r\n            if (defined(intersection)) {\r\n                intersectionFound = true;\r\n\r\n                // move point on the xz-plane slightly away from the plane\r\n                var offset = Cartesian3.multiplyByScalar(Cartesian3.UNIT_Y, offsetScalar, cartesian3Scratch5);\r\n                if (p0.y < 0.0) {\r\n                    Cartesian3.negate(offset, offset);\r\n                    p0Attributes = westGeometry.attributes;\r\n                    p0Indices = westGeometry.indices;\r\n                    p2Attributes = eastGeometry.attributes;\r\n                    p2Indices = eastGeometry.indices;\r\n                }\r\n\r\n                var offsetPoint = Cartesian3.add(intersection, offset, cartesian3Scratch6);\r\n                p0Attributes.position.values.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z);\r\n                p0Attributes.position.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\r\n                p0Attributes.position.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\r\n\r\n                p0Attributes.prevPosition.values.push(prevPositions[i0 * 3], prevPositions[i0 * 3 + 1], prevPositions[i0 * 3 + 2]);\r\n                p0Attributes.prevPosition.values.push(prevPositions[i0 * 3 + 3], prevPositions[i0 * 3 + 4], prevPositions[i0 * 3 + 5]);\r\n                p0Attributes.prevPosition.values.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z);\r\n\r\n                p0Attributes.nextPosition.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\r\n                p0Attributes.nextPosition.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\r\n                p0Attributes.nextPosition.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\r\n                p0Attributes.nextPosition.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\r\n\r\n                Cartesian3.negate(offset, offset);\r\n                Cartesian3.add(intersection, offset, offsetPoint);\r\n                p2Attributes.position.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\r\n                p2Attributes.position.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\r\n                p2Attributes.position.values.push(p2.x, p2.y, p2.z, p2.x, p2.y, p2.z);\r\n\r\n                p2Attributes.prevPosition.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\r\n                p2Attributes.prevPosition.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\r\n                p2Attributes.prevPosition.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\r\n                p2Attributes.prevPosition.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\r\n\r\n                p2Attributes.nextPosition.values.push(p2.x, p2.y, p2.z, p2.x, p2.y, p2.z);\r\n                p2Attributes.nextPosition.values.push(nextPositions[i2 * 3], nextPositions[i2 * 3 + 1], nextPositions[i2 * 3 + 2]);\r\n                p2Attributes.nextPosition.values.push(nextPositions[i2 * 3 + 3], nextPositions[i2 * 3 + 4], nextPositions[i2 * 3 + 5]);\r\n\r\n                var ew0 = Cartesian2.fromArray(expandAndWidths, i0 * 2, cartesian2Scratch0);\r\n                var width = Math.abs(ew0.y);\r\n\r\n                p0Attributes.expandAndWidth.values.push(-1,  width, 1,  width);\r\n                p0Attributes.expandAndWidth.values.push(-1, -width, 1, -width);\r\n                p2Attributes.expandAndWidth.values.push(-1,  width, 1,  width);\r\n                p2Attributes.expandAndWidth.values.push(-1, -width, 1, -width);\r\n\r\n                var t = Cartesian3.magnitudeSquared(Cartesian3.subtract(intersection, p0, cartesian3Scratch3));\r\n                t /= Cartesian3.magnitudeSquared(Cartesian3.subtract(p2, p0, cartesian3Scratch3));\r\n\r\n                if (defined(colors)) {\r\n                    var c0 = Cartesian4.fromArray(colors, i0 * 4, cartesian4Scratch0);\r\n                    var c2 = Cartesian4.fromArray(colors, i2 * 4, cartesian4Scratch0);\r\n\r\n                    var r = CesiumMath.lerp(c0.x, c2.x, t);\r\n                    var g = CesiumMath.lerp(c0.y, c2.y, t);\r\n                    var b = CesiumMath.lerp(c0.z, c2.z, t);\r\n                    var a = CesiumMath.lerp(c0.w, c2.w, t);\r\n\r\n                    for (j = i0 * 4; j < i0 * 4 + 2 * 4; ++j) {\r\n                        p0Attributes.color.values.push(colors[j]);\r\n                    }\r\n                    p0Attributes.color.values.push(r, g, b, a);\r\n                    p0Attributes.color.values.push(r, g, b, a);\r\n                    p2Attributes.color.values.push(r, g, b, a);\r\n                    p2Attributes.color.values.push(r, g, b, a);\r\n                    for (j = i2 * 4; j < i2 * 4 + 2 * 4; ++j) {\r\n                        p2Attributes.color.values.push(colors[j]);\r\n                    }\r\n                }\r\n\r\n                if (defined(texCoords)) {\r\n                    var s0 = Cartesian2.fromArray(texCoords, i0 * 2, cartesian2Scratch0);\r\n                    var s3 = Cartesian2.fromArray(texCoords, (i + 3) * 2, cartesian2Scratch1);\r\n\r\n                    var sx = CesiumMath.lerp(s0.x, s3.x, t);\r\n\r\n                    for (j = i0 * 2; j < i0 * 2 + 2 * 2; ++j) {\r\n                        p0Attributes.st.values.push(texCoords[j]);\r\n                    }\r\n                    p0Attributes.st.values.push(sx, s0.y);\r\n                    p0Attributes.st.values.push(sx, s3.y);\r\n                    p2Attributes.st.values.push(sx, s0.y);\r\n                    p2Attributes.st.values.push(sx, s3.y);\r\n                    for (j = i2 * 2; j < i2 * 2 + 2 * 2; ++j) {\r\n                        p2Attributes.st.values.push(texCoords[j]);\r\n                    }\r\n                }\r\n\r\n                index = p0Attributes.position.values.length / 3 - 4;\r\n                p0Indices.push(index, index + 2, index + 1);\r\n                p0Indices.push(index + 1, index + 2, index + 3);\r\n\r\n                index = p2Attributes.position.values.length / 3 - 4;\r\n                p2Indices.push(index, index + 2, index + 1);\r\n                p2Indices.push(index + 1, index + 2, index + 3);\r\n            } else {\r\n                var currentAttributes;\r\n                var currentIndices;\r\n\r\n                if (p0.y < 0.0) {\r\n                    currentAttributes = westGeometry.attributes;\r\n                    currentIndices = westGeometry.indices;\r\n                } else {\r\n                    currentAttributes = eastGeometry.attributes;\r\n                    currentIndices = eastGeometry.indices;\r\n                }\r\n\r\n                currentAttributes.position.values.push(p0.x, p0.y, p0.z);\r\n                currentAttributes.position.values.push(p0.x, p0.y, p0.z);\r\n                currentAttributes.position.values.push(p2.x, p2.y, p2.z);\r\n                currentAttributes.position.values.push(p2.x, p2.y, p2.z);\r\n\r\n                for (j = i * 3; j < i * 3 + 4 * 3; ++j) {\r\n                    currentAttributes.prevPosition.values.push(prevPositions[j]);\r\n                    currentAttributes.nextPosition.values.push(nextPositions[j]);\r\n                }\r\n\r\n                for (j = i * 2; j < i * 2 + 4 * 2; ++j) {\r\n                    currentAttributes.expandAndWidth.values.push(expandAndWidths[j]);\r\n                    if (defined(texCoords)) {\r\n                        currentAttributes.st.values.push(texCoords[j]);\r\n                    }\r\n                }\r\n\r\n                if (defined(colors)) {\r\n                    for (j = i * 4; j < i * 4 + 4 * 4; ++j) {\r\n                        currentAttributes.color.values.push(colors[j]);\r\n                    }\r\n                }\r\n\r\n                index = currentAttributes.position.values.length / 3 - 4;\r\n                currentIndices.push(index, index + 2, index + 1);\r\n                currentIndices.push(index + 1, index + 2, index + 3);\r\n            }\r\n        }\r\n\r\n        if (intersectionFound) {\r\n            updateAdjacencyAfterSplit(westGeometry);\r\n            updateAdjacencyAfterSplit(eastGeometry);\r\n        }\r\n\r\n        updateInstanceAfterSplit(instance, westGeometry, eastGeometry);\r\n    }\r\n\r\n    /**\r\n     * Splits the instances's geometry, by introducing new vertices and indices,that\r\n     * intersect the International Date Line and Prime Meridian so that no primitives cross longitude\r\n     * -180/180 degrees.  This is not required for 3D drawing, but is required for\r\n     * correcting drawing in 2D and Columbus view.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {GeometryInstance} instance The instance to modify.\r\n     * @returns {GeometryInstance} The modified <code>instance</code> argument, with it's geometry split at the International Date Line.\r\n     *\r\n     * @example\r\n     * instance = Cesium.GeometryPipeline.splitLongitude(instance);\r\n     */\r\n    GeometryPipeline.splitLongitude = function(instance) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(instance)) {\r\n            throw new DeveloperError('instance is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var geometry = instance.geometry;\r\n        var boundingSphere = geometry.boundingSphere;\r\n        if (defined(boundingSphere)) {\r\n            var minX = boundingSphere.center.x - boundingSphere.radius;\r\n            if (minX > 0 || BoundingSphere.intersectPlane(boundingSphere, Plane.ORIGIN_ZX_PLANE) !== Intersect.INTERSECTING) {\r\n                return instance;\r\n            }\r\n        }\r\n\r\n        if (geometry.geometryType !== GeometryType.NONE) {\r\n            switch (geometry.geometryType) {\r\n            case GeometryType.POLYLINES:\r\n                splitLongitudePolyline(instance);\r\n                break;\r\n            case GeometryType.TRIANGLES:\r\n                splitLongitudeTriangles(instance);\r\n                break;\r\n            case GeometryType.LINES:\r\n                splitLongitudeLines(instance);\r\n                break;\r\n            }\r\n        } else {\r\n            indexPrimitive(geometry);\r\n            if (geometry.primitiveType === PrimitiveType.TRIANGLES) {\r\n                splitLongitudeTriangles(instance);\r\n            } else if (geometry.primitiveType === PrimitiveType.LINES) {\r\n                splitLongitudeLines(instance);\r\n            }\r\n        }\r\n\r\n        return instance;\r\n    };\r\nexport default GeometryPipeline;\r\n"],"names":["scratchCartesian1","Cartesian3","scratchCartesian2","scratchCartesian3","Tipsify","calculateACMR","options","indices","defaultValue","EMPTY_OBJECT","maximumIndex","cacheSize","defined","DeveloperError","numIndices","length","currentIndex","intoIndices","vertexTimeStamps","i","s","j","tipsify","cursor","getNextVertex","oneRing","vertices","deadEnd","maximumIndexPlusOne","p","n","m","itOneRing","index","numLiveTriangles","timeStamp","d","splice","skipDeadEnd","endIndex","vertexTriangles","triangle","push","f","vertex","intoVertices","limit","currentOutputIndex","outputIndices","numTriangles","triangleEmitted","k","GeometryPipeline","addTriangle","lines","i0","i1","i2","copyAttributesDescriptions","attributes","newAttributes","attribute","hasOwnProperty","values","attr","GeometryAttribute","componentDatatype","componentsPerAttribute","normalize","copyVertex","destinationAttributes","sourceAttributes","toWireframe","geometry","primitiveType","PrimitiveType","TRIANGLES","triangles","count","size","IndexDatatype","createTypedArray","trianglesToLines","TRIANGLE_STRIP","Uint16Array","triangleStripToLines","TRIANGLE_FAN","base","triangleFanToLines","LINES","createLineSegmentsForVectors","attributeName","position","newBoundingSphere","positions","vectors","positionsLength","newPositions","Float64Array","bs","boundingSphere","BoundingSphere","center","radius","Geometry","ComponentDatatype","DOUBLE","createAttributeLocations","semantics","len","semantic","name","reorderForPreVertexCache","numVertices","computeNumberOfVertices","indexCrossReferenceOldToNew","Int32Array","tempIndex","indicesIn","indicesOut","intoIndicesIn","intoIndicesOut","nextIndex","property","elementsIn","intoElementsIn","numComponents","elementsOut","temp","reorderForPostVertexCache","cacheCapacity","fitToUnsignedShortIndices","POINTS","geometries","numberOfVertices","CesiumMath","SIXTY_FOUR_KILOBYTES","indicesPerPrimitive","oldToNewIndex","newIndices","originalIndices","numberOfIndices","x","boundingSphereCV","scratchProjectTo2DCartesian3","scratchProjectTo2DCartographic","Cartographic","projectTo2D","attributeName3D","attributeName2D","projection","ellipsoid","GeographicProjection","values3D","projectedValues","value","fromArray","lonLat","cartesianToCartographic","y","z","projectedLonLat","project","encodedResult","high","low","encodeAttribute","attributeHighName","attributeLowName","highValues","Float32Array","lowValues","EncodedCartesian3","encode","FLOAT","transformPoint","matrix","unpack","Matrix4","multiplyByPoint","pack","transformVector","Matrix3","multiplyByVector","inverseTranspose","normalMatrix","transformToWorldCoordinates","instance","modelMatrix","equals","IDENTITY","prevPosition","nextPosition","normal","tangent","bitangent","inverse","transpose","getMatrix3","transform","clone","tempScratch","combineGeometries","instances","propertyName","haveIndices","sourceValues","sourceValuesLength","attributesInAllGeometries","attributes0","numberOfComponents","inAllGeometries","otherAttribute","findAttributesInAllGeometries","destIndices","destOffset","offset","sourceIndices","sourceIndicesLen","undefined","add","divideByScalar","tempRadius","magnitude","subtract","combineInstances","instanceGeometry","instanceSplitGeometry","westHemisphereGeometry","eastHemisphereGeometry","v0","v1","v2","computeNormal","normalsPerVertex","Array","normalsPerTriangle","normalIndices","indexOffset","currentCount","i03","i13","i23","cross","vertexNormalData","normalValues","i3","ZERO","equalsEpsilon","EPSILON10","normalScratch","normalScale","tScratch","computeTangentAndBitangent","st","normals","tan1","i02","i12","i22","ux","uy","uz","wx","wy","t1","t2","r","sdirx","sdiry","sdirz","tangentValues","bitangentValues","t","scalar","dot","multiplyByScalar","Cartesian2","toEncode1","toEncode2","toEncode3","encodeResult2","indexPrimitive","indicesIndex","indexTriangleFan","indexTriangleStrip","indexTriangles","LINE_STRIP","indexLineStrip","LINE_LOOP","indexLineLoop","indexLines","offsetPointFromXZPlane","isBehind","Math","abs","EPSILON6","compressVertices","extrudeAttribute","extrudeDirection","extrudeDirections","compressedDirections","AttributeCompression","octEncodeInRange","compressedAttributes","normalAttribute","stAttribute","hasNormal","hasSt","tangents","bitangents","tangentAttribute","bitangentAttribute","hasTangent","hasBitangent","compressedLength","numCompressedComponents","normalIndex","compressTextureCoordinates","octPack","octEncodeFloat","c3","getXZIntersectionOffsetPoints","p1","u1","u2","q1","q2","splitTriangleResult","splitTriangle","p0","p2","p0y","p1y","p2y","sign","offsetTriangleFromXZPlane","p0Behind","p1Behind","p2Behind","numBehind","updateGeometryAfterSplit","computeBoundingSphere","fromVertices","copyGeometryForSplit","copiedAttributes","updateInstanceAfterSplit","westGeometry","eastGeometry","generateBarycentricInterpolateFunction","CartesianType","v0Scratch","v1Scratch","v2Scratch","coords","currentValues","insertedIndex","interpolateAndPackCartesian4","Cartesian4","interpolateAndPackCartesian3","interpolateAndPackCartesian2","p0Scratch","p1Scratch","p2Scratch","barycentricScratch","computeTriangleAttributes","point","texCoords","applyOffset","currentAttributes","customAttributeNames","customAttributesLength","allAttributes","result","dot00","dot01","dot02","dot11","dot12","Check","EPSILON14","UNIT_X","UNIT_Y","UNIT_Z","q","barycentricCoordinates","direction","d0","d1","d2","v3","interpolateAndPackBoolean","genericInterpolate","sourceAttribute","currentAttribute","insertSplitPoint","currentIndices","currentIndexMap","insertIndex","prevIndex","newIndex","NAMED_ATTRIBUTES","splitLongitudeTriangles","westGeometryIndexMap","eastGeometryIndexMap","resultPositions","resultIndices","resultLength","resultIndex","xzPlane","Plane","fromPointNormal","offsetScratch","offsetPointScratch","computeLineAttributes","splitLongitudeLines","p0Attributes","p0Indices","p0IndexMap","p1Attributes","p1Indices","p1IndexMap","intersection","IntersectionTests","lineSegmentPlane","EPSILON9","negate","offsetPoint","cartesian2Scratch0","cartesian2Scratch1","cartesian3Scratch0","cartesian3Scratch2","cartesian3Scratch3","cartesian3Scratch4","cartesian3Scratch5","cartesian3Scratch6","cartesian4Scratch0","updateAdjacencyAfterSplit","prevPositions","nextPositions","offsetScalar","coplanarOffset","splitLongitude","intersectPlane","ORIGIN_ZX_PLANE","Intersect","INTERSECTING","geometryType","GeometryType","NONE","POLYLINES","expandAndWidths","expandAndWidth","colors","color","intersectionFound","p2Attributes","p2Indices","ew0","width","magnitudeSquared","c0","c2","lerp","g","b","a","w","s0","s3","sx","splitLongitudePolyline"],"mappings":"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"}