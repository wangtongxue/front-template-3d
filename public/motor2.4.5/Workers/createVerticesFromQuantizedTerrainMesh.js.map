{"version":3,"file":"createVerticesFromQuantizedTerrainMesh.js","sources":["../../../../Source/Core/TerrainProvider.js","../../../../Source/WorkersES6/createVerticesFromQuantizedTerrainMesh.js"],"sourcesContent":["import defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport IndexDatatype from './IndexDatatype.js';\r\nimport CesiumMath from './Math.js';\r\n\r\n    /**\r\n     * Provides terrain or other geometry for the surface of an ellipsoid.  The surface geometry is\r\n     * organized into a pyramid of tiles according to a {@link TilingScheme}.  This type describes an\r\n     * interface and is not intended to be instantiated directly.\r\n     *\r\n     * @alias TerrainProvider\r\n     * @constructor\r\n     *\r\n     * @see EllipsoidTerrainProvider\r\n     * @see CesiumTerrainProvider\r\n     * @see VRTheWorldTerrainProvider\r\n     * @see GoogleEarthEnterpriseTerrainProvider\r\n     */\r\n    function TerrainProvider() {\r\n        DeveloperError.throwInstantiationError();\r\n    }\r\n\r\n    Object.defineProperties(TerrainProvider.prototype, {\r\n        /**\r\n         * Gets an event that is raised when the terrain provider encounters an asynchronous error..  By subscribing\r\n         * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\r\n         * are passed an instance of {@link TileProviderError}.\r\n         * @memberof TerrainProvider.prototype\r\n         * @type {Event}\r\n         */\r\n        errorEvent : {\r\n            get : DeveloperError.throwInstantiationError\r\n        },\r\n\r\n        /**\r\n         * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\r\n         * the source of the terrain. This function should\r\n         * not be called before {@link TerrainProvider#ready} returns true.\r\n         * @memberof TerrainProvider.prototype\r\n         * @type {Credit}\r\n         */\r\n        credit : {\r\n            get : DeveloperError.throwInstantiationError\r\n        },\r\n\r\n        /**\r\n         * Gets the tiling scheme used by the provider.  This function should\r\n         * not be called before {@link TerrainProvider#ready} returns true.\r\n         * @memberof TerrainProvider.prototype\r\n         * @type {TilingScheme}\r\n         */\r\n        tilingScheme : {\r\n            get : DeveloperError.throwInstantiationError\r\n        },\r\n\r\n        /**\r\n         * Gets a value indicating whether or not the provider is ready for use.\r\n         * @memberof TerrainProvider.prototype\r\n         * @type {Boolean}\r\n         */\r\n        ready : {\r\n            get : DeveloperError.throwInstantiationError\r\n        },\r\n\r\n        /**\r\n         * Gets a promise that resolves to true when the provider is ready for use.\r\n         * @memberof TerrainProvider.prototype\r\n         * @type {Promise.<Boolean>}\r\n         * @readonly\r\n         */\r\n        readyPromise : {\r\n            get : DeveloperError.throwInstantiationError\r\n        },\r\n\r\n        /**\r\n         * Gets a value indicating whether or not the provider includes a water mask.  The water mask\r\n         * indicates which areas of the globe are water rather than land, so they can be rendered\r\n         * as a reflective surface with animated waves.  This function should not be\r\n         * called before {@link TerrainProvider#ready} returns true.\r\n         * @memberof TerrainProvider.prototype\r\n         * @type {Boolean}\r\n         */\r\n        hasWaterMask : {\r\n            get : DeveloperError.throwInstantiationError\r\n        },\r\n\r\n        /**\r\n         * Gets a value indicating whether or not the requested tiles include vertex normals.\r\n         * This function should not be called before {@link TerrainProvider#ready} returns true.\r\n         * @memberof TerrainProvider.prototype\r\n         * @type {Boolean}\r\n         */\r\n        hasVertexNormals : {\r\n            get : DeveloperError.throwInstantiationError\r\n        },\r\n\r\n        /**\r\n         * Gets an object that can be used to determine availability of terrain from this provider, such as\r\n         * at points and in rectangles.  This function should not be called before\r\n         * {@link TerrainProvider#ready} returns true.  This property may be undefined if availability\r\n         * information is not available.\r\n         * @memberof TerrainProvider.prototype\r\n         * @type {TileAvailability}\r\n         */\r\n        availability : {\r\n            get : DeveloperError.throwInstantiationError\r\n        }\r\n    });\r\n\r\n    var regularGridIndicesCache = [];\r\n\r\n    /**\r\n     * Gets a list of indices for a triangle mesh representing a regular grid.  Calling\r\n     * this function multiple times with the same grid width and height returns the\r\n     * same list of indices.  The total number of vertices must be less than or equal\r\n     * to 65536.\r\n     *\r\n     * @param {Number} width The number of vertices in the regular grid in the horizontal direction.\r\n     * @param {Number} height The number of vertices in the regular grid in the vertical direction.\r\n     * @returns {Uint16Array|Uint32Array} The list of indices. Uint16Array gets returned for 64KB or less and Uint32Array for 4GB or less.\r\n     */\r\n    TerrainProvider.getRegularGridIndices = function(width, height) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (width * height >= CesiumMath.FOUR_GIGABYTES) {\r\n            throw new DeveloperError('The total number of vertices (width * height) must be less than 4,294,967,296.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var byWidth = regularGridIndicesCache[width];\r\n        if (!defined(byWidth)) {\r\n            regularGridIndicesCache[width] = byWidth = [];\r\n        }\r\n\r\n        var indices = byWidth[height];\r\n        if (!defined(indices)) {\r\n            if (width * height < CesiumMath.SIXTY_FOUR_KILOBYTES) {\r\n                indices = byWidth[height] = new Uint16Array((width - 1) * (height - 1) * 6);\r\n            } else {\r\n                indices = byWidth[height] = new Uint32Array((width - 1) * (height - 1) * 6);\r\n            }\r\n            addRegularGridIndices(width, height, indices, 0);\r\n        }\r\n\r\n        return indices;\r\n    };\r\n\r\n    var regularGridAndEdgeIndicesCache = [];\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    TerrainProvider.getRegularGridIndicesAndEdgeIndices = function(width, height) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (width * height >= CesiumMath.FOUR_GIGABYTES) {\r\n            throw new DeveloperError('The total number of vertices (width * height) must be less than 4,294,967,296.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var byWidth = regularGridAndEdgeIndicesCache[width];\r\n        if (!defined(byWidth)) {\r\n            regularGridAndEdgeIndicesCache[width] = byWidth = [];\r\n        }\r\n\r\n        var indicesAndEdges = byWidth[height];\r\n        if (!defined(indicesAndEdges)) {\r\n            var indices = TerrainProvider.getRegularGridIndices(width, height);\r\n\r\n            var edgeIndices = getEdgeIndices(width, height);\r\n            var westIndicesSouthToNorth = edgeIndices.westIndicesSouthToNorth;\r\n            var southIndicesEastToWest = edgeIndices.southIndicesEastToWest;\r\n            var eastIndicesNorthToSouth = edgeIndices.eastIndicesNorthToSouth;\r\n            var northIndicesWestToEast = edgeIndices.northIndicesWestToEast;\r\n\r\n            indicesAndEdges = byWidth[height] = {\r\n                indices : indices,\r\n                westIndicesSouthToNorth : westIndicesSouthToNorth,\r\n                southIndicesEastToWest : southIndicesEastToWest,\r\n                eastIndicesNorthToSouth : eastIndicesNorthToSouth,\r\n                northIndicesWestToEast : northIndicesWestToEast\r\n            };\r\n        }\r\n\r\n        return indicesAndEdges;\r\n    };\r\n\r\n    var regularGridAndSkirtAndEdgeIndicesCache = [];\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    TerrainProvider.getRegularGridAndSkirtIndicesAndEdgeIndices = function(width, height) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (width * height >= CesiumMath.FOUR_GIGABYTES) {\r\n            throw new DeveloperError('The total number of vertices (width * height) must be less than 4,294,967,296.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var byWidth = regularGridAndSkirtAndEdgeIndicesCache[width];\r\n        if (!defined(byWidth)) {\r\n            regularGridAndSkirtAndEdgeIndicesCache[width] = byWidth = [];\r\n        }\r\n\r\n        var indicesAndEdges = byWidth[height];\r\n        if (!defined(indicesAndEdges)) {\r\n            var gridVertexCount = width * height;\r\n            var gridIndexCount = (width - 1) * (height - 1) * 6;\r\n            var edgeVertexCount = width * 2 + height * 2;\r\n            var edgeIndexCount = Math.max(0, edgeVertexCount - 4) * 6;\r\n            var vertexCount = gridVertexCount + edgeVertexCount;\r\n            var indexCount = gridIndexCount + edgeIndexCount;\r\n\r\n            var edgeIndices = getEdgeIndices(width, height);\r\n            var westIndicesSouthToNorth = edgeIndices.westIndicesSouthToNorth;\r\n            var southIndicesEastToWest = edgeIndices.southIndicesEastToWest;\r\n            var eastIndicesNorthToSouth = edgeIndices.eastIndicesNorthToSouth;\r\n            var northIndicesWestToEast = edgeIndices.northIndicesWestToEast;\r\n\r\n            var indices = IndexDatatype.createTypedArray(vertexCount, indexCount);\r\n            addRegularGridIndices(width, height, indices, 0);\r\n            TerrainProvider.addSkirtIndices(westIndicesSouthToNorth, southIndicesEastToWest, eastIndicesNorthToSouth, northIndicesWestToEast, gridVertexCount, indices, gridIndexCount);\r\n\r\n            indicesAndEdges = byWidth[height] = {\r\n                indices : indices,\r\n                westIndicesSouthToNorth : westIndicesSouthToNorth,\r\n                southIndicesEastToWest : southIndicesEastToWest,\r\n                eastIndicesNorthToSouth : eastIndicesNorthToSouth,\r\n                northIndicesWestToEast : northIndicesWestToEast,\r\n                indexCountWithoutSkirts : gridIndexCount\r\n            };\r\n        }\r\n\r\n        return indicesAndEdges;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    TerrainProvider.addSkirtIndices = function(westIndicesSouthToNorth, southIndicesEastToWest, eastIndicesNorthToSouth, northIndicesWestToEast, vertexCount, indices, offset) {\r\n        var vertexIndex = vertexCount;\r\n        offset = addSkirtIndices(westIndicesSouthToNorth, vertexIndex, indices, offset);\r\n        vertexIndex += westIndicesSouthToNorth.length;\r\n        offset = addSkirtIndices(southIndicesEastToWest, vertexIndex, indices, offset);\r\n        vertexIndex += southIndicesEastToWest.length;\r\n        offset = addSkirtIndices(eastIndicesNorthToSouth, vertexIndex, indices, offset);\r\n        vertexIndex += eastIndicesNorthToSouth.length;\r\n        addSkirtIndices(northIndicesWestToEast, vertexIndex, indices, offset);\r\n    };\r\n\r\n    function getEdgeIndices(width, height) {\r\n        var westIndicesSouthToNorth = new Array(height);\r\n        var southIndicesEastToWest = new Array(width);\r\n        var eastIndicesNorthToSouth = new Array(height);\r\n        var northIndicesWestToEast = new Array(width);\r\n\r\n        var i;\r\n        for (i = 0; i < width; ++i) {\r\n            northIndicesWestToEast[i] = i;\r\n            southIndicesEastToWest[i] = width * height - 1 - i;\r\n        }\r\n\r\n        for (i = 0; i < height; ++i) {\r\n            eastIndicesNorthToSouth[i] = (i + 1) * width - 1;\r\n            westIndicesSouthToNorth[i] = (height - i - 1) * width;\r\n        }\r\n\r\n        return {\r\n            westIndicesSouthToNorth : westIndicesSouthToNorth,\r\n            southIndicesEastToWest : southIndicesEastToWest,\r\n            eastIndicesNorthToSouth : eastIndicesNorthToSouth,\r\n            northIndicesWestToEast : northIndicesWestToEast\r\n        };\r\n    }\r\n\r\n    function addRegularGridIndices(width, height, indices, offset) {\r\n        var index = 0;\r\n        for (var j = 0; j < height - 1; ++j) {\r\n            for (var i = 0; i < width - 1; ++i) {\r\n                var upperLeft = index;\r\n                var lowerLeft = upperLeft + width;\r\n                var lowerRight = lowerLeft + 1;\r\n                var upperRight = upperLeft + 1;\r\n\r\n                indices[offset++] = upperLeft;\r\n                indices[offset++] = lowerLeft;\r\n                indices[offset++] = upperRight;\r\n                indices[offset++] = upperRight;\r\n                indices[offset++] = lowerLeft;\r\n                indices[offset++] = lowerRight;\r\n\r\n                ++index;\r\n            }\r\n            ++index;\r\n        }\r\n    }\r\n\r\n    function addSkirtIndices(edgeIndices, vertexIndex, indices, offset) {\r\n        var previousIndex = edgeIndices[0];\r\n\r\n        var length = edgeIndices.length;\r\n        for (var i = 1; i < length; ++i) {\r\n            var index = edgeIndices[i];\r\n\r\n            indices[offset++] = previousIndex;\r\n            indices[offset++] = index;\r\n            indices[offset++] = vertexIndex;\r\n\r\n            indices[offset++] = vertexIndex;\r\n            indices[offset++] = index;\r\n            indices[offset++] = vertexIndex + 1;\r\n\r\n            previousIndex = index;\r\n            ++vertexIndex;\r\n        }\r\n\r\n        return offset;\r\n    }\r\n\r\n    /**\r\n     * Specifies the quality of terrain created from heightmaps.  A value of 1.0 will\r\n     * ensure that adjacent heightmap vertices are separated by no more than\r\n     * {@link Globe.maximumScreenSpaceError} screen pixels and will probably go very slowly.\r\n     * A value of 0.5 will cut the estimated level zero geometric error in half, allowing twice the\r\n     * screen pixels between adjacent heightmap vertices and thus rendering more quickly.\r\n     * @type {Number}\r\n     */\r\n    TerrainProvider.heightmapTerrainQuality = 0.25;\r\n\r\n    /**\r\n     * Determines an appropriate geometric error estimate when the geometry comes from a heightmap.\r\n     *\r\n     * @param {Ellipsoid} ellipsoid The ellipsoid to which the terrain is attached.\r\n     * @param {Number} tileImageWidth The width, in pixels, of the heightmap associated with a single tile.\r\n     * @param {Number} numberOfTilesAtLevelZero The number of tiles in the horizontal direction at tile level zero.\r\n     * @returns {Number} An estimated geometric error.\r\n     */\r\n    TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap = function(ellipsoid, tileImageWidth, numberOfTilesAtLevelZero) {\r\n        return ellipsoid.maximumRadius * 2 * Math.PI * TerrainProvider.heightmapTerrainQuality / (tileImageWidth * numberOfTilesAtLevelZero);\r\n    };\r\n\r\n    /**\r\n     * Requests the geometry for a given tile.  This function should not be called before\r\n     * {@link TerrainProvider#ready} returns true.  The result must include terrain data and\r\n     * may optionally include a water mask and an indication of which child tiles are available.\r\n     * @function\r\n     *\r\n     * @param {Number} x The X coordinate of the tile for which to request geometry.\r\n     * @param {Number} y The Y coordinate of the tile for which to request geometry.\r\n     * @param {Number} level The level of the tile for which to request geometry.\r\n     * @param {Request} [request] The request object. Intended for internal use only.\r\n     *\r\n     * @returns {Promise.<TerrainData>|undefined} A promise for the requested geometry.  If this method\r\n     *          returns undefined instead of a promise, it is an indication that too many requests are already\r\n     *          pending and the request will be retried later.\r\n     */\r\n    TerrainProvider.prototype.requestTileGeometry = DeveloperError.throwInstantiationError;\r\n\r\n    /**\r\n     * Gets the maximum geometric error allowed in a tile at a given level.  This function should not be\r\n     * called before {@link TerrainProvider#ready} returns true.\r\n     * @function\r\n     *\r\n     * @param {Number} level The tile level for which to get the maximum geometric error.\r\n     * @returns {Number} The maximum geometric error.\r\n     */\r\n    TerrainProvider.prototype.getLevelMaximumGeometricError = DeveloperError.throwInstantiationError;\r\n\r\n    /**\r\n     * Determines whether data for a tile is available to be loaded.\r\n     * @function\r\n     *\r\n     * @param {Number} x The X coordinate of the tile for which to request geometry.\r\n     * @param {Number} y The Y coordinate of the tile for which to request geometry.\r\n     * @param {Number} level The level of the tile for which to request geometry.\r\n     * @returns {Boolean} Undefined if not supported by the terrain provider, otherwise true or false.\r\n     */\r\n    TerrainProvider.prototype.getTileDataAvailable = DeveloperError.throwInstantiationError;\r\n\r\n    /**\r\n     * Makes sure we load availability data for a tile\r\n     * @function\r\n     *\r\n     * @param {Number} x The X coordinate of the tile for which to request geometry.\r\n     * @param {Number} y The Y coordinate of the tile for which to request geometry.\r\n     * @param {Number} level The level of the tile for which to request geometry.\r\n     * @returns {undefined|Promise} Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded\r\n     */\r\n    TerrainProvider.prototype.loadTileDataAvailability = DeveloperError.throwInstantiationError;\r\nexport default TerrainProvider;\r\n","import AttributeCompression from '../Core/AttributeCompression.js';\r\nimport AxisAlignedBoundingBox from '../Core/AxisAlignedBoundingBox.js';\r\nimport BoundingSphere from '../Core/BoundingSphere.js';\r\nimport Cartesian2 from '../Core/Cartesian2.js';\r\nimport Cartesian3 from '../Core/Cartesian3.js';\r\nimport Cartographic from '../Core/Cartographic.js';\r\nimport defined from '../Core/defined.js';\r\nimport Ellipsoid from '../Core/Ellipsoid.js';\r\nimport EllipsoidalOccluder from '../Core/EllipsoidalOccluder.js';\r\nimport IndexDatatype from '../Core/IndexDatatype.js';\r\nimport CesiumMath from '../Core/Math.js';\r\nimport Matrix4 from '../Core/Matrix4.js';\r\nimport OrientedBoundingBox from '../Core/OrientedBoundingBox.js';\r\nimport Rectangle from '../Core/Rectangle.js';\r\nimport TerrainEncoding from '../Core/TerrainEncoding.js';\r\nimport TerrainProvider from '../Core/TerrainProvider.js';\r\nimport Transforms from '../Core/Transforms.js';\r\nimport WebMercatorProjection from '../Core/WebMercatorProjection.js';\r\nimport createTaskProcessorWorker from './createTaskProcessorWorker.js';\r\n\r\n    var maxShort = 32767;\r\n\r\n    var cartesian3Scratch = new Cartesian3();\r\n    var scratchMinimum = new Cartesian3();\r\n    var scratchMaximum = new Cartesian3();\r\n    var cartographicScratch = new Cartographic();\r\n    var toPack = new Cartesian2();\r\n    var scratchNormal = new Cartesian3();\r\n    var scratchToENU = new Matrix4();\r\n    var scratchFromENU = new Matrix4();\r\n\r\n    function createVerticesFromQuantizedTerrainMesh(parameters, transferableObjects) {\r\n        var quantizedVertices = parameters.quantizedVertices;\r\n        var quantizedVertexCount = quantizedVertices.length / 3;\r\n        var octEncodedNormals = parameters.octEncodedNormals;\r\n        var edgeVertexCount = parameters.westIndices.length + parameters.eastIndices.length +\r\n                              parameters.southIndices.length + parameters.northIndices.length;\r\n        var includeWebMercatorT = parameters.includeWebMercatorT;\r\n\r\n        var rectangle = Rectangle.clone(parameters.rectangle);\r\n        var west = rectangle.west;\r\n        var south = rectangle.south;\r\n        var east = rectangle.east;\r\n        var north = rectangle.north;\r\n\r\n        var ellipsoid = Ellipsoid.clone(parameters.ellipsoid);\r\n\r\n        var exaggeration = parameters.exaggeration;\r\n        var minimumHeight = parameters.minimumHeight * exaggeration;\r\n        var maximumHeight = parameters.maximumHeight * exaggeration;\r\n\r\n        var center = parameters.relativeToCenter;\r\n        var fromENU = Transforms.eastNorthUpToFixedFrame(center, ellipsoid);\r\n        var toENU = Matrix4.inverseTransformation(fromENU, new Matrix4());\r\n\r\n        var southMercatorY;\r\n        var oneOverMercatorHeight;\r\n        if (includeWebMercatorT) {\r\n            southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(south);\r\n            oneOverMercatorHeight = 1.0 / (WebMercatorProjection.geodeticLatitudeToMercatorAngle(north) - southMercatorY);\r\n        }\r\n\r\n        var uBuffer = quantizedVertices.subarray(0, quantizedVertexCount);\r\n        var vBuffer = quantizedVertices.subarray(quantizedVertexCount, 2 * quantizedVertexCount);\r\n        var heightBuffer = quantizedVertices.subarray(quantizedVertexCount * 2, 3 * quantizedVertexCount);\r\n        var hasVertexNormals = defined(octEncodedNormals);\r\n\r\n        var uvs = new Array(quantizedVertexCount);\r\n        var heights = new Array(quantizedVertexCount);\r\n        var positions = new Array(quantizedVertexCount);\r\n        var webMercatorTs = includeWebMercatorT ? new Array(quantizedVertexCount) : [];\r\n\r\n        var minimum = scratchMinimum;\r\n        minimum.x = Number.POSITIVE_INFINITY;\r\n        minimum.y = Number.POSITIVE_INFINITY;\r\n        minimum.z = Number.POSITIVE_INFINITY;\r\n\r\n        var maximum = scratchMaximum;\r\n        maximum.x = Number.NEGATIVE_INFINITY;\r\n        maximum.y = Number.NEGATIVE_INFINITY;\r\n        maximum.z = Number.NEGATIVE_INFINITY;\r\n\r\n        var minLongitude = Number.POSITIVE_INFINITY;\r\n        var maxLongitude = Number.NEGATIVE_INFINITY;\r\n        var minLatitude = Number.POSITIVE_INFINITY;\r\n        var maxLatitude = Number.NEGATIVE_INFINITY;\r\n\r\n        for (var i = 0; i < quantizedVertexCount; ++i) {\r\n            var rawU = uBuffer[i];\r\n            var rawV = vBuffer[i];\r\n\r\n            var u = rawU / maxShort;\r\n            var v = rawV / maxShort;\r\n            var height = CesiumMath.lerp(minimumHeight, maximumHeight, heightBuffer[i] / maxShort);\r\n\r\n            cartographicScratch.longitude = CesiumMath.lerp(west, east, u);\r\n            cartographicScratch.latitude = CesiumMath.lerp(south, north, v);\r\n            cartographicScratch.height = height;\r\n\r\n            minLongitude = Math.min(cartographicScratch.longitude, minLongitude);\r\n            maxLongitude = Math.max(cartographicScratch.longitude, maxLongitude);\r\n            minLatitude = Math.min(cartographicScratch.latitude, minLatitude);\r\n            maxLatitude = Math.max(cartographicScratch.latitude, maxLatitude);\r\n\r\n            var position = ellipsoid.cartographicToCartesian(cartographicScratch);\r\n\r\n            uvs[i] = new Cartesian2(u, v);\r\n            heights[i] = height;\r\n            positions[i] = position;\r\n\r\n            if (includeWebMercatorT) {\r\n                webMercatorTs[i] = (WebMercatorProjection.geodeticLatitudeToMercatorAngle(cartographicScratch.latitude) - southMercatorY) * oneOverMercatorHeight;\r\n            }\r\n\r\n            Matrix4.multiplyByPoint(toENU, position, cartesian3Scratch);\r\n\r\n            Cartesian3.minimumByComponent(cartesian3Scratch, minimum, minimum);\r\n            Cartesian3.maximumByComponent(cartesian3Scratch, maximum, maximum);\r\n        }\r\n\r\n        var westIndicesSouthToNorth = copyAndSort(parameters.westIndices, function(a, b) {\r\n            return uvs[a].y - uvs[b].y;\r\n        });\r\n        var eastIndicesNorthToSouth = copyAndSort(parameters.eastIndices, function(a, b) {\r\n            return uvs[b].y - uvs[a].y;\r\n        });\r\n        var southIndicesEastToWest = copyAndSort(parameters.southIndices, function(a, b) {\r\n            return uvs[b].x - uvs[a].x;\r\n        });\r\n        var northIndicesWestToEast = copyAndSort(parameters.northIndices, function(a, b) {\r\n            return uvs[a].x - uvs[b].x;\r\n        });\r\n\r\n        var orientedBoundingBox;\r\n        var boundingSphere;\r\n\r\n        if (exaggeration !== 1.0) {\r\n            // Bounding volumes need to be recomputed since the tile payload assumes no exaggeration.\r\n            boundingSphere = BoundingSphere.fromPoints(positions);\r\n            orientedBoundingBox = OrientedBoundingBox.fromRectangle(rectangle, minimumHeight, maximumHeight, ellipsoid);\r\n        }\r\n\r\n        var occludeePointInScaledSpace;\r\n        if (exaggeration !== 1.0 || minimumHeight < 0.0) {\r\n            // Horizon culling point needs to be recomputed since the tile payload assumes no exaggeration.\r\n            var occluder = new EllipsoidalOccluder(ellipsoid);\r\n            occludeePointInScaledSpace = occluder.computeHorizonCullingPointPossiblyUnderEllipsoid(center, positions, minimumHeight);\r\n        }\r\n\r\n        var hMin = minimumHeight;\r\n        hMin = Math.min(hMin, findMinMaxSkirts(parameters.westIndices, parameters.westSkirtHeight, heights, uvs, rectangle, ellipsoid, toENU, minimum, maximum));\r\n        hMin = Math.min(hMin, findMinMaxSkirts(parameters.southIndices, parameters.southSkirtHeight, heights, uvs, rectangle, ellipsoid, toENU, minimum, maximum));\r\n        hMin = Math.min(hMin, findMinMaxSkirts(parameters.eastIndices, parameters.eastSkirtHeight, heights, uvs, rectangle, ellipsoid, toENU, minimum, maximum));\r\n        hMin = Math.min(hMin, findMinMaxSkirts(parameters.northIndices, parameters.northSkirtHeight, heights, uvs, rectangle, ellipsoid, toENU, minimum, maximum));\r\n\r\n        var aaBox = new AxisAlignedBoundingBox(minimum, maximum, center);\r\n        var encoding = new TerrainEncoding(aaBox, hMin, maximumHeight, fromENU, hasVertexNormals, includeWebMercatorT);\r\n        var vertexStride = encoding.getStride();\r\n        var size = quantizedVertexCount * vertexStride + edgeVertexCount * vertexStride;\r\n        var vertexBuffer = new Float32Array(size);\r\n\r\n        var bufferIndex = 0;\r\n        for (var j = 0; j < quantizedVertexCount; ++j) {\r\n            if (hasVertexNormals) {\r\n                var n = j * 2.0;\r\n                toPack.x = octEncodedNormals[n];\r\n                toPack.y = octEncodedNormals[n + 1];\r\n\r\n                if (exaggeration !== 1.0) {\r\n                    var normal = AttributeCompression.octDecode(toPack.x, toPack.y, scratchNormal);\r\n                    var fromENUNormal = Transforms.eastNorthUpToFixedFrame(positions[j], ellipsoid, scratchFromENU);\r\n                    var toENUNormal = Matrix4.inverseTransformation(fromENUNormal, scratchToENU);\r\n\r\n                    Matrix4.multiplyByPointAsVector(toENUNormal, normal, normal);\r\n                    normal.z *= exaggeration;\r\n                    Cartesian3.normalize(normal, normal);\r\n\r\n                    Matrix4.multiplyByPointAsVector(fromENUNormal, normal, normal);\r\n                    Cartesian3.normalize(normal, normal);\r\n\r\n                    AttributeCompression.octEncode(normal, toPack);\r\n                }\r\n            }\r\n\r\n            bufferIndex = encoding.encode(vertexBuffer, bufferIndex, positions[j], uvs[j], heights[j], toPack, webMercatorTs[j]);\r\n        }\r\n\r\n        var edgeTriangleCount = Math.max(0, (edgeVertexCount - 4) * 2);\r\n        var indexBufferLength = parameters.indices.length + edgeTriangleCount * 3;\r\n        var indexBuffer = IndexDatatype.createTypedArray(quantizedVertexCount + edgeVertexCount, indexBufferLength);\r\n        indexBuffer.set(parameters.indices, 0);\r\n\r\n        var percentage = 0.0001;\r\n        var lonOffset = (maxLongitude - minLongitude) * percentage;\r\n        var latOffset = (maxLatitude - minLatitude) * percentage;\r\n        var westLongitudeOffset = -lonOffset;\r\n        var westLatitudeOffset = 0.0;\r\n        var eastLongitudeOffset = lonOffset;\r\n        var eastLatitudeOffset = 0.0;\r\n        var northLongitudeOffset = 0.0;\r\n        var northLatitudeOffset = latOffset;\r\n        var southLongitudeOffset = 0.0;\r\n        var southLatitudeOffset = -latOffset;\r\n\r\n        // Add skirts.\r\n        var vertexBufferIndex = quantizedVertexCount * vertexStride;\r\n        addSkirt(vertexBuffer, vertexBufferIndex, westIndicesSouthToNorth, encoding, heights, uvs, octEncodedNormals, ellipsoid, rectangle, parameters.westSkirtHeight, exaggeration, southMercatorY, oneOverMercatorHeight, westLongitudeOffset, westLatitudeOffset);\r\n        vertexBufferIndex += parameters.westIndices.length * vertexStride;\r\n        addSkirt(vertexBuffer, vertexBufferIndex, southIndicesEastToWest, encoding, heights, uvs, octEncodedNormals, ellipsoid, rectangle, parameters.southSkirtHeight, exaggeration, southMercatorY, oneOverMercatorHeight, southLongitudeOffset, southLatitudeOffset);\r\n        vertexBufferIndex += parameters.southIndices.length * vertexStride;\r\n        addSkirt(vertexBuffer, vertexBufferIndex, eastIndicesNorthToSouth, encoding, heights, uvs, octEncodedNormals, ellipsoid, rectangle, parameters.eastSkirtHeight, exaggeration, southMercatorY, oneOverMercatorHeight, eastLongitudeOffset, eastLatitudeOffset);\r\n        vertexBufferIndex += parameters.eastIndices.length * vertexStride;\r\n        addSkirt(vertexBuffer, vertexBufferIndex, northIndicesWestToEast, encoding, heights, uvs, octEncodedNormals, ellipsoid, rectangle, parameters.northSkirtHeight, exaggeration, southMercatorY, oneOverMercatorHeight, northLongitudeOffset, northLatitudeOffset);\r\n\r\n        TerrainProvider.addSkirtIndices(westIndicesSouthToNorth, southIndicesEastToWest, eastIndicesNorthToSouth, northIndicesWestToEast, quantizedVertexCount, indexBuffer, parameters.indices.length);\r\n\r\n        transferableObjects.push(vertexBuffer.buffer, indexBuffer.buffer);\r\n\r\n        return {\r\n            vertices : vertexBuffer.buffer,\r\n            indices : indexBuffer.buffer,\r\n            westIndicesSouthToNorth : westIndicesSouthToNorth,\r\n            southIndicesEastToWest : southIndicesEastToWest,\r\n            eastIndicesNorthToSouth : eastIndicesNorthToSouth,\r\n            northIndicesWestToEast : northIndicesWestToEast,\r\n            vertexStride : vertexStride,\r\n            center : center,\r\n            minimumHeight : minimumHeight,\r\n            maximumHeight : maximumHeight,\r\n            boundingSphere : boundingSphere,\r\n            orientedBoundingBox : orientedBoundingBox,\r\n            occludeePointInScaledSpace : occludeePointInScaledSpace,\r\n            encoding : encoding,\r\n            indexCountWithoutSkirts : parameters.indices.length\r\n        };\r\n    }\r\n\r\n    function findMinMaxSkirts(edgeIndices, edgeHeight, heights, uvs, rectangle, ellipsoid, toENU, minimum, maximum) {\r\n        var hMin = Number.POSITIVE_INFINITY;\r\n\r\n        var north = rectangle.north;\r\n        var south = rectangle.south;\r\n        var east = rectangle.east;\r\n        var west = rectangle.west;\r\n\r\n        if (east < west) {\r\n            east += CesiumMath.TWO_PI;\r\n        }\r\n\r\n        var length = edgeIndices.length;\r\n        for (var i = 0; i < length; ++i) {\r\n            var index = edgeIndices[i];\r\n            var h = heights[index];\r\n            var uv = uvs[index];\r\n\r\n            cartographicScratch.longitude = CesiumMath.lerp(west, east, uv.x);\r\n            cartographicScratch.latitude = CesiumMath.lerp(south, north, uv.y);\r\n            cartographicScratch.height = h - edgeHeight;\r\n\r\n            var position = ellipsoid.cartographicToCartesian(cartographicScratch, cartesian3Scratch);\r\n            Matrix4.multiplyByPoint(toENU, position, position);\r\n\r\n            Cartesian3.minimumByComponent(position, minimum, minimum);\r\n            Cartesian3.maximumByComponent(position, maximum, maximum);\r\n\r\n            hMin = Math.min(hMin, cartographicScratch.height);\r\n        }\r\n        return hMin;\r\n    }\r\n\r\n    function addSkirt(vertexBuffer, vertexBufferIndex, edgeVertices, encoding, heights, uvs, octEncodedNormals, ellipsoid, rectangle, skirtLength, exaggeration, southMercatorY, oneOverMercatorHeight, longitudeOffset, latitudeOffset) {\r\n        var hasVertexNormals = defined(octEncodedNormals);\r\n\r\n        var north = rectangle.north;\r\n        var south = rectangle.south;\r\n        var east = rectangle.east;\r\n        var west = rectangle.west;\r\n\r\n        if (east < west) {\r\n            east += CesiumMath.TWO_PI;\r\n        }\r\n\r\n        var length = edgeVertices.length;\r\n        for (var i = 0; i < length; ++i) {\r\n            var index = edgeVertices[i];\r\n            var h = heights[index];\r\n            var uv = uvs[index];\r\n\r\n            cartographicScratch.longitude = CesiumMath.lerp(west, east, uv.x) + longitudeOffset;\r\n            cartographicScratch.latitude = CesiumMath.lerp(south, north, uv.y) + latitudeOffset;\r\n            cartographicScratch.height = h - skirtLength;\r\n\r\n            var position = ellipsoid.cartographicToCartesian(cartographicScratch, cartesian3Scratch);\r\n\r\n            if (hasVertexNormals) {\r\n                var n = index * 2.0;\r\n                toPack.x = octEncodedNormals[n];\r\n                toPack.y = octEncodedNormals[n + 1];\r\n\r\n                if (exaggeration !== 1.0) {\r\n                    var normal = AttributeCompression.octDecode(toPack.x, toPack.y, scratchNormal);\r\n                    var fromENUNormal = Transforms.eastNorthUpToFixedFrame(cartesian3Scratch, ellipsoid, scratchFromENU);\r\n                    var toENUNormal = Matrix4.inverseTransformation(fromENUNormal, scratchToENU);\r\n\r\n                    Matrix4.multiplyByPointAsVector(toENUNormal, normal, normal);\r\n                    normal.z *= exaggeration;\r\n                    Cartesian3.normalize(normal, normal);\r\n\r\n                    Matrix4.multiplyByPointAsVector(fromENUNormal, normal, normal);\r\n                    Cartesian3.normalize(normal, normal);\r\n\r\n                    AttributeCompression.octEncode(normal, toPack);\r\n                }\r\n            }\r\n\r\n            var webMercatorT;\r\n            if (encoding.hasWebMercatorT) {\r\n                webMercatorT = (WebMercatorProjection.geodeticLatitudeToMercatorAngle(cartographicScratch.latitude) - southMercatorY) * oneOverMercatorHeight;\r\n            }\r\n\r\n            vertexBufferIndex = encoding.encode(vertexBuffer, vertexBufferIndex, position, uv, cartographicScratch.height, toPack, webMercatorT);\r\n        }\r\n    }\r\n\r\n    function copyAndSort(typedArray, comparator) {\r\n        var copy;\r\n        if (typeof typedArray.slice === 'function') {\r\n            copy = typedArray.slice();\r\n            if (typeof copy.sort !== 'function') {\r\n                // Sliced typed array isn't sortable, so we can't use it.\r\n                copy = undefined;\r\n            }\r\n        }\r\n\r\n        if (!defined(copy)) {\r\n            copy = Array.prototype.slice.call(typedArray);\r\n        }\r\n\r\n        copy.sort(comparator);\r\n\r\n        return copy;\r\n    }\r\nexport default createTaskProcessorWorker(createVerticesFromQuantizedTerrainMesh);\r\n"],"names":["TerrainProvider","DeveloperError","throwInstantiationError","Object","defineProperties","prototype","errorEvent","get","credit","tilingScheme","ready","readyPromise","hasWaterMask","hasVertexNormals","availability","regularGridIndicesCache","getRegularGridIndices","width","height","CesiumMath","FOUR_GIGABYTES","byWidth","defined","indices","addRegularGridIndices","SIXTY_FOUR_KILOBYTES","Uint16Array","Uint32Array","regularGridAndEdgeIndicesCache","getRegularGridIndicesAndEdgeIndices","indicesAndEdges","edgeIndices","getEdgeIndices","westIndicesSouthToNorth","southIndicesEastToWest","eastIndicesNorthToSouth","northIndicesWestToEast","regularGridAndSkirtAndEdgeIndicesCache","i","Array","offset","index","j","upperLeft","lowerLeft","lowerRight","upperRight","addSkirtIndices","vertexIndex","previousIndex","length","getRegularGridAndSkirtIndicesAndEdgeIndices","gridVertexCount","gridIndexCount","edgeVertexCount","vertexCount","indexCount","Math","max","IndexDatatype","createTypedArray","indexCountWithoutSkirts","heightmapTerrainQuality","getEstimatedLevelZeroGeometricErrorForAHeightmap","ellipsoid","tileImageWidth","numberOfTilesAtLevelZero","maximumRadius","PI","requestTileGeometry","getLevelMaximumGeometricError","getTileDataAvailable","loadTileDataAvailability","cartesian3Scratch","Cartesian3","scratchMinimum","scratchMaximum","cartographicScratch","Cartographic","toPack","Cartesian2","scratchNormal","scratchToENU","Matrix4","scratchFromENU","findMinMaxSkirts","edgeHeight","heights","uvs","rectangle","toENU","minimum","maximum","hMin","Number","POSITIVE_INFINITY","north","south","east","west","TWO_PI","h","uv","longitude","lerp","x","latitude","y","position","cartographicToCartesian","multiplyByPoint","minimumByComponent","maximumByComponent","min","addSkirt","vertexBuffer","vertexBufferIndex","edgeVertices","encoding","octEncodedNormals","skirtLength","exaggeration","southMercatorY","oneOverMercatorHeight","longitudeOffset","latitudeOffset","webMercatorT","n","normal","AttributeCompression","octDecode","fromENUNormal","Transforms","eastNorthUpToFixedFrame","toENUNormal","inverseTransformation","multiplyByPointAsVector","z","normalize","octEncode","hasWebMercatorT","WebMercatorProjection","geodeticLatitudeToMercatorAngle","encode","copyAndSort","typedArray","comparator","copy","slice","sort","undefined","call","createTaskProcessorWorker","parameters","transferableObjects","quantizedVertices","quantizedVertexCount","westIndices","eastIndices","southIndices","northIndices","includeWebMercatorT","Rectangle","clone","Ellipsoid","minimumHeight","maximumHeight","center","relativeToCenter","fromENU","uBuffer","subarray","vBuffer","heightBuffer","positions","webMercatorTs","NEGATIVE_INFINITY","minLongitude","maxLongitude","minLatitude","maxLatitude","u","v","orientedBoundingBox","boundingSphere","occludeePointInScaledSpace","a","b","BoundingSphere","fromPoints","OrientedBoundingBox","fromRectangle","EllipsoidalOccluder","computeHorizonCullingPointPossiblyUnderEllipsoid","westSkirtHeight","southSkirtHeight","eastSkirtHeight","northSkirtHeight","aaBox","AxisAlignedBoundingBox","TerrainEncoding","vertexStride","getStride","Float32Array","bufferIndex","edgeTriangleCount","indexBufferLength","indexBuffer","set","lonOffset","latOffset","westLongitudeOffset","eastLongitudeOffset","northLatitudeOffset","southLatitudeOffset","push","buffer","vertices"],"mappings":"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"}