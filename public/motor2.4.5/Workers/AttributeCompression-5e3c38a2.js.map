{"version":3,"file":"AttributeCompression-5e3c38a2.js","sources":["../../../../Source/Core/AttributeCompression.js"],"sourcesContent":["import Cartesian2 from './Cartesian2.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport Check from './Check.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport CesiumMath from './Math.js';\r\n\r\n    var RIGHT_SHIFT = 1.0 / 256.0;\r\n    var LEFT_SHIFT = 256.0;\r\n\r\n    /**\r\n     * Attribute compression and decompression functions.\r\n     *\r\n     * @exports AttributeCompression\r\n     *\r\n     * @private\r\n     */\r\n    var AttributeCompression = {};\r\n\r\n    /**\r\n     * Encodes a normalized vector into 2 SNORM values in the range of [0-rangeMax] following the 'oct' encoding.\r\n     *\r\n     * Oct encoding is a compact representation of unit length vectors.\r\n     * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit Vectors\",\r\n     * Cigolle et al 2014: {@link http://jcgt.org/published/0003/02/01/}\r\n     *\r\n     * @param {Cartesian3} vector The normalized vector to be compressed into 2 component 'oct' encoding.\r\n     * @param {Cartesian2} result The 2 component oct-encoded unit length vector.\r\n     * @param {Number} rangeMax The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\r\n     * @returns {Cartesian2} The 2 component oct-encoded unit length vector.\r\n     *\r\n     * @exception {DeveloperError} vector must be normalized.\r\n     *\r\n     * @see AttributeCompression.octDecodeInRange\r\n     */\r\n    AttributeCompression.octEncodeInRange = function(vector, rangeMax, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('vector', vector);\r\n        Check.defined('result', result);\r\n        var magSquared = Cartesian3.magnitudeSquared(vector);\r\n        if (Math.abs(magSquared - 1.0) > CesiumMath.EPSILON6) {\r\n            throw new DeveloperError('vector must be normalized.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        result.x = vector.x / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\r\n        result.y = vector.y / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\r\n        if (vector.z < 0) {\r\n            var x = result.x;\r\n            var y = result.y;\r\n            result.x = (1.0 - Math.abs(y)) * CesiumMath.signNotZero(x);\r\n            result.y = (1.0 - Math.abs(x)) * CesiumMath.signNotZero(y);\r\n        }\r\n\r\n        result.x = CesiumMath.toSNorm(result.x, rangeMax);\r\n        result.y = CesiumMath.toSNorm(result.y, rangeMax);\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the 'oct' encoding.\r\n     *\r\n     * @param {Cartesian3} vector The normalized vector to be compressed into 2 byte 'oct' encoding.\r\n     * @param {Cartesian2} result The 2 byte oct-encoded unit length vector.\r\n     * @returns {Cartesian2} The 2 byte oct-encoded unit length vector.\r\n     *\r\n     * @exception {DeveloperError} vector must be normalized.\r\n     *\r\n     * @see AttributeCompression.octEncodeInRange\r\n     * @see AttributeCompression.octDecode\r\n     */\r\n    AttributeCompression.octEncode = function(vector, result) {\r\n        return AttributeCompression.octEncodeInRange(vector, 255, result);\r\n    };\r\n\r\n    var octEncodeScratch = new Cartesian2();\r\n    var uint8ForceArray = new Uint8Array(1);\r\n    function forceUint8(value) {\r\n        uint8ForceArray[0] = value;\r\n        return uint8ForceArray[0];\r\n    }\r\n    /**\r\n     * @param {Cartesian3} vector The normalized vector to be compressed into 4 byte 'oct' encoding.\r\n     * @param {Cartesian4} result The 4 byte oct-encoded unit length vector.\r\n     * @returns {Cartesian4} The 4 byte oct-encoded unit length vector.\r\n     *\r\n     * @exception {DeveloperError} vector must be normalized.\r\n     *\r\n     * @see AttributeCompression.octEncodeInRange\r\n     * @see AttributeCompression.octDecodeFromCartesian4\r\n     */\r\n    AttributeCompression.octEncodeToCartesian4 = function(vector, result) {\r\n        AttributeCompression.octEncodeInRange(vector, 65535, octEncodeScratch);\r\n        result.x = forceUint8(octEncodeScratch.x * RIGHT_SHIFT);\r\n        result.y = forceUint8(octEncodeScratch.x);\r\n        result.z = forceUint8(octEncodeScratch.y * RIGHT_SHIFT);\r\n        result.w = forceUint8(octEncodeScratch.y);\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component vector.\r\n     *\r\n     * @param {Number} x The x component of the oct-encoded unit length vector.\r\n     * @param {Number} y The y component of the oct-encoded unit length vector.\r\n     * @param {Number} rangeMax The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\r\n     * @param {Cartesian3} result The decoded and normalized vector\r\n     * @returns {Cartesian3} The decoded and normalized vector.\r\n     *\r\n     * @exception {DeveloperError} x and y must be unsigned normalized integers between 0 and rangeMax.\r\n     *\r\n     * @see AttributeCompression.octEncodeInRange\r\n     */\r\n    AttributeCompression.octDecodeInRange = function(x, y, rangeMax, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('result', result);\r\n        if (x < 0 || x > rangeMax || y < 0 || y > rangeMax) {\r\n            throw new DeveloperError('x and y must be unsigned normalized integers between 0 and ' + rangeMax);\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        result.x = CesiumMath.fromSNorm(x, rangeMax);\r\n        result.y = CesiumMath.fromSNorm(y, rangeMax);\r\n        result.z = 1.0 - (Math.abs(result.x) + Math.abs(result.y));\r\n\r\n        if (result.z < 0.0)\r\n        {\r\n            var oldVX = result.x;\r\n            result.x = (1.0 - Math.abs(result.y)) * CesiumMath.signNotZero(oldVX);\r\n            result.y = (1.0 - Math.abs(oldVX)) * CesiumMath.signNotZero(result.y);\r\n        }\r\n\r\n        return Cartesian3.normalize(result, result);\r\n    };\r\n\r\n    /**\r\n     * Decodes a unit-length vector in 2 byte 'oct' encoding to a normalized 3-component vector.\r\n     *\r\n     * @param {Number} x The x component of the oct-encoded unit length vector.\r\n     * @param {Number} y The y component of the oct-encoded unit length vector.\r\n     * @param {Cartesian3} result The decoded and normalized vector.\r\n     * @returns {Cartesian3} The decoded and normalized vector.\r\n     *\r\n     * @exception {DeveloperError} x and y must be an unsigned normalized integer between 0 and 255.\r\n     *\r\n     * @see AttributeCompression.octDecodeInRange\r\n     */\r\n    AttributeCompression.octDecode = function(x, y, result) {\r\n        return AttributeCompression.octDecodeInRange(x, y, 255, result);\r\n    };\r\n\r\n    /**\r\n     * Decodes a unit-length vector in 4 byte 'oct' encoding to a normalized 3-component vector.\r\n     *\r\n     * @param {Cartesian4} encoded The oct-encoded unit length vector.\r\n     * @param {Cartesian3} result The decoded and normalized vector.\r\n     * @returns {Cartesian3} The decoded and normalized vector.\r\n     *\r\n     * @exception {DeveloperError} x, y, z, and w must be unsigned normalized integers between 0 and 255.\r\n     *\r\n     * @see AttributeCompression.octDecodeInRange\r\n     * @see AttributeCompression.octEncodeToCartesian4\r\n     */\r\n    AttributeCompression.octDecodeFromCartesian4 = function(encoded, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('encoded', encoded);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n        var x = encoded.x;\r\n        var y = encoded.y;\r\n        var z = encoded.z;\r\n        var w = encoded.w;\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (x < 0 || x > 255 || y < 0 || y > 255 || z < 0 || z > 255 || w < 0 || w > 255) {\r\n            throw new DeveloperError('x, y, z, and w must be unsigned normalized integers between 0 and 255');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var xOct16 = x * LEFT_SHIFT + y;\r\n        var yOct16 = z * LEFT_SHIFT + w;\r\n        return AttributeCompression.octDecodeInRange(xOct16, yOct16, 65535, result);\r\n    };\r\n\r\n    /**\r\n     * Packs an oct encoded vector into a single floating-point number.\r\n     *\r\n     * @param {Cartesian2} encoded The oct encoded vector.\r\n     * @returns {Number} The oct encoded vector packed into a single float.\r\n     *\r\n     */\r\n    AttributeCompression.octPackFloat = function(encoded) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('encoded', encoded);\r\n        //>>includeEnd('debug');\r\n        return 256.0 * encoded.x + encoded.y;\r\n    };\r\n\r\n    var scratchEncodeCart2 = new Cartesian2();\r\n\r\n    /**\r\n     * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the 'oct' encoding and\r\n     * stores those values in a single float-point number.\r\n     *\r\n     * @param {Cartesian3} vector The normalized vector to be compressed into 2 byte 'oct' encoding.\r\n     * @returns {Number} The 2 byte oct-encoded unit length vector.\r\n     *\r\n     * @exception {DeveloperError} vector must be normalized.\r\n     */\r\n    AttributeCompression.octEncodeFloat = function(vector) {\r\n        AttributeCompression.octEncode(vector, scratchEncodeCart2);\r\n        return AttributeCompression.octPackFloat(scratchEncodeCart2);\r\n    };\r\n\r\n    /**\r\n     * Decodes a unit-length vector in 'oct' encoding packed in a floating-point number to a normalized 3-component vector.\r\n     *\r\n     * @param {Number} value The oct-encoded unit length vector stored as a single floating-point number.\r\n     * @param {Cartesian3} result The decoded and normalized vector\r\n     * @returns {Cartesian3} The decoded and normalized vector.\r\n     *\r\n     */\r\n    AttributeCompression.octDecodeFloat = function(value, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('value', value);\r\n        //>>includeEnd('debug');\r\n\r\n        var temp = value / 256.0;\r\n        var x = Math.floor(temp);\r\n        var y = (temp - x) * 256.0;\r\n\r\n        return AttributeCompression.octDecode(x, y, result);\r\n    };\r\n\r\n    /**\r\n     * Encodes three normalized vectors into 6 SNORM values in the range of [0-255] following the 'oct' encoding and\r\n     * packs those into two floating-point numbers.\r\n     *\r\n     * @param {Cartesian3} v1 A normalized vector to be compressed.\r\n     * @param {Cartesian3} v2 A normalized vector to be compressed.\r\n     * @param {Cartesian3} v3 A normalized vector to be compressed.\r\n     * @param {Cartesian2} result The 'oct' encoded vectors packed into two floating-point numbers.\r\n     * @returns {Cartesian2} The 'oct' encoded vectors packed into two floating-point numbers.\r\n     *\r\n     */\r\n    AttributeCompression.octPack = function(v1, v2, v3, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('v1', v1);\r\n        Check.defined('v2', v2);\r\n        Check.defined('v3', v3);\r\n        Check.defined('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        var encoded1 = AttributeCompression.octEncodeFloat(v1);\r\n        var encoded2 = AttributeCompression.octEncodeFloat(v2);\r\n\r\n        var encoded3 = AttributeCompression.octEncode(v3, scratchEncodeCart2);\r\n        result.x = 65536.0 * encoded3.x + encoded1;\r\n        result.y = 65536.0 * encoded3.y + encoded2;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Decodes three unit-length vectors in 'oct' encoding packed into a floating-point number to a normalized 3-component vector.\r\n     *\r\n     * @param {Cartesian2} packed The three oct-encoded unit length vectors stored as two floating-point number.\r\n     * @param {Cartesian3} v1 One decoded and normalized vector.\r\n     * @param {Cartesian3} v2 One decoded and normalized vector.\r\n     * @param {Cartesian3} v3 One decoded and normalized vector.\r\n     */\r\n    AttributeCompression.octUnpack = function(packed, v1, v2, v3) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('packed', packed);\r\n        Check.defined('v1', v1);\r\n        Check.defined('v2', v2);\r\n        Check.defined('v3', v3);\r\n        //>>includeEnd('debug');\r\n\r\n        var temp = packed.x / 65536.0;\r\n        var x = Math.floor(temp);\r\n        var encodedFloat1 = (temp - x) * 65536.0;\r\n\r\n        temp = packed.y / 65536.0;\r\n        var y = Math.floor(temp);\r\n        var encodedFloat2 = (temp - y) * 65536.0;\r\n\r\n        AttributeCompression.octDecodeFloat(encodedFloat1, v1);\r\n        AttributeCompression.octDecodeFloat(encodedFloat2, v2);\r\n        AttributeCompression.octDecode(x, y, v3);\r\n    };\r\n\r\n    /**\r\n     * Pack texture coordinates into a single float. The texture coordinates will only preserve 12 bits of precision.\r\n     *\r\n     * @param {Cartesian2} textureCoordinates The texture coordinates to compress.  Both coordinates must be in the range 0.0-1.0.\r\n     * @returns {Number} The packed texture coordinates.\r\n     *\r\n     */\r\n    AttributeCompression.compressTextureCoordinates = function(textureCoordinates) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('textureCoordinates', textureCoordinates);\r\n        //>>includeEnd('debug');\r\n\r\n        // Move x and y to the range 0-4095;\r\n        var x = (textureCoordinates.x * 4095.0) | 0;\r\n        var y = (textureCoordinates.y * 4095.0) | 0;\r\n        return 4096.0 * x + y;\r\n    };\r\n\r\n    /**\r\n     * Decompresses texture coordinates that were packed into a single float.\r\n     *\r\n     * @param {Number} compressed The compressed texture coordinates.\r\n     * @param {Cartesian2} result The decompressed texture coordinates.\r\n     * @returns {Cartesian2} The modified result parameter.\r\n     *\r\n     */\r\n    AttributeCompression.decompressTextureCoordinates = function(compressed, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('compressed', compressed);\r\n        Check.defined('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        var temp = compressed / 4096.0;\r\n        var xZeroTo4095 = Math.floor(temp);\r\n        result.x = xZeroTo4095 / 4095.0;\r\n        result.y = (compressed - xZeroTo4095 * 4096) / 4095;\r\n        return result;\r\n    };\r\n\r\n    function zigZagDecode(value) {\r\n        return (value >> 1) ^ (-(value & 1));\r\n    }\r\n\r\n    /**\r\n     * Decodes delta and ZigZag encoded vertices. This modifies the buffers in place.\r\n     *\r\n     * @param {Uint16Array} uBuffer The buffer view of u values.\r\n     * @param {Uint16Array} vBuffer The buffer view of v values.\r\n     * @param {Uint16Array} [heightBuffer] The buffer view of height values.\r\n     *\r\n     * @see {@link https://github.com/CesiumGS/quantized-mesh|quantized-mesh-1.0 terrain format}\r\n     */\r\n    AttributeCompression.zigZagDeltaDecode = function(uBuffer, vBuffer, heightBuffer) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('uBuffer', uBuffer);\r\n        Check.defined('vBuffer', vBuffer);\r\n        Check.typeOf.number.equals('uBuffer.length', 'vBuffer.length', uBuffer.length, vBuffer.length);\r\n        if (defined(heightBuffer)) {\r\n            Check.typeOf.number.equals('uBuffer.length', 'heightBuffer.length', uBuffer.length, heightBuffer.length);\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var count = uBuffer.length;\r\n\r\n        var u = 0;\r\n        var v = 0;\r\n        var height = 0;\r\n\r\n        for (var i = 0; i < count; ++i) {\r\n            u += zigZagDecode(uBuffer[i]);\r\n            v += zigZagDecode(vBuffer[i]);\r\n\r\n            uBuffer[i] = u;\r\n            vBuffer[i] = v;\r\n\r\n            if (defined(heightBuffer)) {\r\n                height += zigZagDecode(heightBuffer[i]);\r\n                heightBuffer[i] = height;\r\n            }\r\n        }\r\n    };\r\nexport default AttributeCompression;\r\n"],"names":["AttributeCompression","octEncodeInRange","vector","rangeMax","result","Check","defined","magSquared","Cartesian3","magnitudeSquared","Math","abs","CesiumMath","EPSILON6","DeveloperError","x","y","z","signNotZero","toSNorm","octEncode","octEncodeScratch","Cartesian2","uint8ForceArray","Uint8Array","forceUint8","value","octEncodeToCartesian4","w","octDecodeInRange","fromSNorm","oldVX","normalize","octDecode","octDecodeFromCartesian4","encoded","typeOf","object","xOct16","yOct16","octPackFloat","scratchEncodeCart2","zigZagDecode","octEncodeFloat","octDecodeFloat","temp","floor","octPack","v1","v2","v3","encoded1","encoded2","encoded3","octUnpack","packed","encodedFloat1","encodedFloat2","compressTextureCoordinates","textureCoordinates","decompressTextureCoordinates","compressed","xZeroTo4095","zigZagDeltaDecode","uBuffer","vBuffer","heightBuffer","number","equals","length","count","u","v","height","i"],"mappings":"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"}