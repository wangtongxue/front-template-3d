{"version":3,"file":"EllipseGeometryLibrary-20fd67d7.js","sources":["../../../../Source/Core/EllipseGeometryLibrary.js"],"sourcesContent":["import Cartesian3 from './Cartesian3.js';\r\nimport CesiumMath from './Math.js';\r\nimport Matrix3 from './Matrix3.js';\r\nimport Quaternion from './Quaternion.js';\r\n\r\n    var EllipseGeometryLibrary = {};\r\n\r\n    var rotAxis = new Cartesian3();\r\n    var tempVec = new Cartesian3();\r\n    var unitQuat = new Quaternion();\r\n    var rotMtx = new Matrix3();\r\n\r\n    function pointOnEllipsoid(theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, result) {\r\n        var azimuth = theta + rotation;\r\n\r\n        Cartesian3.multiplyByScalar(eastVec, Math.cos(azimuth), rotAxis);\r\n        Cartesian3.multiplyByScalar(northVec, Math.sin(azimuth), tempVec);\r\n        Cartesian3.add(rotAxis, tempVec, rotAxis);\r\n\r\n        var cosThetaSquared = Math.cos(theta);\r\n        cosThetaSquared = cosThetaSquared * cosThetaSquared;\r\n\r\n        var sinThetaSquared = Math.sin(theta);\r\n        sinThetaSquared = sinThetaSquared * sinThetaSquared;\r\n\r\n        var radius = ab / Math.sqrt(bSqr * cosThetaSquared + aSqr * sinThetaSquared);\r\n        var angle = radius / mag;\r\n\r\n        // Create the quaternion to rotate the position vector to the boundary of the ellipse.\r\n        Quaternion.fromAxisAngle(rotAxis, angle, unitQuat);\r\n        Matrix3.fromQuaternion(unitQuat, rotMtx);\r\n\r\n        Matrix3.multiplyByVector(rotMtx, unitPos, result);\r\n        Cartesian3.normalize(result, result);\r\n        Cartesian3.multiplyByScalar(result, mag, result);\r\n        return result;\r\n    }\r\n\r\n    var scratchCartesian1 = new Cartesian3();\r\n    var scratchCartesian2 = new Cartesian3();\r\n    var scratchCartesian3 = new Cartesian3();\r\n    var scratchNormal = new Cartesian3();\r\n    /**\r\n     * Returns the positions raised to the given heights\r\n     * @private\r\n     */\r\n    EllipseGeometryLibrary.raisePositionsToHeight = function(positions, options, extrude) {\r\n        var ellipsoid = options.ellipsoid;\r\n        var height = options.height;\r\n        var extrudedHeight = options.extrudedHeight;\r\n        var size = (extrude) ? positions.length / 3 * 2 : positions.length / 3;\r\n\r\n        var finalPositions = new Float64Array(size * 3);\r\n\r\n        var length = positions.length;\r\n        var bottomOffset = (extrude) ? length : 0;\r\n        for (var i = 0; i < length; i += 3) {\r\n            var i1 = i + 1;\r\n            var i2 = i + 2;\r\n\r\n            var position = Cartesian3.fromArray(positions, i, scratchCartesian1);\r\n            ellipsoid.scaleToGeodeticSurface(position, position);\r\n\r\n            var extrudedPosition = Cartesian3.clone(position, scratchCartesian2);\r\n            var normal = ellipsoid.geodeticSurfaceNormal(position, scratchNormal);\r\n            var scaledNormal = Cartesian3.multiplyByScalar(normal, height, scratchCartesian3);\r\n            Cartesian3.add(position, scaledNormal, position);\r\n\r\n            if (extrude) {\r\n                Cartesian3.multiplyByScalar(normal, extrudedHeight, scaledNormal);\r\n                Cartesian3.add(extrudedPosition, scaledNormal, extrudedPosition);\r\n\r\n                finalPositions[i + bottomOffset] = extrudedPosition.x;\r\n                finalPositions[i1 + bottomOffset] = extrudedPosition.y;\r\n                finalPositions[i2 + bottomOffset] = extrudedPosition.z;\r\n            }\r\n\r\n            finalPositions[i] = position.x;\r\n            finalPositions[i1] = position.y;\r\n            finalPositions[i2] = position.z;\r\n        }\r\n\r\n        return finalPositions;\r\n    };\r\n\r\n    var unitPosScratch = new Cartesian3();\r\n    var eastVecScratch = new Cartesian3();\r\n    var northVecScratch = new Cartesian3();\r\n    /**\r\n     * Returns an array of positions that make up the ellipse.\r\n     * @private\r\n     */\r\n    EllipseGeometryLibrary.computeEllipsePositions = function(options, addFillPositions, addEdgePositions) {\r\n        var semiMinorAxis = options.semiMinorAxis;\r\n        var semiMajorAxis = options.semiMajorAxis;\r\n        var rotation = options.rotation;\r\n        var center = options.center;\r\n\r\n        // Computing the arc-length of the ellipse is too expensive to be practical. Estimating it using the\r\n        // arc length of the sphere is too inaccurate and creates sharp edges when either the semi-major or\r\n        // semi-minor axis is much bigger than the other. Instead, scale the angle delta to make\r\n        // the distance along the ellipse boundary more closely match the granularity.\r\n        var granularity = options.granularity * 8.0;\r\n\r\n        var aSqr = semiMinorAxis * semiMinorAxis;\r\n        var bSqr = semiMajorAxis * semiMajorAxis;\r\n        var ab = semiMajorAxis * semiMinorAxis;\r\n\r\n        var mag = Cartesian3.magnitude(center);\r\n\r\n        var unitPos = Cartesian3.normalize(center, unitPosScratch);\r\n        var eastVec = Cartesian3.cross(Cartesian3.UNIT_Z, center, eastVecScratch);\r\n        eastVec = Cartesian3.normalize(eastVec, eastVec);\r\n        var northVec = Cartesian3.cross(unitPos, eastVec, northVecScratch);\r\n\r\n        // The number of points in the first quadrant\r\n        var numPts = 1 + Math.ceil(CesiumMath.PI_OVER_TWO / granularity);\r\n\r\n        var deltaTheta = CesiumMath.PI_OVER_TWO / (numPts - 1);\r\n        var theta = CesiumMath.PI_OVER_TWO - numPts * deltaTheta;\r\n        if (theta < 0.0) {\r\n            numPts -= Math.ceil(Math.abs(theta) / deltaTheta);\r\n        }\r\n\r\n        // If the number of points were three, the ellipse\r\n        // would be tessellated like below:\r\n        //\r\n        //         *---*\r\n        //       / | \\ | \\\r\n        //     *---*---*---*\r\n        //   / | \\ | \\ | \\ | \\\r\n        //  / .*---*---*---*. \\\r\n        // * ` | \\ | \\ | \\ | `*\r\n        //  \\`.*---*---*---*.`/\r\n        //   \\ | \\ | \\ | \\ | /\r\n        //     *---*---*---*\r\n        //       \\ | \\ | /\r\n        //         *---*\r\n        // The first and last column have one position and fan to connect to the adjacent column.\r\n        // Each other vertical column contains an even number of positions.\r\n        var size = 2 * (numPts * (numPts + 2));\r\n        var positions = (addFillPositions) ? new Array(size * 3) : undefined;\r\n        var positionIndex = 0;\r\n        var position = scratchCartesian1;\r\n        var reflectedPosition = scratchCartesian2;\r\n\r\n        var outerPositionsLength = (numPts * 4) * 3;\r\n        var outerRightIndex = outerPositionsLength - 1;\r\n        var outerLeftIndex = 0;\r\n        var outerPositions = (addEdgePositions) ? new Array(outerPositionsLength) : undefined;\r\n\r\n        var i;\r\n        var j;\r\n        var numInterior;\r\n        var t;\r\n        var interiorPosition;\r\n\r\n        // Compute points in the 'eastern' half of the ellipse\r\n        theta = CesiumMath.PI_OVER_TWO;\r\n        position = pointOnEllipsoid(theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);\r\n        if (addFillPositions) {\r\n            positions[positionIndex++] = position.x;\r\n            positions[positionIndex++] = position.y;\r\n            positions[positionIndex++] = position.z;\r\n        }\r\n        if (addEdgePositions) {\r\n            outerPositions[outerRightIndex--] = position.z;\r\n            outerPositions[outerRightIndex--] = position.y;\r\n            outerPositions[outerRightIndex--] = position.x;\r\n        }\r\n        theta = CesiumMath.PI_OVER_TWO -  deltaTheta;\r\n        for (i = 1; i < numPts + 1; ++i) {\r\n            position = pointOnEllipsoid(theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);\r\n            reflectedPosition = pointOnEllipsoid(Math.PI - theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, reflectedPosition);\r\n\r\n            if (addFillPositions) {\r\n                positions[positionIndex++] = position.x;\r\n                positions[positionIndex++] = position.y;\r\n                positions[positionIndex++] = position.z;\r\n\r\n                numInterior = 2 * i + 2;\r\n                for (j = 1; j < numInterior - 1; ++j) {\r\n                    t = j / (numInterior - 1);\r\n                    interiorPosition = Cartesian3.lerp(position, reflectedPosition, t, scratchCartesian3);\r\n                    positions[positionIndex++] = interiorPosition.x;\r\n                    positions[positionIndex++] = interiorPosition.y;\r\n                    positions[positionIndex++] = interiorPosition.z;\r\n                }\r\n\r\n                positions[positionIndex++] = reflectedPosition.x;\r\n                positions[positionIndex++] = reflectedPosition.y;\r\n                positions[positionIndex++] = reflectedPosition.z;\r\n            }\r\n\r\n            if (addEdgePositions) {\r\n                outerPositions[outerRightIndex--] = position.z;\r\n                outerPositions[outerRightIndex--] = position.y;\r\n                outerPositions[outerRightIndex--] = position.x;\r\n                outerPositions[outerLeftIndex++] = reflectedPosition.x;\r\n                outerPositions[outerLeftIndex++] = reflectedPosition.y;\r\n                outerPositions[outerLeftIndex++] = reflectedPosition.z;\r\n            }\r\n\r\n            theta = CesiumMath.PI_OVER_TWO - (i + 1) * deltaTheta;\r\n        }\r\n\r\n        // Compute points in the 'western' half of the ellipse\r\n        for (i = numPts; i > 1; --i) {\r\n            theta = CesiumMath.PI_OVER_TWO - (i - 1) * deltaTheta;\r\n\r\n            position = pointOnEllipsoid(-theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);\r\n            reflectedPosition = pointOnEllipsoid(theta + Math.PI, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, reflectedPosition);\r\n\r\n            if (addFillPositions) {\r\n                positions[positionIndex++] = position.x;\r\n                positions[positionIndex++] = position.y;\r\n                positions[positionIndex++] = position.z;\r\n\r\n                numInterior = 2 * (i - 1) + 2;\r\n                for (j = 1; j < numInterior - 1; ++j) {\r\n                    t = j / (numInterior - 1);\r\n                    interiorPosition = Cartesian3.lerp(position, reflectedPosition, t, scratchCartesian3);\r\n                    positions[positionIndex++] = interiorPosition.x;\r\n                    positions[positionIndex++] = interiorPosition.y;\r\n                    positions[positionIndex++] = interiorPosition.z;\r\n                }\r\n\r\n                positions[positionIndex++] = reflectedPosition.x;\r\n                positions[positionIndex++] = reflectedPosition.y;\r\n                positions[positionIndex++] = reflectedPosition.z;\r\n            }\r\n\r\n            if (addEdgePositions) {\r\n                outerPositions[outerRightIndex--] = position.z;\r\n                outerPositions[outerRightIndex--] = position.y;\r\n                outerPositions[outerRightIndex--] = position.x;\r\n                outerPositions[outerLeftIndex++] = reflectedPosition.x;\r\n                outerPositions[outerLeftIndex++] = reflectedPosition.y;\r\n                outerPositions[outerLeftIndex++] = reflectedPosition.z;\r\n            }\r\n        }\r\n\r\n        theta = CesiumMath.PI_OVER_TWO;\r\n        position = pointOnEllipsoid(-theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);\r\n\r\n        var r = {};\r\n        if (addFillPositions) {\r\n            positions[positionIndex++] = position.x;\r\n            positions[positionIndex++] = position.y;\r\n            positions[positionIndex++] = position.z;\r\n            r.positions = positions;\r\n            r.numPts = numPts;\r\n        }\r\n        if (addEdgePositions) {\r\n            outerPositions[outerRightIndex--] = position.z;\r\n            outerPositions[outerRightIndex--] = position.y;\r\n            outerPositions[outerRightIndex--] = position.x;\r\n            r.outerPositions = outerPositions;\r\n        }\r\n\r\n        return r;\r\n    };\r\nexport default EllipseGeometryLibrary;\r\n"],"names":["EllipseGeometryLibrary","rotAxis","Cartesian3","tempVec","unitQuat","Quaternion","rotMtx","Matrix3","pointOnEllipsoid","theta","rotation","northVec","eastVec","aSqr","ab","bSqr","mag","unitPos","result","azimuth","multiplyByScalar","Math","cos","sin","add","cosThetaSquared","sinThetaSquared","angle","sqrt","fromAxisAngle","fromQuaternion","multiplyByVector","normalize","scratchCartesian1","scratchCartesian2","scratchCartesian3","scratchNormal","raisePositionsToHeight","positions","options","extrude","ellipsoid","height","extrudedHeight","size","length","finalPositions","Float64Array","bottomOffset","i","i1","i2","position","fromArray","scaleToGeodeticSurface","extrudedPosition","clone","normal","geodeticSurfaceNormal","scaledNormal","x","y","z","unitPosScratch","eastVecScratch","northVecScratch","computeEllipsePositions","addFillPositions","addEdgePositions","semiMinorAxis","semiMajorAxis","center","granularity","magnitude","cross","UNIT_Z","numPts","ceil","CesiumMath","PI_OVER_TWO","deltaTheta","abs","j","numInterior","t","interiorPosition","Array","undefined","positionIndex","reflectedPosition","outerPositionsLength","outerRightIndex","outerLeftIndex","outerPositions","PI","lerp","r"],"mappings":"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"}