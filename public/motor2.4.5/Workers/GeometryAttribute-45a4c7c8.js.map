{"version":3,"file":"GeometryAttribute-45a4c7c8.js","sources":["../../../../Source/Core/GeometryType.js","../../../../Source/Core/Matrix2.js","../../../../Source/Core/PrimitiveType.js","../../../../Source/Core/Geometry.js","../../../../Source/Core/GeometryAttribute.js"],"sourcesContent":["\r\n    /**\r\n     * @private\r\n     */\r\n    var GeometryType = {\r\n        NONE : 0,\r\n        TRIANGLES : 1,\r\n        LINES : 2,\r\n        POLYLINES : 3\r\n    };\r\nexport default Object.freeze(GeometryType);\r\n","import Cartesian2 from './Cartesian2.js';\r\nimport Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\n\r\n    /**\r\n     * A 2x2 matrix, indexable as a column-major order array.\r\n     * Constructor parameters are in row-major order for code readability.\r\n     * @alias Matrix2\r\n     * @constructor\r\n     *\r\n     * @param {Number} [column0Row0=0.0] The value for column 0, row 0.\r\n     * @param {Number} [column1Row0=0.0] The value for column 1, row 0.\r\n     * @param {Number} [column0Row1=0.0] The value for column 0, row 1.\r\n     * @param {Number} [column1Row1=0.0] The value for column 1, row 1.\r\n     *\r\n     * @see Matrix2.fromColumnMajorArray\r\n     * @see Matrix2.fromRowMajorArray\r\n     * @see Matrix2.fromScale\r\n     * @see Matrix2.fromUniformScale\r\n     * @see Matrix3\r\n     * @see Matrix4\r\n     */\r\n    function Matrix2(column0Row0, column1Row0, column0Row1, column1Row1) {\r\n        this[0] = defaultValue(column0Row0, 0.0);\r\n        this[1] = defaultValue(column0Row1, 0.0);\r\n        this[2] = defaultValue(column1Row0, 0.0);\r\n        this[3] = defaultValue(column1Row1, 0.0);\r\n    }\r\n\r\n    /**\r\n     * The number of elements used to pack the object into an array.\r\n     * @type {Number}\r\n     */\r\n    Matrix2.packedLength = 4;\r\n\r\n    /**\r\n     * Stores the provided instance into the provided array.\r\n     *\r\n     * @param {Matrix2} value The value to pack.\r\n     * @param {Number[]} array The array to pack into.\r\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n     *\r\n     * @returns {Number[]} The array that was packed into\r\n     */\r\n    Matrix2.pack = function(value, array, startingIndex) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('value', value);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        array[startingIndex++] = value[0];\r\n        array[startingIndex++] = value[1];\r\n        array[startingIndex++] = value[2];\r\n        array[startingIndex++] = value[3];\r\n\r\n        return array;\r\n    };\r\n\r\n    /**\r\n     * Retrieves an instance from a packed array.\r\n     *\r\n     * @param {Number[]} array The packed array.\r\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n     * @param {Matrix2} [result] The object into which to store the result.\r\n     * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\r\n     */\r\n    Matrix2.unpack = function(array, startingIndex, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        if (!defined(result)) {\r\n            result = new Matrix2();\r\n        }\r\n\r\n        result[0] = array[startingIndex++];\r\n        result[1] = array[startingIndex++];\r\n        result[2] = array[startingIndex++];\r\n        result[3] = array[startingIndex++];\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Duplicates a Matrix2 instance.\r\n     *\r\n     * @param {Matrix2} matrix The matrix to duplicate.\r\n     * @param {Matrix2} [result] The object onto which to store the result.\r\n     * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided. (Returns undefined if matrix is undefined)\r\n     */\r\n    Matrix2.clone = function(matrix, result) {\r\n        if (!defined(matrix)) {\r\n            return undefined;\r\n        }\r\n        if (!defined(result)) {\r\n            return new Matrix2(matrix[0], matrix[2],\r\n                               matrix[1], matrix[3]);\r\n        }\r\n        result[0] = matrix[0];\r\n        result[1] = matrix[1];\r\n        result[2] = matrix[2];\r\n        result[3] = matrix[3];\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Creates a Matrix2 from 4 consecutive elements in an array.\r\n     *\r\n     * @param {Number[]} array The array whose 4 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.\r\n     * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.\r\n     * @param {Matrix2} [result] The object onto which to store the result.\r\n     * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\r\n     *\r\n     * @example\r\n     * // Create the Matrix2:\r\n     * // [1.0, 2.0]\r\n     * // [1.0, 2.0]\r\n     *\r\n     * var v = [1.0, 1.0, 2.0, 2.0];\r\n     * var m = Cesium.Matrix2.fromArray(v);\r\n     *\r\n     * // Create same Matrix2 with using an offset into an array\r\n     * var v2 = [0.0, 0.0, 1.0, 1.0, 2.0, 2.0];\r\n     * var m2 = Cesium.Matrix2.fromArray(v2, 2);\r\n     */\r\n    Matrix2.fromArray = function(array, startingIndex, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        if (!defined(result)) {\r\n            result = new Matrix2();\r\n        }\r\n\r\n        result[0] = array[startingIndex];\r\n        result[1] = array[startingIndex + 1];\r\n        result[2] = array[startingIndex + 2];\r\n        result[3] = array[startingIndex + 3];\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Creates a Matrix2 instance from a column-major order array.\r\n     *\r\n     * @param {Number[]} values The column-major order array.\r\n     * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\r\n     * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\r\n     */\r\n    Matrix2.fromColumnMajorArray = function(values, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('values', values);\r\n        //>>includeEnd('debug');\r\n\r\n        return Matrix2.clone(values, result);\r\n    };\r\n\r\n    /**\r\n     * Creates a Matrix2 instance from a row-major order array.\r\n     * The resulting matrix will be in column-major order.\r\n     *\r\n     * @param {Number[]} values The row-major order array.\r\n     * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\r\n     * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\r\n     */\r\n    Matrix2.fromRowMajorArray = function(values, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('values', values);\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            return new Matrix2(values[0], values[1],\r\n                               values[2], values[3]);\r\n        }\r\n        result[0] = values[0];\r\n        result[1] = values[2];\r\n        result[2] = values[1];\r\n        result[3] = values[3];\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes a Matrix2 instance representing a non-uniform scale.\r\n     *\r\n     * @param {Cartesian2} scale The x and y scale factors.\r\n     * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\r\n     * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\r\n     *\r\n     * @example\r\n     * // Creates\r\n     * //   [7.0, 0.0]\r\n     * //   [0.0, 8.0]\r\n     * var m = Cesium.Matrix2.fromScale(new Cesium.Cartesian2(7.0, 8.0));\r\n     */\r\n    Matrix2.fromScale = function(scale, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('scale', scale);\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            return new Matrix2(\r\n                scale.x, 0.0,\r\n                0.0,     scale.y);\r\n        }\r\n\r\n        result[0] = scale.x;\r\n        result[1] = 0.0;\r\n        result[2] = 0.0;\r\n        result[3] = scale.y;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes a Matrix2 instance representing a uniform scale.\r\n     *\r\n     * @param {Number} scale The uniform scale factor.\r\n     * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\r\n     * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\r\n     *\r\n     * @example\r\n     * // Creates\r\n     * //   [2.0, 0.0]\r\n     * //   [0.0, 2.0]\r\n     * var m = Cesium.Matrix2.fromUniformScale(2.0);\r\n     */\r\n    Matrix2.fromUniformScale = function(scale, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.number('scale', scale);\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            return new Matrix2(\r\n                scale, 0.0,\r\n                0.0,   scale);\r\n        }\r\n\r\n        result[0] = scale;\r\n        result[1] = 0.0;\r\n        result[2] = 0.0;\r\n        result[3] = scale;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Creates a rotation matrix.\r\n     *\r\n     * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\r\n     * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\r\n     * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\r\n     *\r\n     * @example\r\n     * // Rotate a point 45 degrees counterclockwise.\r\n     * var p = new Cesium.Cartesian2(5, 6);\r\n     * var m = Cesium.Matrix2.fromRotation(Cesium.Math.toRadians(45.0));\r\n     * var rotated = Cesium.Matrix2.multiplyByVector(m, p, new Cesium.Cartesian2());\r\n     */\r\n    Matrix2.fromRotation = function(angle, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.number('angle', angle);\r\n        //>>includeEnd('debug');\r\n\r\n        var cosAngle = Math.cos(angle);\r\n        var sinAngle = Math.sin(angle);\r\n\r\n        if (!defined(result)) {\r\n            return new Matrix2(\r\n                cosAngle, -sinAngle,\r\n                sinAngle, cosAngle);\r\n        }\r\n        result[0] = cosAngle;\r\n        result[1] = sinAngle;\r\n        result[2] = -sinAngle;\r\n        result[3] = cosAngle;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Creates an Array from the provided Matrix2 instance.\r\n     * The array will be in column-major order.\r\n     *\r\n     * @param {Matrix2} matrix The matrix to use..\r\n     * @param {Number[]} [result] The Array onto which to store the result.\r\n     * @returns {Number[]} The modified Array parameter or a new Array instance if one was not provided.\r\n     */\r\n    Matrix2.toArray = function(matrix, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('matrix', matrix);\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            return [matrix[0], matrix[1], matrix[2], matrix[3]];\r\n        }\r\n        result[0] = matrix[0];\r\n        result[1] = matrix[1];\r\n        result[2] = matrix[2];\r\n        result[3] = matrix[3];\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the array index of the element at the provided row and column.\r\n     *\r\n     * @param {Number} row The zero-based index of the row.\r\n     * @param {Number} column The zero-based index of the column.\r\n     * @returns {Number} The index of the element at the provided row and column.\r\n     *\r\n     * @exception {DeveloperError} row must be 0 or 1.\r\n     * @exception {DeveloperError} column must be 0 or 1.\r\n     *\r\n     * @example\r\n     * var myMatrix = new Cesium.Matrix2();\r\n     * var column1Row0Index = Cesium.Matrix2.getElementIndex(1, 0);\r\n     * var column1Row0 = myMatrix[column1Row0Index]\r\n     * myMatrix[column1Row0Index] = 10.0;\r\n     */\r\n    Matrix2.getElementIndex = function(column, row) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.number.greaterThanOrEquals('row', row, 0);\r\n        Check.typeOf.number.lessThanOrEquals('row', row, 1);\r\n\r\n        Check.typeOf.number.greaterThanOrEquals('column', column, 0);\r\n        Check.typeOf.number.lessThanOrEquals('column', column, 1);\r\n        //>>includeEnd('debug');\r\n\r\n        return column * 2 + row;\r\n    };\r\n\r\n    /**\r\n     * Retrieves a copy of the matrix column at the provided index as a Cartesian2 instance.\r\n     *\r\n     * @param {Matrix2} matrix The matrix to use.\r\n     * @param {Number} index The zero-based index of the column to retrieve.\r\n     * @param {Cartesian2} result The object onto which to store the result.\r\n     * @returns {Cartesian2} The modified result parameter.\r\n     *\r\n     * @exception {DeveloperError} index must be 0 or 1.\r\n     */\r\n    Matrix2.getColumn = function(matrix, index, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('matrix', matrix);\r\n\r\n        Check.typeOf.number.greaterThanOrEquals('index', index, 0);\r\n        Check.typeOf.number.lessThanOrEquals('index', index, 1);\r\n\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        var startIndex = index * 2;\r\n        var x = matrix[startIndex];\r\n        var y = matrix[startIndex + 1];\r\n\r\n        result.x = x;\r\n        result.y = y;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian2 instance.\r\n     *\r\n     * @param {Matrix2} matrix The matrix to use.\r\n     * @param {Number} index The zero-based index of the column to set.\r\n     * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified column.\r\n     * @param {Cartesian2} result The object onto which to store the result.\r\n     * @returns {Matrix2} The modified result parameter.\r\n     *\r\n     * @exception {DeveloperError} index must be 0 or 1.\r\n     */\r\n    Matrix2.setColumn = function(matrix, index, cartesian, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('matrix', matrix);\r\n\r\n        Check.typeOf.number.greaterThanOrEquals('index', index, 0);\r\n        Check.typeOf.number.lessThanOrEquals('index', index, 1);\r\n\r\n        Check.typeOf.object('cartesian', cartesian);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        result = Matrix2.clone(matrix, result);\r\n        var startIndex = index * 2;\r\n        result[startIndex] = cartesian.x;\r\n        result[startIndex + 1] = cartesian.y;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Retrieves a copy of the matrix row at the provided index as a Cartesian2 instance.\r\n     *\r\n     * @param {Matrix2} matrix The matrix to use.\r\n     * @param {Number} index The zero-based index of the row to retrieve.\r\n     * @param {Cartesian2} result The object onto which to store the result.\r\n     * @returns {Cartesian2} The modified result parameter.\r\n     *\r\n     * @exception {DeveloperError} index must be 0 or 1.\r\n     */\r\n    Matrix2.getRow = function(matrix, index, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('matrix', matrix);\r\n\r\n        Check.typeOf.number.greaterThanOrEquals('index', index, 0);\r\n        Check.typeOf.number.lessThanOrEquals('index', index, 1);\r\n\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        var x = matrix[index];\r\n        var y = matrix[index + 2];\r\n\r\n        result.x = x;\r\n        result.y = y;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian2 instance.\r\n     *\r\n     * @param {Matrix2} matrix The matrix to use.\r\n     * @param {Number} index The zero-based index of the row to set.\r\n     * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified row.\r\n     * @param {Matrix2} result The object onto which to store the result.\r\n     * @returns {Matrix2} The modified result parameter.\r\n     *\r\n     * @exception {DeveloperError} index must be 0 or 1.\r\n     */\r\n    Matrix2.setRow = function(matrix, index, cartesian, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('matrix', matrix);\r\n\r\n        Check.typeOf.number.greaterThanOrEquals('index', index, 0);\r\n        Check.typeOf.number.lessThanOrEquals('index', index, 1);\r\n\r\n        Check.typeOf.object('cartesian', cartesian);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        result = Matrix2.clone(matrix, result);\r\n        result[index] = cartesian.x;\r\n        result[index + 2] = cartesian.y;\r\n        return result;\r\n    };\r\n\r\n    var scratchColumn = new Cartesian2();\r\n\r\n    /**\r\n     * Extracts the non-uniform scale assuming the matrix is an affine transformation.\r\n     *\r\n     * @param {Matrix2} matrix The matrix.\r\n     * @param {Cartesian2} result The object onto which to store the result.\r\n     * @returns {Cartesian2} The modified result parameter.\r\n     */\r\n    Matrix2.getScale = function(matrix, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('matrix', matrix);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        result.x = Cartesian2.magnitude(Cartesian2.fromElements(matrix[0], matrix[1], scratchColumn));\r\n        result.y = Cartesian2.magnitude(Cartesian2.fromElements(matrix[2], matrix[3], scratchColumn));\r\n        return result;\r\n    };\r\n\r\n    var scratchScale = new Cartesian2();\r\n\r\n    /**\r\n     * Computes the maximum scale assuming the matrix is an affine transformation.\r\n     * The maximum scale is the maximum length of the column vectors.\r\n     *\r\n     * @param {Matrix2} matrix The matrix.\r\n     * @returns {Number} The maximum scale.\r\n     */\r\n    Matrix2.getMaximumScale = function(matrix) {\r\n        Matrix2.getScale(matrix, scratchScale);\r\n        return Cartesian2.maximumComponent(scratchScale);\r\n    };\r\n\r\n    /**\r\n     * Computes the product of two matrices.\r\n     *\r\n     * @param {Matrix2} left The first matrix.\r\n     * @param {Matrix2} right The second matrix.\r\n     * @param {Matrix2} result The object onto which to store the result.\r\n     * @returns {Matrix2} The modified result parameter.\r\n     */\r\n    Matrix2.multiply = function(left, right, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('left', left);\r\n        Check.typeOf.object('right', right);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        var column0Row0 = left[0] * right[0] + left[2] * right[1];\r\n        var column1Row0 = left[0] * right[2] + left[2] * right[3];\r\n        var column0Row1 = left[1] * right[0] + left[3] * right[1];\r\n        var column1Row1 = left[1] * right[2] + left[3] * right[3];\r\n\r\n        result[0] = column0Row0;\r\n        result[1] = column0Row1;\r\n        result[2] = column1Row0;\r\n        result[3] = column1Row1;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the sum of two matrices.\r\n     *\r\n     * @param {Matrix2} left The first matrix.\r\n     * @param {Matrix2} right The second matrix.\r\n     * @param {Matrix2} result The object onto which to store the result.\r\n     * @returns {Matrix2} The modified result parameter.\r\n     */\r\n    Matrix2.add = function(left, right, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('left', left);\r\n        Check.typeOf.object('right', right);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        result[0] = left[0] + right[0];\r\n        result[1] = left[1] + right[1];\r\n        result[2] = left[2] + right[2];\r\n        result[3] = left[3] + right[3];\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the difference of two matrices.\r\n     *\r\n     * @param {Matrix2} left The first matrix.\r\n     * @param {Matrix2} right The second matrix.\r\n     * @param {Matrix2} result The object onto which to store the result.\r\n     * @returns {Matrix2} The modified result parameter.\r\n     */\r\n    Matrix2.subtract = function(left, right, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('left', left);\r\n        Check.typeOf.object('right', right);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        result[0] = left[0] - right[0];\r\n        result[1] = left[1] - right[1];\r\n        result[2] = left[2] - right[2];\r\n        result[3] = left[3] - right[3];\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the product of a matrix and a column vector.\r\n     *\r\n     * @param {Matrix2} matrix The matrix.\r\n     * @param {Cartesian2} cartesian The column.\r\n     * @param {Cartesian2} result The object onto which to store the result.\r\n     * @returns {Cartesian2} The modified result parameter.\r\n     */\r\n    Matrix2.multiplyByVector = function(matrix, cartesian, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('matrix', matrix);\r\n        Check.typeOf.object('cartesian', cartesian);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        var x = matrix[0] * cartesian.x + matrix[2] * cartesian.y;\r\n        var y = matrix[1] * cartesian.x + matrix[3] * cartesian.y;\r\n\r\n        result.x = x;\r\n        result.y = y;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the product of a matrix and a scalar.\r\n     *\r\n     * @param {Matrix2} matrix The matrix.\r\n     * @param {Number} scalar The number to multiply by.\r\n     * @param {Matrix2} result The object onto which to store the result.\r\n     * @returns {Matrix2} The modified result parameter.\r\n     */\r\n    Matrix2.multiplyByScalar = function(matrix, scalar, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('matrix', matrix);\r\n        Check.typeOf.number('scalar', scalar);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        result[0] = matrix[0] * scalar;\r\n        result[1] = matrix[1] * scalar;\r\n        result[2] = matrix[2] * scalar;\r\n        result[3] = matrix[3] * scalar;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.\r\n     *\r\n     * @param {Matrix2} matrix The matrix on the left-hand side.\r\n     * @param {Cartesian2} scale The non-uniform scale on the right-hand side.\r\n     * @param {Matrix2} result The object onto which to store the result.\r\n     * @returns {Matrix2} The modified result parameter.\r\n     *\r\n     *\r\n     * @example\r\n     * // Instead of Cesium.Matrix2.multiply(m, Cesium.Matrix2.fromScale(scale), m);\r\n     * Cesium.Matrix2.multiplyByScale(m, scale, m);\r\n     *\r\n     * @see Matrix2.fromScale\r\n     * @see Matrix2.multiplyByUniformScale\r\n     */\r\n    Matrix2.multiplyByScale = function(matrix, scale, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('matrix', matrix);\r\n        Check.typeOf.object('scale', scale);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        result[0] = matrix[0] * scale.x;\r\n        result[1] = matrix[1] * scale.x;\r\n        result[2] = matrix[2] * scale.y;\r\n        result[3] = matrix[3] * scale.y;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Creates a negated copy of the provided matrix.\r\n     *\r\n     * @param {Matrix2} matrix The matrix to negate.\r\n     * @param {Matrix2} result The object onto which to store the result.\r\n     * @returns {Matrix2} The modified result parameter.\r\n     */\r\n    Matrix2.negate = function(matrix, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('matrix', matrix);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        result[0] = -matrix[0];\r\n        result[1] = -matrix[1];\r\n        result[2] = -matrix[2];\r\n        result[3] = -matrix[3];\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the transpose of the provided matrix.\r\n     *\r\n     * @param {Matrix2} matrix The matrix to transpose.\r\n     * @param {Matrix2} result The object onto which to store the result.\r\n     * @returns {Matrix2} The modified result parameter.\r\n     */\r\n    Matrix2.transpose = function(matrix, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('matrix', matrix);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        var column0Row0 = matrix[0];\r\n        var column0Row1 = matrix[2];\r\n        var column1Row0 = matrix[1];\r\n        var column1Row1 = matrix[3];\r\n\r\n        result[0] = column0Row0;\r\n        result[1] = column0Row1;\r\n        result[2] = column1Row0;\r\n        result[3] = column1Row1;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.\r\n     *\r\n     * @param {Matrix2} matrix The matrix with signed elements.\r\n     * @param {Matrix2} result The object onto which to store the result.\r\n     * @returns {Matrix2} The modified result parameter.\r\n     */\r\n    Matrix2.abs = function(matrix, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('matrix', matrix);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        result[0] = Math.abs(matrix[0]);\r\n        result[1] = Math.abs(matrix[1]);\r\n        result[2] = Math.abs(matrix[2]);\r\n        result[3] = Math.abs(matrix[3]);\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Compares the provided matrices componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {Matrix2} [left] The first matrix.\r\n     * @param {Matrix2} [right] The second matrix.\r\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n     */\r\n    Matrix2.equals = function(left, right) {\r\n        return (left === right) ||\r\n               (defined(left) &&\r\n                defined(right) &&\r\n                left[0] === right[0] &&\r\n                left[1] === right[1] &&\r\n                left[2] === right[2] &&\r\n                left[3] === right[3]);\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    Matrix2.equalsArray = function(matrix, array, offset) {\r\n        return matrix[0] === array[offset] &&\r\n               matrix[1] === array[offset + 1] &&\r\n               matrix[2] === array[offset + 2] &&\r\n               matrix[3] === array[offset + 3];\r\n    };\r\n\r\n    /**\r\n     * Compares the provided matrices componentwise and returns\r\n     * <code>true</code> if they are within the provided epsilon,\r\n     * <code>false</code> otherwise.\r\n     *\r\n     * @param {Matrix2} [left] The first matrix.\r\n     * @param {Matrix2} [right] The second matrix.\r\n     * @param {Number} epsilon The epsilon to use for equality testing.\r\n     * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\r\n     */\r\n    Matrix2.equalsEpsilon = function(left, right, epsilon) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.number('epsilon', epsilon);\r\n        //>>includeEnd('debug');\r\n\r\n        return (left === right) ||\r\n                (defined(left) &&\r\n                defined(right) &&\r\n                Math.abs(left[0] - right[0]) <= epsilon &&\r\n                Math.abs(left[1] - right[1]) <= epsilon &&\r\n                Math.abs(left[2] - right[2]) <= epsilon &&\r\n                Math.abs(left[3] - right[3]) <= epsilon);\r\n    };\r\n\r\n    /**\r\n     * An immutable Matrix2 instance initialized to the identity matrix.\r\n     *\r\n     * @type {Matrix2}\r\n     * @constant\r\n     */\r\n    Matrix2.IDENTITY = Object.freeze(new Matrix2(1.0, 0.0,\r\n                                                0.0, 1.0));\r\n\r\n    /**\r\n     * An immutable Matrix2 instance initialized to the zero matrix.\r\n     *\r\n     * @type {Matrix2}\r\n     * @constant\r\n     */\r\n    Matrix2.ZERO = Object.freeze(new Matrix2(0.0, 0.0,\r\n                                            0.0, 0.0));\r\n\r\n    /**\r\n     * The index into Matrix2 for column 0, row 0.\r\n     *\r\n     * @type {Number}\r\n     * @constant\r\n     *\r\n     * @example\r\n     * var matrix = new Cesium.Matrix2();\r\n     * matrix[Cesium.Matrix2.COLUMN0ROW0] = 5.0; // set column 0, row 0 to 5.0\r\n     */\r\n    Matrix2.COLUMN0ROW0 = 0;\r\n\r\n    /**\r\n     * The index into Matrix2 for column 0, row 1.\r\n     *\r\n     * @type {Number}\r\n     * @constant\r\n     *\r\n     * @example\r\n     * var matrix = new Cesium.Matrix2();\r\n     * matrix[Cesium.Matrix2.COLUMN0ROW1] = 5.0; // set column 0, row 1 to 5.0\r\n     */\r\n    Matrix2.COLUMN0ROW1 = 1;\r\n\r\n    /**\r\n     * The index into Matrix2 for column 1, row 0.\r\n     *\r\n     * @type {Number}\r\n     * @constant\r\n     *\r\n     * @example\r\n     * var matrix = new Cesium.Matrix2();\r\n     * matrix[Cesium.Matrix2.COLUMN1ROW0] = 5.0; // set column 1, row 0 to 5.0\r\n     */\r\n    Matrix2.COLUMN1ROW0 = 2;\r\n\r\n    /**\r\n     * The index into Matrix2 for column 1, row 1.\r\n     *\r\n     * @type {Number}\r\n     * @constant\r\n     *\r\n     * @example\r\n     * var matrix = new Cesium.Matrix2();\r\n     * matrix[Cesium.Matrix2.COLUMN1ROW1] = 5.0; // set column 1, row 1 to 5.0\r\n     */\r\n    Matrix2.COLUMN1ROW1 = 3;\r\n\r\n    Object.defineProperties(Matrix2.prototype, {\r\n        /**\r\n         * Gets the number of items in the collection.\r\n         * @memberof Matrix2.prototype\r\n         *\r\n         * @type {Number}\r\n         */\r\n        length : {\r\n            get : function() {\r\n                return Matrix2.packedLength;\r\n            }\r\n        }\r\n    });\r\n\r\n    /**\r\n     * Duplicates the provided Matrix2 instance.\r\n     *\r\n     * @param {Matrix2} [result] The object onto which to store the result.\r\n     * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\r\n     */\r\n    Matrix2.prototype.clone = function(result) {\r\n        return Matrix2.clone(this, result);\r\n    };\r\n\r\n    /**\r\n     * Compares this matrix to the provided matrix componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {Matrix2} [right] The right hand side matrix.\r\n     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     */\r\n    Matrix2.prototype.equals = function(right) {\r\n        return Matrix2.equals(this, right);\r\n    };\r\n\r\n    /**\r\n     * Compares this matrix to the provided matrix componentwise and returns\r\n     * <code>true</code> if they are within the provided epsilon,\r\n     * <code>false</code> otherwise.\r\n     *\r\n     * @param {Matrix2} [right] The right hand side matrix.\r\n     * @param {Number} epsilon The epsilon to use for equality testing.\r\n     * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\r\n     */\r\n    Matrix2.prototype.equalsEpsilon = function(right, epsilon) {\r\n        return Matrix2.equalsEpsilon(this, right, epsilon);\r\n    };\r\n\r\n    /**\r\n     * Creates a string representing this Matrix with each row being\r\n     * on a separate line and in the format '(column0, column1)'.\r\n     *\r\n     * @returns {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1)'.\r\n     */\r\n    Matrix2.prototype.toString = function() {\r\n        return '(' + this[0] + ', ' + this[2] + ')\\n' +\r\n               '(' + this[1] + ', ' + this[3] + ')';\r\n    };\r\nexport default Matrix2;\r\n","import WebGLConstants from './WebGLConstants.js';\r\n\r\n    /**\r\n     * The type of a geometric primitive, i.e., points, lines, and triangles.\r\n     *\r\n     * @exports PrimitiveType\r\n     */\r\n    var PrimitiveType = {\r\n        /**\r\n         * Points primitive where each vertex (or index) is a separate point.\r\n         *\r\n         * @type {Number}\r\n         * @constant\r\n         */\r\n        POINTS : WebGLConstants.POINTS,\r\n\r\n        /**\r\n         * Lines primitive where each two vertices (or indices) is a line segment.  Line segments are not necessarily connected.\r\n         *\r\n         * @type {Number}\r\n         * @constant\r\n         */\r\n        LINES : WebGLConstants.LINES,\r\n\r\n        /**\r\n         * Line loop primitive where each vertex (or index) after the first connects a line to\r\n         * the previous vertex, and the last vertex implicitly connects to the first.\r\n         *\r\n         * @type {Number}\r\n         * @constant\r\n         */\r\n        LINE_LOOP : WebGLConstants.LINE_LOOP,\r\n\r\n        /**\r\n         * Line strip primitive where each vertex (or index) after the first connects a line to the previous vertex.\r\n         *\r\n         * @type {Number}\r\n         * @constant\r\n         */\r\n        LINE_STRIP : WebGLConstants.LINE_STRIP,\r\n\r\n        /**\r\n         * Triangles primitive where each three vertices (or indices) is a triangle.  Triangles do not necessarily share edges.\r\n         *\r\n         * @type {Number}\r\n         * @constant\r\n         */\r\n        TRIANGLES : WebGLConstants.TRIANGLES,\r\n\r\n        /**\r\n         * Triangle strip primitive where each vertex (or index) after the first two connect to\r\n         * the previous two vertices forming a triangle.  For example, this can be used to model a wall.\r\n         *\r\n         * @type {Number}\r\n         * @constant\r\n         */\r\n        TRIANGLE_STRIP : WebGLConstants.TRIANGLE_STRIP,\r\n\r\n        /**\r\n         * Triangle fan primitive where each vertex (or index) after the first two connect to\r\n         * the previous vertex and the first vertex forming a triangle.  For example, this can be used\r\n         * to model a cone or circle.\r\n         *\r\n         * @type {Number}\r\n         * @constant\r\n         */\r\n        TRIANGLE_FAN : WebGLConstants.TRIANGLE_FAN,\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        validate : function(primitiveType) {\r\n            return primitiveType === PrimitiveType.POINTS ||\r\n                   primitiveType === PrimitiveType.LINES ||\r\n                   primitiveType === PrimitiveType.LINE_LOOP ||\r\n                   primitiveType === PrimitiveType.LINE_STRIP ||\r\n                   primitiveType === PrimitiveType.TRIANGLES ||\r\n                   primitiveType === PrimitiveType.TRIANGLE_STRIP ||\r\n                   primitiveType === PrimitiveType.TRIANGLE_FAN;\r\n        }\r\n    };\r\nexport default Object.freeze(PrimitiveType);\r\n","import Cartesian2 from './Cartesian2.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport Cartographic from './Cartographic.js';\r\nimport Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport GeometryType from './GeometryType.js';\r\nimport Matrix2 from './Matrix2.js';\r\nimport Matrix3 from './Matrix3.js';\r\nimport Matrix4 from './Matrix4.js';\r\nimport PrimitiveType from './PrimitiveType.js';\r\nimport Quaternion from './Quaternion.js';\r\nimport Rectangle from './Rectangle.js';\r\nimport Transforms from './Transforms.js';\r\n\r\n    /**\r\n     * A geometry representation with attributes forming vertices and optional index data\r\n     * defining primitives.  Geometries and an {@link Appearance}, which describes the shading,\r\n     * can be assigned to a {@link Primitive} for visualization.  A <code>Primitive</code> can\r\n     * be created from many heterogeneous - in many cases - geometries for performance.\r\n     * <p>\r\n     * Geometries can be transformed and optimized using functions in {@link GeometryPipeline}.\r\n     * </p>\r\n     *\r\n     * @alias Geometry\r\n     * @constructor\r\n     *\r\n     * @param {Object} options Object with the following properties:\r\n     * @param {GeometryAttributes} options.attributes Attributes, which make up the geometry's vertices.\r\n     * @param {PrimitiveType} [options.primitiveType=PrimitiveType.TRIANGLES] The type of primitives in the geometry.\r\n     * @param {Uint16Array|Uint32Array} [options.indices] Optional index data that determines the primitives in the geometry.\r\n     * @param {BoundingSphere} [options.boundingSphere] An optional bounding sphere that fully enclosed the geometry.\r\n     *\r\n     * @see PolygonGeometry\r\n     * @see RectangleGeometry\r\n     * @see EllipseGeometry\r\n     * @see CircleGeometry\r\n     * @see WallGeometry\r\n     * @see SimplePolylineGeometry\r\n     * @see BoxGeometry\r\n     * @see EllipsoidGeometry\r\n     *\r\n     * @demo {@link https://sandcastle.cesium.com/index.html?src=Geometry%20and%20Appearances.html|Geometry and Appearances Demo}\r\n     *\r\n     * @example\r\n     * // Create geometry with a position attribute and indexed lines.\r\n     * var positions = new Float64Array([\r\n     *   0.0, 0.0, 0.0,\r\n     *   7500000.0, 0.0, 0.0,\r\n     *   0.0, 7500000.0, 0.0\r\n     * ]);\r\n     *\r\n     * var geometry = new Cesium.Geometry({\r\n     *   attributes : {\r\n     *     position : new Cesium.GeometryAttribute({\r\n     *       componentDatatype : Cesium.ComponentDatatype.DOUBLE,\r\n     *       componentsPerAttribute : 3,\r\n     *       values : positions\r\n     *     })\r\n     *   },\r\n     *   indices : new Uint16Array([0, 1, 1, 2, 2, 0]),\r\n     *   primitiveType : Cesium.PrimitiveType.LINES,\r\n     *   boundingSphere : Cesium.BoundingSphere.fromVertices(positions)\r\n     * });\r\n     */\r\n    function Geometry(options) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('options.attributes', options.attributes);\r\n        //>>includeEnd('debug');\r\n\r\n        /**\r\n         * Attributes, which make up the geometry's vertices.  Each property in this object corresponds to a\r\n         * {@link GeometryAttribute} containing the attribute's data.\r\n         * <p>\r\n         * Attributes are always stored non-interleaved in a Geometry.\r\n         * </p>\r\n         * <p>\r\n         * There are reserved attribute names with well-known semantics.  The following attributes\r\n         * are created by a Geometry (depending on the provided {@link VertexFormat}.\r\n         * <ul>\r\n         *    <li><code>position</code> - 3D vertex position.  64-bit floating-point (for precision).  3 components per attribute.  See {@link VertexFormat#position}.</li>\r\n         *    <li><code>normal</code> - Normal (normalized), commonly used for lighting.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#normal}.</li>\r\n         *    <li><code>st</code> - 2D texture coordinate.  32-bit floating-point.  2 components per attribute.  See {@link VertexFormat#st}.</li>\r\n         *    <li><code>bitangent</code> - Bitangent (normalized), used for tangent-space effects like bump mapping.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#bitangent}.</li>\r\n         *    <li><code>tangent</code> - Tangent (normalized), used for tangent-space effects like bump mapping.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#tangent}.</li>\r\n         * </ul>\r\n         * </p>\r\n         * <p>\r\n         * The following attribute names are generally not created by a Geometry, but are added\r\n         * to a Geometry by a {@link Primitive} or {@link GeometryPipeline} functions to prepare\r\n         * the geometry for rendering.\r\n         * <ul>\r\n         *    <li><code>position3DHigh</code> - High 32 bits for encoded 64-bit position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\r\n         *    <li><code>position3DLow</code> - Low 32 bits for encoded 64-bit position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\r\n         *    <li><code>position3DHigh</code> - High 32 bits for encoded 64-bit 2D (Columbus view) position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\r\n         *    <li><code>position2DLow</code> - Low 32 bits for encoded 64-bit 2D (Columbus view) position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\r\n         *    <li><code>color</code> - RGBA color (normalized) usually from {@link GeometryInstance#color}.  32-bit floating-point.  4 components per attribute.</li>\r\n         *    <li><code>pickColor</code> - RGBA color used for picking.  32-bit floating-point.  4 components per attribute.</li>\r\n         * </ul>\r\n         * </p>\r\n         *\r\n         * @type GeometryAttributes\r\n         *\r\n         * @default undefined\r\n         *\r\n         *\r\n         * @example\r\n         * geometry.attributes.position = new Cesium.GeometryAttribute({\r\n         *   componentDatatype : Cesium.ComponentDatatype.FLOAT,\r\n         *   componentsPerAttribute : 3,\r\n         *   values : new Float32Array(0)\r\n         * });\r\n         *\r\n         * @see GeometryAttribute\r\n         * @see VertexFormat\r\n         */\r\n        this.attributes = options.attributes;\r\n\r\n        /**\r\n         * Optional index data that - along with {@link Geometry#primitiveType} -\r\n         * determines the primitives in the geometry.\r\n         *\r\n         * @type Array\r\n         *\r\n         * @default undefined\r\n         */\r\n        this.indices = options.indices;\r\n\r\n        /**\r\n         * The type of primitives in the geometry.  This is most often {@link PrimitiveType.TRIANGLES},\r\n         * but can varying based on the specific geometry.\r\n         *\r\n         * @type PrimitiveType\r\n         *\r\n         * @default undefined\r\n         */\r\n        this.primitiveType = defaultValue(options.primitiveType, PrimitiveType.TRIANGLES);\r\n\r\n        /**\r\n         * An optional bounding sphere that fully encloses the geometry.  This is\r\n         * commonly used for culling.\r\n         *\r\n         * @type BoundingSphere\r\n         *\r\n         * @default undefined\r\n         */\r\n        this.boundingSphere = options.boundingSphere;\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        this.geometryType = defaultValue(options.geometryType, GeometryType.NONE);\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        this.boundingSphereCV = options.boundingSphereCV;\r\n\r\n        /**\r\n         * @private\r\n         * Used for computing the bounding sphere for geometry using the applyOffset vertex attribute\r\n         */\r\n        this.offsetAttribute = options.offsetAttribute;\r\n    }\r\n\r\n    /**\r\n     * Computes the number of vertices in a geometry.  The runtime is linear with\r\n     * respect to the number of attributes in a vertex, not the number of vertices.\r\n     *\r\n     * @param {Geometry} geometry The geometry.\r\n     * @returns {Number} The number of vertices in the geometry.\r\n     *\r\n     * @example\r\n     * var numVertices = Cesium.Geometry.computeNumberOfVertices(geometry);\r\n     */\r\n    Geometry.computeNumberOfVertices = function(geometry) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('geometry', geometry);\r\n        //>>includeEnd('debug');\r\n\r\n        var numberOfVertices = -1;\r\n        for ( var property in geometry.attributes) {\r\n            if (geometry.attributes.hasOwnProperty(property) &&\r\n                    defined(geometry.attributes[property]) &&\r\n                    defined(geometry.attributes[property].values)) {\r\n\r\n                var attribute = geometry.attributes[property];\r\n                var num = attribute.values.length / attribute.componentsPerAttribute;\r\n                //>>includeStart('debug', pragmas.debug);\r\n                if ((numberOfVertices !== num) && (numberOfVertices !== -1)) {\r\n                    throw new DeveloperError('All attribute lists must have the same number of attributes.');\r\n                }\r\n                //>>includeEnd('debug');\r\n                numberOfVertices = num;\r\n            }\r\n        }\r\n\r\n        return numberOfVertices;\r\n    };\r\n\r\n    var rectangleCenterScratch = new Cartographic();\r\n    var enuCenterScratch = new Cartesian3();\r\n    var fixedFrameToEnuScratch = new Matrix4();\r\n    var boundingRectanglePointsCartographicScratch = [new Cartographic(), new Cartographic(), new Cartographic()];\r\n    var boundingRectanglePointsEnuScratch = [new Cartesian2(), new Cartesian2(), new Cartesian2()];\r\n    var points2DScratch = [new Cartesian2(), new Cartesian2(), new Cartesian2()];\r\n    var pointEnuScratch = new Cartesian3();\r\n    var enuRotationScratch = new Quaternion();\r\n    var enuRotationMatrixScratch = new Matrix4();\r\n    var rotation2DScratch = new Matrix2();\r\n\r\n    /**\r\n     * For remapping texture coordinates when rendering GroundPrimitives with materials.\r\n     * GroundPrimitive texture coordinates are computed to align with the cartographic coordinate system on the globe.\r\n     * However, EllipseGeometry, RectangleGeometry, and PolygonGeometry all bake rotations to per-vertex texture coordinates\r\n     * using different strategies.\r\n     *\r\n     * This method is used by EllipseGeometry and PolygonGeometry to approximate the same visual effect.\r\n     * We encapsulate rotation and scale by computing a \"transformed\" texture coordinate system and computing\r\n     * a set of reference points from which \"cartographic\" texture coordinates can be remapped to the \"transformed\"\r\n     * system using distances to lines in 2D.\r\n     *\r\n     * This approximation becomes less accurate as the covered area increases, especially for GroundPrimitives near the poles,\r\n     * but is generally reasonable for polygons and ellipses around the size of USA states.\r\n     *\r\n     * RectangleGeometry has its own version of this method that computes remapping coordinates using cartographic space\r\n     * as an intermediary instead of local ENU, which is more accurate for large-area rectangles.\r\n     *\r\n     * @param {Cartesian3[]} positions Array of positions outlining the geometry\r\n     * @param {Number} stRotation Texture coordinate rotation.\r\n     * @param {Ellipsoid} ellipsoid Ellipsoid for projecting and generating local vectors.\r\n     * @param {Rectangle} boundingRectangle Bounding rectangle around the positions.\r\n     * @returns {Number[]} An array of 6 numbers specifying [minimum point, u extent, v extent] as points in the \"cartographic\" system.\r\n     * @private\r\n     */\r\n    Geometry._textureCoordinateRotationPoints = function(positions, stRotation, ellipsoid, boundingRectangle) {\r\n        var i;\r\n\r\n        // Create a local east-north-up coordinate system centered on the polygon's bounding rectangle.\r\n        // Project the southwest, northwest, and southeast corners of the bounding rectangle into the plane of ENU as 2D points.\r\n        // These are the equivalents of (0,0), (0,1), and (1,0) in the texture coordiante system computed in ShadowVolumeAppearanceFS,\r\n        // aka \"ENU texture space.\"\r\n        var rectangleCenter = Rectangle.center(boundingRectangle, rectangleCenterScratch);\r\n        var enuCenter = Cartographic.toCartesian(rectangleCenter, ellipsoid, enuCenterScratch);\r\n        var enuToFixedFrame = Transforms.eastNorthUpToFixedFrame(enuCenter, ellipsoid, fixedFrameToEnuScratch);\r\n        var fixedFrameToEnu = Matrix4.inverse(enuToFixedFrame, fixedFrameToEnuScratch);\r\n\r\n        var boundingPointsEnu = boundingRectanglePointsEnuScratch;\r\n        var boundingPointsCarto = boundingRectanglePointsCartographicScratch;\r\n\r\n        boundingPointsCarto[0].longitude = boundingRectangle.west;\r\n        boundingPointsCarto[0].latitude = boundingRectangle.south;\r\n\r\n        boundingPointsCarto[1].longitude = boundingRectangle.west;\r\n        boundingPointsCarto[1].latitude = boundingRectangle.north;\r\n\r\n        boundingPointsCarto[2].longitude = boundingRectangle.east;\r\n        boundingPointsCarto[2].latitude = boundingRectangle.south;\r\n\r\n        var posEnu = pointEnuScratch;\r\n\r\n        for (i = 0; i < 3; i++) {\r\n            Cartographic.toCartesian(boundingPointsCarto[i], ellipsoid, posEnu);\r\n            posEnu = Matrix4.multiplyByPointAsVector(fixedFrameToEnu, posEnu, posEnu);\r\n            boundingPointsEnu[i].x = posEnu.x;\r\n            boundingPointsEnu[i].y = posEnu.y;\r\n        }\r\n\r\n        // Rotate each point in the polygon around the up vector in the ENU by -stRotation and project into ENU as 2D.\r\n        // Compute the bounding box of these rotated points in the 2D ENU plane.\r\n        // Rotate the corners back by stRotation, then compute their equivalents in the ENU texture space using the corners computed earlier.\r\n        var rotation = Quaternion.fromAxisAngle(Cartesian3.UNIT_Z, -stRotation, enuRotationScratch);\r\n        var textureMatrix = Matrix3.fromQuaternion(rotation, enuRotationMatrixScratch);\r\n\r\n        var positionsLength = positions.length;\r\n        var enuMinX = Number.POSITIVE_INFINITY;\r\n        var enuMinY = Number.POSITIVE_INFINITY;\r\n        var enuMaxX = Number.NEGATIVE_INFINITY;\r\n        var enuMaxY = Number.NEGATIVE_INFINITY;\r\n        for (i = 0; i < positionsLength; i++) {\r\n            posEnu = Matrix4.multiplyByPointAsVector(fixedFrameToEnu, positions[i], posEnu);\r\n            posEnu = Matrix3.multiplyByVector(textureMatrix, posEnu, posEnu);\r\n\r\n            enuMinX = Math.min(enuMinX, posEnu.x);\r\n            enuMinY = Math.min(enuMinY, posEnu.y);\r\n            enuMaxX = Math.max(enuMaxX, posEnu.x);\r\n            enuMaxY = Math.max(enuMaxY, posEnu.y);\r\n        }\r\n\r\n        var toDesiredInComputed = Matrix2.fromRotation(stRotation, rotation2DScratch);\r\n\r\n        var points2D = points2DScratch;\r\n        points2D[0].x = enuMinX;\r\n        points2D[0].y = enuMinY;\r\n\r\n        points2D[1].x = enuMinX;\r\n        points2D[1].y = enuMaxY;\r\n\r\n        points2D[2].x = enuMaxX;\r\n        points2D[2].y = enuMinY;\r\n\r\n        var boundingEnuMin = boundingPointsEnu[0];\r\n        var boundingPointsWidth = boundingPointsEnu[2].x - boundingEnuMin.x;\r\n        var boundingPointsHeight = boundingPointsEnu[1].y - boundingEnuMin.y;\r\n\r\n        for (i = 0; i < 3; i++) {\r\n            var point2D = points2D[i];\r\n            // rotate back\r\n            Matrix2.multiplyByVector(toDesiredInComputed, point2D, point2D);\r\n\r\n            // Convert point into east-north texture coordinate space\r\n            point2D.x = (point2D.x - boundingEnuMin.x) / boundingPointsWidth;\r\n            point2D.y = (point2D.y - boundingEnuMin.y) / boundingPointsHeight;\r\n        }\r\n\r\n        var minXYCorner = points2D[0];\r\n        var maxYCorner = points2D[1];\r\n        var maxXCorner = points2D[2];\r\n        var result = new Array(6);\r\n        Cartesian2.pack(minXYCorner, result);\r\n        Cartesian2.pack(maxYCorner, result, 2);\r\n        Cartesian2.pack(maxXCorner, result, 4);\r\n\r\n        return result;\r\n    };\r\nexport default Geometry;\r\n","import defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\n\r\n    /**\r\n     * Values and type information for geometry attributes.  A {@link Geometry}\r\n     * generally contains one or more attributes.  All attributes together form\r\n     * the geometry's vertices.\r\n     *\r\n     * @alias GeometryAttribute\r\n     * @constructor\r\n     *\r\n     * @param {Object} [options] Object with the following properties:\r\n     * @param {ComponentDatatype} [options.componentDatatype] The datatype of each component in the attribute, e.g., individual elements in values.\r\n     * @param {Number} [options.componentsPerAttribute] A number between 1 and 4 that defines the number of components in an attributes.\r\n     * @param {Boolean} [options.normalize=false] When <code>true</code> and <code>componentDatatype</code> is an integer format, indicate that the components should be mapped to the range [0, 1] (unsigned) or [-1, 1] (signed) when they are accessed as floating-point for rendering.\r\n     * @param {TypedArray} [options.values] The values for the attributes stored in a typed array.\r\n     *\r\n     * @exception {DeveloperError} options.componentsPerAttribute must be between 1 and 4.\r\n     *\r\n     *\r\n     * @example\r\n     * var geometry = new Cesium.Geometry({\r\n     *   attributes : {\r\n     *     position : new Cesium.GeometryAttribute({\r\n     *       componentDatatype : Cesium.ComponentDatatype.FLOAT,\r\n     *       componentsPerAttribute : 3,\r\n     *       values : new Float32Array([\r\n     *         0.0, 0.0, 0.0,\r\n     *         7500000.0, 0.0, 0.0,\r\n     *         0.0, 7500000.0, 0.0\r\n     *       ])\r\n     *     })\r\n     *   },\r\n     *   primitiveType : Cesium.PrimitiveType.LINE_LOOP\r\n     * });\r\n     *\r\n     * @see Geometry\r\n     */\r\n    function GeometryAttribute(options) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(options.componentDatatype)) {\r\n            throw new DeveloperError('options.componentDatatype is required.');\r\n        }\r\n        if (!defined(options.componentsPerAttribute)) {\r\n            throw new DeveloperError('options.componentsPerAttribute is required.');\r\n        }\r\n        if (options.componentsPerAttribute < 1 || options.componentsPerAttribute > 4) {\r\n            throw new DeveloperError('options.componentsPerAttribute must be between 1 and 4.');\r\n        }\r\n        if (!defined(options.values)) {\r\n            throw new DeveloperError('options.values is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        /**\r\n         * The datatype of each component in the attribute, e.g., individual elements in\r\n         * {@link GeometryAttribute#values}.\r\n         *\r\n         * @type ComponentDatatype\r\n         *\r\n         * @default undefined\r\n         */\r\n        this.componentDatatype = options.componentDatatype;\r\n\r\n        /**\r\n         * A number between 1 and 4 that defines the number of components in an attributes.\r\n         * For example, a position attribute with x, y, and z components would have 3 as\r\n         * shown in the code example.\r\n         *\r\n         * @type Number\r\n         *\r\n         * @default undefined\r\n         *\r\n         * @example\r\n         * attribute.componentDatatype = Cesium.ComponentDatatype.FLOAT;\r\n         * attribute.componentsPerAttribute = 3;\r\n         * attribute.values = new Float32Array([\r\n         *   0.0, 0.0, 0.0,\r\n         *   7500000.0, 0.0, 0.0,\r\n         *   0.0, 7500000.0, 0.0\r\n         * ]);\r\n         */\r\n        this.componentsPerAttribute = options.componentsPerAttribute;\r\n\r\n        /**\r\n         * When <code>true</code> and <code>componentDatatype</code> is an integer format,\r\n         * indicate that the components should be mapped to the range [0, 1] (unsigned)\r\n         * or [-1, 1] (signed) when they are accessed as floating-point for rendering.\r\n         * <p>\r\n         * This is commonly used when storing colors using {@link ComponentDatatype.UNSIGNED_BYTE}.\r\n         * </p>\r\n         *\r\n         * @type Boolean\r\n         *\r\n         * @default false\r\n         *\r\n         * @example\r\n         * attribute.componentDatatype = Cesium.ComponentDatatype.UNSIGNED_BYTE;\r\n         * attribute.componentsPerAttribute = 4;\r\n         * attribute.normalize = true;\r\n         * attribute.values = new Uint8Array([\r\n         *   Cesium.Color.floatToByte(color.red),\r\n         *   Cesium.Color.floatToByte(color.green),\r\n         *   Cesium.Color.floatToByte(color.blue),\r\n         *   Cesium.Color.floatToByte(color.alpha)\r\n         * ]);\r\n         */\r\n        this.normalize = defaultValue(options.normalize, false);\r\n\r\n        /**\r\n         * The values for the attributes stored in a typed array.  In the code example,\r\n         * every three elements in <code>values</code> defines one attributes since\r\n         * <code>componentsPerAttribute</code> is 3.\r\n         *\r\n         * @type TypedArray\r\n         *\r\n         * @default undefined\r\n         *\r\n         * @example\r\n         * attribute.componentDatatype = Cesium.ComponentDatatype.FLOAT;\r\n         * attribute.componentsPerAttribute = 3;\r\n         * attribute.values = new Float32Array([\r\n         *   0.0, 0.0, 0.0,\r\n         *   7500000.0, 0.0, 0.0,\r\n         *   0.0, 7500000.0, 0.0\r\n         * ]);\r\n         */\r\n        this.values = options.values;\r\n    }\r\nexport default GeometryAttribute;\r\n"],"names":["Object","freeze","NONE","TRIANGLES","LINES","POLYLINES","Matrix2","column0Row0","column1Row0","column0Row1","column1Row1","this","defaultValue","packedLength","pack","value","array","startingIndex","Check","typeOf","object","defined","unpack","result","clone","matrix","fromArray","fromColumnMajorArray","values","fromRowMajorArray","fromScale","scale","x","y","fromUniformScale","number","fromRotation","angle","cosAngle","Math","cos","sinAngle","sin","toArray","getElementIndex","column","row","greaterThanOrEquals","lessThanOrEquals","getColumn","index","startIndex","setColumn","cartesian","getRow","setRow","scratchColumn","Cartesian2","getScale","magnitude","fromElements","scratchScale","getMaximumScale","maximumComponent","multiply","left","right","add","subtract","multiplyByVector","multiplyByScalar","scalar","multiplyByScale","negate","transpose","abs","equals","equalsArray","offset","equalsEpsilon","epsilon","IDENTITY","ZERO","COLUMN0ROW0","COLUMN0ROW1","COLUMN1ROW0","COLUMN1ROW1","defineProperties","prototype","length","get","toString","PrimitiveType","POINTS","WebGLConstants","LINE_LOOP","LINE_STRIP","TRIANGLE_STRIP","TRIANGLE_FAN","validate","primitiveType","Geometry","options","EMPTY_OBJECT","attributes","indices","boundingSphere","geometryType","GeometryType","boundingSphereCV","offsetAttribute","computeNumberOfVertices","geometry","numberOfVertices","property","hasOwnProperty","attribute","num","componentsPerAttribute","DeveloperError","rectangleCenterScratch","Cartographic","enuCenterScratch","Cartesian3","fixedFrameToEnuScratch","Matrix4","boundingRectanglePointsCartographicScratch","boundingRectanglePointsEnuScratch","points2DScratch","pointEnuScratch","enuRotationScratch","Quaternion","enuRotationMatrixScratch","rotation2DScratch","_textureCoordinateRotationPoints","positions","stRotation","ellipsoid","boundingRectangle","i","rectangleCenter","Rectangle","center","enuCenter","toCartesian","enuToFixedFrame","Transforms","eastNorthUpToFixedFrame","fixedFrameToEnu","inverse","boundingPointsEnu","boundingPointsCarto","longitude","west","latitude","south","north","east","posEnu","multiplyByPointAsVector","rotation","fromAxisAngle","UNIT_Z","textureMatrix","Matrix3","fromQuaternion","positionsLength","enuMinX","Number","POSITIVE_INFINITY","enuMinY","enuMaxX","NEGATIVE_INFINITY","enuMaxY","min","max","toDesiredInComputed","points2D","boundingEnuMin","boundingPointsWidth","boundingPointsHeight","point2D","minXYCorner","maxYCorner","maxXCorner","Array","componentDatatype","normalize"],"mappings":"iMAII,MAMWA,OAAOC,OANC,CACfC,KAAO,EACPC,UAAY,EACZC,MAAQ,EACRC,UAAY,ICehB,SAASC,EAAQC,EAAaC,EAAaC,EAAaC,GACpDC,KAAK,GAAKC,eAAaL,EAAa,GACpCI,KAAK,GAAKC,eAAaH,EAAa,GACpCE,KAAK,GAAKC,eAAaJ,EAAa,GACpCG,KAAK,GAAKC,eAAaF,EAAa,GAOxCJ,EAAQO,aAAe,EAWvBP,EAAQQ,KAAO,SAASC,EAAOC,EAAOC,GAalC,OAXAC,QAAMC,OAAOC,OAAO,QAASL,GAC7BG,QAAMG,QAAQ,QAASL,GAGvBC,EAAgBL,eAAaK,EAAe,GAE5CD,EAAMC,KAAmBF,EAAM,GAC/BC,EAAMC,KAAmBF,EAAM,GAC/BC,EAAMC,KAAmBF,EAAM,GAC/BC,EAAMC,KAAmBF,EAAM,GAExBC,GAWXV,EAAQgB,OAAS,SAASN,EAAOC,EAAeM,GAe5C,OAbAL,QAAMG,QAAQ,QAASL,GAGvBC,EAAgBL,eAAaK,EAAe,GAEvCI,UAAQE,KACTA,EAAS,IAAIjB,GAGjBiB,EAAO,GAAKP,EAAMC,KAClBM,EAAO,GAAKP,EAAMC,KAClBM,EAAO,GAAKP,EAAMC,KAClBM,EAAO,GAAKP,EAAMC,KACXM,GAUXjB,EAAQkB,MAAQ,SAASC,EAAQF,GAC7B,GAAKF,UAAQI,GAGb,OAAKJ,UAAQE,IAIbA,EAAO,GAAKE,EAAO,GACnBF,EAAO,GAAKE,EAAO,GACnBF,EAAO,GAAKE,EAAO,GACnBF,EAAO,GAAKE,EAAO,GACZF,GAPI,IAAIjB,EAAQmB,EAAO,GAAIA,EAAO,GAClBA,EAAO,GAAIA,EAAO,KA6B7CnB,EAAQoB,UAAY,SAASV,EAAOC,EAAeM,GAe/C,OAbAL,QAAMG,QAAQ,QAASL,GAGvBC,EAAgBL,eAAaK,EAAe,GAEvCI,UAAQE,KACTA,EAAS,IAAIjB,GAGjBiB,EAAO,GAAKP,EAAMC,GAClBM,EAAO,GAAKP,EAAMC,EAAgB,GAClCM,EAAO,GAAKP,EAAMC,EAAgB,GAClCM,EAAO,GAAKP,EAAMC,EAAgB,GAC3BM,GAUXjB,EAAQqB,qBAAuB,SAASC,EAAQL,GAK5C,OAHAL,QAAMG,QAAQ,SAAUO,GAGjBtB,EAAQkB,MAAMI,EAAQL,IAWjCjB,EAAQuB,kBAAoB,SAASD,EAAQL,GAKzC,OAHAL,QAAMG,QAAQ,SAAUO,GAGnBP,UAAQE,IAIbA,EAAO,GAAKK,EAAO,GACnBL,EAAO,GAAKK,EAAO,GACnBL,EAAO,GAAKK,EAAO,GACnBL,EAAO,GAAKK,EAAO,GACZL,GAPI,IAAIjB,EAAQsB,EAAO,GAAIA,EAAO,GAClBA,EAAO,GAAIA,EAAO,KAsB7CtB,EAAQwB,UAAY,SAASC,EAAOR,GAKhC,OAHAL,QAAMC,OAAOC,OAAO,QAASW,GAGxBV,UAAQE,IAMbA,EAAO,GAAKQ,EAAMC,EAClBT,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAKQ,EAAME,EACXV,GATI,IAAIjB,EACPyB,EAAMC,EAAG,EACT,EAASD,EAAME,IAuB3B3B,EAAQ4B,iBAAmB,SAASH,EAAOR,GAKvC,OAHAL,QAAMC,OAAOgB,OAAO,QAASJ,GAGxBV,UAAQE,IAMbA,EAAO,GAAKQ,EACZR,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAKQ,EACLR,GATI,IAAIjB,EACPyB,EAAO,EACP,EAAOA,IAuBnBzB,EAAQ8B,aAAe,SAASC,EAAOd,GAEnCL,QAAMC,OAAOgB,OAAO,QAASE,GAG7B,IAAIC,EAAWC,KAAKC,IAAIH,GACpBI,EAAWF,KAAKG,IAAIL,GAExB,OAAKhB,UAAQE,IAKbA,EAAO,GAAKe,EACZf,EAAO,GAAKkB,EACZlB,EAAO,IAAMkB,EACblB,EAAO,GAAKe,EACLf,GARI,IAAIjB,EACPgC,GAAWG,EACXA,EAAUH,IAiBtBhC,EAAQqC,QAAU,SAASlB,EAAQF,GAK/B,OAHAL,QAAMC,OAAOC,OAAO,SAAUK,GAGzBJ,UAAQE,IAGbA,EAAO,GAAKE,EAAO,GACnBF,EAAO,GAAKE,EAAO,GACnBF,EAAO,GAAKE,EAAO,GACnBF,EAAO,GAAKE,EAAO,GACZF,GANI,CAACE,EAAO,GAAIA,EAAO,GAAIA,EAAO,GAAIA,EAAO,KAyBxDnB,EAAQsC,gBAAkB,SAASC,EAAQC,GASvC,OAPA5B,QAAMC,OAAOgB,OAAOY,oBAAoB,MAAOD,EAAK,GACpD5B,QAAMC,OAAOgB,OAAOa,iBAAiB,MAAOF,EAAK,GAEjD5B,QAAMC,OAAOgB,OAAOY,oBAAoB,SAAUF,EAAQ,GAC1D3B,QAAMC,OAAOgB,OAAOa,iBAAiB,SAAUH,EAAQ,GAGvC,EAATA,EAAaC,GAaxBxC,EAAQ2C,UAAY,SAASxB,EAAQyB,EAAO3B,GAExCL,QAAMC,OAAOC,OAAO,SAAUK,GAE9BP,QAAMC,OAAOgB,OAAOY,oBAAoB,QAASG,EAAO,GACxDhC,QAAMC,OAAOgB,OAAOa,iBAAiB,QAASE,EAAO,GAErDhC,QAAMC,OAAOC,OAAO,SAAUG,GAG9B,IAAI4B,EAAqB,EAARD,EACblB,EAAIP,EAAO0B,GACXlB,EAAIR,EAAO0B,EAAa,GAI5B,OAFA5B,EAAOS,EAAIA,EACXT,EAAOU,EAAIA,EACJV,GAcXjB,EAAQ8C,UAAY,SAAS3B,EAAQyB,EAAOG,EAAW9B,GAEnDL,QAAMC,OAAOC,OAAO,SAAUK,GAE9BP,QAAMC,OAAOgB,OAAOY,oBAAoB,QAASG,EAAO,GACxDhC,QAAMC,OAAOgB,OAAOa,iBAAiB,QAASE,EAAO,GAErDhC,QAAMC,OAAOC,OAAO,YAAaiC,GACjCnC,QAAMC,OAAOC,OAAO,SAAUG,GAI9B,IAAI4B,EAAqB,EAARD,EAGjB,OAJA3B,EAASjB,EAAQkB,MAAMC,EAAQF,IAExB4B,GAAcE,EAAUrB,EAC/BT,EAAO4B,EAAa,GAAKE,EAAUpB,EAC5BV,GAaXjB,EAAQgD,OAAS,SAAS7B,EAAQyB,EAAO3B,GAErCL,QAAMC,OAAOC,OAAO,SAAUK,GAE9BP,QAAMC,OAAOgB,OAAOY,oBAAoB,QAASG,EAAO,GACxDhC,QAAMC,OAAOgB,OAAOa,iBAAiB,QAASE,EAAO,GAErDhC,QAAMC,OAAOC,OAAO,SAAUG,GAG9B,IAAIS,EAAIP,EAAOyB,GACXjB,EAAIR,EAAOyB,EAAQ,GAIvB,OAFA3B,EAAOS,EAAIA,EACXT,EAAOU,EAAIA,EACJV,GAcXjB,EAAQiD,OAAS,SAAS9B,EAAQyB,EAAOG,EAAW9B,GAchD,OAZAL,QAAMC,OAAOC,OAAO,SAAUK,GAE9BP,QAAMC,OAAOgB,OAAOY,oBAAoB,QAASG,EAAO,GACxDhC,QAAMC,OAAOgB,OAAOa,iBAAiB,QAASE,EAAO,GAErDhC,QAAMC,OAAOC,OAAO,YAAaiC,GACjCnC,QAAMC,OAAOC,OAAO,SAAUG,IAG9BA,EAASjB,EAAQkB,MAAMC,EAAQF,IACxB2B,GAASG,EAAUrB,EAC1BT,EAAO2B,EAAQ,GAAKG,EAAUpB,EACvBV,GAGX,IAAIiC,EAAgB,IAAIC,aASxBnD,EAAQoD,SAAW,SAASjC,EAAQF,GAQhC,OANAL,QAAMC,OAAOC,OAAO,SAAUK,GAC9BP,QAAMC,OAAOC,OAAO,SAAUG,GAG9BA,EAAOS,EAAIyB,aAAWE,UAAUF,aAAWG,aAAanC,EAAO,GAAIA,EAAO,GAAI+B,IAC9EjC,EAAOU,EAAIwB,aAAWE,UAAUF,aAAWG,aAAanC,EAAO,GAAIA,EAAO,GAAI+B,IACvEjC,GAGX,IAAIsC,EAAe,IAAIJ,aASvBnD,EAAQwD,gBAAkB,SAASrC,GAE/B,OADAnB,EAAQoD,SAASjC,EAAQoC,GAClBJ,aAAWM,iBAAiBF,IAWvCvD,EAAQ0D,SAAW,SAASC,EAAMC,EAAO3C,GAErCL,QAAMC,OAAOC,OAAO,OAAQ6C,GAC5B/C,QAAMC,OAAOC,OAAO,QAAS8C,GAC7BhD,QAAMC,OAAOC,OAAO,SAAUG,GAG9B,IAAIhB,EAAc0D,EAAK,GAAKC,EAAM,GAAKD,EAAK,GAAKC,EAAM,GACnD1D,EAAcyD,EAAK,GAAKC,EAAM,GAAKD,EAAK,GAAKC,EAAM,GACnDzD,EAAcwD,EAAK,GAAKC,EAAM,GAAKD,EAAK,GAAKC,EAAM,GACnDxD,EAAcuD,EAAK,GAAKC,EAAM,GAAKD,EAAK,GAAKC,EAAM,GAMvD,OAJA3C,EAAO,GAAKhB,EACZgB,EAAO,GAAKd,EACZc,EAAO,GAAKf,EACZe,EAAO,GAAKb,EACLa,GAWXjB,EAAQ6D,IAAM,SAASF,EAAMC,EAAO3C,GAWhC,OATAL,QAAMC,OAAOC,OAAO,OAAQ6C,GAC5B/C,QAAMC,OAAOC,OAAO,QAAS8C,GAC7BhD,QAAMC,OAAOC,OAAO,SAAUG,GAG9BA,EAAO,GAAK0C,EAAK,GAAKC,EAAM,GAC5B3C,EAAO,GAAK0C,EAAK,GAAKC,EAAM,GAC5B3C,EAAO,GAAK0C,EAAK,GAAKC,EAAM,GAC5B3C,EAAO,GAAK0C,EAAK,GAAKC,EAAM,GACrB3C,GAWXjB,EAAQ8D,SAAW,SAASH,EAAMC,EAAO3C,GAWrC,OATAL,QAAMC,OAAOC,OAAO,OAAQ6C,GAC5B/C,QAAMC,OAAOC,OAAO,QAAS8C,GAC7BhD,QAAMC,OAAOC,OAAO,SAAUG,GAG9BA,EAAO,GAAK0C,EAAK,GAAKC,EAAM,GAC5B3C,EAAO,GAAK0C,EAAK,GAAKC,EAAM,GAC5B3C,EAAO,GAAK0C,EAAK,GAAKC,EAAM,GAC5B3C,EAAO,GAAK0C,EAAK,GAAKC,EAAM,GACrB3C,GAWXjB,EAAQ+D,iBAAmB,SAAS5C,EAAQ4B,EAAW9B,GAEnDL,QAAMC,OAAOC,OAAO,SAAUK,GAC9BP,QAAMC,OAAOC,OAAO,YAAaiC,GACjCnC,QAAMC,OAAOC,OAAO,SAAUG,GAG9B,IAAIS,EAAIP,EAAO,GAAK4B,EAAUrB,EAAIP,EAAO,GAAK4B,EAAUpB,EACpDA,EAAIR,EAAO,GAAK4B,EAAUrB,EAAIP,EAAO,GAAK4B,EAAUpB,EAIxD,OAFAV,EAAOS,EAAIA,EACXT,EAAOU,EAAIA,EACJV,GAWXjB,EAAQgE,iBAAmB,SAAS7C,EAAQ8C,EAAQhD,GAWhD,OATAL,QAAMC,OAAOC,OAAO,SAAUK,GAC9BP,QAAMC,OAAOgB,OAAO,SAAUoC,GAC9BrD,QAAMC,OAAOC,OAAO,SAAUG,GAG9BA,EAAO,GAAKE,EAAO,GAAK8C,EACxBhD,EAAO,GAAKE,EAAO,GAAK8C,EACxBhD,EAAO,GAAKE,EAAO,GAAK8C,EACxBhD,EAAO,GAAKE,EAAO,GAAK8C,EACjBhD,GAmBXjB,EAAQkE,gBAAkB,SAAS/C,EAAQM,EAAOR,GAW9C,OATAL,QAAMC,OAAOC,OAAO,SAAUK,GAC9BP,QAAMC,OAAOC,OAAO,QAASW,GAC7Bb,QAAMC,OAAOC,OAAO,SAAUG,GAG9BA,EAAO,GAAKE,EAAO,GAAKM,EAAMC,EAC9BT,EAAO,GAAKE,EAAO,GAAKM,EAAMC,EAC9BT,EAAO,GAAKE,EAAO,GAAKM,EAAME,EAC9BV,EAAO,GAAKE,EAAO,GAAKM,EAAME,EACvBV,GAUXjB,EAAQmE,OAAS,SAAShD,EAAQF,GAU9B,OARAL,QAAMC,OAAOC,OAAO,SAAUK,GAC9BP,QAAMC,OAAOC,OAAO,SAAUG,GAG9BA,EAAO,IAAME,EAAO,GACpBF,EAAO,IAAME,EAAO,GACpBF,EAAO,IAAME,EAAO,GACpBF,EAAO,IAAME,EAAO,GACbF,GAUXjB,EAAQoE,UAAY,SAASjD,EAAQF,GAEjCL,QAAMC,OAAOC,OAAO,SAAUK,GAC9BP,QAAMC,OAAOC,OAAO,SAAUG,GAG9B,IAAIhB,EAAckB,EAAO,GACrBhB,EAAcgB,EAAO,GACrBjB,EAAciB,EAAO,GACrBf,EAAce,EAAO,GAMzB,OAJAF,EAAO,GAAKhB,EACZgB,EAAO,GAAKd,EACZc,EAAO,GAAKf,EACZe,EAAO,GAAKb,EACLa,GAUXjB,EAAQqE,IAAM,SAASlD,EAAQF,GAW3B,OATAL,QAAMC,OAAOC,OAAO,SAAUK,GAC9BP,QAAMC,OAAOC,OAAO,SAAUG,GAG9BA,EAAO,GAAKgB,KAAKoC,IAAIlD,EAAO,IAC5BF,EAAO,GAAKgB,KAAKoC,IAAIlD,EAAO,IAC5BF,EAAO,GAAKgB,KAAKoC,IAAIlD,EAAO,IAC5BF,EAAO,GAAKgB,KAAKoC,IAAIlD,EAAO,IAErBF,GAWXjB,EAAQsE,OAAS,SAASX,EAAMC,GAC5B,OAAQD,IAASC,GACT7C,UAAQ4C,IACR5C,UAAQ6C,IACRD,EAAK,KAAOC,EAAM,IAClBD,EAAK,KAAOC,EAAM,IAClBD,EAAK,KAAOC,EAAM,IAClBD,EAAK,KAAOC,EAAM,IAM9B5D,EAAQuE,YAAc,SAASpD,EAAQT,EAAO8D,GAC1C,OAAOrD,EAAO,KAAOT,EAAM8D,IACpBrD,EAAO,KAAOT,EAAM8D,EAAS,IAC7BrD,EAAO,KAAOT,EAAM8D,EAAS,IAC7BrD,EAAO,KAAOT,EAAM8D,EAAS,IAaxCxE,EAAQyE,cAAgB,SAASd,EAAMC,EAAOc,GAK1C,OAHA9D,QAAMC,OAAOgB,OAAO,UAAW6C,GAGvBf,IAASC,GACR7C,UAAQ4C,IACT5C,UAAQ6C,IACR3B,KAAKoC,IAAIV,EAAK,GAAKC,EAAM,KAAOc,GAChCzC,KAAKoC,IAAIV,EAAK,GAAKC,EAAM,KAAOc,GAChCzC,KAAKoC,IAAIV,EAAK,GAAKC,EAAM,KAAOc,GAChCzC,KAAKoC,IAAIV,EAAK,GAAKC,EAAM,KAAOc,GAS5C1E,EAAQ2E,SAAWjF,OAAOC,OAAO,IAAIK,EAAQ,EAAK,EACN,EAAK,IAQjDA,EAAQ4E,KAAOlF,OAAOC,OAAO,IAAIK,EAAQ,EAAK,EACN,EAAK,IAY7CA,EAAQ6E,YAAc,EAYtB7E,EAAQ8E,YAAc,EAYtB9E,EAAQ+E,YAAc,EAYtB/E,EAAQgF,YAAc,EAEtBtF,OAAOuF,iBAAiBjF,EAAQkF,UAAW,CAOvCC,OAAS,CACLC,IAAM,WACF,OAAOpF,EAAQO,iBAW3BP,EAAQkF,UAAUhE,MAAQ,SAASD,GAC/B,OAAOjB,EAAQkB,MAAMb,KAAMY,IAU/BjB,EAAQkF,UAAUZ,OAAS,SAASV,GAChC,OAAO5D,EAAQsE,OAAOjE,KAAMuD,IAYhC5D,EAAQkF,UAAUT,cAAgB,SAASb,EAAOc,GAC9C,OAAO1E,EAAQyE,cAAcpE,KAAMuD,EAAOc,IAS9C1E,EAAQkF,UAAUG,SAAW,WACzB,MAAO,IAAMhF,KAAK,GAAK,KAAOA,KAAK,GAAK,OAC3BA,KAAK,GAAK,KAAOA,KAAK,GAAK,KC31B5C,IAAIiF,EAAgB,CAOhBC,OAASC,iBAAeD,OAQxBzF,MAAQ0F,iBAAe1F,MASvB2F,UAAYD,iBAAeC,UAQ3BC,WAAaF,iBAAeE,WAQ5B7F,UAAY2F,iBAAe3F,UAS3B8F,eAAiBH,iBAAeG,eAUhCC,aAAeJ,iBAAeI,aAK9BC,SAAW,SAASC,GAChB,OAAOA,IAAkBR,EAAcC,QAChCO,IAAkBR,EAAcxF,OAChCgG,IAAkBR,EAAcG,WAChCK,IAAkBR,EAAcI,YAChCI,IAAkBR,EAAczF,WAChCiG,IAAkBR,EAAcK,gBAChCG,IAAkBR,EAAcM,iBAGpClG,OAAOC,OAAO2F,GCfzB,SAASS,EAASC,GACdA,EAAU1F,eAAa0F,EAAS1F,eAAa2F,cAG7CrF,QAAMC,OAAOC,OAAO,qBAAsBkF,EAAQE,YAiDlD7F,KAAK6F,WAAaF,EAAQE,WAU1B7F,KAAK8F,QAAUH,EAAQG,QAUvB9F,KAAKyF,cAAgBxF,eAAa0F,EAAQF,cAAeR,EAAczF,WAUvEQ,KAAK+F,eAAiBJ,EAAQI,eAK9B/F,KAAKgG,aAAe/F,eAAa0F,EAAQK,aAAcC,EAAa1G,MAKpES,KAAKkG,iBAAmBP,EAAQO,iBAMhClG,KAAKmG,gBAAkBR,EAAQQ,gBAanCT,EAASU,wBAA0B,SAASC,GAExC9F,QAAMC,OAAOC,OAAO,WAAY4F,GAGhC,IAAIC,GAAoB,EACxB,IAAM,IAAIC,KAAYF,EAASR,WAC3B,GAAIQ,EAASR,WAAWW,eAAeD,IAC/B7F,UAAQ2F,EAASR,WAAWU,KAC5B7F,UAAQ2F,EAASR,WAAWU,GAAUtF,QAAS,CAEnD,IAAIwF,EAAYJ,EAASR,WAAWU,GAChCG,EAAMD,EAAUxF,OAAO6D,OAAS2B,EAAUE,uBAE9C,GAAKL,IAAqBI,IAA+B,IAAtBJ,EAC/B,MAAM,IAAIM,iBAAe,gEAG7BN,EAAmBI,EAI3B,OAAOJ,GAGX,IAAIO,EAAyB,IAAIC,eAC7BC,EAAmB,IAAIC,aACvBC,EAAyB,IAAIC,UAC7BC,EAA6C,CAAC,IAAIL,eAAgB,IAAIA,eAAgB,IAAIA,gBAC1FM,EAAoC,CAAC,IAAItE,aAAc,IAAIA,aAAc,IAAIA,cAC7EuE,EAAkB,CAAC,IAAIvE,aAAc,IAAIA,aAAc,IAAIA,cAC3DwE,EAAkB,IAAIN,aACtBO,EAAqB,IAAIC,aACzBC,EAA2B,IAAIP,UAC/BQ,EAAoB,IAAI/H,EA0B5B+F,EAASiC,iCAAmC,SAASC,EAAWC,EAAYC,EAAWC,GACnF,IAAIC,EAMAC,EAAkBC,YAAUC,OAAOJ,EAAmBlB,GACtDuB,EAAYtB,eAAauB,YAAYJ,EAAiBH,EAAWf,GACjEuB,EAAkBC,aAAWC,wBAAwBJ,EAAWN,EAAWb,GAC3EwB,EAAkBvB,UAAQwB,QAAQJ,EAAiBrB,GAEnD0B,EAAoBvB,EACpBwB,EAAsBzB,EAE1ByB,EAAoB,GAAGC,UAAYd,EAAkBe,KACrDF,EAAoB,GAAGG,SAAWhB,EAAkBiB,MAEpDJ,EAAoB,GAAGC,UAAYd,EAAkBe,KACrDF,EAAoB,GAAGG,SAAWhB,EAAkBkB,MAEpDL,EAAoB,GAAGC,UAAYd,EAAkBmB,KACrDN,EAAoB,GAAGG,SAAWhB,EAAkBiB,MAEpD,IAAIG,EAAS7B,EAEb,IAAKU,EAAI,EAAGA,EAAI,EAAGA,IACflB,eAAauB,YAAYO,EAAoBZ,GAAIF,EAAWqB,GAC5DA,EAASjC,UAAQkC,wBAAwBX,EAAiBU,EAAQA,GAClER,EAAkBX,GAAG3G,EAAI8H,EAAO9H,EAChCsH,EAAkBX,GAAG1G,EAAI6H,EAAO7H,EAMpC,IAAI+H,EAAW7B,aAAW8B,cAActC,aAAWuC,QAAS1B,EAAYN,GACpEiC,EAAgBC,UAAQC,eAAeL,EAAU5B,GAEjDkC,EAAkB/B,EAAU9C,OAC5B8E,EAAUC,OAAOC,kBACjBC,EAAUF,OAAOC,kBACjBE,EAAUH,OAAOI,kBACjBC,EAAUL,OAAOI,kBACrB,IAAKjC,EAAI,EAAGA,EAAI2B,EAAiB3B,IAC7BmB,EAASjC,UAAQkC,wBAAwBX,EAAiBb,EAAUI,GAAImB,GACxEA,EAASM,UAAQ/F,iBAAiB8F,EAAeL,EAAQA,GAEzDS,EAAUhI,KAAKuI,IAAIP,EAAST,EAAO9H,GACnC0I,EAAUnI,KAAKuI,IAAIJ,EAASZ,EAAO7H,GACnC0I,EAAUpI,KAAKwI,IAAIJ,EAASb,EAAO9H,GACnC6I,EAAUtI,KAAKwI,IAAIF,EAASf,EAAO7H,GAGvC,IAAI+I,EAAsB1K,EAAQ8B,aAAaoG,EAAYH,GAEvD4C,EAAWjD,EACfiD,EAAS,GAAGjJ,EAAIuI,EAChBU,EAAS,GAAGhJ,EAAIyI,EAEhBO,EAAS,GAAGjJ,EAAIuI,EAChBU,EAAS,GAAGhJ,EAAI4I,EAEhBI,EAAS,GAAGjJ,EAAI2I,EAChBM,EAAS,GAAGhJ,EAAIyI,EAEhB,IAAIQ,EAAiB5B,EAAkB,GACnC6B,EAAsB7B,EAAkB,GAAGtH,EAAIkJ,EAAelJ,EAC9DoJ,EAAuB9B,EAAkB,GAAGrH,EAAIiJ,EAAejJ,EAEnE,IAAK0G,EAAI,EAAGA,EAAI,EAAGA,IAAK,CACpB,IAAI0C,EAAUJ,EAAStC,GAEvBrI,EAAQ+D,iBAAiB2G,EAAqBK,EAASA,GAGvDA,EAAQrJ,GAAKqJ,EAAQrJ,EAAIkJ,EAAelJ,GAAKmJ,EAC7CE,EAAQpJ,GAAKoJ,EAAQpJ,EAAIiJ,EAAejJ,GAAKmJ,EAGjD,IAAIE,EAAcL,EAAS,GACvBM,EAAaN,EAAS,GACtBO,EAAaP,EAAS,GACtB1J,EAAS,IAAIkK,MAAM,GAKvB,OAJAhI,aAAW3C,KAAKwK,EAAa/J,GAC7BkC,aAAW3C,KAAKyK,EAAYhK,EAAQ,GACpCkC,aAAW3C,KAAK0K,EAAYjK,EAAQ,GAE7BA,oCC/RX,SAA2B+E,GAIvB,GAHAA,EAAU1F,eAAa0F,EAAS1F,eAAa2F,eAGxClF,UAAQiF,EAAQoF,mBACjB,MAAM,IAAInE,iBAAe,0CAE7B,IAAKlG,UAAQiF,EAAQgB,wBACjB,MAAM,IAAIC,iBAAe,+CAE7B,GAAIjB,EAAQgB,uBAAyB,GAAKhB,EAAQgB,uBAAyB,EACvE,MAAM,IAAIC,iBAAe,2DAE7B,IAAKlG,UAAQiF,EAAQ1E,QACjB,MAAM,IAAI2F,iBAAe,+BAY7B5G,KAAK+K,kBAAoBpF,EAAQoF,kBAoBjC/K,KAAK2G,uBAAyBhB,EAAQgB,uBAyBtC3G,KAAKgL,UAAY/K,eAAa0F,EAAQqF,WAAW,GAoBjDhL,KAAKiB,OAAS0E,EAAQ1E"}