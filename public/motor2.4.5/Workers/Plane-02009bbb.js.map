{"version":3,"file":"Plane-02009bbb.js","sources":["../../../../Source/Core/Plane.js"],"sourcesContent":["import Cartesian3 from './Cartesian3.js';\r\nimport Check from './Check.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport CesiumMath from './Math.js';\r\nimport Matrix4 from './Matrix4.js';\r\n\r\n    /**\r\n     * A plane in Hessian Normal Form defined by\r\n     * <pre>\r\n     * ax + by + cz + d = 0\r\n     * </pre>\r\n     * where (a, b, c) is the plane's <code>normal</code>, d is the signed\r\n     * <code>distance</code> to the plane, and (x, y, z) is any point on\r\n     * the plane.\r\n     *\r\n     * @alias Plane\r\n     * @constructor\r\n     *\r\n     * @param {Cartesian3} normal The plane's normal (normalized).\r\n     * @param {Number} distance The shortest distance from the origin to the plane.  The sign of\r\n     * <code>distance</code> determines which side of the plane the origin\r\n     * is on.  If <code>distance</code> is positive, the origin is in the half-space\r\n     * in the direction of the normal; if negative, the origin is in the half-space\r\n     * opposite to the normal; if zero, the plane passes through the origin.\r\n     *\r\n     * @example\r\n     * // The plane x=0\r\n     * var plane = new Cesium.Plane(Cesium.Cartesian3.UNIT_X, 0.0);\r\n     *\r\n     * @exception {DeveloperError} Normal must be normalized\r\n     */\r\n    function Plane(normal, distance) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('normal', normal);\r\n        if (!CesiumMath.equalsEpsilon(Cartesian3.magnitude(normal), 1.0, CesiumMath.EPSILON6)) {\r\n            throw new DeveloperError('normal must be normalized.');\r\n        }\r\n        Check.typeOf.number('distance', distance);\r\n        //>>includeEnd('debug');\r\n\r\n        /**\r\n         * The plane's normal.\r\n         *\r\n         * @type {Cartesian3}\r\n         */\r\n        this.normal = Cartesian3.clone(normal);\r\n\r\n        /**\r\n         * The shortest distance from the origin to the plane.  The sign of\r\n         * <code>distance</code> determines which side of the plane the origin\r\n         * is on.  If <code>distance</code> is positive, the origin is in the half-space\r\n         * in the direction of the normal; if negative, the origin is in the half-space\r\n         * opposite to the normal; if zero, the plane passes through the origin.\r\n         *\r\n         * @type {Number}\r\n         */\r\n        this.distance = distance;\r\n    }\r\n\r\n    /**\r\n     * Creates a plane from a normal and a point on the plane.\r\n     *\r\n     * @param {Cartesian3} point The point on the plane.\r\n     * @param {Cartesian3} normal The plane's normal (normalized).\r\n     * @param {Plane} [result] The object onto which to store the result.\r\n     * @returns {Plane} A new plane instance or the modified result parameter.\r\n     *\r\n     * @example\r\n     * var point = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);\r\n     * var normal = ellipsoid.geodeticSurfaceNormal(point);\r\n     * var tangentPlane = Cesium.Plane.fromPointNormal(point, normal);\r\n     *\r\n     * @exception {DeveloperError} Normal must be normalized\r\n     */\r\n    Plane.fromPointNormal = function(point, normal, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('point', point);\r\n        Check.typeOf.object('normal', normal);\r\n        if (!CesiumMath.equalsEpsilon(Cartesian3.magnitude(normal), 1.0, CesiumMath.EPSILON6)) {\r\n            throw new DeveloperError('normal must be normalized.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var distance = -Cartesian3.dot(normal, point);\r\n\r\n        if (!defined(result)) {\r\n            return new Plane(normal, distance);\r\n        }\r\n\r\n        Cartesian3.clone(normal, result.normal);\r\n        result.distance = distance;\r\n        return result;\r\n    };\r\n\r\n    var scratchNormal = new Cartesian3();\r\n    /**\r\n     * Creates a plane from the general equation\r\n     *\r\n     * @param {Cartesian4} coefficients The plane's normal (normalized).\r\n     * @param {Plane} [result] The object onto which to store the result.\r\n     * @returns {Plane} A new plane instance or the modified result parameter.\r\n     *\r\n     * @exception {DeveloperError} Normal must be normalized\r\n     */\r\n    Plane.fromCartesian4 = function(coefficients, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('coefficients', coefficients);\r\n        //>>includeEnd('debug');\r\n\r\n        var normal = Cartesian3.fromCartesian4(coefficients, scratchNormal);\r\n        var distance = coefficients.w;\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!CesiumMath.equalsEpsilon(Cartesian3.magnitude(normal), 1.0, CesiumMath.EPSILON6)) {\r\n            throw new DeveloperError('normal must be normalized.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            return new Plane(normal, distance);\r\n        }\r\n        Cartesian3.clone(normal, result.normal);\r\n        result.distance = distance;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the signed shortest distance of a point to a plane.\r\n     * The sign of the distance determines which side of the plane the point\r\n     * is on.  If the distance is positive, the point is in the half-space\r\n     * in the direction of the normal; if negative, the point is in the half-space\r\n     * opposite to the normal; if zero, the plane passes through the point.\r\n     *\r\n     * @param {Plane} plane The plane.\r\n     * @param {Cartesian3} point The point.\r\n     * @returns {Number} The signed shortest distance of the point to the plane.\r\n     */\r\n    Plane.getPointDistance = function(plane, point) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('plane', plane);\r\n        Check.typeOf.object('point', point);\r\n        //>>includeEnd('debug');\r\n\r\n        return Cartesian3.dot(plane.normal, point) + plane.distance;\r\n    };\r\n\r\n    var scratchCartesian = new Cartesian3();\r\n    /**\r\n     * Projects a point onto the plane.\r\n     * @param {Plane} plane The plane to project the point onto\r\n     * @param {Cartesian3} point The point to project onto the plane\r\n     * @param {Cartesian3} [result] The result point.  If undefined, a new Cartesian3 will be created.\r\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\r\n     */\r\n    Plane.projectPointOntoPlane = function(plane, point, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('plane', plane);\r\n        Check.typeOf.object('point', point);\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n\r\n        // projectedPoint = point - (normal.point + scale) * normal\r\n        var pointDistance = Plane.getPointDistance(plane, point);\r\n        var scaledNormal = Cartesian3.multiplyByScalar(plane.normal, pointDistance, scratchCartesian);\r\n\r\n        return Cartesian3.subtract(point, scaledNormal, result);\r\n    };\r\n\r\n    var scratchPosition = new Cartesian3();\r\n    /**\r\n     * Transforms the plane by the given transformation matrix.\r\n     *\r\n     * @param {Plane} plane The plane.\r\n     * @param {Matrix4} transform The transformation matrix.\r\n     * @param {Plane} [result] The object into which to store the result.\r\n     * @returns {Plane} The plane transformed by the given transformation matrix.\r\n     */\r\n    Plane.transform = function(plane, transform, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('plane', plane);\r\n        Check.typeOf.object('transform', transform);\r\n        //>>includeEnd('debug');\r\n\r\n        Matrix4.multiplyByPointAsVector(transform, plane.normal, scratchNormal);\r\n        Cartesian3.normalize(scratchNormal, scratchNormal);\r\n\r\n        Cartesian3.multiplyByScalar(plane.normal, -plane.distance, scratchPosition);\r\n        Matrix4.multiplyByPoint(transform, scratchPosition, scratchPosition);\r\n\r\n        return Plane.fromPointNormal(scratchPosition, scratchNormal, result);\r\n    };\r\n\r\n    /**\r\n     * Duplicates a Plane instance.\r\n     *\r\n     * @param {Plane} plane The plane to duplicate.\r\n     * @param {Plane} [result] The object onto which to store the result.\r\n     * @returns {Plane} The modified result parameter or a new Plane instance if one was not provided.\r\n     */\r\n    Plane.clone = function(plane, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('plane', plane);\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            return new Plane(plane.normal, plane.distance);\r\n        }\r\n\r\n        Cartesian3.clone(plane.normal, result.normal);\r\n        result.distance = plane.distance;\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Compares the provided Planes by normal and distance and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {Plane} left The first plane.\r\n     * @param {Plane} right The second plane.\r\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n     */\r\n    Plane.equals = function(left, right) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('left', left);\r\n        Check.typeOf.object('right', right);\r\n        //>>includeEnd('debug');\r\n\r\n        return (left.distance === right.distance) && Cartesian3.equals(left.normal, right.normal);\r\n    };\r\n\r\n    /**\r\n     * A constant initialized to the XY plane passing through the origin, with normal in positive Z.\r\n     *\r\n     * @type {Plane}\r\n     * @constant\r\n     */\r\n    Plane.ORIGIN_XY_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_Z, 0.0));\r\n\r\n    /**\r\n     * A constant initialized to the YZ plane passing through the origin, with normal in positive X.\r\n     *\r\n     * @type {Plane}\r\n     * @constant\r\n     */\r\n    Plane.ORIGIN_YZ_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_X, 0.0));\r\n\r\n    /**\r\n     * A constant initialized to the ZX plane passing through the origin, with normal in positive Y.\r\n     *\r\n     * @type {Plane}\r\n     * @constant\r\n     */\r\n    Plane.ORIGIN_ZX_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_Y, 0.0));\r\nexport default Plane;\r\n"],"names":["Plane","normal","distance","Check","typeOf","object","CesiumMath","equalsEpsilon","Cartesian3","magnitude","EPSILON6","DeveloperError","number","this","clone","fromPointNormal","point","result","dot","defined","scratchNormal","fromCartesian4","coefficients","w","getPointDistance","plane","scratchCartesian","projectPointOntoPlane","pointDistance","scaledNormal","multiplyByScalar","subtract","scratchPosition","transform","Matrix4","multiplyByPointAsVector","normalize","multiplyByPoint","equals","left","right","ORIGIN_XY_PLANE","Object","freeze","UNIT_Z","ORIGIN_YZ_PLANE","UNIT_X","ORIGIN_ZX_PLANE","UNIT_Y"],"mappings":"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"}