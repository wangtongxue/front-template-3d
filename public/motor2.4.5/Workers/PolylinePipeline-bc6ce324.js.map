{"version":3,"file":"PolylinePipeline-bc6ce324.js","sources":["../../../../Source/Core/PolylinePipeline.js"],"sourcesContent":["import Cartesian3 from './Cartesian3.js';\r\nimport Cartographic from './Cartographic.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport EllipsoidGeodesic from './EllipsoidGeodesic.js';\r\nimport EllipsoidRhumbLine from './EllipsoidRhumbLine.js';\r\nimport IntersectionTests from './IntersectionTests.js';\r\nimport CesiumMath from './Math.js';\r\nimport Matrix4 from './Matrix4.js';\r\nimport Plane from './Plane.js';\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    var PolylinePipeline = {};\r\n\r\n    PolylinePipeline.numberOfPoints = function(p0, p1, minDistance) {\r\n        var distance = Cartesian3.distance(p0, p1);\r\n        return Math.ceil(distance / minDistance);\r\n    };\r\n\r\n    PolylinePipeline.numberOfPointsRhumbLine = function(p0, p1, granularity) {\r\n        var radiansDistanceSquared = Math.pow((p0.longitude - p1.longitude), 2) + Math.pow((p0.latitude - p1.latitude), 2);\r\n        return Math.ceil(Math.sqrt(radiansDistanceSquared / (granularity * granularity)));\r\n    };\r\n\r\n    var cartoScratch = new Cartographic();\r\n    PolylinePipeline.extractHeights = function(positions, ellipsoid) {\r\n        var length = positions.length;\r\n        var heights = new Array(length);\r\n        for (var i = 0; i < length; i++) {\r\n            var p = positions[i];\r\n            heights[i] = ellipsoid.cartesianToCartographic(p, cartoScratch).height;\r\n        }\r\n        return heights;\r\n    };\r\n\r\n    var wrapLongitudeInversMatrix = new Matrix4();\r\n    var wrapLongitudeOrigin = new Cartesian3();\r\n    var wrapLongitudeXZNormal = new Cartesian3();\r\n    var wrapLongitudeXZPlane = new Plane(Cartesian3.UNIT_X, 0.0);\r\n    var wrapLongitudeYZNormal = new Cartesian3();\r\n    var wrapLongitudeYZPlane = new Plane(Cartesian3.UNIT_X, 0.0);\r\n    var wrapLongitudeIntersection = new Cartesian3();\r\n    var wrapLongitudeOffset = new Cartesian3();\r\n\r\n    var subdivideHeightsScratchArray = [];\r\n\r\n    function subdivideHeights(numPoints, h0, h1) {\r\n        var heights = subdivideHeightsScratchArray;\r\n        heights.length = numPoints;\r\n\r\n        var i;\r\n        if (h0 === h1) {\r\n            for (i = 0; i < numPoints; i++) {\r\n                heights[i] = h0;\r\n            }\r\n            return heights;\r\n        }\r\n\r\n        var dHeight = h1 - h0;\r\n        var heightPerVertex = dHeight / numPoints;\r\n\r\n        for (i = 0; i < numPoints; i++) {\r\n            var h = h0 + i*heightPerVertex;\r\n            heights[i] = h;\r\n        }\r\n\r\n        return heights;\r\n    }\r\n\r\n    var carto1 = new Cartographic();\r\n    var carto2 = new Cartographic();\r\n    var cartesian = new Cartesian3();\r\n    var scaleFirst = new Cartesian3();\r\n    var scaleLast = new Cartesian3();\r\n    var ellipsoidGeodesic = new EllipsoidGeodesic();\r\n    var ellipsoidRhumb = new EllipsoidRhumbLine();\r\n\r\n    //Returns subdivided line scaled to ellipsoid surface starting at p1 and ending at p2.\r\n    //Result includes p1, but not include p2.  This function is called for a sequence of line segments,\r\n    //and this prevents duplication of end point.\r\n    function generateCartesianArc(p0, p1, minDistance, ellipsoid, h0, h1, array, offset) {\r\n        var first = ellipsoid.scaleToGeodeticSurface(p0, scaleFirst);\r\n        var last = ellipsoid.scaleToGeodeticSurface(p1, scaleLast);\r\n        var numPoints = PolylinePipeline.numberOfPoints(p0, p1, minDistance);\r\n        var start = ellipsoid.cartesianToCartographic(first, carto1);\r\n        var end = ellipsoid.cartesianToCartographic(last, carto2);\r\n        var heights = subdivideHeights(numPoints, h0, h1);\r\n\r\n        ellipsoidGeodesic.setEndPoints(start, end);\r\n        var surfaceDistanceBetweenPoints = ellipsoidGeodesic.surfaceDistance / numPoints;\r\n\r\n        var index = offset;\r\n        start.height = h0;\r\n        var cart = ellipsoid.cartographicToCartesian(start, cartesian);\r\n        Cartesian3.pack(cart, array, index);\r\n        index += 3;\r\n\r\n        for (var i = 1; i < numPoints; i++) {\r\n            var carto = ellipsoidGeodesic.interpolateUsingSurfaceDistance(i * surfaceDistanceBetweenPoints, carto2);\r\n            carto.height = heights[i];\r\n            cart = ellipsoid.cartographicToCartesian(carto, cartesian);\r\n            Cartesian3.pack(cart, array, index);\r\n            index += 3;\r\n        }\r\n\r\n        return index;\r\n    }\r\n\r\n    //Returns subdivided line scaled to ellipsoid surface starting at p1 and ending at p2.\r\n    //Result includes p1, but not include p2.  This function is called for a sequence of line segments,\r\n    //and this prevents duplication of end point.\r\n    function generateCartesianRhumbArc(p0, p1, granularity, ellipsoid, h0, h1, array, offset) {\r\n        var first = ellipsoid.scaleToGeodeticSurface(p0, scaleFirst);\r\n        var last = ellipsoid.scaleToGeodeticSurface(p1, scaleLast);\r\n        var start = ellipsoid.cartesianToCartographic(first, carto1);\r\n        var end = ellipsoid.cartesianToCartographic(last, carto2);\r\n\r\n        var numPoints = PolylinePipeline.numberOfPointsRhumbLine(start, end, granularity);\r\n        var heights = subdivideHeights(numPoints, h0, h1);\r\n\r\n        if (!ellipsoidRhumb.ellipsoid.equals(ellipsoid)) {\r\n            ellipsoidRhumb = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\r\n        }\r\n        ellipsoidRhumb.setEndPoints(start, end);\r\n        var surfaceDistanceBetweenPoints = ellipsoidRhumb.surfaceDistance / numPoints;\r\n\r\n        var index = offset;\r\n        start.height = h0;\r\n        var cart = ellipsoid.cartographicToCartesian(start, cartesian);\r\n        Cartesian3.pack(cart, array, index);\r\n        index += 3;\r\n\r\n        for (var i = 1; i < numPoints; i++) {\r\n            var carto = ellipsoidRhumb.interpolateUsingSurfaceDistance(i * surfaceDistanceBetweenPoints, carto2);\r\n            carto.height = heights[i];\r\n            cart = ellipsoid.cartographicToCartesian(carto, cartesian);\r\n            Cartesian3.pack(cart, array, index);\r\n            index += 3;\r\n        }\r\n\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Breaks a {@link Polyline} into segments such that it does not cross the &plusmn;180 degree meridian of an ellipsoid.\r\n     *\r\n     * @param {Cartesian3[]} positions The polyline's Cartesian positions.\r\n     * @param {Matrix4} [modelMatrix=Matrix4.IDENTITY] The polyline's model matrix. Assumed to be an affine\r\n     * transformation matrix, where the upper left 3x3 elements are a rotation matrix, and\r\n     * the upper three elements in the fourth column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].\r\n     * The matrix is not verified to be in the proper form.\r\n     * @returns {Object} An object with a <code>positions</code> property that is an array of positions and a\r\n     * <code>segments</code> property.\r\n     *\r\n     *\r\n     * @example\r\n     * var polylines = new Cesium.PolylineCollection();\r\n     * var polyline = polylines.add(...);\r\n     * var positions = polyline.positions;\r\n     * var modelMatrix = polylines.modelMatrix;\r\n     * var segments = Cesium.PolylinePipeline.wrapLongitude(positions, modelMatrix);\r\n     *\r\n     * @see PolygonPipeline.wrapLongitude\r\n     * @see Polyline\r\n     * @see PolylineCollection\r\n     */\r\n    PolylinePipeline.wrapLongitude = function(positions, modelMatrix) {\r\n        var cartesians = [];\r\n        var segments = [];\r\n\r\n        if (defined(positions) && positions.length > 0) {\r\n            modelMatrix = defaultValue(modelMatrix, Matrix4.IDENTITY);\r\n            var inverseModelMatrix = Matrix4.inverseTransformation(modelMatrix, wrapLongitudeInversMatrix);\r\n\r\n            var origin = Matrix4.multiplyByPoint(inverseModelMatrix, Cartesian3.ZERO, wrapLongitudeOrigin);\r\n            var xzNormal = Cartesian3.normalize(Matrix4.multiplyByPointAsVector(inverseModelMatrix, Cartesian3.UNIT_Y, wrapLongitudeXZNormal), wrapLongitudeXZNormal);\r\n            var xzPlane = Plane.fromPointNormal(origin, xzNormal, wrapLongitudeXZPlane);\r\n            var yzNormal = Cartesian3.normalize(Matrix4.multiplyByPointAsVector(inverseModelMatrix, Cartesian3.UNIT_X, wrapLongitudeYZNormal), wrapLongitudeYZNormal);\r\n            var yzPlane = Plane.fromPointNormal(origin, yzNormal, wrapLongitudeYZPlane);\r\n\r\n            var count = 1;\r\n            cartesians.push(Cartesian3.clone(positions[0]));\r\n            var prev = cartesians[0];\r\n\r\n            var length = positions.length;\r\n            for (var i = 1; i < length; ++i) {\r\n                var cur = positions[i];\r\n\r\n                // intersects the IDL if either endpoint is on the negative side of the yz-plane\r\n                if (Plane.getPointDistance(yzPlane, prev) < 0.0 || Plane.getPointDistance(yzPlane, cur) < 0.0) {\r\n                    // and intersects the xz-plane\r\n                    var intersection = IntersectionTests.lineSegmentPlane(prev, cur, xzPlane, wrapLongitudeIntersection);\r\n                    if (defined(intersection)) {\r\n                        // move point on the xz-plane slightly away from the plane\r\n                        var offset = Cartesian3.multiplyByScalar(xzNormal, 5.0e-9, wrapLongitudeOffset);\r\n                        if (Plane.getPointDistance(xzPlane, prev) < 0.0) {\r\n                            Cartesian3.negate(offset, offset);\r\n                        }\r\n\r\n                        cartesians.push(Cartesian3.add(intersection, offset, new Cartesian3()));\r\n                        segments.push(count + 1);\r\n\r\n                        Cartesian3.negate(offset, offset);\r\n                        cartesians.push(Cartesian3.add(intersection, offset, new Cartesian3()));\r\n                        count = 1;\r\n                    }\r\n                }\r\n\r\n                cartesians.push(Cartesian3.clone(positions[i]));\r\n                count++;\r\n\r\n                prev = cur;\r\n            }\r\n\r\n            segments.push(count);\r\n        }\r\n\r\n        return {\r\n            positions : cartesians,\r\n            lengths : segments\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Subdivides polyline and raises all points to the specified height.  Returns an array of numbers to represent the positions.\r\n     * @param {Object} options Object with the following properties:\r\n     * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\r\n     * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\r\n     * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\r\n     * @returns {Number[]} A new array of positions of type {Number} that have been subdivided and raised to the surface of the ellipsoid.\r\n     *\r\n     * @example\r\n     * var positions = Cesium.Cartesian3.fromDegreesArray([\r\n     *   -105.0, 40.0,\r\n     *   -100.0, 38.0,\r\n     *   -105.0, 35.0,\r\n     *   -100.0, 32.0\r\n     * ]);\r\n     * var surfacePositions = Cesium.PolylinePipeline.generateArc({\r\n     *   positons: positions\r\n     * });\r\n     */\r\n    PolylinePipeline.generateArc = function(options) {\r\n        if (!defined(options)) {\r\n            options = {};\r\n        }\r\n        var positions = options.positions;\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(positions)) {\r\n            throw new DeveloperError('options.positions is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var length = positions.length;\r\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n        var height = defaultValue(options.height, 0);\r\n        var hasHeightArray = Array.isArray(height);\r\n\r\n        if (length < 1) {\r\n            return [];\r\n        } else if (length === 1) {\r\n            var p = ellipsoid.scaleToGeodeticSurface(positions[0], scaleFirst);\r\n            height = hasHeightArray ? height[0] : height;\r\n            if (height !== 0) {\r\n                var n = ellipsoid.geodeticSurfaceNormal(p, cartesian);\r\n                Cartesian3.multiplyByScalar(n, height, n);\r\n                Cartesian3.add(p, n, p);\r\n            }\r\n\r\n            return [p.x, p.y, p.z];\r\n        }\r\n\r\n        var minDistance = options.minDistance;\r\n        if (!defined(minDistance)) {\r\n            var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\r\n            minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\r\n        }\r\n\r\n        var numPoints = 0;\r\n        var i;\r\n\r\n        for (i = 0; i < length -1; i++) {\r\n            numPoints += PolylinePipeline.numberOfPoints(positions[i], positions[i+1], minDistance);\r\n        }\r\n\r\n        var arrayLength = (numPoints + 1) * 3;\r\n        var newPositions = new Array(arrayLength);\r\n        var offset = 0;\r\n\r\n        for (i = 0; i < length - 1; i++) {\r\n            var p0 = positions[i];\r\n            var p1 = positions[i + 1];\r\n\r\n            var h0 = hasHeightArray ? height[i] : height;\r\n            var h1 = hasHeightArray ? height[i + 1] : height;\r\n\r\n            offset = generateCartesianArc(p0, p1, minDistance, ellipsoid, h0, h1, newPositions, offset);\r\n        }\r\n\r\n        subdivideHeightsScratchArray.length = 0;\r\n\r\n        var lastPoint = positions[length - 1];\r\n        var carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);\r\n        carto.height = hasHeightArray ? height[length - 1] : height;\r\n        var cart = ellipsoid.cartographicToCartesian(carto, cartesian);\r\n        Cartesian3.pack(cart, newPositions, arrayLength - 3);\r\n\r\n        return newPositions;\r\n    };\r\n\r\n    var scratchCartographic0 = new Cartographic();\r\n    var scratchCartographic1 = new Cartographic();\r\n\r\n    /**\r\n     * Subdivides polyline and raises all points to the specified height using Rhumb lines.  Returns an array of numbers to represent the positions.\r\n     * @param {Object} options Object with the following properties:\r\n     * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\r\n     * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\r\n     * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\r\n     * @returns {Number[]} A new array of positions of type {Number} that have been subdivided and raised to the surface of the ellipsoid.\r\n     *\r\n     * @example\r\n     * var positions = Cesium.Cartesian3.fromDegreesArray([\r\n     *   -105.0, 40.0,\r\n     *   -100.0, 38.0,\r\n     *   -105.0, 35.0,\r\n     *   -100.0, 32.0\r\n     * ]);\r\n     * var surfacePositions = Cesium.PolylinePipeline.generateRhumbArc({\r\n     *   positons: positions\r\n     * });\r\n     */\r\n    PolylinePipeline.generateRhumbArc = function(options) {\r\n        if (!defined(options)) {\r\n            options = {};\r\n        }\r\n        var positions = options.positions;\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(positions)) {\r\n            throw new DeveloperError('options.positions is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var length = positions.length;\r\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n        var height = defaultValue(options.height, 0);\r\n        var hasHeightArray = Array.isArray(height);\r\n\r\n        if (length < 1) {\r\n            return [];\r\n        } else if (length === 1) {\r\n            var p = ellipsoid.scaleToGeodeticSurface(positions[0], scaleFirst);\r\n            height = hasHeightArray ? height[0] : height;\r\n            if (height !== 0) {\r\n                var n = ellipsoid.geodeticSurfaceNormal(p, cartesian);\r\n                Cartesian3.multiplyByScalar(n, height, n);\r\n                Cartesian3.add(p, n, p);\r\n            }\r\n\r\n            return [p.x, p.y, p.z];\r\n        }\r\n\r\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\r\n\r\n        var numPoints = 0;\r\n        var i;\r\n\r\n        var c0 = ellipsoid.cartesianToCartographic(positions[0], scratchCartographic0);\r\n        var c1;\r\n        for (i = 0; i < length - 1; i++) {\r\n            c1 = ellipsoid.cartesianToCartographic(positions[i + 1], scratchCartographic1);\r\n            numPoints += PolylinePipeline.numberOfPointsRhumbLine(c0, c1, granularity);\r\n            c0 = Cartographic.clone(c1, scratchCartographic0);\r\n        }\r\n\r\n        var arrayLength = (numPoints + 1) * 3;\r\n        var newPositions = new Array(arrayLength);\r\n        var offset = 0;\r\n\r\n        for (i = 0; i < length - 1; i++) {\r\n            var p0 = positions[i];\r\n            var p1 = positions[i + 1];\r\n\r\n            var h0 = hasHeightArray ? height[i] : height;\r\n            var h1 = hasHeightArray ? height[i + 1] : height;\r\n\r\n            offset = generateCartesianRhumbArc(p0, p1, granularity, ellipsoid, h0, h1, newPositions, offset);\r\n        }\r\n\r\n        subdivideHeightsScratchArray.length = 0;\r\n\r\n        var lastPoint = positions[length - 1];\r\n        var carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);\r\n        carto.height = hasHeightArray ? height[length - 1] : height;\r\n        var cart = ellipsoid.cartographicToCartesian(carto, cartesian);\r\n        Cartesian3.pack(cart, newPositions, arrayLength - 3);\r\n\r\n        return newPositions;\r\n    };\r\n\r\n    /**\r\n     * Subdivides polyline and raises all points to the specified height. Returns an array of new {Cartesian3} positions.\r\n     * @param {Object} options Object with the following properties:\r\n     * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\r\n     * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\r\n     * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\r\n     * @returns {Cartesian3[]} A new array of cartesian3 positions that have been subdivided and raised to the surface of the ellipsoid.\r\n     *\r\n     * @example\r\n     * var positions = Cesium.Cartesian3.fromDegreesArray([\r\n     *   -105.0, 40.0,\r\n     *   -100.0, 38.0,\r\n     *   -105.0, 35.0,\r\n     *   -100.0, 32.0\r\n     * ]);\r\n     * var surfacePositions = Cesium.PolylinePipeline.generateCartesianArc({\r\n     *   positons: positions\r\n     * });\r\n     */\r\n    PolylinePipeline.generateCartesianArc = function(options) {\r\n        var numberArray = PolylinePipeline.generateArc(options);\r\n        var size = numberArray.length/3;\r\n        var newPositions = new Array(size);\r\n        for (var i = 0; i < size; i++) {\r\n            newPositions[i] = Cartesian3.unpack(numberArray, i*3);\r\n        }\r\n        return newPositions;\r\n    };\r\n\r\n    /**\r\n     * Subdivides polyline and raises all points to the specified height using Rhumb Lines. Returns an array of new {Cartesian3} positions.\r\n     * @param {Object} options Object with the following properties:\r\n     * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\r\n     * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\r\n     * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\r\n     * @returns {Cartesian3[]} A new array of cartesian3 positions that have been subdivided and raised to the surface of the ellipsoid.\r\n     *\r\n     * @example\r\n     * var positions = Cesium.Cartesian3.fromDegreesArray([\r\n     *   -105.0, 40.0,\r\n     *   -100.0, 38.0,\r\n     *   -105.0, 35.0,\r\n     *   -100.0, 32.0\r\n     * ]);\r\n     * var surfacePositions = Cesium.PolylinePipeline.generateCartesianRhumbArc({\r\n     *   positons: positions\r\n     * });\r\n     */\r\n    PolylinePipeline.generateCartesianRhumbArc = function(options) {\r\n        var numberArray = PolylinePipeline.generateRhumbArc(options);\r\n        var size = numberArray.length/3;\r\n        var newPositions = new Array(size);\r\n        for (var i = 0; i < size; i++) {\r\n            newPositions[i] = Cartesian3.unpack(numberArray, i*3);\r\n        }\r\n        return newPositions;\r\n    };\r\nexport default PolylinePipeline;\r\n"],"names":["PolylinePipeline","numberOfPoints","p0","p1","minDistance","distance","Cartesian3","Math","ceil","numberOfPointsRhumbLine","granularity","radiansDistanceSquared","pow","longitude","latitude","sqrt","cartoScratch","Cartographic","extractHeights","positions","ellipsoid","length","heights","Array","i","p","cartesianToCartographic","height","wrapLongitudeInversMatrix","Matrix4","wrapLongitudeOrigin","wrapLongitudeXZNormal","wrapLongitudeXZPlane","Plane","UNIT_X","wrapLongitudeYZNormal","wrapLongitudeYZPlane","wrapLongitudeIntersection","wrapLongitudeOffset","subdivideHeightsScratchArray","subdivideHeights","numPoints","h0","h1","heightPerVertex","h","carto1","carto2","cartesian","scaleFirst","scaleLast","ellipsoidGeodesic","EllipsoidGeodesic","ellipsoidRhumb","EllipsoidRhumbLine","generateCartesianArc","array","offset","first","scaleToGeodeticSurface","last","start","end","setEndPoints","surfaceDistanceBetweenPoints","surfaceDistance","index","cart","cartographicToCartesian","pack","carto","interpolateUsingSurfaceDistance","generateCartesianRhumbArc","equals","undefined","wrapLongitude","modelMatrix","cartesians","segments","defined","defaultValue","IDENTITY","inverseModelMatrix","inverseTransformation","origin","multiplyByPoint","ZERO","xzNormal","normalize","multiplyByPointAsVector","UNIT_Y","xzPlane","fromPointNormal","yzNormal","yzPlane","count","push","clone","prev","cur","getPointDistance","intersection","IntersectionTests","lineSegmentPlane","multiplyByScalar","negate","add","lengths","generateArc","options","DeveloperError","Ellipsoid","WGS84","hasHeightArray","isArray","n","geodeticSurfaceNormal","x","y","z","CesiumMath","RADIANS_PER_DEGREE","chordLength","maximumRadius","arrayLength","newPositions","lastPoint","scratchCartographic0","scratchCartographic1","generateRhumbArc","c1","c0","numberArray","size","unpack"],"mappings":"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"}