{"version":3,"file":"CorridorGeometryLibrary-3680b5c9.js","sources":["../../../../Source/Core/CorridorGeometryLibrary.js"],"sourcesContent":["import Cartesian3 from './Cartesian3.js';\r\nimport CornerType from './CornerType.js';\r\nimport defined from './defined.js';\r\nimport CesiumMath from './Math.js';\r\nimport Matrix3 from './Matrix3.js';\r\nimport PolylinePipeline from './PolylinePipeline.js';\r\nimport PolylineVolumeGeometryLibrary from './PolylineVolumeGeometryLibrary.js';\r\nimport Quaternion from './Quaternion.js';\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    var CorridorGeometryLibrary = {};\r\n\r\n    var scratch1 = new Cartesian3();\r\n    var scratch2 = new Cartesian3();\r\n    var scratch3 = new Cartesian3();\r\n    var scratch4 = new Cartesian3();\r\n\r\n    var scaleArray2 = [new Cartesian3(), new Cartesian3()];\r\n\r\n    var cartesian1 = new Cartesian3();\r\n    var cartesian2 = new Cartesian3();\r\n    var cartesian3 = new Cartesian3();\r\n    var cartesian4 = new Cartesian3();\r\n    var cartesian5 = new Cartesian3();\r\n    var cartesian6 = new Cartesian3();\r\n    var cartesian7 = new Cartesian3();\r\n    var cartesian8 = new Cartesian3();\r\n    var cartesian9 = new Cartesian3();\r\n    var cartesian10 = new Cartesian3();\r\n\r\n    var quaterion = new Quaternion();\r\n    var rotMatrix = new Matrix3();\r\n    function computeRoundCorner(cornerPoint, startPoint, endPoint, cornerType, leftIsOutside) {\r\n        var angle = Cartesian3.angleBetween(Cartesian3.subtract(startPoint, cornerPoint, scratch1), Cartesian3.subtract(endPoint, cornerPoint, scratch2));\r\n        var granularity = (cornerType === CornerType.BEVELED) ? 1 : Math.ceil(angle / CesiumMath.toRadians(5)) + 1;\r\n\r\n        var size = granularity * 3;\r\n        var array = new Array(size);\r\n\r\n        array[size - 3] = endPoint.x;\r\n        array[size - 2] = endPoint.y;\r\n        array[size - 1] = endPoint.z;\r\n\r\n        var m;\r\n        if (leftIsOutside) {\r\n            m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(Cartesian3.negate(cornerPoint, scratch1), angle / granularity, quaterion), rotMatrix);\r\n        } else {\r\n            m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(cornerPoint, angle / granularity, quaterion), rotMatrix);\r\n        }\r\n\r\n        var index = 0;\r\n        startPoint = Cartesian3.clone(startPoint, scratch1);\r\n        for (var i = 0; i < granularity; i++) {\r\n            startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);\r\n            array[index++] = startPoint.x;\r\n            array[index++] = startPoint.y;\r\n            array[index++] = startPoint.z;\r\n        }\r\n\r\n        return array;\r\n    }\r\n\r\n    function addEndCaps(calculatedPositions) {\r\n        var cornerPoint = cartesian1;\r\n        var startPoint = cartesian2;\r\n        var endPoint = cartesian3;\r\n\r\n        var leftEdge = calculatedPositions[1];\r\n        startPoint = Cartesian3.fromArray(calculatedPositions[1], leftEdge.length - 3, startPoint);\r\n        endPoint = Cartesian3.fromArray(calculatedPositions[0], 0, endPoint);\r\n        cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);\r\n        var firstEndCap = computeRoundCorner(cornerPoint, startPoint, endPoint, CornerType.ROUNDED, false);\r\n\r\n        var length = calculatedPositions.length - 1;\r\n        var rightEdge = calculatedPositions[length - 1];\r\n        leftEdge = calculatedPositions[length];\r\n        startPoint = Cartesian3.fromArray(rightEdge, rightEdge.length - 3, startPoint);\r\n        endPoint = Cartesian3.fromArray(leftEdge, 0, endPoint);\r\n        cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);\r\n        var lastEndCap = computeRoundCorner(cornerPoint, startPoint, endPoint, CornerType.ROUNDED, false);\r\n\r\n        return [firstEndCap, lastEndCap];\r\n    }\r\n\r\n    function computeMiteredCorner(position, leftCornerDirection, lastPoint, leftIsOutside) {\r\n        var cornerPoint = scratch1;\r\n        if (leftIsOutside) {\r\n            cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);\r\n        } else {\r\n            leftCornerDirection = Cartesian3.negate(leftCornerDirection, leftCornerDirection);\r\n            cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);\r\n        }\r\n        return [cornerPoint.x, cornerPoint.y, cornerPoint.z, lastPoint.x, lastPoint.y, lastPoint.z];\r\n    }\r\n\r\n    function addShiftedPositions(positions, left, scalar, calculatedPositions) {\r\n        var rightPositions = new Array(positions.length);\r\n        var leftPositions = new Array(positions.length);\r\n        var scaledLeft = Cartesian3.multiplyByScalar(left, scalar, scratch1);\r\n        var scaledRight = Cartesian3.negate(scaledLeft, scratch2);\r\n        var rightIndex = 0;\r\n        var leftIndex = positions.length - 1;\r\n\r\n        for (var i = 0; i < positions.length; i += 3) {\r\n            var pos = Cartesian3.fromArray(positions, i, scratch3);\r\n            var rightPos = Cartesian3.add(pos, scaledRight, scratch4);\r\n            rightPositions[rightIndex++] = rightPos.x;\r\n            rightPositions[rightIndex++] = rightPos.y;\r\n            rightPositions[rightIndex++] = rightPos.z;\r\n\r\n            var leftPos = Cartesian3.add(pos, scaledLeft, scratch4);\r\n            leftPositions[leftIndex--] = leftPos.z;\r\n            leftPositions[leftIndex--] = leftPos.y;\r\n            leftPositions[leftIndex--] = leftPos.x;\r\n        }\r\n        calculatedPositions.push(rightPositions, leftPositions);\r\n\r\n        return calculatedPositions;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    CorridorGeometryLibrary.addAttribute = function(attribute, value, front, back) {\r\n        var x = value.x;\r\n        var y = value.y;\r\n        var z = value.z;\r\n        if (defined(front)) {\r\n            attribute[front] = x;\r\n            attribute[front + 1] = y;\r\n            attribute[front + 2] = z;\r\n        }\r\n        if (defined(back)) {\r\n            attribute[back] = z;\r\n            attribute[back - 1] = y;\r\n            attribute[back - 2] = x;\r\n        }\r\n    };\r\n\r\n    var scratchForwardProjection = new Cartesian3();\r\n    var scratchBackwardProjection = new Cartesian3();\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    CorridorGeometryLibrary.computePositions = function(params) {\r\n        var granularity = params.granularity;\r\n        var positions = params.positions;\r\n        var ellipsoid = params.ellipsoid;\r\n        var width = params.width / 2;\r\n        var cornerType = params.cornerType;\r\n        var saveAttributes = params.saveAttributes;\r\n        var normal = cartesian1;\r\n        var forward = cartesian2;\r\n        var backward = cartesian3;\r\n        var left = cartesian4;\r\n        var cornerDirection = cartesian5;\r\n        var startPoint = cartesian6;\r\n        var previousPos = cartesian7;\r\n        var rightPos = cartesian8;\r\n        var leftPos = cartesian9;\r\n        var center = cartesian10;\r\n        var calculatedPositions = [];\r\n        var calculatedLefts = (saveAttributes) ? [] : undefined;\r\n        var calculatedNormals = (saveAttributes) ? [] : undefined;\r\n        var position = positions[0]; //add first point\r\n        var nextPosition = positions[1];\r\n\r\n        forward = Cartesian3.normalize(Cartesian3.subtract(nextPosition, position, forward), forward);\r\n        normal = ellipsoid.geodeticSurfaceNormal(position, normal);\r\n        left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);\r\n        if (saveAttributes) {\r\n            calculatedLefts.push(left.x, left.y, left.z);\r\n            calculatedNormals.push(normal.x, normal.y, normal.z);\r\n        }\r\n        previousPos = Cartesian3.clone(position, previousPos);\r\n        position = nextPosition;\r\n        backward = Cartesian3.negate(forward, backward);\r\n\r\n        var subdividedPositions;\r\n        var corners = [];\r\n        var i;\r\n        var length = positions.length;\r\n        for (i = 1; i < length - 1; i++) { // add middle points and corners\r\n            normal = ellipsoid.geodeticSurfaceNormal(position, normal);\r\n            nextPosition = positions[i + 1];\r\n            forward = Cartesian3.normalize(Cartesian3.subtract(nextPosition, position, forward), forward);\r\n            cornerDirection = Cartesian3.normalize(Cartesian3.add(forward, backward, cornerDirection), cornerDirection);\r\n\r\n            var forwardProjection = Cartesian3.multiplyByScalar(normal, Cartesian3.dot(forward, normal), scratchForwardProjection);\r\n            Cartesian3.subtract(forward, forwardProjection, forwardProjection);\r\n            Cartesian3.normalize(forwardProjection, forwardProjection);\r\n\r\n            var backwardProjection = Cartesian3.multiplyByScalar(normal, Cartesian3.dot(backward, normal), scratchBackwardProjection);\r\n            Cartesian3.subtract(backward, backwardProjection, backwardProjection);\r\n            Cartesian3.normalize(backwardProjection, backwardProjection);\r\n\r\n            var doCorner = !CesiumMath.equalsEpsilon(Math.abs(Cartesian3.dot(forwardProjection, backwardProjection)), 1.0, CesiumMath.EPSILON7);\r\n\r\n            if (doCorner) {\r\n                cornerDirection = Cartesian3.cross(cornerDirection, normal, cornerDirection);\r\n                cornerDirection = Cartesian3.cross(normal, cornerDirection, cornerDirection);\r\n                cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\r\n                var scalar = width / Math.max(0.25, Cartesian3.magnitude(Cartesian3.cross(cornerDirection, backward, scratch1)));\r\n                var leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(forward, backward, position, ellipsoid);\r\n                cornerDirection = Cartesian3.multiplyByScalar(cornerDirection, scalar, cornerDirection);\r\n                if (leftIsOutside) {\r\n                    rightPos = Cartesian3.add(position, cornerDirection, rightPos);\r\n                    center = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width, center), center);\r\n                    leftPos = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width * 2, leftPos), leftPos);\r\n                    scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\r\n                    scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);\r\n                    subdividedPositions = PolylinePipeline.generateArc({\r\n                        positions: scaleArray2,\r\n                        granularity: granularity,\r\n                        ellipsoid: ellipsoid\r\n                    });\r\n                    calculatedPositions = addShiftedPositions(subdividedPositions, left, width, calculatedPositions);\r\n                    if (saveAttributes) {\r\n                        calculatedLefts.push(left.x, left.y, left.z);\r\n                        calculatedNormals.push(normal.x, normal.y, normal.z);\r\n                    }\r\n                    startPoint = Cartesian3.clone(leftPos, startPoint);\r\n                    left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);\r\n                    leftPos = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width * 2, leftPos), leftPos);\r\n                    previousPos = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width, previousPos), previousPos);\r\n                    if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {\r\n                        corners.push({\r\n                            leftPositions : computeRoundCorner(rightPos, startPoint, leftPos, cornerType, leftIsOutside)\r\n                        });\r\n                    } else {\r\n                        corners.push({\r\n                            leftPositions : computeMiteredCorner(position, Cartesian3.negate(cornerDirection, cornerDirection), leftPos, leftIsOutside)\r\n                        });\r\n                    }\r\n                } else {\r\n                    leftPos = Cartesian3.add(position, cornerDirection, leftPos);\r\n                    center = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width, center), center), center);\r\n                    rightPos = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width * 2, rightPos), rightPos), rightPos);\r\n                    scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\r\n                    scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);\r\n                    subdividedPositions = PolylinePipeline.generateArc({\r\n                        positions: scaleArray2,\r\n                        granularity: granularity,\r\n                        ellipsoid: ellipsoid\r\n                    });\r\n                    calculatedPositions = addShiftedPositions(subdividedPositions, left, width, calculatedPositions);\r\n                    if (saveAttributes) {\r\n                        calculatedLefts.push(left.x, left.y, left.z);\r\n                        calculatedNormals.push(normal.x, normal.y, normal.z);\r\n                    }\r\n                    startPoint = Cartesian3.clone(rightPos, startPoint);\r\n                    left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);\r\n                    rightPos = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width * 2, rightPos), rightPos), rightPos);\r\n                    previousPos = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width, previousPos), previousPos), previousPos);\r\n                    if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {\r\n                        corners.push({\r\n                            rightPositions : computeRoundCorner(leftPos, startPoint, rightPos, cornerType, leftIsOutside)\r\n                        });\r\n                    } else {\r\n                        corners.push({\r\n                            rightPositions : computeMiteredCorner(position, cornerDirection, rightPos, leftIsOutside)\r\n                        });\r\n                    }\r\n                }\r\n                backward = Cartesian3.negate(forward, backward);\r\n            }\r\n            position = nextPosition;\r\n        }\r\n\r\n        normal = ellipsoid.geodeticSurfaceNormal(position, normal);\r\n        scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\r\n        scaleArray2[1] = Cartesian3.clone(position, scaleArray2[1]);\r\n        subdividedPositions = PolylinePipeline.generateArc({\r\n            positions: scaleArray2,\r\n            granularity: granularity,\r\n            ellipsoid: ellipsoid\r\n        });\r\n        calculatedPositions = addShiftedPositions(subdividedPositions, left, width, calculatedPositions);\r\n        if (saveAttributes) {\r\n            calculatedLefts.push(left.x, left.y, left.z);\r\n            calculatedNormals.push(normal.x, normal.y, normal.z);\r\n        }\r\n\r\n        var endPositions;\r\n        if (cornerType === CornerType.ROUNDED) {\r\n            endPositions = addEndCaps(calculatedPositions);\r\n        }\r\n\r\n        return {\r\n            positions : calculatedPositions,\r\n            corners : corners,\r\n            lefts : calculatedLefts,\r\n            normals : calculatedNormals,\r\n            endPositions : endPositions\r\n        };\r\n    };\r\nexport default CorridorGeometryLibrary;\r\n"],"names":["CorridorGeometryLibrary","scratch1","Cartesian3","scratch2","scratch3","scratch4","scaleArray2","cartesian1","cartesian2","cartesian3","cartesian4","cartesian5","cartesian6","cartesian7","cartesian8","cartesian9","cartesian10","quaterion","Quaternion","rotMatrix","Matrix3","computeRoundCorner","cornerPoint","startPoint","endPoint","cornerType","leftIsOutside","m","angle","angleBetween","subtract","granularity","CornerType","BEVELED","Math","ceil","CesiumMath","toRadians","size","array","Array","x","y","z","fromQuaternion","fromAxisAngle","negate","index","clone","i","multiplyByVector","computeMiteredCorner","position","leftCornerDirection","lastPoint","add","addShiftedPositions","positions","left","scalar","calculatedPositions","rightPositions","length","leftPositions","scaledLeft","multiplyByScalar","scaledRight","rightIndex","leftIndex","pos","fromArray","rightPos","leftPos","push","addAttribute","attribute","value","front","back","defined","scratchForwardProjection","scratchBackwardProjection","computePositions","params","ellipsoid","width","saveAttributes","normal","forward","backward","cornerDirection","previousPos","center","calculatedLefts","undefined","calculatedNormals","nextPosition","normalize","geodeticSurfaceNormal","cross","endPositions","corners","forwardProjection","dot","backwardProjection","equalsEpsilon","abs","EPSILON7","max","magnitude","PolylineVolumeGeometryLibrary","angleIsGreaterThanPi","PolylinePipeline","generateArc","ROUNDED","leftEdge","firstEndCap","midpoint","rightEdge","addEndCaps","lefts","normals"],"mappings":"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"}