{"version":3,"file":"decodeDraco.js","sources":["../../../../Source/WorkersES6/decodeDraco.js"],"sourcesContent":["/* global require */\r\nimport ComponentDatatype from '../Core/ComponentDatatype.js';\r\nimport defined from '../Core/defined.js';\r\nimport IndexDatatype from '../Core/IndexDatatype.js';\r\nimport RuntimeError from '../Core/RuntimeError.js';\r\nimport createTaskProcessorWorker from './createTaskProcessorWorker.js';\r\n\r\n    var draco;\r\n\r\n    function decodeIndexArray(dracoGeometry, dracoDecoder) {\r\n        var numPoints = dracoGeometry.num_points();\r\n        var numFaces = dracoGeometry.num_faces();\r\n        var faceIndices = new draco.DracoInt32Array();\r\n        var numIndices = numFaces * 3;\r\n        var indexArray = IndexDatatype.createTypedArray(numPoints, numIndices);\r\n\r\n        var offset = 0;\r\n        for (var i = 0; i < numFaces; ++i) {\r\n            dracoDecoder.GetFaceFromMesh(dracoGeometry, i, faceIndices);\r\n\r\n            indexArray[offset + 0] = faceIndices.GetValue(0);\r\n            indexArray[offset + 1] = faceIndices.GetValue(1);\r\n            indexArray[offset + 2] = faceIndices.GetValue(2);\r\n            offset += 3;\r\n        }\r\n\r\n        draco.destroy(faceIndices);\r\n\r\n        return {\r\n            typedArray : indexArray,\r\n            numberOfIndices : numIndices\r\n        };\r\n    }\r\n\r\n    function decodeQuantizedDracoTypedArray(dracoGeometry, dracoDecoder, dracoAttribute, quantization, vertexArrayLength) {\r\n        var vertexArray;\r\n        var attributeData;\r\n        if (quantization.quantizationBits <= 8) {\r\n            attributeData = new draco.DracoUInt8Array();\r\n            vertexArray = new Uint8Array(vertexArrayLength);\r\n            dracoDecoder.GetAttributeUInt8ForAllPoints(dracoGeometry, dracoAttribute, attributeData);\r\n        } else {\r\n            attributeData = new draco.DracoUInt16Array();\r\n            vertexArray = new Uint16Array(vertexArrayLength);\r\n            dracoDecoder.GetAttributeUInt16ForAllPoints(dracoGeometry, dracoAttribute, attributeData);\r\n        }\r\n\r\n        for (var i = 0; i < vertexArrayLength; ++i) {\r\n            vertexArray[i] = attributeData.GetValue(i);\r\n        }\r\n\r\n        draco.destroy(attributeData);\r\n        return vertexArray;\r\n    }\r\n\r\n    function decodeDracoTypedArray(dracoGeometry, dracoDecoder, dracoAttribute, vertexArrayLength) {\r\n        var vertexArray;\r\n        var attributeData;\r\n\r\n        // Some attribute types are casted down to 32 bit since Draco only returns 32 bit values\r\n        switch (dracoAttribute.data_type()) {\r\n            case 1: case 11: // DT_INT8 or DT_BOOL\r\n                attributeData = new draco.DracoInt8Array();\r\n                vertexArray = new Int8Array(vertexArrayLength);\r\n                dracoDecoder.GetAttributeInt8ForAllPoints(dracoGeometry, dracoAttribute, attributeData);\r\n                break;\r\n            case 2: // DT_UINT8\r\n                attributeData = new draco.DracoUInt8Array();\r\n                vertexArray = new Uint8Array(vertexArrayLength);\r\n                dracoDecoder.GetAttributeUInt8ForAllPoints(dracoGeometry, dracoAttribute, attributeData);\r\n                break;\r\n            case 3: // DT_INT16\r\n                attributeData = new draco.DracoInt16Array();\r\n                vertexArray = new Int16Array(vertexArrayLength);\r\n                dracoDecoder.GetAttributeInt16ForAllPoints(dracoGeometry, dracoAttribute, attributeData);\r\n                break;\r\n            case 4: // DT_UINT16\r\n                attributeData = new draco.DracoUInt16Array();\r\n                vertexArray = new Uint16Array(vertexArrayLength);\r\n                dracoDecoder.GetAttributeUInt16ForAllPoints(dracoGeometry, dracoAttribute, attributeData);\r\n                break;\r\n            case 5: case 7: // DT_INT32 or DT_INT64\r\n                attributeData = new draco.DracoInt32Array();\r\n                vertexArray = new Int32Array(vertexArrayLength);\r\n                dracoDecoder.GetAttributeInt32ForAllPoints(dracoGeometry, dracoAttribute, attributeData);\r\n                break;\r\n            case 6: case 8: // DT_UINT32 or DT_UINT64\r\n                attributeData = new draco.DracoUInt32Array();\r\n                vertexArray = new Uint32Array(vertexArrayLength);\r\n                dracoDecoder.GetAttributeUInt32ForAllPoints(dracoGeometry, dracoAttribute, attributeData);\r\n                break;\r\n            case 9: case 10: // DT_FLOAT32 or DT_FLOAT64\r\n                attributeData = new draco.DracoFloat32Array();\r\n                vertexArray = new Float32Array(vertexArrayLength);\r\n                dracoDecoder.GetAttributeFloatForAllPoints(dracoGeometry, dracoAttribute, attributeData);\r\n                break;\r\n        }\r\n\r\n        for (var i = 0; i < vertexArrayLength; ++i) {\r\n            vertexArray[i] = attributeData.GetValue(i);\r\n        }\r\n\r\n        draco.destroy(attributeData);\r\n        return vertexArray;\r\n    }\r\n\r\n    function decodeAttribute(dracoGeometry, dracoDecoder, dracoAttribute) {\r\n        var numPoints = dracoGeometry.num_points();\r\n        var numComponents = dracoAttribute.num_components();\r\n\r\n        var quantization;\r\n        var transform = new draco.AttributeQuantizationTransform();\r\n        if (transform.InitFromAttribute(dracoAttribute)) {\r\n            var minValues = new Array(numComponents);\r\n            for (var i = 0; i < numComponents; ++i) {\r\n                minValues[i] = transform.min_value(i);\r\n            }\r\n            quantization = {\r\n                quantizationBits : transform.quantization_bits(),\r\n                minValues : minValues,\r\n                range : transform.range(),\r\n                octEncoded : false\r\n            };\r\n        }\r\n        draco.destroy(transform);\r\n\r\n        transform = new draco.AttributeOctahedronTransform();\r\n        if (transform.InitFromAttribute(dracoAttribute)) {\r\n            quantization = {\r\n                quantizationBits : transform.quantization_bits(),\r\n                octEncoded : true\r\n            };\r\n        }\r\n        draco.destroy(transform);\r\n\r\n        var vertexArrayLength = numPoints * numComponents;\r\n        var vertexArray;\r\n        if (defined(quantization)) {\r\n            vertexArray = decodeQuantizedDracoTypedArray(dracoGeometry, dracoDecoder, dracoAttribute, quantization, vertexArrayLength);\r\n        } else {\r\n            vertexArray = decodeDracoTypedArray(dracoGeometry, dracoDecoder, dracoAttribute, vertexArrayLength);\r\n        }\r\n\r\n        var componentDatatype = ComponentDatatype.fromTypedArray(vertexArray);\r\n\r\n        return {\r\n            array : vertexArray,\r\n            data : {\r\n                componentsPerAttribute : numComponents,\r\n                componentDatatype : componentDatatype,\r\n                byteOffset : dracoAttribute.byte_offset(),\r\n                byteStride : ComponentDatatype.getSizeInBytes(componentDatatype) * numComponents,\r\n                normalized : dracoAttribute.normalized(),\r\n                quantization : quantization\r\n            }\r\n        };\r\n    }\r\n\r\n    function decodePointCloud(parameters) {\r\n        var dracoDecoder = new draco.Decoder();\r\n\r\n        if (parameters.dequantizeInShader) {\r\n            dracoDecoder.SkipAttributeTransform(draco.POSITION);\r\n            dracoDecoder.SkipAttributeTransform(draco.NORMAL);\r\n        }\r\n\r\n        var buffer = new draco.DecoderBuffer();\r\n        buffer.Init(parameters.buffer, parameters.buffer.length);\r\n\r\n        var geometryType = dracoDecoder.GetEncodedGeometryType(buffer);\r\n        if (geometryType !== draco.POINT_CLOUD) {\r\n            throw new RuntimeError('Draco geometry type must be POINT_CLOUD.');\r\n        }\r\n\r\n        var dracoPointCloud = new draco.PointCloud();\r\n        var decodingStatus = dracoDecoder.DecodeBufferToPointCloud(buffer, dracoPointCloud);\r\n        if (!decodingStatus.ok() || dracoPointCloud.ptr === 0) {\r\n            throw new RuntimeError('Error decoding draco point cloud: ' + decodingStatus.error_msg());\r\n        }\r\n\r\n        draco.destroy(buffer);\r\n\r\n        var result = {};\r\n\r\n        var properties = parameters.properties;\r\n        for (var propertyName in properties) {\r\n            if (properties.hasOwnProperty(propertyName)) {\r\n                var attributeId = properties[propertyName];\r\n                var dracoAttribute = dracoDecoder.GetAttributeByUniqueId(dracoPointCloud, attributeId);\r\n                result[propertyName] = decodeAttribute(dracoPointCloud, dracoDecoder, dracoAttribute);\r\n            }\r\n        }\r\n\r\n        draco.destroy(dracoPointCloud);\r\n        draco.destroy(dracoDecoder);\r\n\r\n        return result;\r\n    }\r\n\r\n    function decodePrimitive(parameters) {\r\n        var dracoDecoder = new draco.Decoder();\r\n        // if(parameters.projected){\r\n        //     var projectionString = parameters.projectionString;\r\n        //     var dCenX = parameters.dCenX;\r\n        //     var dCenY = parameters.dCenY;\r\n        //     var dCenZ = parameters.dCenZ;\r\n        //     var lbdeal = new draco.LBDeal();\r\n        //     var isInit = lbdeal.Init(projectionString,dCenX,dCenY,dCenZ);\r\n        // }\r\n\r\n        // Skip all parameter types except generic\r\n        var attributesToSkip = ['POSITION', 'NORMAL', 'COLOR', 'TEX_COORD'];\r\n        if (parameters.dequantizeInShader) {\r\n            for (var i = 0; i < attributesToSkip.length; ++i) {\r\n                dracoDecoder.SkipAttributeTransform(draco[attributesToSkip[i]]);\r\n            }\r\n        }\r\n\r\n        var bufferView = parameters.bufferView;\r\n        var buffer = new draco.DecoderBuffer();\r\n        buffer.Init(parameters.array, bufferView.byteLength);\r\n\r\n        var geometryType = dracoDecoder.GetEncodedGeometryType(buffer);\r\n        if (geometryType !== draco.TRIANGULAR_MESH) {\r\n            throw new RuntimeError('Unsupported draco mesh geometry type.');\r\n        }\r\n\r\n        var dracoGeometry = new draco.Mesh();\r\n        var decodingStatus = dracoDecoder.DecodeBufferToMesh(buffer, dracoGeometry);\r\n        if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\r\n            throw new RuntimeError('Error decoding draco mesh geometry: ' + decodingStatus.error_msg());\r\n        }\r\n\r\n        draco.destroy(buffer);\r\n\r\n        var attributeData = {};\r\n        var min = [Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY];\r\n        var max = [Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY];\r\n\r\n        var compressedAttributes = parameters.compressedAttributes;\r\n        for (var attributeName in compressedAttributes) {\r\n            if (compressedAttributes.hasOwnProperty(attributeName)) {\r\n                var compressedAttribute = compressedAttributes[attributeName];\r\n                var dracoAttribute = dracoDecoder.GetAttributeByUniqueId(dracoGeometry, compressedAttribute);\r\n                attributeData[attributeName] = decodeAttribute(dracoGeometry, dracoDecoder, dracoAttribute);\r\n                //投影变换\r\n                if(attributeName==='POSITION' && parameters.projected && !parameters.isInstance){\r\n                    var projectionString = parameters.projectionString;\r\n                    var dCenX = parameters.dCenX;\r\n                    var dCenY = parameters.dCenY;\r\n                    var dCenZ = parameters.dCenZ;\r\n                    var lbdeal = new draco.LBDeal();\r\n                    var isInit = lbdeal.Init(projectionString,dCenX,dCenY,dCenZ);\r\n                    if(isInit){\r\n                        var typedArray = attributeData[attributeName].array;\r\n                        var iPtNum = typedArray.length;\r\n                        var matrix = parameters.matrix;\r\n\r\n                        var numBytes = typedArray.byteLength;\r\n                        var ptr = draco._malloc(numBytes);\r\n                        draco.HEAPF32.set(typedArray,ptr / 4);\r\n\r\n                        var matrixPtr = draco._malloc(matrix.byteLength);\r\n                        draco.HEAPF64.set(matrix,matrixPtr / 8);\r\n                        lbdeal.ComputeProjToCartesian(ptr,iPtNum,matrixPtr);\r\n                        // lbdeal.compute_utm_to_cartesian_pts(dCenX,dCenY,dCenZ,ptr,iPtNum,matrixPtr);\r\n\r\n                        var resultAttributeData = new Float32Array(typedArray.length);\r\n\r\n                        for(var index = 0; index < typedArray.length; ++index){\r\n                            resultAttributeData[index] = draco.HEAPF32[(ptr>>2) + index];\r\n                            if(min[index%3]>resultAttributeData[index]){\r\n                                min[index%3] = resultAttributeData[index];\r\n                            }\r\n                            if(max[index%3]<resultAttributeData[index]){\r\n                                max[index%3] = resultAttributeData[index];\r\n                            }\r\n                        }\r\n                        attributeData[attributeName].array = resultAttributeData;\r\n                        draco._free(ptr);\r\n                        draco._free(matrixPtr);\r\n                    }\r\n                    draco.destroy(lbdeal);\r\n                }\r\n            }\r\n        }\r\n        // if(parameters.projected){\r\n        //     draco.destroy(lbdeal);\r\n        // }\r\n\r\n        var result = {\r\n            indexArray : decodeIndexArray(dracoGeometry, dracoDecoder),\r\n            attributeData : attributeData,\r\n            min:min,\r\n            max:max\r\n        };\r\n\r\n        draco.destroy(dracoGeometry);\r\n        draco.destroy(dracoDecoder);\r\n\r\n        return result;\r\n    }\r\n\r\n    function projectiveTransform(parameters, transferableObjects){\r\n        var result = {};\r\n        if(parameters.projected){\r\n            var projectionString = parameters.projectionString;\r\n            var dCenX = parameters.dCenX;\r\n            var dCenY = parameters.dCenY;\r\n            var dCenZ = parameters.dCenZ;\r\n            var lbdeal = new draco.LBDeal();\r\n            var isInit = lbdeal.Init(projectionString,dCenX,dCenY,dCenZ);\r\n            if(isInit){\r\n                var typedArray = new Float32Array(parameters.array.buffer,0);\r\n                var iPtNum = typedArray.length;\r\n                var matrix = parameters.matrix;\r\n\r\n                var numBytes = typedArray.byteLength;\r\n                var ptr = draco._malloc(numBytes);\r\n                draco.HEAPF32.set(typedArray,ptr / 4);\r\n\r\n                var matrixPtr = draco._malloc(matrix.byteLength);\r\n                draco.HEAPF64.set(matrix,matrixPtr / 8);\r\n                lbdeal.ComputeProjToCartesian(ptr,iPtNum,matrixPtr);\r\n\r\n                var resultAttributeData = new Float32Array(typedArray.length);\r\n                for(var index = 0; index < typedArray.length; ++index){\r\n                    resultAttributeData[index] = draco.HEAPF32[(ptr>>2) + index];\r\n                }\r\n                result = {\r\n                    unDraco : true,\r\n                    attributeData : resultAttributeData\r\n                };\r\n\r\n                transferableObjects.push(resultAttributeData.buffer);\r\n\r\n                draco._free(ptr);\r\n                draco._free(matrixPtr);\r\n\r\n            }\r\n            draco.destroy(lbdeal);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function decode(parameters, transferableObjects) {\r\n        if(defined(parameters.unDraco)){\r\n            //非压缩模型，直接球面投影变换\r\n            return projectiveTransform(parameters, transferableObjects);\r\n        }\r\n        if (defined(parameters.primitive)) {\r\n            return decodePrimitive(parameters);\r\n        }\r\n        return decodePointCloud(parameters);\r\n    }\r\n\r\n    function initWorker(dracoModule) {\r\n        draco = dracoModule;\r\n        self.onmessage = createTaskProcessorWorker(decode);\r\n        self.postMessage(true);\r\n    }\r\n\r\n    function decodeDraco(event) {\r\n        var data = event.data;\r\n\r\n        // Expect the first message to be to load a web assembly module\r\n        var wasmConfig = data.webAssemblyConfig;\r\n        if (defined(wasmConfig)) {\r\n            // Require and compile WebAssembly module, or use fallback if not supported\r\n            return require([wasmConfig.modulePath], function(dracoModule) {\r\n                if (defined(wasmConfig.wasmBinaryFile)) {\r\n                    if (!defined(dracoModule)) {\r\n                        dracoModule = self.DracoDecoderModule;\r\n                    }\r\n\r\n                    dracoModule(wasmConfig).then(function (compiledModule) {\r\n                        initWorker(compiledModule);\r\n                    });\r\n                } else {\r\n                    initWorker(dracoModule());\r\n                }\r\n            });\r\n        }\r\n    }\r\nexport default decodeDraco;\r\n"],"names":["draco","decodeIndexArray","dracoGeometry","dracoDecoder","numPoints","num_points","numFaces","num_faces","faceIndices","DracoInt32Array","numIndices","indexArray","IndexDatatype","createTypedArray","offset","i","GetFaceFromMesh","GetValue","destroy","typedArray","numberOfIndices","decodeAttribute","dracoAttribute","quantization","numComponents","num_components","transform","AttributeQuantizationTransform","InitFromAttribute","minValues","Array","min_value","quantizationBits","quantization_bits","range","octEncoded","AttributeOctahedronTransform","vertexArray","vertexArrayLength","defined","attributeData","DracoUInt8Array","Uint8Array","GetAttributeUInt8ForAllPoints","DracoUInt16Array","Uint16Array","GetAttributeUInt16ForAllPoints","decodeQuantizedDracoTypedArray","data_type","DracoInt8Array","Int8Array","GetAttributeInt8ForAllPoints","DracoInt16Array","Int16Array","GetAttributeInt16ForAllPoints","Int32Array","GetAttributeInt32ForAllPoints","DracoUInt32Array","Uint32Array","GetAttributeUInt32ForAllPoints","DracoFloat32Array","Float32Array","GetAttributeFloatForAllPoints","decodeDracoTypedArray","componentDatatype","ComponentDatatype","fromTypedArray","array","data","componentsPerAttribute","byteOffset","byte_offset","byteStride","getSizeInBytes","normalized","decode","parameters","transferableObjects","unDraco","result","projected","projectionString","dCenX","dCenY","dCenZ","lbdeal","LBDeal","Init","buffer","iPtNum","length","matrix","numBytes","byteLength","ptr","_malloc","HEAPF32","set","matrixPtr","HEAPF64","ComputeProjToCartesian","resultAttributeData","index","push","_free","projectiveTransform","primitive","Decoder","attributesToSkip","dequantizeInShader","SkipAttributeTransform","bufferView","DecoderBuffer","GetEncodedGeometryType","TRIANGULAR_MESH","RuntimeError","Mesh","decodingStatus","DecodeBufferToMesh","ok","error_msg","min","Number","POSITIVE_INFINITY","max","NEGATIVE_INFINITY","compressedAttributes","attributeName","hasOwnProperty","compressedAttribute","GetAttributeByUniqueId","isInstance","decodePrimitive","POSITION","NORMAL","POINT_CLOUD","dracoPointCloud","PointCloud","DecodeBufferToPointCloud","properties","propertyName","attributeId","decodePointCloud","initWorker","dracoModule","self","onmessage","createTaskProcessorWorker","postMessage","event","wasmConfig","webAssemblyConfig","require","modulePath","wasmBinaryFile","DracoDecoderModule","then","compiledModule"],"mappings":"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"}