{"version":3,"file":"TerrainEncoding-35fa9829.js","sources":["../../../../Source/Core/EllipsoidalOccluder.js","../../../../Source/Core/TerrainQuantization.js","../../../../Source/Core/TerrainEncoding.js"],"sourcesContent":["import BoundingSphere from './BoundingSphere.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport Rectangle from './Rectangle.js';\r\n\r\n    /**\r\n     * Determine whether or not other objects are visible or hidden behind the visible horizon defined by\r\n     * an {@link Ellipsoid} and a camera position.  The ellipsoid is assumed to be located at the\r\n     * origin of the coordinate system.  This class uses the algorithm described in the\r\n     * {@link https://cesium.com/blog/2013/04/25/Horizon-culling/|Horizon Culling} blog post.\r\n     *\r\n     * @alias EllipsoidalOccluder\r\n     *\r\n     * @param {Ellipsoid} ellipsoid The ellipsoid to use as an occluder.\r\n     * @param {Cartesian3} [cameraPosition] The coordinate of the viewer/camera.  If this parameter is not\r\n     *        specified, {@link EllipsoidalOccluder#cameraPosition} must be called before\r\n     *        testing visibility.\r\n     *\r\n     * @constructor\r\n     *\r\n     * @example\r\n     * // Construct an ellipsoidal occluder with radii 1.0, 1.1, and 0.9.\r\n     * var cameraPosition = new Cesium.Cartesian3(5.0, 6.0, 7.0);\r\n     * var occluderEllipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\r\n     * var occluder = new Cesium.EllipsoidalOccluder(occluderEllipsoid, cameraPosition);\r\n     *\r\n     * @private\r\n     */\r\n    function EllipsoidalOccluder(ellipsoid, cameraPosition) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('ellipsoid', ellipsoid);\r\n        //>>includeEnd('debug');\r\n\r\n        this._ellipsoid = ellipsoid;\r\n        this._cameraPosition = new Cartesian3();\r\n        this._cameraPositionInScaledSpace = new Cartesian3();\r\n        this._distanceToLimbInScaledSpaceSquared = 0.0;\r\n\r\n        // cameraPosition fills in the above values\r\n        if (defined(cameraPosition)) {\r\n            this.cameraPosition = cameraPosition;\r\n        }\r\n    }\r\n\r\n    Object.defineProperties(EllipsoidalOccluder.prototype, {\r\n        /**\r\n         * Gets the occluding ellipsoid.\r\n         * @memberof EllipsoidalOccluder.prototype\r\n         * @type {Ellipsoid}\r\n         */\r\n        ellipsoid : {\r\n            get: function() {\r\n                return this._ellipsoid;\r\n            }\r\n        },\r\n        /**\r\n         * Gets or sets the position of the camera.\r\n         * @memberof EllipsoidalOccluder.prototype\r\n         * @type {Cartesian3}\r\n         */\r\n        cameraPosition : {\r\n            get : function() {\r\n                return this._cameraPosition;\r\n            },\r\n            set : function(cameraPosition) {\r\n                // See https://cesium.com/blog/2013/04/25/Horizon-culling/\r\n                var ellipsoid = this._ellipsoid;\r\n                var cv = ellipsoid.transformPositionToScaledSpace(cameraPosition, this._cameraPositionInScaledSpace);\r\n                var vhMagnitudeSquared = Cartesian3.magnitudeSquared(cv) - 1.0;\r\n\r\n                Cartesian3.clone(cameraPosition, this._cameraPosition);\r\n                this._cameraPositionInScaledSpace = cv;\r\n                this._distanceToLimbInScaledSpaceSquared = vhMagnitudeSquared;\r\n            }\r\n        }\r\n    });\r\n\r\n    var scratchCartesian = new Cartesian3();\r\n\r\n    /**\r\n     * Determines whether or not a point, the <code>occludee</code>, is hidden from view by the occluder.\r\n     *\r\n     * @param {Cartesian3} occludee The point to test for visibility.\r\n     * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\r\n     *\r\n     * @example\r\n     * var cameraPosition = new Cesium.Cartesian3(0, 0, 2.5);\r\n     * var ellipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\r\n     * var occluder = new Cesium.EllipsoidalOccluder(ellipsoid, cameraPosition);\r\n     * var point = new Cesium.Cartesian3(0, -3, -3);\r\n     * occluder.isPointVisible(point); //returns true\r\n     */\r\n    EllipsoidalOccluder.prototype.isPointVisible = function(occludee) {\r\n        var ellipsoid = this._ellipsoid;\r\n        var occludeeScaledSpacePosition = ellipsoid.transformPositionToScaledSpace(occludee, scratchCartesian);\r\n        return isScaledSpacePointVisible(occludeeScaledSpacePosition, this._cameraPositionInScaledSpace, this._distanceToLimbInScaledSpaceSquared);\r\n    };\r\n\r\n    /**\r\n     * Determines whether or not a point expressed in the ellipsoid scaled space, is hidden from view by the\r\n     * occluder.  To transform a Cartesian X, Y, Z position in the coordinate system aligned with the ellipsoid\r\n     * into the scaled space, call {@link Ellipsoid#transformPositionToScaledSpace}.\r\n     *\r\n     * @param {Cartesian3} occludeeScaledSpacePosition The point to test for visibility, represented in the scaled space.\r\n     * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\r\n     *\r\n     * @example\r\n     * var cameraPosition = new Cesium.Cartesian3(0, 0, 2.5);\r\n     * var ellipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\r\n     * var occluder = new Cesium.EllipsoidalOccluder(ellipsoid, cameraPosition);\r\n     * var point = new Cesium.Cartesian3(0, -3, -3);\r\n     * var scaledSpacePoint = ellipsoid.transformPositionToScaledSpace(point);\r\n     * occluder.isScaledSpacePointVisible(scaledSpacePoint); //returns true\r\n     */\r\n    EllipsoidalOccluder.prototype.isScaledSpacePointVisible = function(occludeeScaledSpacePosition) {\r\n        return isScaledSpacePointVisible(occludeeScaledSpacePosition, this._cameraPositionInScaledSpace, this._distanceToLimbInScaledSpaceSquared);\r\n    };\r\n\r\n    var scratchCameraPositionInScaledSpaceShrunk = new Cartesian3();\r\n\r\n    /**\r\n     * Similar to {@link EllipsoidalOccluder#isScaledSpacePointVisible} except tests against an\r\n     * ellipsoid that has been shrunk by the minimum height when the minimum height is below\r\n     * the ellipsoid. This is intended to be used with points generated by\r\n     * {@link EllipsoidalOccluder#computeHorizonCullingPointPossiblyUnderEllipsoid} or\r\n     * {@link EllipsoidalOccluder#computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid}.\r\n     *\r\n     * @param {Cartesian3} occludeeScaledSpacePosition The point to test for visibility, represented in the scaled space of the possibly-shrunk ellipsoid.\r\n     * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\r\n     */\r\n    EllipsoidalOccluder.prototype.isScaledSpacePointVisiblePossiblyUnderEllipsoid = function(occludeeScaledSpacePosition, minimumHeight) {\r\n        var ellipsoid = this._ellipsoid;\r\n        var vhMagnitudeSquared;\r\n        var cv;\r\n\r\n        if (defined(minimumHeight) && minimumHeight < 0.0 && ellipsoid.minimumRadius > -minimumHeight) {\r\n            // This code is similar to the cameraPosition setter, but unrolled for performance because it will be called a lot.\r\n            cv = scratchCameraPositionInScaledSpaceShrunk;\r\n            cv.x = this._cameraPosition.x / (ellipsoid.radii.x + minimumHeight);\r\n            cv.y = this._cameraPosition.y / (ellipsoid.radii.y + minimumHeight);\r\n            cv.z = this._cameraPosition.z / (ellipsoid.radii.z + minimumHeight);\r\n            vhMagnitudeSquared = cv.x * cv.x + cv.y * cv.y + cv.z * cv.z - 1.0;\r\n        } else {\r\n            cv = this._cameraPositionInScaledSpace;\r\n            vhMagnitudeSquared = this._distanceToLimbInScaledSpaceSquared;\r\n        }\r\n\r\n        return isScaledSpacePointVisible(occludeeScaledSpacePosition, cv, vhMagnitudeSquared);\r\n    };\r\n\r\n    /**\r\n     * Computes a point that can be used for horizon culling from a list of positions.  If the point is below\r\n     * the horizon, all of the positions are guaranteed to be below the horizon as well.  The returned point\r\n     * is expressed in the ellipsoid-scaled space and is suitable for use with\r\n     * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\r\n     *\r\n     * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\r\n     *                     A reasonable direction to use is the direction from the center of the ellipsoid to\r\n     *                     the center of the bounding sphere computed from the positions.  The direction need not\r\n     *                     be normalized.\r\n     * @param {Cartesian3[]} positions The positions from which to compute the horizon culling point.  The positions\r\n     *                       must be expressed in a reference frame centered at the ellipsoid and aligned with the\r\n     *                       ellipsoid's axes.\r\n     * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\r\n     * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\r\n     */\r\n    EllipsoidalOccluder.prototype.computeHorizonCullingPoint = function(directionToPoint, positions, result) {\r\n        return computeHorizonCullingPointFromPositions(this._ellipsoid, directionToPoint, positions, result);\r\n    };\r\n\r\n    var scratchEllipsoidShrunk = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\r\n\r\n    /**\r\n     * Similar to {@link EllipsoidalOccluder#computeHorizonCullingPoint} except computes the culling\r\n     * point relative to an ellipsoid that has been shrunk by the minimum height when the minimum height is below\r\n     * the ellipsoid. The returned point is expressed in the possibly-shrunk ellipsoid-scaled space and is suitable\r\n     * for use with {@link EllipsoidalOccluder#isScaledSpacePointVisiblePossiblyUnderEllipsoid}.\r\n     *\r\n     * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\r\n     *                     A reasonable direction to use is the direction from the center of the ellipsoid to\r\n     *                     the center of the bounding sphere computed from the positions.  The direction need not\r\n     *                     be normalized.\r\n     * @param {Cartesian3[]} positions The positions from which to compute the horizon culling point.  The positions\r\n     *                       must be expressed in a reference frame centered at the ellipsoid and aligned with the\r\n     *                       ellipsoid's axes.\r\n     * @param {Number} [minimumHeight] The minimum height of all positions. If this value is undefined, all positions are assumed to be above the ellipsoid.\r\n     * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\r\n     * @returns {Cartesian3} The computed horizon culling point, expressed in the possibly-shrunk ellipsoid-scaled space.\r\n     */\r\n    EllipsoidalOccluder.prototype.computeHorizonCullingPointPossiblyUnderEllipsoid = function(directionToPoint, positions, minimumHeight, result) {\r\n        var possiblyShrunkEllipsoid = getPossiblyShrunkEllipsoid(this._ellipsoid, minimumHeight, scratchEllipsoidShrunk);\r\n        return computeHorizonCullingPointFromPositions(possiblyShrunkEllipsoid, directionToPoint, positions, result);\r\n    };\r\n    /**\r\n     * Computes a point that can be used for horizon culling from a list of positions.  If the point is below\r\n     * the horizon, all of the positions are guaranteed to be below the horizon as well.  The returned point\r\n     * is expressed in the ellipsoid-scaled space and is suitable for use with\r\n     * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\r\n     *\r\n     * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\r\n     *                     A reasonable direction to use is the direction from the center of the ellipsoid to\r\n     *                     the center of the bounding sphere computed from the positions.  The direction need not\r\n     *                     be normalized.\r\n     * @param {Number[]} vertices  The vertices from which to compute the horizon culling point.  The positions\r\n     *                   must be expressed in a reference frame centered at the ellipsoid and aligned with the\r\n     *                   ellipsoid's axes.\r\n     * @param {Number} [stride=3]\r\n     * @param {Cartesian3} [center=Cartesian3.ZERO]\r\n     * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\r\n     * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\r\n     */\r\n    EllipsoidalOccluder.prototype.computeHorizonCullingPointFromVertices = function(directionToPoint, vertices, stride, center, result) {\r\n        return computeHorizonCullingPointFromVertices(this._ellipsoid, directionToPoint, vertices, stride, center, result);\r\n    };\r\n\r\n    /**\r\n     * Similar to {@link EllipsoidalOccluder#computeHorizonCullingPointFromVertices} except computes the culling\r\n     * point relative to an ellipsoid that has been shrunk by the minimum height when the minimum height is below\r\n     * the ellipsoid. The returned point is expressed in the possibly-shrunk ellipsoid-scaled space and is suitable\r\n     * for use with {@link EllipsoidalOccluder#isScaledSpacePointVisiblePossiblyUnderEllipsoid}.\r\n     *\r\n     * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\r\n     *                     A reasonable direction to use is the direction from the center of the ellipsoid to\r\n     *                     the center of the bounding sphere computed from the positions.  The direction need not\r\n     *                     be normalized.\r\n     * @param {Number[]} vertices  The vertices from which to compute the horizon culling point.  The positions\r\n     *                   must be expressed in a reference frame centered at the ellipsoid and aligned with the\r\n     *                   ellipsoid's axes.\r\n     * @param {Number} [stride=3]\r\n     * @param {Cartesian3} [center=Cartesian3.ZERO]\r\n     * @param {Number} [minimumHeight] The minimum height of all vertices. If this value is undefined, all vertices are assumed to be above the ellipsoid.\r\n     * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\r\n     * @returns {Cartesian3} The computed horizon culling point, expressed in the possibly-shrunk ellipsoid-scaled space.\r\n     */\r\n    EllipsoidalOccluder.prototype.computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid = function(directionToPoint, vertices, stride, center, minimumHeight, result) {\r\n        var possiblyShrunkEllipsoid = getPossiblyShrunkEllipsoid(this._ellipsoid, minimumHeight, scratchEllipsoidShrunk);\r\n        return computeHorizonCullingPointFromVertices(possiblyShrunkEllipsoid, directionToPoint, vertices, stride, center, result);\r\n    };\r\n\r\n    var subsampleScratch = [];\r\n\r\n    /**\r\n     * Computes a point that can be used for horizon culling of a rectangle.  If the point is below\r\n     * the horizon, the ellipsoid-conforming rectangle is guaranteed to be below the horizon as well.\r\n     * The returned point is expressed in the ellipsoid-scaled space and is suitable for use with\r\n     * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\r\n     *\r\n     * @param {Rectangle} rectangle The rectangle for which to compute the horizon culling point.\r\n     * @param {Ellipsoid} ellipsoid The ellipsoid on which the rectangle is defined.  This may be different from\r\n     *                    the ellipsoid used by this instance for occlusion testing.\r\n     * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\r\n     * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\r\n     */\r\n    EllipsoidalOccluder.prototype.computeHorizonCullingPointFromRectangle = function(rectangle, ellipsoid, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('rectangle', rectangle);\r\n        //>>includeEnd('debug');\r\n\r\n        var positions = Rectangle.subsample(rectangle, ellipsoid, 0.0, subsampleScratch);\r\n        var bs = BoundingSphere.fromPoints(positions);\r\n\r\n        // If the bounding sphere center is too close to the center of the occluder, it doesn't make\r\n        // sense to try to horizon cull it.\r\n        if (Cartesian3.magnitude(bs.center) < 0.1 * ellipsoid.minimumRadius) {\r\n            return undefined;\r\n        }\r\n\r\n        return this.computeHorizonCullingPoint(bs.center, positions, result);\r\n    };\r\n\r\n    var scratchEllipsoidShrunkRadii = new Cartesian3();\r\n\r\n    function getPossiblyShrunkEllipsoid(ellipsoid, minimumHeight, result) {\r\n        if (defined(minimumHeight) && minimumHeight < 0.0 && ellipsoid.minimumRadius > -minimumHeight) {\r\n            var ellipsoidShrunkRadii = Cartesian3.fromElements(\r\n                ellipsoid.radii.x + minimumHeight,\r\n                ellipsoid.radii.y + minimumHeight,\r\n                ellipsoid.radii.z + minimumHeight,\r\n                scratchEllipsoidShrunkRadii\r\n            );\r\n            ellipsoid = Ellipsoid.fromCartesian3(ellipsoidShrunkRadii, result);\r\n        }\r\n        return ellipsoid;\r\n    }\r\n\r\n    function computeHorizonCullingPointFromPositions(ellipsoid, directionToPoint, positions, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('directionToPoint', directionToPoint);\r\n        Check.defined('positions', positions);\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n\r\n        var scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(ellipsoid, directionToPoint);\r\n        var resultMagnitude = 0.0;\r\n\r\n        for (var i = 0, len = positions.length; i < len; ++i) {\r\n            var position = positions[i];\r\n            var candidateMagnitude = computeMagnitude(ellipsoid, position, scaledSpaceDirectionToPoint);\r\n            if (candidateMagnitude < 0.0) {\r\n                // all points should face the same direction, but this one doesn't, so return undefined\r\n                return undefined;\r\n            }\r\n            resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);\r\n        }\r\n\r\n        return magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);\r\n    }\r\n\r\n    var positionScratch = new Cartesian3();\r\n\r\n    function computeHorizonCullingPointFromVertices(ellipsoid, directionToPoint, vertices, stride, center, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('directionToPoint', directionToPoint);\r\n        Check.defined('vertices', vertices);\r\n        Check.typeOf.number('stride', stride);\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n\r\n        stride = defaultValue(stride, 3);\r\n        center = defaultValue(center, Cartesian3.ZERO);\r\n        var scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(ellipsoid, directionToPoint);\r\n        var resultMagnitude = 0.0;\r\n\r\n        for (var i = 0, len = vertices.length; i < len; i += stride) {\r\n            positionScratch.x = vertices[i] + center.x;\r\n            positionScratch.y = vertices[i + 1] + center.y;\r\n            positionScratch.z = vertices[i + 2] + center.z;\r\n\r\n            var candidateMagnitude = computeMagnitude(ellipsoid, positionScratch, scaledSpaceDirectionToPoint);\r\n            if (candidateMagnitude < 0.0) {\r\n                // all points should face the same direction, but this one doesn't, so return undefined\r\n                return undefined;\r\n            }\r\n            resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);\r\n        }\r\n\r\n        return magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);\r\n    }\r\n\r\n    function isScaledSpacePointVisible(occludeeScaledSpacePosition, cameraPositionInScaledSpace, distanceToLimbInScaledSpaceSquared) {\r\n        // See https://cesium.com/blog/2013/04/25/Horizon-culling/\r\n        var cv = cameraPositionInScaledSpace;\r\n        var vhMagnitudeSquared = distanceToLimbInScaledSpaceSquared;\r\n        var vt = Cartesian3.subtract(occludeeScaledSpacePosition, cv, scratchCartesian);\r\n        var vtDotVc = -Cartesian3.dot(vt, cv);\r\n        // If vhMagnitudeSquared < 0 then we are below the surface of the ellipsoid and\r\n        // in this case, set the culling plane to be on V.\r\n        var isOccluded = vhMagnitudeSquared < 0 ? vtDotVc > 0 : (vtDotVc > vhMagnitudeSquared &&\r\n                         vtDotVc * vtDotVc / Cartesian3.magnitudeSquared(vt) > vhMagnitudeSquared);\r\n        return !isOccluded;\r\n    }\r\n\r\n    var scaledSpaceScratch = new Cartesian3();\r\n    var directionScratch = new Cartesian3();\r\n\r\n    function computeMagnitude(ellipsoid, position, scaledSpaceDirectionToPoint) {\r\n        var scaledSpacePosition = ellipsoid.transformPositionToScaledSpace(position, scaledSpaceScratch);\r\n        var magnitudeSquared = Cartesian3.magnitudeSquared(scaledSpacePosition);\r\n        var magnitude = Math.sqrt(magnitudeSquared);\r\n        var direction = Cartesian3.divideByScalar(scaledSpacePosition, magnitude, directionScratch);\r\n\r\n        // For the purpose of this computation, points below the ellipsoid are consider to be on it instead.\r\n        magnitudeSquared = Math.max(1.0, magnitudeSquared);\r\n        magnitude = Math.max(1.0, magnitude);\r\n\r\n        var cosAlpha = Cartesian3.dot(direction, scaledSpaceDirectionToPoint);\r\n        var sinAlpha = Cartesian3.magnitude(Cartesian3.cross(direction, scaledSpaceDirectionToPoint, direction));\r\n        var cosBeta = 1.0 / magnitude;\r\n        var sinBeta = Math.sqrt(magnitudeSquared - 1.0) * cosBeta;\r\n\r\n        return 1.0 / (cosAlpha * cosBeta - sinAlpha * sinBeta);\r\n    }\r\n\r\n    function magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result) {\r\n        // The horizon culling point is undefined if there were no positions from which to compute it,\r\n        // the directionToPoint is pointing opposite all of the positions,  or if we computed NaN or infinity.\r\n        if (resultMagnitude <= 0.0 || resultMagnitude === 1.0 / 0.0 || resultMagnitude !== resultMagnitude) {\r\n            return undefined;\r\n        }\r\n\r\n        return Cartesian3.multiplyByScalar(scaledSpaceDirectionToPoint, resultMagnitude, result);\r\n    }\r\n\r\n    var directionToPointScratch = new Cartesian3();\r\n\r\n    function computeScaledSpaceDirectionToPoint(ellipsoid, directionToPoint) {\r\n        if (Cartesian3.equals(directionToPoint, Cartesian3.ZERO)) {\r\n            return directionToPoint;\r\n        }\r\n\r\n        ellipsoid.transformPositionToScaledSpace(directionToPoint, directionToPointScratch);\r\n        return Cartesian3.normalize(directionToPointScratch, directionToPointScratch);\r\n    }\r\nexport default EllipsoidalOccluder;\r\n","\r\n    /**\r\n     * This enumerated type is used to determine how the vertices of the terrain mesh are compressed.\r\n     *\r\n     * @exports TerrainQuantization\r\n     *\r\n     * @private\r\n     */\r\n    var TerrainQuantization = {\r\n        /**\r\n         * The vertices are not compressed.\r\n         *\r\n         * @type {Number}\r\n         * @constant\r\n         */\r\n        NONE : 0,\r\n\r\n        /**\r\n         * The vertices are compressed to 12 bits.\r\n         *\r\n         * @type {Number}\r\n         * @constant\r\n         */\r\n        BITS12 : 1\r\n    };\r\nexport default Object.freeze(TerrainQuantization);\r\n","import AttributeCompression from './AttributeCompression.js';\r\nimport Cartesian2 from './Cartesian2.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport ComponentDatatype from './ComponentDatatype.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport CesiumMath from './Math.js';\r\nimport Matrix4 from './Matrix4.js';\r\nimport TerrainQuantization from './TerrainQuantization.js';\r\n\r\n    var cartesian3Scratch = new Cartesian3();\r\n    var cartesian3DimScratch = new Cartesian3();\r\n    var cartesian2Scratch = new Cartesian2();\r\n    var matrix4Scratch = new Matrix4();\r\n    var matrix4Scratch2 = new Matrix4();\r\n\r\n    var SHIFT_LEFT_12 = Math.pow(2.0, 12.0);\r\n\r\n    /**\r\n     * Data used to quantize and pack the terrain mesh. The position can be unpacked for picking and all attributes\r\n     * are unpacked in the vertex shader.\r\n     *\r\n     * @alias TerrainEncoding\r\n     * @constructor\r\n     *\r\n     * @param {AxisAlignedBoundingBox} axisAlignedBoundingBox The bounds of the tile in the east-north-up coordinates at the tiles center.\r\n     * @param {Number} minimumHeight The minimum height.\r\n     * @param {Number} maximumHeight The maximum height.\r\n     * @param {Matrix4} fromENU The east-north-up to fixed frame matrix at the center of the terrain mesh.\r\n     * @param {Boolean} hasVertexNormals If the mesh has vertex normals.\r\n     * @param {Boolean} [hasWebMercatorT=false] true if the terrain data includes a Web Mercator texture coordinate; otherwise, false.\r\n     *\r\n     * @private\r\n     */\r\n    function TerrainEncoding(axisAlignedBoundingBox, minimumHeight, maximumHeight, fromENU, hasVertexNormals, hasWebMercatorT) {\r\n        var quantization = TerrainQuantization.NONE;\r\n        var center;\r\n        var toENU;\r\n        var matrix;\r\n\r\n        if (defined(axisAlignedBoundingBox) && defined(minimumHeight) && defined(maximumHeight) && defined(fromENU)) {\r\n            var minimum = axisAlignedBoundingBox.minimum;\r\n            var maximum = axisAlignedBoundingBox.maximum;\r\n\r\n            var dimensions = Cartesian3.subtract(maximum, minimum, cartesian3DimScratch);\r\n            var hDim = maximumHeight - minimumHeight;\r\n            var maxDim = Math.max(Cartesian3.maximumComponent(dimensions), hDim);\r\n\r\n            if (maxDim < SHIFT_LEFT_12 - 1.0) {\r\n                quantization = TerrainQuantization.BITS12;\r\n            } else {\r\n                quantization = TerrainQuantization.NONE;\r\n            }\r\n\r\n            center = axisAlignedBoundingBox.center;\r\n            toENU = Matrix4.inverseTransformation(fromENU, new Matrix4());\r\n\r\n            var translation = Cartesian3.negate(minimum, cartesian3Scratch);\r\n            Matrix4.multiply(Matrix4.fromTranslation(translation, matrix4Scratch), toENU, toENU);\r\n\r\n            var scale = cartesian3Scratch;\r\n            scale.x = 1.0 / dimensions.x;\r\n            scale.y = 1.0 / dimensions.y;\r\n            scale.z = 1.0 / dimensions.z;\r\n            Matrix4.multiply(Matrix4.fromScale(scale, matrix4Scratch), toENU, toENU);\r\n\r\n            matrix = Matrix4.clone(fromENU);\r\n            Matrix4.setTranslation(matrix, Cartesian3.ZERO, matrix);\r\n\r\n            fromENU = Matrix4.clone(fromENU, new Matrix4());\r\n\r\n            var translationMatrix = Matrix4.fromTranslation(minimum, matrix4Scratch);\r\n            var scaleMatrix =  Matrix4.fromScale(dimensions, matrix4Scratch2);\r\n            var st = Matrix4.multiply(translationMatrix, scaleMatrix,matrix4Scratch);\r\n\r\n            Matrix4.multiply(fromENU, st, fromENU);\r\n            Matrix4.multiply(matrix, st, matrix);\r\n        }\r\n\r\n        /**\r\n         * How the vertices of the mesh were compressed.\r\n         * @type {TerrainQuantization}\r\n         */\r\n        this.quantization = quantization;\r\n\r\n        /**\r\n         * The minimum height of the tile including the skirts.\r\n         * @type {Number}\r\n         */\r\n        this.minimumHeight = minimumHeight;\r\n\r\n        /**\r\n         * The maximum height of the tile.\r\n         * @type {Number}\r\n         */\r\n        this.maximumHeight = maximumHeight;\r\n\r\n        /**\r\n         * The center of the tile.\r\n         * @type {Cartesian3}\r\n         */\r\n        this.center = center;\r\n\r\n        /**\r\n         * A matrix that takes a vertex from the tile, transforms it to east-north-up at the center and scales\r\n         * it so each component is in the [0, 1] range.\r\n         * @type {Matrix4}\r\n         */\r\n        this.toScaledENU = toENU;\r\n\r\n        /**\r\n         * A matrix that restores a vertex transformed with toScaledENU back to the earth fixed reference frame\r\n         * @type {Matrix4}\r\n         */\r\n        this.fromScaledENU = fromENU;\r\n\r\n        /**\r\n         * The matrix used to decompress the terrain vertices in the shader for RTE rendering.\r\n         * @type {Matrix4}\r\n         */\r\n        this.matrix = matrix;\r\n\r\n        /**\r\n         * The terrain mesh contains normals.\r\n         * @type {Boolean}\r\n         */\r\n        this.hasVertexNormals = hasVertexNormals;\r\n\r\n        /**\r\n         * The terrain mesh contains a vertical texture coordinate following the Web Mercator projection.\r\n         * @type {Boolean}\r\n         */\r\n        this.hasWebMercatorT = defaultValue(hasWebMercatorT, false);\r\n    }\r\n\r\n    TerrainEncoding.prototype.encode = function(vertexBuffer, bufferIndex, position, uv, height, normalToPack, webMercatorT) {\r\n        var u = uv.x;\r\n        var v = uv.y;\r\n\r\n        if (this.quantization === TerrainQuantization.BITS12) {\r\n            position = Matrix4.multiplyByPoint(this.toScaledENU, position, cartesian3Scratch);\r\n\r\n            position.x = CesiumMath.clamp(position.x, 0.0, 1.0);\r\n            position.y = CesiumMath.clamp(position.y, 0.0, 1.0);\r\n            position.z = CesiumMath.clamp(position.z, 0.0, 1.0);\r\n\r\n            var hDim = this.maximumHeight - this.minimumHeight;\r\n            var h = CesiumMath.clamp((height - this.minimumHeight) / hDim, 0.0, 1.0);\r\n\r\n            Cartesian2.fromElements(position.x, position.y, cartesian2Scratch);\r\n            var compressed0 = AttributeCompression.compressTextureCoordinates(cartesian2Scratch);\r\n\r\n            Cartesian2.fromElements(position.z, h, cartesian2Scratch);\r\n            var compressed1 = AttributeCompression.compressTextureCoordinates(cartesian2Scratch);\r\n\r\n            Cartesian2.fromElements(u, v, cartesian2Scratch);\r\n            var compressed2 = AttributeCompression.compressTextureCoordinates(cartesian2Scratch);\r\n\r\n            vertexBuffer[bufferIndex++] = compressed0;\r\n            vertexBuffer[bufferIndex++] = compressed1;\r\n            vertexBuffer[bufferIndex++] = compressed2;\r\n\r\n            if (this.hasWebMercatorT) {\r\n                Cartesian2.fromElements(webMercatorT, 0.0, cartesian2Scratch);\r\n                var compressed3 = AttributeCompression.compressTextureCoordinates(cartesian2Scratch);\r\n                vertexBuffer[bufferIndex++] = compressed3;\r\n            }\r\n        } else {\r\n            Cartesian3.subtract(position, this.center, cartesian3Scratch);\r\n\r\n            vertexBuffer[bufferIndex++] = cartesian3Scratch.x;\r\n            vertexBuffer[bufferIndex++] = cartesian3Scratch.y;\r\n            vertexBuffer[bufferIndex++] = cartesian3Scratch.z;\r\n            vertexBuffer[bufferIndex++] = height;\r\n            vertexBuffer[bufferIndex++] = u;\r\n            vertexBuffer[bufferIndex++] = v;\r\n\r\n            if (this.hasWebMercatorT) {\r\n                vertexBuffer[bufferIndex++] = webMercatorT;\r\n            }\r\n        }\r\n\r\n        if (this.hasVertexNormals) {\r\n            vertexBuffer[bufferIndex++] = AttributeCompression.octPackFloat(normalToPack);\r\n        }\r\n\r\n        return bufferIndex;\r\n    };\r\n\r\n    TerrainEncoding.prototype.decodePosition = function(buffer, index, result) {\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n\r\n        index *= this.getStride();\r\n\r\n        if (this.quantization === TerrainQuantization.BITS12) {\r\n            var xy = AttributeCompression.decompressTextureCoordinates(buffer[index], cartesian2Scratch);\r\n            result.x = xy.x;\r\n            result.y = xy.y;\r\n\r\n            var zh = AttributeCompression.decompressTextureCoordinates(buffer[index + 1], cartesian2Scratch);\r\n            result.z = zh.x;\r\n\r\n            return Matrix4.multiplyByPoint(this.fromScaledENU, result, result);\r\n        }\r\n\r\n        result.x = buffer[index];\r\n        result.y = buffer[index + 1];\r\n        result.z = buffer[index + 2];\r\n        return Cartesian3.add(result, this.center, result);\r\n    };\r\n\r\n    TerrainEncoding.prototype.decodeTextureCoordinates = function(buffer, index, result) {\r\n        if (!defined(result)) {\r\n            result = new Cartesian2();\r\n        }\r\n\r\n        index *= this.getStride();\r\n\r\n        if (this.quantization === TerrainQuantization.BITS12) {\r\n            return AttributeCompression.decompressTextureCoordinates(buffer[index + 2], result);\r\n        }\r\n\r\n        return Cartesian2.fromElements(buffer[index + 4], buffer[index + 5], result);\r\n    };\r\n\r\n    TerrainEncoding.prototype.decodeHeight = function(buffer, index) {\r\n        index *= this.getStride();\r\n\r\n        if (this.quantization === TerrainQuantization.BITS12) {\r\n            var zh = AttributeCompression.decompressTextureCoordinates(buffer[index + 1], cartesian2Scratch);\r\n            return zh.y * (this.maximumHeight - this.minimumHeight) + this.minimumHeight;\r\n        }\r\n\r\n        return buffer[index + 3];\r\n    };\r\n\r\n    TerrainEncoding.prototype.decodeWebMercatorT = function(buffer, index) {\r\n        index *= this.getStride();\r\n\r\n        if (this.quantization === TerrainQuantization.BITS12) {\r\n            return AttributeCompression.decompressTextureCoordinates(buffer[index + 3], cartesian2Scratch).x;\r\n        }\r\n\r\n        return buffer[index + 6];\r\n    };\r\n\r\n    TerrainEncoding.prototype.getOctEncodedNormal = function(buffer, index, result) {\r\n        var stride = this.getStride();\r\n        index = (index + 1) * stride - 1;\r\n\r\n        var temp = buffer[index] / 256.0;\r\n        var x = Math.floor(temp);\r\n        var y = (temp - x) * 256.0;\r\n\r\n        return Cartesian2.fromElements(x, y, result);\r\n    };\r\n\r\n    TerrainEncoding.prototype.getStride = function() {\r\n        var vertexStride;\r\n\r\n        switch (this.quantization) {\r\n            case TerrainQuantization.BITS12:\r\n                vertexStride = 3;\r\n                break;\r\n            default:\r\n                vertexStride = 6;\r\n        }\r\n\r\n        if (this.hasWebMercatorT) {\r\n            ++vertexStride;\r\n        }\r\n\r\n        if (this.hasVertexNormals) {\r\n            ++vertexStride;\r\n        }\r\n\r\n        return vertexStride;\r\n    };\r\n\r\n    var attributesNone = {\r\n        position3DAndHeight : 0,\r\n        textureCoordAndEncodedNormals : 1\r\n    };\r\n    var attributes = {\r\n        compressed0 : 0,\r\n        compressed1 : 1\r\n    };\r\n\r\n    TerrainEncoding.prototype.getAttributes = function(buffer) {\r\n        var datatype = ComponentDatatype.FLOAT;\r\n        var sizeInBytes = ComponentDatatype.getSizeInBytes(datatype);\r\n        var stride;\r\n\r\n        if (this.quantization === TerrainQuantization.NONE) {\r\n            var position3DAndHeightLength = 4;\r\n            var numTexCoordComponents = 2;\r\n\r\n            if (this.hasWebMercatorT) {\r\n                ++numTexCoordComponents;\r\n            }\r\n\r\n            if (this.hasVertexNormals) {\r\n                ++numTexCoordComponents;\r\n            }\r\n\r\n            stride = (position3DAndHeightLength + numTexCoordComponents) * sizeInBytes;\r\n\r\n            return [{\r\n                index : attributesNone.position3DAndHeight,\r\n                vertexBuffer : buffer,\r\n                componentDatatype : datatype,\r\n                componentsPerAttribute : position3DAndHeightLength,\r\n                offsetInBytes : 0,\r\n                strideInBytes : stride\r\n            }, {\r\n                index : attributesNone.textureCoordAndEncodedNormals,\r\n                vertexBuffer : buffer,\r\n                componentDatatype : datatype,\r\n                componentsPerAttribute : numTexCoordComponents,\r\n                offsetInBytes : position3DAndHeightLength * sizeInBytes,\r\n                strideInBytes : stride\r\n            }];\r\n        }\r\n\r\n        var numCompressed0 = 3;\r\n        var numCompressed1 = 0;\r\n\r\n        if (this.hasWebMercatorT || this.hasVertexNormals) {\r\n            ++numCompressed0;\r\n        }\r\n\r\n        if (this.hasWebMercatorT && this.hasVertexNormals) {\r\n            ++numCompressed1;\r\n\r\n            stride = (numCompressed0 + numCompressed1) * sizeInBytes;\r\n\r\n            return [{\r\n                index : attributes.compressed0,\r\n                vertexBuffer : buffer,\r\n                componentDatatype : datatype,\r\n                componentsPerAttribute : numCompressed0,\r\n                offsetInBytes : 0,\r\n                strideInBytes : stride\r\n            }, {\r\n                index : attributes.compressed1,\r\n                vertexBuffer : buffer,\r\n                componentDatatype : datatype,\r\n                componentsPerAttribute : numCompressed1,\r\n                offsetInBytes : numCompressed0 * sizeInBytes,\r\n                strideInBytes : stride\r\n            }];\r\n        }\r\n        return [{\r\n            index : attributes.compressed0,\r\n            vertexBuffer : buffer,\r\n            componentDatatype : datatype,\r\n            componentsPerAttribute : numCompressed0\r\n        }];\r\n    };\r\n\r\n    TerrainEncoding.prototype.getAttributeLocations = function() {\r\n        if (this.quantization === TerrainQuantization.NONE) {\r\n            return attributesNone;\r\n        }\r\n        return attributes;\r\n    };\r\n\r\n    TerrainEncoding.clone = function(encoding, result) {\r\n        if (!defined(result)) {\r\n            result = new TerrainEncoding();\r\n        }\r\n\r\n        result.quantization = encoding.quantization;\r\n        result.minimumHeight = encoding.minimumHeight;\r\n        result.maximumHeight = encoding.maximumHeight;\r\n        result.center = Cartesian3.clone(encoding.center);\r\n        result.toScaledENU = Matrix4.clone(encoding.toScaledENU);\r\n        result.fromScaledENU = Matrix4.clone(encoding.fromScaledENU);\r\n        result.matrix = Matrix4.clone(encoding.matrix);\r\n        result.hasVertexNormals = encoding.hasVertexNormals;\r\n        result.hasWebMercatorT = encoding.hasWebMercatorT;\r\n        return result;\r\n    };\r\nexport default TerrainEncoding;\r\n"],"names":["EllipsoidalOccluder","ellipsoid","cameraPosition","Check","typeOf","object","this","_ellipsoid","_cameraPosition","Cartesian3","_cameraPositionInScaledSpace","_distanceToLimbInScaledSpaceSquared","defined","Object","defineProperties","prototype","get","set","cv","transformPositionToScaledSpace","vhMagnitudeSquared","magnitudeSquared","clone","scratchCartesian","isPointVisible","occludee","isScaledSpacePointVisible","occludeeScaledSpacePosition","scratchCameraPositionInScaledSpaceShrunk","isScaledSpacePointVisiblePossiblyUnderEllipsoid","minimumHeight","minimumRadius","x","radii","y","z","computeHorizonCullingPoint","directionToPoint","positions","result","computeHorizonCullingPointFromPositions","scratchEllipsoidShrunk","Ellipsoid","UNIT_SPHERE","computeHorizonCullingPointPossiblyUnderEllipsoid","getPossiblyShrunkEllipsoid","computeHorizonCullingPointFromVertices","vertices","stride","center","computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid","subsampleScratch","computeHorizonCullingPointFromRectangle","rectangle","Rectangle","subsample","bs","BoundingSphere","fromPoints","magnitude","scratchEllipsoidShrunkRadii","ellipsoidShrunkRadii","fromElements","fromCartesian3","scaledSpaceDirectionToPoint","computeScaledSpaceDirectionToPoint","resultMagnitude","i","len","length","candidateMagnitude","computeMagnitude","Math","max","magnitudeToPoint","positionScratch","number","defaultValue","ZERO","cameraPositionInScaledSpace","distanceToLimbInScaledSpaceSquared","vt","subtract","vtDotVc","dot","scaledSpaceScratch","directionScratch","position","scaledSpacePosition","sqrt","direction","divideByScalar","cosBeta","cross","multiplyByScalar","directionToPointScratch","equals","normalize","freeze","NONE","BITS12","cartesian3Scratch","cartesian3DimScratch","cartesian2Scratch","Cartesian2","matrix4Scratch","Matrix4","matrix4Scratch2","SHIFT_LEFT_12","pow","TerrainEncoding","axisAlignedBoundingBox","maximumHeight","fromENU","hasVertexNormals","hasWebMercatorT","toENU","matrix","quantization","TerrainQuantization","minimum","maximum","dimensions","hDim","maximumComponent","inverseTransformation","translation","negate","multiply","fromTranslation","scale","fromScale","setTranslation","translationMatrix","scaleMatrix","st","toScaledENU","fromScaledENU","encode","vertexBuffer","bufferIndex","uv","height","normalToPack","webMercatorT","u","v","multiplyByPoint","CesiumMath","clamp","h","compressed0","AttributeCompression","compressTextureCoordinates","compressed1","compressed2","compressed3","octPackFloat","decodePosition","buffer","index","getStride","xy","decompressTextureCoordinates","zh","add","decodeTextureCoordinates","decodeHeight","decodeWebMercatorT","getOctEncodedNormal","temp","floor","vertexStride","attributesNone","position3DAndHeight","textureCoordAndEncodedNormals","attributes","getAttributes","datatype","ComponentDatatype","FLOAT","sizeInBytes","getSizeInBytes","numTexCoordComponents","componentDatatype","componentsPerAttribute","offsetInBytes","strideInBytes","numCompressed0","numCompressed1","getAttributeLocations","encoding"],"mappings":"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"}