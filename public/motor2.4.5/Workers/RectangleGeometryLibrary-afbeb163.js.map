{"version":3,"file":"RectangleGeometryLibrary-afbeb163.js","sources":["../../../../Source/Core/RectangleGeometryLibrary.js"],"sourcesContent":["import Cartesian3 from './Cartesian3.js';\r\nimport Cartographic from './Cartographic.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport GeographicProjection from './GeographicProjection.js';\r\nimport CesiumMath from './Math.js';\r\nimport Matrix2 from './Matrix2.js';\r\nimport Rectangle from './Rectangle.js';\r\n\r\n    var cos = Math.cos;\r\n    var sin = Math.sin;\r\n    var sqrt = Math.sqrt;\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    var RectangleGeometryLibrary = {};\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    RectangleGeometryLibrary.computePosition = function(computedOptions, ellipsoid, computeST, row, col, position, st) {\r\n        var radiiSquared = ellipsoid.radiiSquared;\r\n        var nwCorner = computedOptions.nwCorner;\r\n        var rectangle = computedOptions.boundingRectangle;\r\n\r\n        var stLatitude = nwCorner.latitude - computedOptions.granYCos * row + col * computedOptions.granXSin;\r\n        var cosLatitude = cos(stLatitude);\r\n        var nZ = sin(stLatitude);\r\n        var kZ = radiiSquared.z * nZ;\r\n\r\n        var stLongitude = nwCorner.longitude + row * computedOptions.granYSin + col * computedOptions.granXCos;\r\n        var nX = cosLatitude * cos(stLongitude);\r\n        var nY = cosLatitude * sin(stLongitude);\r\n\r\n        var kX = radiiSquared.x * nX;\r\n        var kY = radiiSquared.y * nY;\r\n\r\n        var gamma = sqrt((kX * nX) + (kY * nY) + (kZ * nZ));\r\n\r\n        position.x = kX / gamma;\r\n        position.y = kY / gamma;\r\n        position.z = kZ / gamma;\r\n\r\n        if (computeST) {\r\n            var stNwCorner = computedOptions.stNwCorner;\r\n            if (defined(stNwCorner)) {\r\n                stLatitude = stNwCorner.latitude - computedOptions.stGranYCos * row + col * computedOptions.stGranXSin;\r\n                stLongitude = stNwCorner.longitude + row * computedOptions.stGranYSin + col * computedOptions.stGranXCos;\r\n\r\n                st.x = (stLongitude - computedOptions.stWest) * computedOptions.lonScalar;\r\n                st.y = (stLatitude - computedOptions.stSouth) * computedOptions.latScalar;\r\n            } else {\r\n                st.x = (stLongitude - rectangle.west) * computedOptions.lonScalar;\r\n                st.y = (stLatitude - rectangle.south) * computedOptions.latScalar;\r\n            }\r\n        }\r\n    };\r\n\r\n    var rotationMatrixScratch = new Matrix2();\r\n    var nwCartesian = new Cartesian3();\r\n    var centerScratch = new Cartographic();\r\n    var centerCartesian = new Cartesian3();\r\n    var proj = new GeographicProjection();\r\n\r\n    function getRotationOptions(nwCorner, rotation, granularityX, granularityY, center, width, height) {\r\n        var cosRotation = Math.cos(rotation);\r\n        var granYCos = granularityY * cosRotation;\r\n        var granXCos = granularityX * cosRotation;\r\n\r\n        var sinRotation = Math.sin(rotation);\r\n        var granYSin = granularityY * sinRotation;\r\n        var granXSin = granularityX * sinRotation;\r\n\r\n        nwCartesian = proj.project(nwCorner, nwCartesian);\r\n\r\n        nwCartesian = Cartesian3.subtract(nwCartesian, centerCartesian, nwCartesian);\r\n        var rotationMatrix = Matrix2.fromRotation(rotation, rotationMatrixScratch);\r\n        nwCartesian = Matrix2.multiplyByVector(rotationMatrix, nwCartesian, nwCartesian);\r\n        nwCartesian = Cartesian3.add(nwCartesian, centerCartesian, nwCartesian);\r\n        nwCorner = proj.unproject(nwCartesian, nwCorner);\r\n\r\n        width -= 1;\r\n        height -= 1;\r\n\r\n        var latitude = nwCorner.latitude;\r\n        var latitude0 = latitude + width * granXSin;\r\n        var latitude1 = latitude - granYCos * height;\r\n        var latitude2 = latitude - granYCos * height + width * granXSin;\r\n\r\n        var north = Math.max(latitude, latitude0, latitude1, latitude2);\r\n        var south = Math.min(latitude, latitude0, latitude1, latitude2);\r\n\r\n        var longitude = nwCorner.longitude;\r\n        var longitude0 = longitude + width * granXCos;\r\n        var longitude1 = longitude + height * granYSin;\r\n        var longitude2 = longitude + height * granYSin + width * granXCos;\r\n\r\n        var east = Math.max(longitude, longitude0, longitude1, longitude2);\r\n        var west = Math.min(longitude, longitude0, longitude1, longitude2);\r\n\r\n        return {\r\n            north: north,\r\n            south: south,\r\n            east: east,\r\n            west: west,\r\n            granYCos : granYCos,\r\n            granYSin : granYSin,\r\n            granXCos : granXCos,\r\n            granXSin : granXSin,\r\n            nwCorner : nwCorner\r\n        };\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    RectangleGeometryLibrary.computeOptions = function(rectangle, granularity, rotation, stRotation, boundingRectangleScratch, nwCornerResult, stNwCornerResult) {\r\n        var east = rectangle.east;\r\n        var west = rectangle.west;\r\n        var north = rectangle.north;\r\n        var south = rectangle.south;\r\n\r\n        var northCap = false;\r\n        var southCap = false;\r\n\r\n        if (north === CesiumMath.PI_OVER_TWO) {\r\n            northCap = true;\r\n        }\r\n        if (south === -CesiumMath.PI_OVER_TWO) {\r\n            southCap = true;\r\n        }\r\n\r\n        var width;\r\n        var height;\r\n        var granularityX;\r\n        var granularityY;\r\n        var dx;\r\n        var dy = north - south;\r\n        if (west > east) {\r\n            dx = (CesiumMath.TWO_PI - west + east);\r\n        } else {\r\n            dx = east - west;\r\n        }\r\n\r\n        width = Math.ceil(dx / granularity) + 1;\r\n        height = Math.ceil(dy / granularity) + 1;\r\n        granularityX = dx / (width - 1);\r\n        granularityY = dy / (height - 1);\r\n\r\n        var nwCorner = Rectangle.northwest(rectangle, nwCornerResult);\r\n        var center = Rectangle.center(rectangle, centerScratch);\r\n        if (rotation !== 0 || stRotation !== 0) {\r\n            if (center.longitude < nwCorner.longitude) {\r\n                center.longitude += CesiumMath.TWO_PI;\r\n            }\r\n            centerCartesian = proj.project(center, centerCartesian);\r\n        }\r\n\r\n        var granYCos = granularityY;\r\n        var granXCos = granularityX;\r\n        var granYSin = 0.0;\r\n        var granXSin = 0.0;\r\n\r\n        var boundingRectangle = Rectangle.clone(rectangle, boundingRectangleScratch);\r\n\r\n        var computedOptions = {\r\n            granYCos : granYCos,\r\n            granYSin : granYSin,\r\n            granXCos : granXCos,\r\n            granXSin : granXSin,\r\n            nwCorner : nwCorner,\r\n            boundingRectangle : boundingRectangle,\r\n            width: width,\r\n            height: height,\r\n            northCap: northCap,\r\n            southCap: southCap\r\n        };\r\n\r\n        if (rotation !== 0) {\r\n            var rotationOptions = getRotationOptions(nwCorner, rotation, granularityX, granularityY, center, width, height);\r\n            north = rotationOptions.north;\r\n            south = rotationOptions.south;\r\n            east = rotationOptions.east;\r\n            west = rotationOptions.west;\r\n\r\n            //>>includeStart('debug', pragmas.debug);\r\n            if (north < -CesiumMath.PI_OVER_TWO || north > CesiumMath.PI_OVER_TWO ||\r\n                south < -CesiumMath.PI_OVER_TWO || south > CesiumMath.PI_OVER_TWO) {\r\n                throw new DeveloperError('Rotated rectangle is invalid.  It crosses over either the north or south pole.');\r\n            }\r\n            //>>includeEnd('debug')\r\n\r\n            computedOptions.granYCos = rotationOptions.granYCos;\r\n            computedOptions.granYSin = rotationOptions.granYSin;\r\n            computedOptions.granXCos = rotationOptions.granXCos;\r\n            computedOptions.granXSin = rotationOptions.granXSin;\r\n\r\n            boundingRectangle.north = north;\r\n            boundingRectangle.south = south;\r\n            boundingRectangle.east = east;\r\n            boundingRectangle.west = west;\r\n        }\r\n\r\n        if (stRotation !== 0) {\r\n            rotation = rotation - stRotation;\r\n            var stNwCorner = Rectangle.northwest(boundingRectangle, stNwCornerResult);\r\n\r\n            var stRotationOptions = getRotationOptions(stNwCorner, rotation, granularityX, granularityY, center, width, height);\r\n\r\n            computedOptions.stGranYCos =  stRotationOptions.granYCos;\r\n            computedOptions.stGranXCos = stRotationOptions.granXCos;\r\n            computedOptions.stGranYSin = stRotationOptions.granYSin;\r\n            computedOptions.stGranXSin = stRotationOptions.granXSin;\r\n            computedOptions.stNwCorner = stNwCorner;\r\n            computedOptions.stWest = stRotationOptions.west;\r\n            computedOptions.stSouth = stRotationOptions.south;\r\n        }\r\n\r\n        return computedOptions;\r\n    };\r\nexport default RectangleGeometryLibrary;\r\n"],"names":["cos","Math","sin","sqrt","RectangleGeometryLibrary","computePosition","computedOptions","ellipsoid","computeST","row","col","position","st","radiiSquared","nwCorner","rectangle","boundingRectangle","stLatitude","latitude","granYCos","granXSin","cosLatitude","nZ","kZ","z","stLongitude","longitude","granYSin","granXCos","nX","nY","kX","x","kY","y","gamma","stNwCorner","defined","stGranYCos","stGranXSin","stGranYSin","stGranXCos","stWest","lonScalar","stSouth","latScalar","west","south","rotationMatrixScratch","Matrix2","nwCartesian","Cartesian3","centerScratch","Cartographic","centerCartesian","proj","GeographicProjection","getRotationOptions","rotation","granularityX","granularityY","center","width","height","cosRotation","sinRotation","project","subtract","rotationMatrix","fromRotation","multiplyByVector","add","unproject","latitude0","latitude1","latitude2","north","max","min","longitude0","longitude1","longitude2","east","computeOptions","granularity","stRotation","boundingRectangleScratch","nwCornerResult","stNwCornerResult","dx","northCap","southCap","CesiumMath","PI_OVER_TWO","dy","TWO_PI","ceil","Rectangle","northwest","clone","rotationOptions","DeveloperError","stRotationOptions"],"mappings":"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"}