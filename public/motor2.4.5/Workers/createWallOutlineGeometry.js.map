{"version":3,"file":"createWallOutlineGeometry.js","sources":["../../../../Source/Core/WallOutlineGeometry.js","../../../../Source/WorkersES6/createWallOutlineGeometry.js"],"sourcesContent":["import BoundingSphere from './BoundingSphere.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport ComponentDatatype from './ComponentDatatype.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport Geometry from './Geometry.js';\r\nimport GeometryAttribute from './GeometryAttribute.js';\r\nimport GeometryAttributes from './GeometryAttributes.js';\r\nimport IndexDatatype from './IndexDatatype.js';\r\nimport CesiumMath from './Math.js';\r\nimport PrimitiveType from './PrimitiveType.js';\r\nimport WallGeometryLibrary from './WallGeometryLibrary.js';\r\n\r\n    var scratchCartesian3Position1 = new Cartesian3();\r\n    var scratchCartesian3Position2 = new Cartesian3();\r\n\r\n    /**\r\n     * A description of a wall outline. A wall is defined by a series of points,\r\n     * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\r\n     *\r\n     * @alias WallOutlineGeometry\r\n     * @constructor\r\n     *\r\n     * @param {Object} options Object with the following properties:\r\n     * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\r\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n     * @param {Number[]} [options.maximumHeights] An array parallel to <code>positions</code> that give the maximum height of the\r\n     *        wall at <code>positions</code>. If undefined, the height of each position in used.\r\n     * @param {Number[]} [options.minimumHeights] An array parallel to <code>positions</code> that give the minimum height of the\r\n     *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\r\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid for coordinate manipulation\r\n     *\r\n     * @exception {DeveloperError} positions length must be greater than or equal to 2.\r\n     * @exception {DeveloperError} positions and maximumHeights must have the same length.\r\n     * @exception {DeveloperError} positions and minimumHeights must have the same length.\r\n     *\r\n     * @see WallGeometry#createGeometry\r\n     * @see WallGeometry#fromConstantHeight\r\n     *\r\n     * @example\r\n     * // create a wall outline that spans from ground level to 10000 meters\r\n     * var wall = new Cesium.WallOutlineGeometry({\r\n     *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\r\n     *     19.0, 47.0, 10000.0,\r\n     *     19.0, 48.0, 10000.0,\r\n     *     20.0, 48.0, 10000.0,\r\n     *     20.0, 47.0, 10000.0,\r\n     *     19.0, 47.0, 10000.0\r\n     *   ])\r\n     * });\r\n     * var geometry = Cesium.WallOutlineGeometry.createGeometry(wall);\r\n     */\r\n    function WallOutlineGeometry(options) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n        var wallPositions = options.positions;\r\n        var maximumHeights = options.maximumHeights;\r\n        var minimumHeights = options.minimumHeights;\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(wallPositions)) {\r\n            throw new DeveloperError('options.positions is required.');\r\n        }\r\n        if (defined(maximumHeights) && maximumHeights.length !== wallPositions.length) {\r\n            throw new DeveloperError('options.positions and options.maximumHeights must have the same length.');\r\n        }\r\n        if (defined(minimumHeights) && minimumHeights.length !== wallPositions.length) {\r\n            throw new DeveloperError('options.positions and options.minimumHeights must have the same length.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\r\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n\r\n        this._positions = wallPositions;\r\n        this._minimumHeights = minimumHeights;\r\n        this._maximumHeights = maximumHeights;\r\n        this._granularity = granularity;\r\n        this._ellipsoid = Ellipsoid.clone(ellipsoid);\r\n        this._workerName = 'createWallOutlineGeometry';\r\n\r\n        var numComponents = 1 + wallPositions.length * Cartesian3.packedLength + 2;\r\n        if (defined(minimumHeights)) {\r\n            numComponents += minimumHeights.length;\r\n        }\r\n        if (defined(maximumHeights)) {\r\n            numComponents += maximumHeights.length;\r\n        }\r\n\r\n        /**\r\n         * The number of elements used to pack the object into an array.\r\n         * @type {Number}\r\n         */\r\n        this.packedLength = numComponents + Ellipsoid.packedLength + 1;\r\n    }\r\n\r\n    /**\r\n     * Stores the provided instance into the provided array.\r\n     *\r\n     * @param {WallOutlineGeometry} value The value to pack.\r\n     * @param {Number[]} array The array to pack into.\r\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n     *\r\n     * @returns {Number[]} The array that was packed into\r\n     */\r\n    WallOutlineGeometry.pack = function(value, array, startingIndex) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(value)) {\r\n            throw new DeveloperError('value is required');\r\n        }\r\n        if (!defined(array)) {\r\n            throw new DeveloperError('array is required');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        var i;\r\n\r\n        var positions = value._positions;\r\n        var length = positions.length;\r\n        array[startingIndex++] = length;\r\n\r\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\r\n            Cartesian3.pack(positions[i], array, startingIndex);\r\n        }\r\n\r\n        var minimumHeights = value._minimumHeights;\r\n        length = defined(minimumHeights) ? minimumHeights.length : 0;\r\n        array[startingIndex++] = length;\r\n\r\n        if (defined(minimumHeights)) {\r\n            for (i = 0; i < length; ++i) {\r\n                array[startingIndex++] = minimumHeights[i];\r\n            }\r\n        }\r\n\r\n        var maximumHeights = value._maximumHeights;\r\n        length = defined(maximumHeights) ? maximumHeights.length : 0;\r\n        array[startingIndex++] = length;\r\n\r\n        if (defined(maximumHeights)) {\r\n            for (i = 0; i < length; ++i) {\r\n                array[startingIndex++] = maximumHeights[i];\r\n            }\r\n        }\r\n\r\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\r\n        startingIndex += Ellipsoid.packedLength;\r\n\r\n        array[startingIndex]   = value._granularity;\r\n\r\n        return array;\r\n    };\r\n\r\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\r\n    var scratchOptions = {\r\n        positions : undefined,\r\n        minimumHeights : undefined,\r\n        maximumHeights : undefined,\r\n        ellipsoid : scratchEllipsoid,\r\n        granularity : undefined\r\n    };\r\n\r\n    /**\r\n     * Retrieves an instance from a packed array.\r\n     *\r\n     * @param {Number[]} array The packed array.\r\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n     * @param {WallOutlineGeometry} [result] The object into which to store the result.\r\n     * @returns {WallOutlineGeometry} The modified result parameter or a new WallOutlineGeometry instance if one was not provided.\r\n     */\r\n    WallOutlineGeometry.unpack = function(array, startingIndex, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(array)) {\r\n            throw new DeveloperError('array is required');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        var i;\r\n\r\n        var length = array[startingIndex++];\r\n        var positions = new Array(length);\r\n\r\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\r\n            positions[i] = Cartesian3.unpack(array, startingIndex);\r\n        }\r\n\r\n        length = array[startingIndex++];\r\n        var minimumHeights;\r\n\r\n        if (length > 0) {\r\n            minimumHeights = new Array(length);\r\n            for (i = 0; i < length; ++i) {\r\n                minimumHeights[i] = array[startingIndex++];\r\n            }\r\n        }\r\n\r\n        length = array[startingIndex++];\r\n        var maximumHeights;\r\n\r\n        if (length > 0) {\r\n            maximumHeights = new Array(length);\r\n            for (i = 0; i < length; ++i) {\r\n                maximumHeights[i] = array[startingIndex++];\r\n            }\r\n        }\r\n\r\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\r\n        startingIndex += Ellipsoid.packedLength;\r\n\r\n        var granularity = array[startingIndex];\r\n\r\n        if (!defined(result)) {\r\n            scratchOptions.positions = positions;\r\n            scratchOptions.minimumHeights = minimumHeights;\r\n            scratchOptions.maximumHeights = maximumHeights;\r\n            scratchOptions.granularity = granularity;\r\n            return new WallOutlineGeometry(scratchOptions);\r\n        }\r\n\r\n        result._positions = positions;\r\n        result._minimumHeights = minimumHeights;\r\n        result._maximumHeights = maximumHeights;\r\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\r\n        result._granularity = granularity;\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * A description of a walloutline. A wall is defined by a series of points,\r\n     * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\r\n     *\r\n     * @param {Object} options Object with the following properties:\r\n     * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\r\n     * @param {Number} [options.maximumHeight] A constant that defines the maximum height of the\r\n     *        wall at <code>positions</code>. If undefined, the height of each position in used.\r\n     * @param {Number} [options.minimumHeight] A constant that defines the minimum height of the\r\n     *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\r\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid for coordinate manipulation\r\n     * @returns {WallOutlineGeometry}\r\n     *\r\n     *\r\n     * @example\r\n     * // create a wall that spans from 10000 meters to 20000 meters\r\n     * var wall = Cesium.WallOutlineGeometry.fromConstantHeights({\r\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\r\n     *     19.0, 47.0,\r\n     *     19.0, 48.0,\r\n     *     20.0, 48.0,\r\n     *     20.0, 47.0,\r\n     *     19.0, 47.0,\r\n     *   ]),\r\n     *   minimumHeight : 20000.0,\r\n     *   maximumHeight : 10000.0\r\n     * });\r\n     * var geometry = Cesium.WallOutlineGeometry.createGeometry(wall);\r\n     *\r\n     * @see WallOutlineGeometry#createGeometry\r\n     */\r\n    WallOutlineGeometry.fromConstantHeights = function(options) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n        var positions = options.positions;\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(positions)) {\r\n            throw new DeveloperError('options.positions is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var minHeights;\r\n        var maxHeights;\r\n\r\n        var min = options.minimumHeight;\r\n        var max = options.maximumHeight;\r\n\r\n        var doMin = defined(min);\r\n        var doMax = defined(max);\r\n        if (doMin || doMax) {\r\n            var length = positions.length;\r\n            minHeights = (doMin) ? new Array(length) : undefined;\r\n            maxHeights = (doMax) ? new Array(length) : undefined;\r\n\r\n            for (var i = 0; i < length; ++i) {\r\n                if (doMin) {\r\n                    minHeights[i] = min;\r\n                }\r\n\r\n                if (doMax) {\r\n                    maxHeights[i] = max;\r\n                }\r\n            }\r\n        }\r\n\r\n        var newOptions = {\r\n            positions : positions,\r\n            maximumHeights : maxHeights,\r\n            minimumHeights : minHeights,\r\n            ellipsoid : options.ellipsoid\r\n        };\r\n        return new WallOutlineGeometry(newOptions);\r\n    };\r\n\r\n    /**\r\n     * Computes the geometric representation of a wall outline, including its vertices, indices, and a bounding sphere.\r\n     *\r\n     * @param {WallOutlineGeometry} wallGeometry A description of the wall outline.\r\n     * @returns {Geometry|undefined} The computed vertices and indices.\r\n     */\r\n    WallOutlineGeometry.createGeometry = function(wallGeometry) {\r\n        var wallPositions = wallGeometry._positions;\r\n        var minimumHeights = wallGeometry._minimumHeights;\r\n        var maximumHeights = wallGeometry._maximumHeights;\r\n        var granularity = wallGeometry._granularity;\r\n        var ellipsoid = wallGeometry._ellipsoid;\r\n\r\n        var pos = WallGeometryLibrary.computePositions(ellipsoid, wallPositions, maximumHeights, minimumHeights, granularity, false);\r\n        if (!defined(pos)) {\r\n            return;\r\n        }\r\n\r\n        var bottomPositions = pos.bottomPositions;\r\n        var topPositions = pos.topPositions;\r\n\r\n        var length = topPositions.length;\r\n        var size = length * 2;\r\n\r\n        var positions = new Float64Array(size);\r\n        var positionIndex = 0;\r\n\r\n        // add lower and upper points one after the other, lower\r\n        // points being even and upper points being odd\r\n        length /= 3;\r\n        var i;\r\n        for (i = 0; i < length; ++i) {\r\n            var i3 = i * 3;\r\n            var topPosition = Cartesian3.fromArray(topPositions, i3, scratchCartesian3Position1);\r\n            var bottomPosition = Cartesian3.fromArray(bottomPositions, i3, scratchCartesian3Position2);\r\n\r\n            // insert the lower point\r\n            positions[positionIndex++] = bottomPosition.x;\r\n            positions[positionIndex++] = bottomPosition.y;\r\n            positions[positionIndex++] = bottomPosition.z;\r\n\r\n            // insert the upper point\r\n            positions[positionIndex++] = topPosition.x;\r\n            positions[positionIndex++] = topPosition.y;\r\n            positions[positionIndex++] = topPosition.z;\r\n        }\r\n\r\n        var attributes = new GeometryAttributes({\r\n            position : new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.DOUBLE,\r\n                componentsPerAttribute : 3,\r\n                values : positions\r\n            })\r\n        });\r\n\r\n        var numVertices = size / 3;\r\n        size = 2 * numVertices - 4 + numVertices;\r\n        var indices = IndexDatatype.createTypedArray(numVertices, size);\r\n\r\n        var edgeIndex = 0;\r\n        for (i = 0; i < numVertices - 2; i += 2) {\r\n            var LL = i;\r\n            var LR = i + 2;\r\n            var pl = Cartesian3.fromArray(positions, LL * 3, scratchCartesian3Position1);\r\n            var pr = Cartesian3.fromArray(positions, LR * 3, scratchCartesian3Position2);\r\n            if (Cartesian3.equalsEpsilon(pl, pr, CesiumMath.EPSILON10)) {\r\n                continue;\r\n            }\r\n            var UL = i + 1;\r\n            var UR = i + 3;\r\n\r\n            indices[edgeIndex++] = UL;\r\n            indices[edgeIndex++] = LL;\r\n            indices[edgeIndex++] = UL;\r\n            indices[edgeIndex++] = UR;\r\n            indices[edgeIndex++] = LL;\r\n            indices[edgeIndex++] = LR;\r\n        }\r\n\r\n        indices[edgeIndex++] = numVertices - 2;\r\n        indices[edgeIndex++] = numVertices - 1;\r\n\r\n        return new Geometry({\r\n            attributes : attributes,\r\n            indices : indices,\r\n            primitiveType : PrimitiveType.LINES,\r\n            boundingSphere : new BoundingSphere.fromVertices(positions)\r\n        });\r\n    };\r\nexport default WallOutlineGeometry;\r\n","import defined from '../Core/defined.js';\r\nimport Ellipsoid from '../Core/Ellipsoid.js';\r\nimport WallOutlineGeometry from '../Core/WallOutlineGeometry.js';\r\n\r\n    function createWallOutlineGeometry(wallGeometry, offset) {\r\n        if (defined(offset)) {\r\n            wallGeometry = WallOutlineGeometry.unpack(wallGeometry, offset);\r\n        }\r\n        wallGeometry._ellipsoid = Ellipsoid.clone(wallGeometry._ellipsoid);\r\n        return WallOutlineGeometry.createGeometry(wallGeometry);\r\n    }\r\nexport default createWallOutlineGeometry;\r\n"],"names":["scratchCartesian3Position1","Cartesian3","scratchCartesian3Position2","WallOutlineGeometry","options","wallPositions","defaultValue","EMPTY_OBJECT","positions","maximumHeights","minimumHeights","defined","DeveloperError","length","granularity","CesiumMath","RADIANS_PER_DEGREE","ellipsoid","Ellipsoid","WGS84","this","_positions","_minimumHeights","_maximumHeights","_granularity","_ellipsoid","clone","_workerName","numComponents","packedLength","pack","value","array","startingIndex","i","scratchEllipsoid","UNIT_SPHERE","scratchOptions","undefined","unpack","result","Array","fromConstantHeights","minHeights","maxHeights","min","minimumHeight","max","maximumHeight","doMin","doMax","createGeometry","wallGeometry","pos","WallGeometryLibrary","computePositions","bottomPositions","topPositions","size","Float64Array","positionIndex","i3","topPosition","fromArray","bottomPosition","x","y","z","attributes","GeometryAttributes","position","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","numVertices","indices","IndexDatatype","createTypedArray","edgeIndex","LL","LR","pl","pr","equalsEpsilon","EPSILON10","UL","UR","Geometry","primitiveType","PrimitiveType","LINES","boundingSphere","BoundingSphere","fromVertices","offset"],"mappings":"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"}