{"version":3,"file":"createCorridorGeometry.js","sources":["../../../../Source/Core/CorridorGeometry.js","../../../../Source/WorkersES6/createCorridorGeometry.js"],"sourcesContent":["import arrayFill from './arrayFill.js';\r\nimport arrayRemoveDuplicates from './arrayRemoveDuplicates.js';\r\nimport BoundingSphere from './BoundingSphere.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport Cartographic from './Cartographic.js';\r\nimport Check from './Check.js';\r\nimport ComponentDatatype from './ComponentDatatype.js';\r\nimport CornerType from './CornerType.js';\r\nimport CorridorGeometryLibrary from './CorridorGeometryLibrary.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport Geometry from './Geometry.js';\r\nimport GeometryAttribute from './GeometryAttribute.js';\r\nimport GeometryAttributes from './GeometryAttributes.js';\r\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\r\nimport IndexDatatype from './IndexDatatype.js';\r\nimport CesiumMath from './Math.js';\r\nimport PolygonPipeline from './PolygonPipeline.js';\r\nimport PrimitiveType from './PrimitiveType.js';\r\nimport Rectangle from './Rectangle.js';\r\nimport VertexFormat from './VertexFormat.js';\r\n\r\n    var cartesian1 = new Cartesian3();\r\n    var cartesian2 = new Cartesian3();\r\n    var cartesian3 = new Cartesian3();\r\n    var cartesian4 = new Cartesian3();\r\n    var cartesian5 = new Cartesian3();\r\n    var cartesian6 = new Cartesian3();\r\n\r\n    var scratch1 = new Cartesian3();\r\n    var scratch2 = new Cartesian3();\r\n\r\n    function scaleToSurface(positions, ellipsoid) {\r\n        for (var i = 0; i < positions.length; i++) {\r\n            positions[i] = ellipsoid.scaleToGeodeticSurface(positions[i], positions[i]);\r\n        }\r\n        return positions;\r\n    }\r\n\r\n    function addNormals(attr, normal, left, front, back, vertexFormat) {\r\n        var normals = attr.normals;\r\n        var tangents = attr.tangents;\r\n        var bitangents = attr.bitangents;\r\n        var forward = Cartesian3.normalize(Cartesian3.cross(left, normal, scratch1), scratch1);\r\n        if (vertexFormat.normal) {\r\n            CorridorGeometryLibrary.addAttribute(normals, normal, front, back);\r\n        }\r\n        if (vertexFormat.tangent) {\r\n            CorridorGeometryLibrary.addAttribute(tangents, forward, front, back);\r\n        }\r\n        if (vertexFormat.bitangent) {\r\n            CorridorGeometryLibrary.addAttribute(bitangents, left, front, back);\r\n        }\r\n    }\r\n\r\n    function combine(computedPositions, vertexFormat, ellipsoid) {\r\n        var positions = computedPositions.positions;\r\n        var corners = computedPositions.corners;\r\n        var endPositions = computedPositions.endPositions;\r\n        var computedLefts = computedPositions.lefts;\r\n        var computedNormals = computedPositions.normals;\r\n        var attributes = new GeometryAttributes();\r\n        var corner;\r\n        var leftCount = 0;\r\n        var rightCount = 0;\r\n        var i;\r\n        var indicesLength = 0;\r\n        var length;\r\n        for (i = 0; i < positions.length; i += 2) {\r\n            length = positions[i].length - 3;\r\n            leftCount += length; //subtracting 3 to account for duplicate points at corners\r\n            indicesLength += length*2;\r\n            rightCount += positions[i + 1].length - 3;\r\n        }\r\n        leftCount += 3; //add back count for end positions\r\n        rightCount += 3;\r\n        for (i = 0; i < corners.length; i++) {\r\n            corner = corners[i];\r\n            var leftSide = corners[i].leftPositions;\r\n            if (defined(leftSide)) {\r\n                length = leftSide.length;\r\n                leftCount += length;\r\n                indicesLength += length;\r\n            } else {\r\n                length = corners[i].rightPositions.length;\r\n                rightCount += length;\r\n                indicesLength += length;\r\n            }\r\n        }\r\n\r\n        var addEndPositions = defined(endPositions);\r\n        var endPositionLength;\r\n        if (addEndPositions) {\r\n            endPositionLength = endPositions[0].length - 3;\r\n            leftCount += endPositionLength;\r\n            rightCount += endPositionLength;\r\n            endPositionLength /= 3;\r\n            indicesLength += endPositionLength * 6;\r\n        }\r\n        var size = leftCount + rightCount;\r\n        var finalPositions = new Float64Array(size);\r\n        var normals = (vertexFormat.normal) ? new Float32Array(size) : undefined;\r\n        var tangents = (vertexFormat.tangent) ? new Float32Array(size) : undefined;\r\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(size) : undefined;\r\n        var attr = {\r\n            normals : normals,\r\n            tangents : tangents,\r\n            bitangents : bitangents\r\n        };\r\n        var front = 0;\r\n        var back = size - 1;\r\n        var UL, LL, UR, LR;\r\n        var normal = cartesian1;\r\n        var left = cartesian2;\r\n        var rightPos, leftPos;\r\n        var halfLength = endPositionLength / 2;\r\n\r\n        var indices = IndexDatatype.createTypedArray(size / 3, indicesLength);\r\n        var index = 0;\r\n        if (addEndPositions) { // add rounded end\r\n            leftPos = cartesian3;\r\n            rightPos = cartesian4;\r\n            var firstEndPositions = endPositions[0];\r\n            normal = Cartesian3.fromArray(computedNormals, 0, normal);\r\n            left = Cartesian3.fromArray(computedLefts, 0, left);\r\n            for (i = 0; i < halfLength; i++) {\r\n                leftPos = Cartesian3.fromArray(firstEndPositions, (halfLength - 1 - i) * 3, leftPos);\r\n                rightPos = Cartesian3.fromArray(firstEndPositions, (halfLength + i) * 3, rightPos);\r\n                CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\r\n                CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);\r\n                addNormals(attr, normal, left, front, back, vertexFormat);\r\n\r\n                LL = front / 3;\r\n                LR = LL + 1;\r\n                UL = (back - 2) / 3;\r\n                UR = UL - 1;\r\n                indices[index++] = UL;\r\n                indices[index++] = LL;\r\n                indices[index++] = UR;\r\n                indices[index++] = UR;\r\n                indices[index++] = LL;\r\n                indices[index++] = LR;\r\n\r\n                front += 3;\r\n                back -= 3;\r\n            }\r\n        }\r\n\r\n        var posIndex = 0;\r\n        var compIndex = 0;\r\n        var rightEdge = positions[posIndex++]; //add first two edges\r\n        var leftEdge = positions[posIndex++];\r\n        finalPositions.set(rightEdge, front);\r\n        finalPositions.set(leftEdge, back - leftEdge.length + 1);\r\n\r\n        left = Cartesian3.fromArray(computedLefts, compIndex, left);\r\n        var rightNormal;\r\n        var leftNormal;\r\n        length = leftEdge.length - 3;\r\n        for (i = 0; i < length; i += 3) {\r\n            rightNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(rightEdge, i, scratch1), scratch1);\r\n            leftNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(leftEdge, length - i, scratch2), scratch2);\r\n            normal = Cartesian3.normalize(Cartesian3.add(rightNormal, leftNormal, normal), normal);\r\n            addNormals(attr, normal, left, front, back, vertexFormat);\r\n\r\n            LL = front / 3;\r\n            LR = LL + 1;\r\n            UL = (back - 2) / 3;\r\n            UR = UL - 1;\r\n            indices[index++] = UL;\r\n            indices[index++] = LL;\r\n            indices[index++] = UR;\r\n            indices[index++] = UR;\r\n            indices[index++] = LL;\r\n            indices[index++] = LR;\r\n\r\n            front += 3;\r\n            back -= 3;\r\n        }\r\n\r\n        rightNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(rightEdge, length, scratch1), scratch1);\r\n        leftNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(leftEdge, length, scratch2), scratch2);\r\n        normal = Cartesian3.normalize(Cartesian3.add(rightNormal, leftNormal, normal), normal);\r\n        compIndex += 3;\r\n        for (i = 0; i < corners.length; i++) {\r\n            var j;\r\n            corner = corners[i];\r\n            var l = corner.leftPositions;\r\n            var r = corner.rightPositions;\r\n            var pivot;\r\n            var start;\r\n            var outsidePoint = cartesian6;\r\n            var previousPoint = cartesian3;\r\n            var nextPoint = cartesian4;\r\n            normal = Cartesian3.fromArray(computedNormals, compIndex, normal);\r\n            if (defined(l)) {\r\n                addNormals(attr, normal, left, undefined, back, vertexFormat);\r\n                back -= 3;\r\n                pivot = LR;\r\n                start = UR;\r\n                for (j = 0; j < l.length / 3; j++) {\r\n                    outsidePoint = Cartesian3.fromArray(l, j * 3, outsidePoint);\r\n                    indices[index++] = pivot;\r\n                    indices[index++] = start - j - 1;\r\n                    indices[index++] = start - j;\r\n                    CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, undefined, back);\r\n                    previousPoint = Cartesian3.fromArray(finalPositions, (start - j - 1) * 3, previousPoint);\r\n                    nextPoint = Cartesian3.fromArray(finalPositions, pivot * 3, nextPoint);\r\n                    left = Cartesian3.normalize(Cartesian3.subtract(previousPoint, nextPoint, left), left);\r\n                    addNormals(attr, normal, left, undefined, back, vertexFormat);\r\n                    back -= 3;\r\n                }\r\n                outsidePoint = Cartesian3.fromArray(finalPositions, pivot * 3, outsidePoint);\r\n                previousPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, (start) * 3, previousPoint), outsidePoint, previousPoint);\r\n                nextPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, (start - j) * 3, nextPoint), outsidePoint, nextPoint);\r\n                left = Cartesian3.normalize(Cartesian3.add(previousPoint, nextPoint, left), left);\r\n                addNormals(attr, normal, left, front, undefined, vertexFormat);\r\n                front += 3;\r\n            } else {\r\n                addNormals(attr, normal, left, front, undefined, vertexFormat);\r\n                front += 3;\r\n                pivot = UR;\r\n                start = LR;\r\n                for (j = 0; j < r.length / 3; j++) {\r\n                    outsidePoint = Cartesian3.fromArray(r, j * 3, outsidePoint);\r\n                    indices[index++] = pivot;\r\n                    indices[index++] = start + j;\r\n                    indices[index++] = start + j + 1;\r\n                    CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, front);\r\n                    previousPoint = Cartesian3.fromArray(finalPositions, pivot * 3, previousPoint);\r\n                    nextPoint = Cartesian3.fromArray(finalPositions, (start + j) * 3, nextPoint);\r\n                    left = Cartesian3.normalize(Cartesian3.subtract(previousPoint, nextPoint, left), left);\r\n                    addNormals(attr, normal, left, front, undefined, vertexFormat);\r\n                    front += 3;\r\n                }\r\n                outsidePoint = Cartesian3.fromArray(finalPositions, pivot * 3, outsidePoint);\r\n                previousPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, (start + j) * 3, previousPoint), outsidePoint, previousPoint);\r\n                nextPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, start * 3, nextPoint), outsidePoint, nextPoint);\r\n                left = Cartesian3.normalize(Cartesian3.negate(Cartesian3.add(nextPoint, previousPoint, left), left), left);\r\n                addNormals(attr, normal, left, undefined, back, vertexFormat);\r\n                back -= 3;\r\n            }\r\n            rightEdge = positions[posIndex++];\r\n            leftEdge = positions[posIndex++];\r\n            rightEdge.splice(0, 3); //remove duplicate points added by corner\r\n            leftEdge.splice(leftEdge.length - 3, 3);\r\n            finalPositions.set(rightEdge, front);\r\n            finalPositions.set(leftEdge, back - leftEdge.length + 1);\r\n            length = leftEdge.length - 3;\r\n\r\n            compIndex += 3;\r\n            left = Cartesian3.fromArray(computedLefts, compIndex, left);\r\n            for (j = 0; j < leftEdge.length; j += 3) {\r\n                rightNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(rightEdge, j, scratch1), scratch1);\r\n                leftNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(leftEdge, length - j, scratch2), scratch2);\r\n                normal = Cartesian3.normalize(Cartesian3.add(rightNormal, leftNormal, normal), normal);\r\n                addNormals(attr, normal, left, front, back, vertexFormat);\r\n\r\n                LR = front / 3;\r\n                LL = LR - 1;\r\n                UR = (back - 2) / 3;\r\n                UL = UR + 1;\r\n                indices[index++] = UL;\r\n                indices[index++] = LL;\r\n                indices[index++] = UR;\r\n                indices[index++] = UR;\r\n                indices[index++] = LL;\r\n                indices[index++] = LR;\r\n\r\n                front += 3;\r\n                back -= 3;\r\n            }\r\n            front -= 3;\r\n            back += 3;\r\n        }\r\n        normal = Cartesian3.fromArray(computedNormals, computedNormals.length - 3, normal);\r\n        addNormals(attr, normal, left, front, back, vertexFormat);\r\n\r\n        if (addEndPositions) { // add rounded end\r\n            front += 3;\r\n            back -= 3;\r\n            leftPos = cartesian3;\r\n            rightPos = cartesian4;\r\n            var lastEndPositions = endPositions[1];\r\n            for (i = 0; i < halfLength; i++) {\r\n                leftPos = Cartesian3.fromArray(lastEndPositions, (endPositionLength - i - 1) * 3, leftPos);\r\n                rightPos = Cartesian3.fromArray(lastEndPositions, i * 3, rightPos);\r\n                CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);\r\n                CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\r\n                addNormals(attr, normal, left, front, back, vertexFormat);\r\n\r\n                LR = front / 3;\r\n                LL = LR - 1;\r\n                UR = (back - 2) / 3;\r\n                UL = UR + 1;\r\n                indices[index++] = UL;\r\n                indices[index++] = LL;\r\n                indices[index++] = UR;\r\n                indices[index++] = UR;\r\n                indices[index++] = LL;\r\n                indices[index++] = LR;\r\n\r\n                front += 3;\r\n                back -= 3;\r\n            }\r\n        }\r\n\r\n        attributes.position = new GeometryAttribute({\r\n            componentDatatype : ComponentDatatype.DOUBLE,\r\n            componentsPerAttribute : 3,\r\n            values : finalPositions\r\n        });\r\n\r\n        if (vertexFormat.st) {\r\n            var st = new Float32Array(size / 3 * 2);\r\n            var rightSt;\r\n            var leftSt;\r\n            var stIndex = 0;\r\n            if (addEndPositions) {\r\n                leftCount /= 3;\r\n                rightCount /= 3;\r\n                var theta = Math.PI / (endPositionLength + 1);\r\n                leftSt = 1 / (leftCount - endPositionLength + 1);\r\n                rightSt = 1 / (rightCount - endPositionLength + 1);\r\n                var a;\r\n                var halfEndPos = endPositionLength / 2;\r\n                for (i = halfEndPos + 1; i < endPositionLength + 1; i++) { // lower left rounded end\r\n                    a = CesiumMath.PI_OVER_TWO + theta * i;\r\n                    st[stIndex++] = rightSt * (1 + Math.cos(a));\r\n                    st[stIndex++] = 0.5 * (1 + Math.sin(a));\r\n                }\r\n                for (i = 1; i < rightCount - endPositionLength + 1; i++) { // bottom edge\r\n                    st[stIndex++] = i * rightSt;\r\n                    st[stIndex++] = 0;\r\n                }\r\n                for (i = endPositionLength; i > halfEndPos; i--) { // lower right rounded end\r\n                    a = CesiumMath.PI_OVER_TWO - i * theta;\r\n                    st[stIndex++] = 1 - rightSt * (1 + Math.cos(a));\r\n                    st[stIndex++] = 0.5 * (1 + Math.sin(a));\r\n                }\r\n                for (i = halfEndPos; i > 0; i--) { // upper right rounded end\r\n                    a = CesiumMath.PI_OVER_TWO - theta * i;\r\n                    st[stIndex++] = 1 - leftSt * (1 + Math.cos(a));\r\n                    st[stIndex++] = 0.5 * (1 + Math.sin(a));\r\n                }\r\n                for (i = leftCount - endPositionLength; i > 0; i--) { // top edge\r\n                    st[stIndex++] = i * leftSt;\r\n                    st[stIndex++] = 1;\r\n                }\r\n                for (i = 1; i < halfEndPos + 1; i++) { // upper left rounded end\r\n                    a = CesiumMath.PI_OVER_TWO + theta * i;\r\n                    st[stIndex++] = leftSt * (1 + Math.cos(a));\r\n                    st[stIndex++] = 0.5 * (1 + Math.sin(a));\r\n                }\r\n            } else {\r\n                leftCount /= 3;\r\n                rightCount /= 3;\r\n                leftSt = 1 / (leftCount - 1);\r\n                rightSt = 1 / (rightCount - 1);\r\n                for (i = 0; i < rightCount; i++) { // bottom edge\r\n                    st[stIndex++] = i * rightSt;\r\n                    st[stIndex++] = 0;\r\n                }\r\n                for (i = leftCount; i > 0; i--) { // top edge\r\n                    st[stIndex++] = (i - 1) * leftSt;\r\n                    st[stIndex++] = 1;\r\n                }\r\n            }\r\n\r\n            attributes.st = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.FLOAT,\r\n                componentsPerAttribute : 2,\r\n                values : st\r\n            });\r\n        }\r\n\r\n        if (vertexFormat.normal) {\r\n            attributes.normal = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.FLOAT,\r\n                componentsPerAttribute : 3,\r\n                values : attr.normals\r\n            });\r\n        }\r\n\r\n        if (vertexFormat.tangent) {\r\n            attributes.tangent = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.FLOAT,\r\n                componentsPerAttribute : 3,\r\n                values : attr.tangents\r\n            });\r\n        }\r\n\r\n        if (vertexFormat.bitangent) {\r\n            attributes.bitangent = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.FLOAT,\r\n                componentsPerAttribute : 3,\r\n                values : attr.bitangents\r\n            });\r\n        }\r\n\r\n        return {\r\n            attributes : attributes,\r\n            indices : indices\r\n        };\r\n    }\r\n\r\n    function extrudedAttributes(attributes, vertexFormat) {\r\n        if (!vertexFormat.normal && !vertexFormat.tangent && !vertexFormat.bitangent && !vertexFormat.st) {\r\n            return attributes;\r\n        }\r\n        var positions = attributes.position.values;\r\n        var topNormals;\r\n        var topBitangents;\r\n        if (vertexFormat.normal || vertexFormat.bitangent) {\r\n            topNormals = attributes.normal.values;\r\n            topBitangents = attributes.bitangent.values;\r\n        }\r\n        var size = attributes.position.values.length / 18;\r\n        var threeSize = size * 3;\r\n        var twoSize = size * 2;\r\n        var sixSize = threeSize * 2;\r\n        var i;\r\n        if (vertexFormat.normal || vertexFormat.bitangent || vertexFormat.tangent) {\r\n            var normals = (vertexFormat.normal) ? new Float32Array(threeSize * 6) : undefined;\r\n            var tangents = (vertexFormat.tangent) ? new Float32Array(threeSize * 6) : undefined;\r\n            var bitangents = (vertexFormat.bitangent) ? new Float32Array(threeSize * 6) : undefined;\r\n            var topPosition = cartesian1;\r\n            var bottomPosition = cartesian2;\r\n            var previousPosition = cartesian3;\r\n            var normal = cartesian4;\r\n            var tangent = cartesian5;\r\n            var bitangent = cartesian6;\r\n            var attrIndex = sixSize;\r\n            for (i = 0; i < threeSize; i += 3) {\r\n                var attrIndexOffset = attrIndex + sixSize;\r\n                topPosition      = Cartesian3.fromArray(positions, i, topPosition);\r\n                bottomPosition   = Cartesian3.fromArray(positions, i + threeSize, bottomPosition);\r\n                previousPosition = Cartesian3.fromArray(positions, (i + 3) % threeSize, previousPosition);\r\n                bottomPosition   = Cartesian3.subtract(bottomPosition,   topPosition, bottomPosition);\r\n                previousPosition = Cartesian3.subtract(previousPosition, topPosition, previousPosition);\r\n                normal = Cartesian3.normalize(Cartesian3.cross(bottomPosition, previousPosition, normal), normal);\r\n                if (vertexFormat.normal) {\r\n                    CorridorGeometryLibrary.addAttribute(normals, normal, attrIndexOffset);\r\n                    CorridorGeometryLibrary.addAttribute(normals, normal, attrIndexOffset + 3);\r\n                    CorridorGeometryLibrary.addAttribute(normals, normal, attrIndex);\r\n                    CorridorGeometryLibrary.addAttribute(normals, normal, attrIndex + 3);\r\n                }\r\n                if (vertexFormat.tangent || vertexFormat.bitangent) {\r\n                    bitangent = Cartesian3.fromArray(topNormals, i, bitangent);\r\n                    if (vertexFormat.bitangent) {\r\n                        CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndexOffset);\r\n                        CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndexOffset + 3);\r\n                        CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndex);\r\n                        CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndex + 3);\r\n                    }\r\n\r\n                    if (vertexFormat.tangent) {\r\n                        tangent = Cartesian3.normalize(Cartesian3.cross(bitangent, normal, tangent), tangent);\r\n                        CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndexOffset);\r\n                        CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndexOffset + 3);\r\n                        CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndex);\r\n                        CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndex + 3);\r\n                    }\r\n                }\r\n                attrIndex += 6;\r\n            }\r\n\r\n            if (vertexFormat.normal) {\r\n                normals.set(topNormals); //top\r\n                for (i = 0; i < threeSize; i += 3) { //bottom normals\r\n                    normals[i + threeSize] = -topNormals[i];\r\n                    normals[i + threeSize + 1] = -topNormals[i + 1];\r\n                    normals[i + threeSize + 2] = -topNormals[i + 2];\r\n                }\r\n                attributes.normal.values = normals;\r\n            } else {\r\n                attributes.normal = undefined;\r\n            }\r\n\r\n            if (vertexFormat.bitangent) {\r\n                bitangents.set(topBitangents); //top\r\n                bitangents.set(topBitangents, threeSize); //bottom\r\n                attributes.bitangent.values = bitangents;\r\n            } else {\r\n                attributes.bitangent = undefined;\r\n            }\r\n\r\n            if (vertexFormat.tangent) {\r\n                var topTangents = attributes.tangent.values;\r\n                tangents.set(topTangents); //top\r\n                tangents.set(topTangents, threeSize); //bottom\r\n                attributes.tangent.values = tangents;\r\n            }\r\n        }\r\n        if (vertexFormat.st) {\r\n            var topSt = attributes.st.values;\r\n            var st = new Float32Array(twoSize * 6);\r\n            st.set(topSt); //top\r\n            st.set(topSt, twoSize); //bottom\r\n            var index = twoSize * 2;\r\n\r\n            for ( var j = 0; j < 2; j++) {\r\n                st[index++] = topSt[0];\r\n                st[index++] = topSt[1];\r\n                for (i = 2; i < twoSize; i += 2) {\r\n                    var s = topSt[i];\r\n                    var t = topSt[i + 1];\r\n                    st[index++] = s;\r\n                    st[index++] = t;\r\n                    st[index++] = s;\r\n                    st[index++] = t;\r\n                }\r\n                st[index++] = topSt[0];\r\n                st[index++] = topSt[1];\r\n            }\r\n            attributes.st.values = st;\r\n        }\r\n\r\n        return attributes;\r\n    }\r\n\r\n    function addWallPositions(positions, index, wallPositions) {\r\n        wallPositions[index++] = positions[0];\r\n        wallPositions[index++] = positions[1];\r\n        wallPositions[index++] = positions[2];\r\n        for ( var i = 3; i < positions.length; i += 3) {\r\n            var x = positions[i];\r\n            var y = positions[i + 1];\r\n            var z = positions[i + 2];\r\n            wallPositions[index++] = x;\r\n            wallPositions[index++] = y;\r\n            wallPositions[index++] = z;\r\n            wallPositions[index++] = x;\r\n            wallPositions[index++] = y;\r\n            wallPositions[index++] = z;\r\n        }\r\n        wallPositions[index++] = positions[0];\r\n        wallPositions[index++] = positions[1];\r\n        wallPositions[index++] = positions[2];\r\n\r\n        return wallPositions;\r\n    }\r\n\r\n    function computePositionsExtruded(params, vertexFormat) {\r\n        var topVertexFormat = new VertexFormat({\r\n            position : vertexFormat.position,\r\n            normal : (vertexFormat.normal || vertexFormat.bitangent || params.shadowVolume),\r\n            tangent : vertexFormat.tangent,\r\n            bitangent : (vertexFormat.normal || vertexFormat.bitangent),\r\n            st : vertexFormat.st\r\n        });\r\n        var ellipsoid = params.ellipsoid;\r\n        var computedPositions = CorridorGeometryLibrary.computePositions(params);\r\n        var attr = combine(computedPositions, topVertexFormat, ellipsoid);\r\n        var height = params.height;\r\n        var extrudedHeight = params.extrudedHeight;\r\n        var attributes = attr.attributes;\r\n        var indices = attr.indices;\r\n        var positions = attributes.position.values;\r\n        var length = positions.length;\r\n        var newPositions = new Float64Array(length * 6);\r\n        var extrudedPositions = new Float64Array(length);\r\n        extrudedPositions.set(positions);\r\n        var wallPositions = new Float64Array(length * 4);\r\n\r\n        positions = PolygonPipeline.scaleToGeodeticHeight(positions, height, ellipsoid);\r\n        wallPositions = addWallPositions(positions, 0, wallPositions);\r\n        extrudedPositions = PolygonPipeline.scaleToGeodeticHeight(extrudedPositions, extrudedHeight, ellipsoid);\r\n        wallPositions = addWallPositions(extrudedPositions, length * 2, wallPositions);\r\n        newPositions.set(positions);\r\n        newPositions.set(extrudedPositions, length);\r\n        newPositions.set(wallPositions, length * 2);\r\n        attributes.position.values = newPositions;\r\n\r\n        attributes = extrudedAttributes(attributes, vertexFormat);\r\n        var i;\r\n        var size = length / 3;\r\n        if (params.shadowVolume) {\r\n            var topNormals = attributes.normal.values;\r\n            length = topNormals.length;\r\n\r\n            var extrudeNormals = new Float32Array(length * 6);\r\n            for (i = 0; i < length; i ++) {\r\n                topNormals[i] = -topNormals[i];\r\n            }\r\n            //only get normals for bottom layer that's going to be pushed down\r\n            extrudeNormals.set(topNormals, length); //bottom face\r\n            extrudeNormals = addWallPositions(topNormals, length*4, extrudeNormals); //bottom wall\r\n            attributes.extrudeDirection = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.FLOAT,\r\n                componentsPerAttribute : 3,\r\n                values : extrudeNormals\r\n            });\r\n            if (!vertexFormat.normal) {\r\n                attributes.normal = undefined;\r\n            }\r\n        }\r\n        if (defined(params.offsetAttribute)) {\r\n            var applyOffset = new Uint8Array(size * 6);\r\n            if (params.offsetAttribute === GeometryOffsetAttribute.TOP) {\r\n                applyOffset = arrayFill(applyOffset, 1, 0, size); // top face\r\n                applyOffset = arrayFill(applyOffset, 1, size*2, size * 4); // top wall\r\n            } else {\r\n                var applyOffsetValue = params.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\r\n                applyOffset = arrayFill(applyOffset, applyOffsetValue);\r\n            }\r\n            attributes.applyOffset = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\r\n                componentsPerAttribute : 1,\r\n                values: applyOffset\r\n            });\r\n        }\r\n\r\n        var iLength = indices.length;\r\n        var twoSize = size + size;\r\n        var newIndices = IndexDatatype.createTypedArray(newPositions.length / 3, iLength * 2 + twoSize * 3);\r\n        newIndices.set(indices);\r\n        var index = iLength;\r\n        for (i = 0; i < iLength; i += 3) { // bottom indices\r\n            var v0 = indices[i];\r\n            var v1 = indices[i + 1];\r\n            var v2 = indices[i + 2];\r\n            newIndices[index++] = v2 + size;\r\n            newIndices[index++] = v1 + size;\r\n            newIndices[index++] = v0 + size;\r\n        }\r\n\r\n        var UL, LL, UR, LR;\r\n\r\n        for (i = 0; i < twoSize; i += 2) { //wall indices\r\n            UL = i + twoSize;\r\n            LL = UL + twoSize;\r\n            UR = UL + 1;\r\n            LR = LL + 1;\r\n            newIndices[index++] = UL;\r\n            newIndices[index++] = LL;\r\n            newIndices[index++] = UR;\r\n            newIndices[index++] = UR;\r\n            newIndices[index++] = LL;\r\n            newIndices[index++] = LR;\r\n        }\r\n\r\n        return {\r\n            attributes : attributes,\r\n            indices : newIndices\r\n        };\r\n    }\r\n\r\n    var scratchCartesian1 = new Cartesian3();\r\n    var scratchCartesian2 = new Cartesian3();\r\n    var scratchCartographic = new Cartographic();\r\n\r\n    function computeOffsetPoints(position1, position2, ellipsoid, halfWidth, min, max) {\r\n        // Compute direction of offset the point\r\n        var direction = Cartesian3.subtract(position2, position1, scratchCartesian1);\r\n        Cartesian3.normalize(direction, direction);\r\n        var normal = ellipsoid.geodeticSurfaceNormal(position1, scratchCartesian2);\r\n        var offsetDirection = Cartesian3.cross(direction, normal, scratchCartesian1);\r\n        Cartesian3.multiplyByScalar(offsetDirection, halfWidth, offsetDirection);\r\n\r\n        var minLat = min.latitude;\r\n        var minLon = min.longitude;\r\n        var maxLat = max.latitude;\r\n        var maxLon = max.longitude;\r\n\r\n        // Compute 2 offset points\r\n        Cartesian3.add(position1, offsetDirection, scratchCartesian2);\r\n        ellipsoid.cartesianToCartographic(scratchCartesian2, scratchCartographic);\r\n\r\n        var lat = scratchCartographic.latitude;\r\n        var lon = scratchCartographic.longitude;\r\n        minLat = Math.min(minLat, lat);\r\n        minLon = Math.min(minLon, lon);\r\n        maxLat = Math.max(maxLat, lat);\r\n        maxLon = Math.max(maxLon, lon);\r\n\r\n        Cartesian3.subtract(position1, offsetDirection, scratchCartesian2);\r\n        ellipsoid.cartesianToCartographic(scratchCartesian2, scratchCartographic);\r\n\r\n        lat = scratchCartographic.latitude;\r\n        lon = scratchCartographic.longitude;\r\n        minLat = Math.min(minLat, lat);\r\n        minLon = Math.min(minLon, lon);\r\n        maxLat = Math.max(maxLat, lat);\r\n        maxLon = Math.max(maxLon, lon);\r\n\r\n        min.latitude = minLat;\r\n        min.longitude = minLon;\r\n        max.latitude = maxLat;\r\n        max.longitude = maxLon;\r\n    }\r\n\r\n    var scratchCartesianOffset = new Cartesian3();\r\n    var scratchCartesianEnds = new Cartesian3();\r\n    var scratchCartographicMin = new Cartographic();\r\n    var scratchCartographicMax = new Cartographic();\r\n\r\n    function computeRectangle(positions, ellipsoid, width, cornerType, result) {\r\n        positions = scaleToSurface(positions, ellipsoid);\r\n        var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\r\n        var length = cleanPositions.length;\r\n        if (length < 2 || width <= 0) {\r\n            return new Rectangle();\r\n        }\r\n        var halfWidth = width * 0.5;\r\n\r\n        scratchCartographicMin.latitude = Number.POSITIVE_INFINITY;\r\n        scratchCartographicMin.longitude = Number.POSITIVE_INFINITY;\r\n        scratchCartographicMax.latitude = Number.NEGATIVE_INFINITY;\r\n        scratchCartographicMax.longitude = Number.NEGATIVE_INFINITY;\r\n\r\n        var lat, lon;\r\n        if (cornerType === CornerType.ROUNDED) {\r\n            // Compute start cap\r\n            var first = cleanPositions[0];\r\n            Cartesian3.subtract(first, cleanPositions[1], scratchCartesianOffset);\r\n            Cartesian3.normalize(scratchCartesianOffset, scratchCartesianOffset);\r\n            Cartesian3.multiplyByScalar(scratchCartesianOffset, halfWidth, scratchCartesianOffset);\r\n            Cartesian3.add(first, scratchCartesianOffset, scratchCartesianEnds);\r\n\r\n            ellipsoid.cartesianToCartographic(scratchCartesianEnds, scratchCartographic);\r\n            lat = scratchCartographic.latitude;\r\n            lon = scratchCartographic.longitude;\r\n            scratchCartographicMin.latitude = Math.min(scratchCartographicMin.latitude, lat);\r\n            scratchCartographicMin.longitude = Math.min(scratchCartographicMin.longitude, lon);\r\n            scratchCartographicMax.latitude = Math.max(scratchCartographicMax.latitude, lat);\r\n            scratchCartographicMax.longitude = Math.max(scratchCartographicMax.longitude, lon);\r\n        }\r\n\r\n        // Compute the rest\r\n        for (var i = 0; i < length-1; ++i) {\r\n            computeOffsetPoints(cleanPositions[i], cleanPositions[i+1], ellipsoid, halfWidth,\r\n                scratchCartographicMin, scratchCartographicMax);\r\n        }\r\n\r\n        // Compute ending point\r\n        var last = cleanPositions[length-1];\r\n        Cartesian3.subtract(last, cleanPositions[length-2], scratchCartesianOffset);\r\n        Cartesian3.normalize(scratchCartesianOffset, scratchCartesianOffset);\r\n        Cartesian3.multiplyByScalar(scratchCartesianOffset, halfWidth, scratchCartesianOffset);\r\n        Cartesian3.add(last, scratchCartesianOffset, scratchCartesianEnds);\r\n        computeOffsetPoints(last, scratchCartesianEnds, ellipsoid, halfWidth,\r\n            scratchCartographicMin, scratchCartographicMax);\r\n\r\n        if (cornerType === CornerType.ROUNDED) {\r\n            // Compute end cap\r\n            ellipsoid.cartesianToCartographic(scratchCartesianEnds, scratchCartographic);\r\n            lat = scratchCartographic.latitude;\r\n            lon = scratchCartographic.longitude;\r\n            scratchCartographicMin.latitude = Math.min(scratchCartographicMin.latitude, lat);\r\n            scratchCartographicMin.longitude = Math.min(scratchCartographicMin.longitude, lon);\r\n            scratchCartographicMax.latitude = Math.max(scratchCartographicMax.latitude, lat);\r\n            scratchCartographicMax.longitude = Math.max(scratchCartographicMax.longitude, lon);\r\n        }\r\n\r\n        var rectangle = defined(result) ? result : new Rectangle();\r\n        rectangle.north = scratchCartographicMax.latitude;\r\n        rectangle.south = scratchCartographicMin.latitude;\r\n        rectangle.east = scratchCartographicMax.longitude;\r\n        rectangle.west = scratchCartographicMin.longitude;\r\n\r\n        return rectangle;\r\n    }\r\n\r\n    /**\r\n     * A description of a corridor. Corridor geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\r\n     *\r\n     * @alias CorridorGeometry\r\n     * @constructor\r\n     *\r\n     * @param {Object} options Object with the following properties:\r\n     * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor.\r\n     * @param {Number} options.width The distance between the edges of the corridor in meters.\r\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\r\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n     * @param {Number} [options.height=0] The distance in meters between the ellipsoid surface and the positions.\r\n     * @param {Number} [options.extrudedHeight] The distance in meters between the ellipsoid surface and the extruded face.\r\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\r\n     * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\r\n     *\r\n     * @see CorridorGeometry.createGeometry\r\n     * @see Packable\r\n     *\r\n     * @demo {@link https://sandcastle.cesium.com/index.html?src=Corridor.html|Cesium Sandcastle Corridor Demo}\r\n     *\r\n     * @example\r\n     * var corridor = new Cesium.CorridorGeometry({\r\n     *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\r\n     *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),\r\n     *   width : 100000\r\n     * });\r\n     */\r\n    function CorridorGeometry(options) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n        var positions = options.positions;\r\n        var width = options.width;\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('options.positions', positions);\r\n        Check.defined('options.width', width);\r\n        //>>includeEnd('debug');\r\n\r\n        var height = defaultValue(options.height, 0.0);\r\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\r\n\r\n        this._positions = positions;\r\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\r\n        this._vertexFormat = VertexFormat.clone(defaultValue(options.vertexFormat, VertexFormat.DEFAULT));\r\n        this._width = width;\r\n        this._height = Math.max(height, extrudedHeight);\r\n        this._extrudedHeight = Math.min(height, extrudedHeight);\r\n        this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\r\n        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\r\n        this._shadowVolume = defaultValue(options.shadowVolume, false);\r\n        this._workerName = 'createCorridorGeometry';\r\n        this._offsetAttribute = options.offsetAttribute;\r\n        this._rectangle = undefined;\r\n\r\n        /**\r\n         * The number of elements used to pack the object into an array.\r\n         * @type {Number}\r\n         */\r\n        this.packedLength = 1 + positions.length * Cartesian3.packedLength + Ellipsoid.packedLength + VertexFormat.packedLength + 7;\r\n    }\r\n\r\n    /**\r\n     * Stores the provided instance into the provided array.\r\n     *\r\n     * @param {CorridorGeometry} value The value to pack.\r\n     * @param {Number[]} array The array to pack into.\r\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n     *\r\n     * @returns {Number[]} The array that was packed into\r\n     */\r\n    CorridorGeometry.pack = function(value, array, startingIndex) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('value', value);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        var positions = value._positions;\r\n        var length = positions.length;\r\n        array[startingIndex++] = length;\r\n\r\n        for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\r\n            Cartesian3.pack(positions[i], array, startingIndex);\r\n        }\r\n\r\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\r\n        startingIndex += Ellipsoid.packedLength;\r\n\r\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\r\n        startingIndex += VertexFormat.packedLength;\r\n\r\n        array[startingIndex++] = value._width;\r\n        array[startingIndex++] = value._height;\r\n        array[startingIndex++] = value._extrudedHeight;\r\n        array[startingIndex++] = value._cornerType;\r\n        array[startingIndex++] = value._granularity;\r\n        array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\r\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\r\n\r\n        return array;\r\n    };\r\n\r\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\r\n    var scratchVertexFormat = new VertexFormat();\r\n    var scratchOptions = {\r\n        positions : undefined,\r\n        ellipsoid : scratchEllipsoid,\r\n        vertexFormat : scratchVertexFormat,\r\n        width : undefined,\r\n        height : undefined,\r\n        extrudedHeight : undefined,\r\n        cornerType : undefined,\r\n        granularity : undefined,\r\n        shadowVolume: undefined,\r\n        offsetAttribute: undefined\r\n    };\r\n\r\n    /**\r\n     * Retrieves an instance from a packed array.\r\n     *\r\n     * @param {Number[]} array The packed array.\r\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n     * @param {CorridorGeometry} [result] The object into which to store the result.\r\n     * @returns {CorridorGeometry} The modified result parameter or a new CorridorGeometry instance if one was not provided.\r\n     */\r\n    CorridorGeometry.unpack = function(array, startingIndex, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        var length = array[startingIndex++];\r\n        var positions = new Array(length);\r\n\r\n        for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\r\n            positions[i] = Cartesian3.unpack(array, startingIndex);\r\n        }\r\n\r\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\r\n        startingIndex += Ellipsoid.packedLength;\r\n\r\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\r\n        startingIndex += VertexFormat.packedLength;\r\n\r\n        var width = array[startingIndex++];\r\n        var height = array[startingIndex++];\r\n        var extrudedHeight = array[startingIndex++];\r\n        var cornerType = array[startingIndex++];\r\n        var granularity = array[startingIndex++];\r\n        var shadowVolume = array[startingIndex++] === 1.0;\r\n        var offsetAttribute = array[startingIndex];\r\n\r\n        if (!defined(result)) {\r\n            scratchOptions.positions = positions;\r\n            scratchOptions.width = width;\r\n            scratchOptions.height = height;\r\n            scratchOptions.extrudedHeight = extrudedHeight;\r\n            scratchOptions.cornerType = cornerType;\r\n            scratchOptions.granularity = granularity;\r\n            scratchOptions.shadowVolume = shadowVolume;\r\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\r\n\r\n            return new CorridorGeometry(scratchOptions);\r\n        }\r\n\r\n        result._positions = positions;\r\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\r\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\r\n        result._width = width;\r\n        result._height = height;\r\n        result._extrudedHeight = extrudedHeight;\r\n        result._cornerType = cornerType;\r\n        result._granularity = granularity;\r\n        result._shadowVolume = shadowVolume;\r\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the bounding rectangle given the provided options\r\n     *\r\n     * @param {Object} options Object with the following properties:\r\n     * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor.\r\n     * @param {Number} options.width The distance between the edges of the corridor in meters.\r\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\r\n     * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\r\n     * @param {Rectangle} [result] An object in which to store the result.\r\n     *\r\n     * @returns {Rectangle} The result rectangle.\r\n     */\r\n    CorridorGeometry.computeRectangle = function(options, result) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n        var positions = options.positions;\r\n        var width = options.width;\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('options.positions', positions);\r\n        Check.defined('options.width', width);\r\n        //>>includeEnd('debug');\r\n\r\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n        var cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\r\n\r\n        return computeRectangle(positions, ellipsoid, width, cornerType, result);\r\n    };\r\n\r\n    /**\r\n     * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.\r\n     *\r\n     * @param {CorridorGeometry} corridorGeometry A description of the corridor.\r\n     * @returns {Geometry|undefined} The computed vertices and indices.\r\n     */\r\n    CorridorGeometry.createGeometry = function(corridorGeometry) {\r\n        var positions = corridorGeometry._positions;\r\n        var width = corridorGeometry._width;\r\n        var ellipsoid = corridorGeometry._ellipsoid;\r\n\r\n        positions = scaleToSurface(positions, ellipsoid);\r\n        var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\r\n\r\n        if ((cleanPositions.length < 2) || (width <= 0)) {\r\n            return;\r\n        }\r\n\r\n        var height = corridorGeometry._height;\r\n        var extrudedHeight = corridorGeometry._extrudedHeight;\r\n        var extrude = !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\r\n\r\n        var vertexFormat = corridorGeometry._vertexFormat;\r\n        var params = {\r\n            ellipsoid : ellipsoid,\r\n            positions : cleanPositions,\r\n            width : width,\r\n            cornerType : corridorGeometry._cornerType,\r\n            granularity : corridorGeometry._granularity,\r\n            saveAttributes: true\r\n        };\r\n        var attr;\r\n        if (extrude) {\r\n            params.height = height;\r\n            params.extrudedHeight = extrudedHeight;\r\n            params.shadowVolume = corridorGeometry._shadowVolume;\r\n            params.offsetAttribute = corridorGeometry._offsetAttribute;\r\n            attr = computePositionsExtruded(params, vertexFormat);\r\n        } else {\r\n            var computedPositions = CorridorGeometryLibrary.computePositions(params);\r\n            attr = combine(computedPositions, vertexFormat, ellipsoid);\r\n            attr.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(attr.attributes.position.values, height, ellipsoid);\r\n\r\n            if (defined(corridorGeometry._offsetAttribute)) {\r\n                var applyOffsetValue = corridorGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\r\n                var length = attr.attributes.position.values.length;\r\n                var applyOffset = new Uint8Array(length / 3);\r\n                arrayFill(applyOffset, applyOffsetValue);\r\n                attr.attributes.applyOffset = new GeometryAttribute({\r\n                    componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\r\n                    componentsPerAttribute : 1,\r\n                    values: applyOffset\r\n                });\r\n            }\r\n        }\r\n        var attributes = attr.attributes;\r\n        var boundingSphere = BoundingSphere.fromVertices(attributes.position.values, undefined, 3);\r\n        if (!vertexFormat.position) {\r\n            attr.attributes.position.values = undefined;\r\n        }\r\n\r\n        return new Geometry({\r\n            attributes : attributes,\r\n            indices : attr.indices,\r\n            primitiveType : PrimitiveType.TRIANGLES,\r\n            boundingSphere : boundingSphere,\r\n            offsetAttribute : corridorGeometry._offsetAttribute\r\n        });\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    CorridorGeometry.createShadowVolume = function(corridorGeometry, minHeightFunc, maxHeightFunc) {\r\n        var granularity = corridorGeometry._granularity;\r\n        var ellipsoid = corridorGeometry._ellipsoid;\r\n\r\n        var minHeight = minHeightFunc(granularity, ellipsoid);\r\n        var maxHeight = maxHeightFunc(granularity, ellipsoid);\r\n\r\n        return new CorridorGeometry({\r\n            positions : corridorGeometry._positions,\r\n            width : corridorGeometry._width,\r\n            cornerType : corridorGeometry._cornerType,\r\n            ellipsoid : ellipsoid,\r\n            granularity : granularity,\r\n            extrudedHeight : minHeight,\r\n            height : maxHeight,\r\n            vertexFormat : VertexFormat.POSITION_ONLY,\r\n            shadowVolume: true\r\n        });\r\n    };\r\n\r\n    Object.defineProperties(CorridorGeometry.prototype, {\r\n        /**\r\n         * @private\r\n         */\r\n        rectangle : {\r\n            get : function() {\r\n                if (!defined(this._rectangle)) {\r\n                    this._rectangle = computeRectangle(this._positions, this._ellipsoid, this._width, this._cornerType);\r\n                }\r\n                return this._rectangle;\r\n            }\r\n        },\r\n        /**\r\n         * For remapping texture coordinates when rendering CorridorGeometries as GroundPrimitives.\r\n         *\r\n         * Corridors don't support stRotation,\r\n         * so just return the corners of the original system.\r\n         * @private\r\n         */\r\n        textureCoordinateRotationPoints : {\r\n            get : function() {\r\n                return [0, 0, 0, 1, 1, 0];\r\n            }\r\n        }\r\n    });\r\nexport default CorridorGeometry;\r\n","import CorridorGeometry from '../Core/CorridorGeometry.js';\r\nimport defined from '../Core/defined.js';\r\nimport Ellipsoid from '../Core/Ellipsoid.js';\r\n\r\n    function createCorridorGeometry(corridorGeometry, offset) {\r\n        if (defined(offset)) {\r\n            corridorGeometry = CorridorGeometry.unpack(corridorGeometry, offset);\r\n        }\r\n        corridorGeometry._ellipsoid = Ellipsoid.clone(corridorGeometry._ellipsoid);\r\n        return CorridorGeometry.createGeometry(corridorGeometry);\r\n    }\r\nexport default createCorridorGeometry;\r\n"],"names":["cartesian1","Cartesian3","cartesian2","cartesian3","cartesian4","cartesian5","cartesian6","scratch1","scratch2","scaleToSurface","positions","ellipsoid","i","length","scaleToGeodeticSurface","addNormals","attr","normal","left","front","back","vertexFormat","normals","tangents","bitangents","forward","normalize","cross","CorridorGeometryLibrary","addAttribute","tangent","bitangent","combine","computedPositions","corner","corners","endPositions","computedLefts","lefts","computedNormals","attributes","GeometryAttributes","leftCount","rightCount","indicesLength","leftSide","leftPositions","defined","rightPositions","endPositionLength","addEndPositions","UL","LL","UR","LR","rightPos","leftPos","size","finalPositions","Float64Array","Float32Array","undefined","halfLength","indices","IndexDatatype","createTypedArray","index","firstEndPositions","fromArray","rightNormal","leftNormal","posIndex","compIndex","rightEdge","leftEdge","set","geodeticSurfaceNormal","add","j","pivot","start","l","r","outsidePoint","previousPoint","nextPoint","subtract","negate","splice","lastEndPositions","position","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","st","rightSt","leftSt","stIndex","a","theta","Math","PI","halfEndPos","CesiumMath","PI_OVER_TWO","cos","sin","FLOAT","addWallPositions","wallPositions","x","y","z","computePositionsExtruded","params","topVertexFormat","VertexFormat","shadowVolume","computePositions","height","extrudedHeight","newPositions","extrudedPositions","PolygonPipeline","scaleToGeodeticHeight","topNormals","topBitangents","threeSize","twoSize","sixSize","topPosition","bottomPosition","previousPosition","attrIndex","attrIndexOffset","topTangents","topSt","s","t","extrudedAttributes","extrudeNormals","extrudeDirection","offsetAttribute","applyOffset","Uint8Array","GeometryOffsetAttribute","TOP","arrayFill","applyOffsetValue","NONE","UNSIGNED_BYTE","iLength","newIndices","v0","v1","v2","scratchCartesian1","scratchCartesian2","scratchCartographic","Cartographic","computeOffsetPoints","position1","position2","halfWidth","min","max","direction","offsetDirection","multiplyByScalar","minLat","latitude","minLon","longitude","maxLat","maxLon","cartesianToCartographic","lat","lon","scratchCartesianOffset","scratchCartesianEnds","scratchCartographicMin","scratchCartographicMax","computeRectangle","width","cornerType","result","cleanPositions","arrayRemoveDuplicates","equalsEpsilon","Rectangle","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","CornerType","ROUNDED","first","last","rectangle","north","south","east","west","CorridorGeometry","options","defaultValue","EMPTY_OBJECT","Check","this","_positions","_ellipsoid","Ellipsoid","clone","WGS84","_vertexFormat","DEFAULT","_width","_height","_extrudedHeight","_cornerType","_granularity","granularity","RADIANS_PER_DEGREE","_shadowVolume","_workerName","_offsetAttribute","_rectangle","packedLength","pack","value","array","startingIndex","scratchEllipsoid","UNIT_SPHERE","scratchVertexFormat","scratchOptions","unpack","Array","createGeometry","corridorGeometry","extrude","EPSILON2","saveAttributes","boundingSphere","BoundingSphere","fromVertices","Geometry","primitiveType","PrimitiveType","TRIANGLES","createShadowVolume","minHeightFunc","maxHeightFunc","minHeight","maxHeight","POSITION_ONLY","Object","defineProperties","prototype","get","textureCoordinateRotationPoints","offset"],"mappings":"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"}