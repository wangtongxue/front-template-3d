{"version":3,"file":"createVectorTilePolygons.js","sources":["../../../../Source/WorkersES6/createVectorTilePolygons.js"],"sourcesContent":["import AttributeCompression from '../Core/AttributeCompression.js';\r\nimport Cartesian3 from '../Core/Cartesian3.js';\r\nimport Cartographic from '../Core/Cartographic.js';\r\nimport Color from '../Core/Color.js';\r\nimport defined from '../Core/defined.js';\r\nimport Ellipsoid from '../Core/Ellipsoid.js';\r\nimport IndexDatatype from '../Core/IndexDatatype.js';\r\nimport CesiumMath from '../Core/Math.js';\r\nimport OrientedBoundingBox from '../Core/OrientedBoundingBox.js';\r\nimport Rectangle from '../Core/Rectangle.js';\r\nimport createTaskProcessorWorker from './createTaskProcessorWorker.js';\r\n\r\n    var scratchCenter = new Cartesian3();\r\n    var scratchEllipsoid = new Ellipsoid();\r\n    var scratchRectangle = new Rectangle();\r\n    var scratchScalars = {\r\n        min : undefined,\r\n        max : undefined,\r\n        indexBytesPerElement : undefined\r\n    };\r\n\r\n    function unpackBuffer(buffer) {\r\n        var packedBuffer = new Float64Array(buffer);\r\n\r\n        var offset = 0;\r\n        scratchScalars.indexBytesPerElement = packedBuffer[offset++];\r\n\r\n        scratchScalars.min = packedBuffer[offset++];\r\n        scratchScalars.max = packedBuffer[offset++];\r\n\r\n        Cartesian3.unpack(packedBuffer, offset, scratchCenter);\r\n        offset += Cartesian3.packedLength;\r\n\r\n        Ellipsoid.unpack(packedBuffer, offset, scratchEllipsoid);\r\n        offset += Ellipsoid.packedLength;\r\n\r\n        Rectangle.unpack(packedBuffer, offset, scratchRectangle);\r\n    }\r\n\r\n    function packedBatchedIndicesLength(batchedIndices) {\r\n        var length = batchedIndices.length;\r\n        var count = 0;\r\n        for (var i = 0; i < length; ++i) {\r\n            count += Color.packedLength + 3 + batchedIndices[i].batchIds.length;\r\n        }\r\n        return count;\r\n    }\r\n\r\n    function packBuffer(indexDatatype, boundingVolumes, batchedIndices) {\r\n        var numBVs = boundingVolumes.length;\r\n        var length = 1 + 1 + numBVs * OrientedBoundingBox.packedLength + 1 + packedBatchedIndicesLength(batchedIndices);\r\n\r\n        var packedBuffer = new Float64Array(length);\r\n\r\n        var offset = 0;\r\n        packedBuffer[offset++] = indexDatatype;\r\n        packedBuffer[offset++] = numBVs;\r\n\r\n        for (var i = 0; i < numBVs; ++i) {\r\n            OrientedBoundingBox.pack(boundingVolumes[i], packedBuffer, offset);\r\n            offset += OrientedBoundingBox.packedLength;\r\n        }\r\n\r\n        var indicesLength = batchedIndices.length;\r\n        packedBuffer[offset++] = indicesLength;\r\n\r\n        for (var j = 0; j < indicesLength; ++j) {\r\n            var batchedIndex = batchedIndices[j];\r\n\r\n            Color.pack(batchedIndex.color, packedBuffer, offset);\r\n            offset += Color.packedLength;\r\n\r\n            packedBuffer[offset++] = batchedIndex.offset;\r\n            packedBuffer[offset++] = batchedIndex.count;\r\n\r\n            var batchIds = batchedIndex.batchIds;\r\n            var batchIdsLength = batchIds.length;\r\n            packedBuffer[offset++] = batchIdsLength;\r\n\r\n            for (var k = 0; k < batchIdsLength; ++k) {\r\n                packedBuffer[offset++] = batchIds[k];\r\n            }\r\n        }\r\n\r\n        return packedBuffer;\r\n    }\r\n\r\n    var maxShort = 32767;\r\n\r\n    var scratchEncodedPosition = new Cartesian3();\r\n    var scratchNormal = new Cartesian3();\r\n    var scratchScaledNormal = new Cartesian3();\r\n    var scratchMinHeightPosition = new Cartesian3();\r\n    var scratchMaxHeightPosition = new Cartesian3();\r\n    var scratchBVCartographic = new Cartographic();\r\n    var scratchBVRectangle = new Rectangle();\r\n\r\n    function createVectorTilePolygons(parameters, transferableObjects) {\r\n        unpackBuffer(parameters.packedBuffer);\r\n\r\n        var indices;\r\n        var indexBytesPerElement = scratchScalars.indexBytesPerElement;\r\n        if (indexBytesPerElement === 2) {\r\n            indices = new Uint16Array(parameters.indices);\r\n        } else {\r\n            indices = new Uint32Array(parameters.indices);\r\n        }\r\n\r\n        var positions = new Uint16Array(parameters.positions);\r\n        var counts = new Uint32Array(parameters.counts);\r\n        var indexCounts = new Uint32Array(parameters.indexCounts);\r\n        var batchIds = new Uint32Array(parameters.batchIds);\r\n        var batchTableColors = new Uint32Array(parameters.batchTableColors);\r\n\r\n        var boundingVolumes = new Array(counts.length);\r\n\r\n        var center = scratchCenter;\r\n        var ellipsoid = scratchEllipsoid;\r\n        var rectangle = scratchRectangle;\r\n        var minHeight = scratchScalars.min;\r\n        var maxHeight = scratchScalars.max;\r\n\r\n        var minimumHeights = parameters.minimumHeights;\r\n        var maximumHeights = parameters.maximumHeights;\r\n        if (defined(minimumHeights) && defined(maximumHeights)) {\r\n            minimumHeights = new Float32Array(minimumHeights);\r\n            maximumHeights = new Float32Array(maximumHeights);\r\n        }\r\n\r\n        var i;\r\n        var j;\r\n        var rgba;\r\n\r\n        var positionsLength = positions.length / 2;\r\n        var uBuffer = positions.subarray(0, positionsLength);\r\n        var vBuffer = positions.subarray(positionsLength, 2 * positionsLength);\r\n        AttributeCompression.zigZagDeltaDecode(uBuffer, vBuffer);\r\n\r\n        var decodedPositions = new Float64Array(positionsLength * 3);\r\n        for (i = 0; i < positionsLength; ++i) {\r\n            var u = uBuffer[i];\r\n            var v = vBuffer[i];\r\n\r\n            var x = CesiumMath.lerp(rectangle.west, rectangle.east, u / maxShort);\r\n            var y = CesiumMath.lerp(rectangle.south, rectangle.north, v / maxShort);\r\n\r\n            var cart = Cartographic.fromRadians(x, y, 0.0, scratchBVCartographic);\r\n            var decodedPosition = ellipsoid.cartographicToCartesian(cart, scratchEncodedPosition);\r\n            Cartesian3.pack(decodedPosition, decodedPositions, i * 3);\r\n        }\r\n\r\n        var countsLength = counts.length;\r\n        var offsets = new Array(countsLength);\r\n        var indexOffsets = new Array(countsLength);\r\n        var currentOffset = 0;\r\n        var currentIndexOffset = 0;\r\n        for (i = 0; i < countsLength; ++i) {\r\n            offsets[i] = currentOffset;\r\n            indexOffsets[i] = currentIndexOffset;\r\n\r\n            currentOffset += counts[i];\r\n            currentIndexOffset += indexCounts[i];\r\n        }\r\n\r\n        var batchedPositions = new Float32Array(positionsLength * 3 * 2);\r\n        var batchedIds = new Uint16Array(positionsLength * 2);\r\n        var batchedIndexOffsets = new Uint32Array(indexOffsets.length);\r\n        var batchedIndexCounts = new Uint32Array(indexCounts.length);\r\n        var batchedIndices = [];\r\n\r\n        var colorToBuffers = {};\r\n        for (i = 0; i < countsLength; ++i) {\r\n            rgba = batchTableColors[i];\r\n            if (!defined(colorToBuffers[rgba])) {\r\n                colorToBuffers[rgba] = {\r\n                    positionLength : counts[i],\r\n                    indexLength : indexCounts[i],\r\n                    offset : 0,\r\n                    indexOffset : 0,\r\n                    batchIds : [i]\r\n                };\r\n            } else {\r\n                colorToBuffers[rgba].positionLength += counts[i];\r\n                colorToBuffers[rgba].indexLength += indexCounts[i];\r\n                colorToBuffers[rgba].batchIds.push(i);\r\n            }\r\n        }\r\n\r\n        // get the offsets and counts for the positions and indices of each primitive\r\n        var buffer;\r\n        var byColorPositionOffset = 0;\r\n        var byColorIndexOffset = 0;\r\n        for (rgba in colorToBuffers) {\r\n            if (colorToBuffers.hasOwnProperty(rgba)) {\r\n                buffer = colorToBuffers[rgba];\r\n                buffer.offset = byColorPositionOffset;\r\n                buffer.indexOffset = byColorIndexOffset;\r\n\r\n                var positionLength = buffer.positionLength * 2;\r\n                var indexLength = buffer.indexLength * 2 + buffer.positionLength * 6;\r\n\r\n                byColorPositionOffset += positionLength;\r\n                byColorIndexOffset += indexLength;\r\n\r\n                buffer.indexLength = indexLength;\r\n            }\r\n        }\r\n\r\n        var batchedDrawCalls = [];\r\n\r\n        for (rgba in colorToBuffers) {\r\n            if (colorToBuffers.hasOwnProperty(rgba)) {\r\n                buffer = colorToBuffers[rgba];\r\n\r\n                batchedDrawCalls.push({\r\n                    color : Color.fromRgba(parseInt(rgba)),\r\n                    offset : buffer.indexOffset,\r\n                    count : buffer.indexLength,\r\n                    batchIds : buffer.batchIds\r\n                });\r\n            }\r\n        }\r\n\r\n        for (i = 0; i < countsLength; ++i) {\r\n            rgba = batchTableColors[i];\r\n\r\n            buffer = colorToBuffers[rgba];\r\n            var positionOffset = buffer.offset;\r\n            var positionIndex = positionOffset * 3;\r\n            var batchIdIndex = positionOffset;\r\n\r\n            var polygonOffset = offsets[i];\r\n            var polygonCount = counts[i];\r\n            var batchId = batchIds[i];\r\n\r\n            var polygonMinimumHeight = minHeight;\r\n            var polygonMaximumHeight = maxHeight;\r\n            if (defined(minimumHeights) && defined(maximumHeights)) {\r\n                polygonMinimumHeight = minimumHeights[i];\r\n                polygonMaximumHeight = maximumHeights[i];\r\n            }\r\n\r\n            var minLat = Number.POSITIVE_INFINITY;\r\n            var maxLat = Number.NEGATIVE_INFINITY;\r\n            var minLon = Number.POSITIVE_INFINITY;\r\n            var maxLon = Number.NEGATIVE_INFINITY;\r\n\r\n            for (j = 0; j < polygonCount; ++j) {\r\n                var position = Cartesian3.unpack(decodedPositions, polygonOffset * 3 + j * 3, scratchEncodedPosition);\r\n                ellipsoid.scaleToGeodeticSurface(position, position);\r\n\r\n                var carto = ellipsoid.cartesianToCartographic(position, scratchBVCartographic);\r\n                var lat = carto.latitude;\r\n                var lon = carto.longitude;\r\n\r\n                minLat = Math.min(lat, minLat);\r\n                maxLat = Math.max(lat, maxLat);\r\n                minLon = Math.min(lon, minLon);\r\n                maxLon = Math.max(lon, maxLon);\r\n\r\n                var normal = ellipsoid.geodeticSurfaceNormal(position, scratchNormal);\r\n                var scaledNormal = Cartesian3.multiplyByScalar(normal, polygonMinimumHeight, scratchScaledNormal);\r\n                var minHeightPosition = Cartesian3.add(position, scaledNormal, scratchMinHeightPosition);\r\n\r\n                scaledNormal = Cartesian3.multiplyByScalar(normal, polygonMaximumHeight, scaledNormal);\r\n                var maxHeightPosition = Cartesian3.add(position, scaledNormal, scratchMaxHeightPosition);\r\n\r\n                Cartesian3.subtract(maxHeightPosition, center, maxHeightPosition);\r\n                Cartesian3.subtract(minHeightPosition, center, minHeightPosition);\r\n\r\n                Cartesian3.pack(maxHeightPosition, batchedPositions, positionIndex);\r\n                Cartesian3.pack(minHeightPosition, batchedPositions, positionIndex + 3);\r\n\r\n                batchedIds[batchIdIndex] = batchId;\r\n                batchedIds[batchIdIndex + 1] = batchId;\r\n\r\n                positionIndex += 6;\r\n                batchIdIndex += 2;\r\n            }\r\n\r\n            rectangle = scratchBVRectangle;\r\n            rectangle.west = minLon;\r\n            rectangle.east = maxLon;\r\n            rectangle.south = minLat;\r\n            rectangle.north = maxLat;\r\n\r\n            boundingVolumes[i] = OrientedBoundingBox.fromRectangle(rectangle, minHeight, maxHeight, ellipsoid);\r\n\r\n            var indicesIndex = buffer.indexOffset;\r\n\r\n            var indexOffset = indexOffsets[i];\r\n            var indexCount = indexCounts[i];\r\n\r\n            batchedIndexOffsets[i] = indicesIndex;\r\n\r\n            for (j = 0; j < indexCount; j += 3) {\r\n                var i0 = indices[indexOffset + j] - polygonOffset;\r\n                var i1 = indices[indexOffset + j + 1] - polygonOffset;\r\n                var i2 = indices[indexOffset + j + 2] - polygonOffset;\r\n\r\n                // triangle on the top of the extruded polygon\r\n                batchedIndices[indicesIndex++] = i0 * 2 + positionOffset;\r\n                batchedIndices[indicesIndex++] = i1 * 2 + positionOffset;\r\n                batchedIndices[indicesIndex++] = i2 * 2 + positionOffset;\r\n\r\n                // triangle on the bottom of the extruded polygon\r\n                batchedIndices[indicesIndex++] = i2 * 2 + 1 + positionOffset;\r\n                batchedIndices[indicesIndex++] = i1 * 2 + 1 + positionOffset;\r\n                batchedIndices[indicesIndex++] = i0 * 2 + 1 + positionOffset;\r\n            }\r\n\r\n            // indices for the walls of the extruded polygon\r\n            for (j = 0; j < polygonCount; ++j) {\r\n                var v0 = j;\r\n                var v1 = (j + 1) % polygonCount;\r\n\r\n                batchedIndices[indicesIndex++] = v0 * 2 + 1 + positionOffset;\r\n                batchedIndices[indicesIndex++] = v1 * 2 + positionOffset;\r\n                batchedIndices[indicesIndex++] = v0 * 2 + positionOffset;\r\n\r\n                batchedIndices[indicesIndex++] = v0 * 2 + 1 + positionOffset;\r\n                batchedIndices[indicesIndex++] = v1 * 2 + 1 + positionOffset;\r\n                batchedIndices[indicesIndex++] = v1 * 2 + positionOffset;\r\n            }\r\n\r\n            buffer.offset += polygonCount * 2;\r\n            buffer.indexOffset = indicesIndex;\r\n\r\n            batchedIndexCounts[i] = indicesIndex - batchedIndexOffsets[i];\r\n        }\r\n\r\n        batchedIndices = IndexDatatype.createTypedArray(batchedPositions.length / 3, batchedIndices);\r\n\r\n        var batchedIndicesLength = batchedDrawCalls.length;\r\n        for (var m = 0; m < batchedIndicesLength; ++m) {\r\n            var tempIds = batchedDrawCalls[m].batchIds;\r\n            var count = 0;\r\n            var tempIdsLength = tempIds.length;\r\n            for (var n = 0; n < tempIdsLength; ++n) {\r\n                count += batchedIndexCounts[tempIds[n]];\r\n            }\r\n            batchedDrawCalls[m].count = count;\r\n        }\r\n\r\n        var indexDatatype = (batchedIndices.BYTES_PER_ELEMENT === 2) ?  IndexDatatype.UNSIGNED_SHORT : IndexDatatype.UNSIGNED_INT;\r\n        var packedBuffer = packBuffer(indexDatatype, boundingVolumes, batchedDrawCalls);\r\n\r\n        transferableObjects.push(batchedPositions.buffer, batchedIndices.buffer, batchedIndexOffsets.buffer, batchedIndexCounts.buffer, batchedIds.buffer, packedBuffer.buffer);\r\n\r\n        return {\r\n            positions : batchedPositions.buffer,\r\n            indices : batchedIndices.buffer,\r\n            indexOffsets : batchedIndexOffsets.buffer,\r\n            indexCounts : batchedIndexCounts.buffer,\r\n            batchIds : batchedIds.buffer,\r\n            packedBuffer : packedBuffer.buffer\r\n        };\r\n    }\r\nexport default createTaskProcessorWorker(createVectorTilePolygons);\r\n"],"names":["scratchCenter","Cartesian3","scratchEllipsoid","Ellipsoid","scratchRectangle","Rectangle","scratchScalars","min","undefined","max","indexBytesPerElement","packBuffer","indexDatatype","boundingVolumes","batchedIndices","numBVs","length","OrientedBoundingBox","packedLength","count","i","Color","batchIds","packedBatchedIndicesLength","packedBuffer","Float64Array","offset","pack","indicesLength","j","batchedIndex","color","batchIdsLength","k","scratchEncodedPosition","scratchNormal","scratchScaledNormal","scratchMinHeightPosition","scratchMaxHeightPosition","scratchBVCartographic","Cartographic","scratchBVRectangle","createTaskProcessorWorker","parameters","transferableObjects","indices","buffer","unpack","unpackBuffer","Uint16Array","Uint32Array","rgba","positions","counts","indexCounts","batchTableColors","Array","center","ellipsoid","rectangle","minHeight","maxHeight","minimumHeights","maximumHeights","defined","Float32Array","positionsLength","uBuffer","subarray","vBuffer","AttributeCompression","zigZagDeltaDecode","decodedPositions","u","v","x","CesiumMath","lerp","west","east","y","south","north","cart","fromRadians","decodedPosition","cartographicToCartesian","countsLength","offsets","indexOffsets","currentOffset","currentIndexOffset","batchedPositions","batchedIds","batchedIndexOffsets","batchedIndexCounts","colorToBuffers","positionLength","indexLength","push","indexOffset","byColorPositionOffset","byColorIndexOffset","hasOwnProperty","batchedDrawCalls","fromRgba","parseInt","positionOffset","positionIndex","batchIdIndex","polygonOffset","polygonCount","batchId","polygonMinimumHeight","polygonMaximumHeight","minLat","Number","POSITIVE_INFINITY","maxLat","NEGATIVE_INFINITY","minLon","maxLon","position","scaleToGeodeticSurface","carto","cartesianToCartographic","lat","latitude","lon","longitude","Math","normal","geodeticSurfaceNormal","scaledNormal","multiplyByScalar","minHeightPosition","add","maxHeightPosition","subtract","fromRectangle","indicesIndex","indexCount","i0","i1","i2","v0","v1","IndexDatatype","createTypedArray","batchedIndicesLength","m","tempIds","tempIdsLength","n","BYTES_PER_ELEMENT","UNSIGNED_SHORT","UNSIGNED_INT"],"mappings":"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"}