{"version":3,"file":"Cartesian2-ff47d58f.js","sources":["../../../../Source/Core/Rectangle.js","../../../../Source/Core/Cartesian2.js"],"sourcesContent":["import Cartographic from './Cartographic.js';\r\nimport Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport CesiumMath from './Math.js';\r\n\r\n    /**\r\n     * A two dimensional region specified as longitude and latitude coordinates.\r\n     *\r\n     * @alias Rectangle\r\n     * @constructor\r\n     *\r\n     * @param {Number} [west=0.0] The westernmost longitude, in radians, in the range [-Pi, Pi].\r\n     * @param {Number} [south=0.0] The southernmost latitude, in radians, in the range [-Pi/2, Pi/2].\r\n     * @param {Number} [east=0.0] The easternmost longitude, in radians, in the range [-Pi, Pi].\r\n     * @param {Number} [north=0.0] The northernmost latitude, in radians, in the range [-Pi/2, Pi/2].\r\n     *\r\n     * @see Packable\r\n     */\r\n    function Rectangle(west, south, east, north) {\r\n        /**\r\n         * The westernmost longitude in radians in the range [-Pi, Pi].\r\n         *\r\n         * @type {Number}\r\n         * @default 0.0\r\n         */\r\n        this.west = defaultValue(west, 0.0);\r\n\r\n        /**\r\n         * The southernmost latitude in radians in the range [-Pi/2, Pi/2].\r\n         *\r\n         * @type {Number}\r\n         * @default 0.0\r\n         */\r\n        this.south = defaultValue(south, 0.0);\r\n\r\n        /**\r\n         * The easternmost longitude in radians in the range [-Pi, Pi].\r\n         *\r\n         * @type {Number}\r\n         * @default 0.0\r\n         */\r\n        this.east = defaultValue(east, 0.0);\r\n\r\n        /**\r\n         * The northernmost latitude in radians in the range [-Pi/2, Pi/2].\r\n         *\r\n         * @type {Number}\r\n         * @default 0.0\r\n         */\r\n        this.north = defaultValue(north, 0.0);\r\n    }\r\n\r\n    Object.defineProperties(Rectangle.prototype, {\r\n        /**\r\n         * Gets the width of the rectangle in radians.\r\n         * @memberof Rectangle.prototype\r\n         * @type {Number}\r\n         */\r\n        width : {\r\n            get : function() {\r\n                return Rectangle.computeWidth(this);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Gets the height of the rectangle in radians.\r\n         * @memberof Rectangle.prototype\r\n         * @type {Number}\r\n         */\r\n        height : {\r\n            get : function() {\r\n                return Rectangle.computeHeight(this);\r\n            }\r\n        }\r\n    });\r\n\r\n    /**\r\n     * The number of elements used to pack the object into an array.\r\n     * @type {Number}\r\n     */\r\n    Rectangle.packedLength = 4;\r\n\r\n    /**\r\n     * Stores the provided instance into the provided array.\r\n     *\r\n     * @param {Rectangle} value The value to pack.\r\n     * @param {Number[]} array The array to pack into.\r\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n     *\r\n     * @returns {Number[]} The array that was packed into\r\n     */\r\n    Rectangle.pack = function(value, array, startingIndex) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('value', value);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        array[startingIndex++] = value.west;\r\n        array[startingIndex++] = value.south;\r\n        array[startingIndex++] = value.east;\r\n        array[startingIndex] = value.north;\r\n\r\n        return array;\r\n    };\r\n\r\n    /**\r\n     * Retrieves an instance from a packed array.\r\n     *\r\n     * @param {Number[]} array The packed array.\r\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n     * @param {Rectangle} [result] The object into which to store the result.\r\n     * @returns {Rectangle} The modified result parameter or a new Rectangle instance if one was not provided.\r\n     */\r\n    Rectangle.unpack = function(array, startingIndex, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        if (!defined(result)) {\r\n            result = new Rectangle();\r\n        }\r\n\r\n        result.west = array[startingIndex++];\r\n        result.south = array[startingIndex++];\r\n        result.east = array[startingIndex++];\r\n        result.north = array[startingIndex];\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the width of a rectangle in radians.\r\n     * @param {Rectangle} rectangle The rectangle to compute the width of.\r\n     * @returns {Number} The width.\r\n     */\r\n    Rectangle.computeWidth = function(rectangle) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('rectangle', rectangle);\r\n        //>>includeEnd('debug');\r\n        var east = rectangle.east;\r\n        var west = rectangle.west;\r\n        if (east < west) {\r\n            east += CesiumMath.TWO_PI;\r\n        }\r\n        return east - west;\r\n    };\r\n\r\n    /**\r\n     * Computes the height of a rectangle in radians.\r\n     * @param {Rectangle} rectangle The rectangle to compute the height of.\r\n     * @returns {Number} The height.\r\n     */\r\n    Rectangle.computeHeight = function(rectangle) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('rectangle', rectangle);\r\n        //>>includeEnd('debug');\r\n        return rectangle.north - rectangle.south;\r\n    };\r\n\r\n    /**\r\n     * Creates a rectangle given the boundary longitude and latitude in degrees.\r\n     *\r\n     * @param {Number} [west=0.0] The westernmost longitude in degrees in the range [-180.0, 180.0].\r\n     * @param {Number} [south=0.0] The southernmost latitude in degrees in the range [-90.0, 90.0].\r\n     * @param {Number} [east=0.0] The easternmost longitude in degrees in the range [-180.0, 180.0].\r\n     * @param {Number} [north=0.0] The northernmost latitude in degrees in the range [-90.0, 90.0].\r\n     * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\r\n     * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\r\n     *\r\n     * @example\r\n     * var rectangle = Cesium.Rectangle.fromDegrees(0.0, 20.0, 10.0, 30.0);\r\n     */\r\n    Rectangle.fromDegrees = function(west, south, east, north, result) {\r\n        west = CesiumMath.toRadians(defaultValue(west, 0.0));\r\n        south = CesiumMath.toRadians(defaultValue(south, 0.0));\r\n        east = CesiumMath.toRadians(defaultValue(east, 0.0));\r\n        north = CesiumMath.toRadians(defaultValue(north, 0.0));\r\n\r\n        if (!defined(result)) {\r\n            return new Rectangle(west, south, east, north);\r\n        }\r\n\r\n        result.west = west;\r\n        result.south = south;\r\n        result.east = east;\r\n        result.north = north;\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Creates a rectangle given the boundary longitude and latitude in radians.\r\n     *\r\n     * @param {Number} [west=0.0] The westernmost longitude in radians in the range [-Math.PI, Math.PI].\r\n     * @param {Number} [south=0.0] The southernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].\r\n     * @param {Number} [east=0.0] The easternmost longitude in radians in the range [-Math.PI, Math.PI].\r\n     * @param {Number} [north=0.0] The northernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].\r\n     * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\r\n     * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\r\n     *\r\n     * @example\r\n     * var rectangle = Cesium.Rectangle.fromRadians(0.0, Math.PI/4, Math.PI/8, 3*Math.PI/4);\r\n     */\r\n    Rectangle.fromRadians = function(west, south, east, north, result) {\r\n        if (!defined(result)) {\r\n            return new Rectangle(west, south, east, north);\r\n        }\r\n\r\n        result.west = defaultValue(west, 0.0);\r\n        result.south = defaultValue(south, 0.0);\r\n        result.east = defaultValue(east, 0.0);\r\n        result.north = defaultValue(north, 0.0);\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Creates the smallest possible Rectangle that encloses all positions in the provided array.\r\n     *\r\n     * @param {Cartographic[]} cartographics The list of Cartographic instances.\r\n     * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\r\n     * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\r\n     */\r\n    Rectangle.fromCartographicArray = function(cartographics, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('cartographics', cartographics);\r\n        //>>includeEnd('debug');\r\n\r\n        var west = Number.MAX_VALUE;\r\n        var east = -Number.MAX_VALUE;\r\n        var westOverIDL = Number.MAX_VALUE;\r\n        var eastOverIDL = -Number.MAX_VALUE;\r\n        var south = Number.MAX_VALUE;\r\n        var north = -Number.MAX_VALUE;\r\n\r\n        for ( var i = 0, len = cartographics.length; i < len; i++) {\r\n            var position = cartographics[i];\r\n            west = Math.min(west, position.longitude);\r\n            east = Math.max(east, position.longitude);\r\n            south = Math.min(south, position.latitude);\r\n            north = Math.max(north, position.latitude);\r\n\r\n            var lonAdjusted = position.longitude >= 0 ?  position.longitude : position.longitude +  CesiumMath.TWO_PI;\r\n            westOverIDL = Math.min(westOverIDL, lonAdjusted);\r\n            eastOverIDL = Math.max(eastOverIDL, lonAdjusted);\r\n        }\r\n\r\n        if(east - west > eastOverIDL - westOverIDL) {\r\n            west = westOverIDL;\r\n            east = eastOverIDL;\r\n\r\n            if (east > CesiumMath.PI) {\r\n                east = east - CesiumMath.TWO_PI;\r\n            }\r\n            if (west > CesiumMath.PI) {\r\n                west = west - CesiumMath.TWO_PI;\r\n            }\r\n        }\r\n\r\n        if (!defined(result)) {\r\n            return new Rectangle(west, south, east, north);\r\n        }\r\n\r\n        result.west = west;\r\n        result.south = south;\r\n        result.east = east;\r\n        result.north = north;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Creates the smallest possible Rectangle that encloses all positions in the provided array.\r\n     *\r\n     * @param {Cartesian3[]} cartesians The list of Cartesian instances.\r\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid the cartesians are on.\r\n     * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\r\n     * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\r\n     */\r\n    Rectangle.fromCartesianArray = function(cartesians, ellipsoid, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('cartesians', cartesians);\r\n        //>>includeEnd('debug');\r\n        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n\r\n        var west = Number.MAX_VALUE;\r\n        var east = -Number.MAX_VALUE;\r\n        var westOverIDL = Number.MAX_VALUE;\r\n        var eastOverIDL = -Number.MAX_VALUE;\r\n        var south = Number.MAX_VALUE;\r\n        var north = -Number.MAX_VALUE;\r\n\r\n        for ( var i = 0, len = cartesians.length; i < len; i++) {\r\n            var position = ellipsoid.cartesianToCartographic(cartesians[i]);\r\n            west = Math.min(west, position.longitude);\r\n            east = Math.max(east, position.longitude);\r\n            south = Math.min(south, position.latitude);\r\n            north = Math.max(north, position.latitude);\r\n\r\n            var lonAdjusted = position.longitude >= 0 ?  position.longitude : position.longitude +  CesiumMath.TWO_PI;\r\n            westOverIDL = Math.min(westOverIDL, lonAdjusted);\r\n            eastOverIDL = Math.max(eastOverIDL, lonAdjusted);\r\n        }\r\n\r\n        if(east - west > eastOverIDL - westOverIDL) {\r\n            west = westOverIDL;\r\n            east = eastOverIDL;\r\n\r\n            if (east > CesiumMath.PI) {\r\n                east = east - CesiumMath.TWO_PI;\r\n            }\r\n            if (west > CesiumMath.PI) {\r\n                west = west - CesiumMath.TWO_PI;\r\n            }\r\n        }\r\n\r\n        if (!defined(result)) {\r\n            return new Rectangle(west, south, east, north);\r\n        }\r\n\r\n        result.west = west;\r\n        result.south = south;\r\n        result.east = east;\r\n        result.north = north;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Duplicates a Rectangle.\r\n     *\r\n     * @param {Rectangle} rectangle The rectangle to clone.\r\n     * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\r\n     * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided. (Returns undefined if rectangle is undefined)\r\n     */\r\n    Rectangle.clone = function(rectangle, result) {\r\n        if (!defined(rectangle)) {\r\n            return undefined;\r\n        }\r\n\r\n        if (!defined(result)) {\r\n            return new Rectangle(rectangle.west, rectangle.south, rectangle.east, rectangle.north);\r\n        }\r\n\r\n        result.west = rectangle.west;\r\n        result.south = rectangle.south;\r\n        result.east = rectangle.east;\r\n        result.north = rectangle.north;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Compares the provided Rectangles componentwise and returns\r\n     * <code>true</code> if they pass an absolute or relative tolerance test,\r\n     * <code>false</code> otherwise.\r\n     *\r\n     * @param {Rectangle} [left] The first Rectangle.\r\n     * @param {Rectangle} [right] The second Rectangle.\r\n     * @param {Number} absoluteEpsilon The absolute epsilon tolerance to use for equality testing.\r\n     * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\r\n     */\r\n    Rectangle.equalsEpsilon = function(left, right, absoluteEpsilon) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.number('absoluteEpsilon', absoluteEpsilon);\r\n        //>>includeEnd('debug');\r\n\r\n        return (left === right) ||\r\n               (defined(left) &&\r\n                defined(right) &&\r\n                (Math.abs(left.west - right.west) <= absoluteEpsilon) &&\r\n                (Math.abs(left.south - right.south) <= absoluteEpsilon) &&\r\n                (Math.abs(left.east - right.east) <= absoluteEpsilon) &&\r\n                (Math.abs(left.north - right.north) <= absoluteEpsilon));\r\n    };\r\n\r\n    /**\r\n     * Duplicates this Rectangle.\r\n     *\r\n     * @param {Rectangle} [result] The object onto which to store the result.\r\n     * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\r\n     */\r\n    Rectangle.prototype.clone = function(result) {\r\n        return Rectangle.clone(this, result);\r\n    };\r\n\r\n    /**\r\n     * Compares the provided Rectangle with this Rectangle componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {Rectangle} [other] The Rectangle to compare.\r\n     * @returns {Boolean} <code>true</code> if the Rectangles are equal, <code>false</code> otherwise.\r\n     */\r\n    Rectangle.prototype.equals = function(other) {\r\n        return Rectangle.equals(this, other);\r\n    };\r\n\r\n    /**\r\n     * Compares the provided rectangles and returns <code>true</code> if they are equal,\r\n     * <code>false</code> otherwise.\r\n     *\r\n     * @param {Rectangle} [left] The first Rectangle.\r\n     * @param {Rectangle} [right] The second Rectangle.\r\n     * @returns {Boolean} <code>true</code> if left and right are equal; otherwise <code>false</code>.\r\n     */\r\n    Rectangle.equals = function(left, right) {\r\n        return (left === right) ||\r\n               ((defined(left)) &&\r\n                (defined(right)) &&\r\n                (left.west === right.west) &&\r\n                (left.south === right.south) &&\r\n                (left.east === right.east) &&\r\n                (left.north === right.north));\r\n    };\r\n\r\n    /**\r\n     * Compares the provided Rectangle with this Rectangle componentwise and returns\r\n     * <code>true</code> if they are within the provided epsilon,\r\n     * <code>false</code> otherwise.\r\n     *\r\n     * @param {Rectangle} [other] The Rectangle to compare.\r\n     * @param {Number} epsilon The epsilon to use for equality testing.\r\n     * @returns {Boolean} <code>true</code> if the Rectangles are within the provided epsilon, <code>false</code> otherwise.\r\n     */\r\n    Rectangle.prototype.equalsEpsilon = function(other, epsilon) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.number('epsilon', epsilon);\r\n        //>>includeEnd('debug');\r\n\r\n        return Rectangle.equalsEpsilon(this, other, epsilon);\r\n    };\r\n\r\n    /**\r\n     * Checks a Rectangle's properties and throws if they are not in valid ranges.\r\n     *\r\n     * @param {Rectangle} rectangle The rectangle to validate\r\n     *\r\n     * @exception {DeveloperError} <code>north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\r\n     * @exception {DeveloperError} <code>south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\r\n     * @exception {DeveloperError} <code>east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\r\n     * @exception {DeveloperError} <code>west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\r\n     */\r\n    Rectangle.validate = function(rectangle) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('rectangle', rectangle);\r\n\r\n        var north = rectangle.north;\r\n        Check.typeOf.number.greaterThanOrEquals('north', north, -CesiumMath.PI_OVER_TWO);\r\n        Check.typeOf.number.lessThanOrEquals('north', north, CesiumMath.PI_OVER_TWO);\r\n\r\n        var south = rectangle.south;\r\n        Check.typeOf.number.greaterThanOrEquals('south', south, -CesiumMath.PI_OVER_TWO);\r\n        Check.typeOf.number.lessThanOrEquals('south', south, CesiumMath.PI_OVER_TWO);\r\n\r\n        var west = rectangle.west;\r\n        Check.typeOf.number.greaterThanOrEquals('west', west, -Math.PI);\r\n        Check.typeOf.number.lessThanOrEquals('west', west, Math.PI);\r\n\r\n        var east = rectangle.east;\r\n        Check.typeOf.number.greaterThanOrEquals('east', east, -Math.PI);\r\n        Check.typeOf.number.lessThanOrEquals('east', east, Math.PI);\r\n        //>>includeEnd('debug');\r\n    };\r\n\r\n    /**\r\n     * Computes the southwest corner of a rectangle.\r\n     *\r\n     * @param {Rectangle} rectangle The rectangle for which to find the corner\r\n     * @param {Cartographic} [result] The object onto which to store the result.\r\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\r\n     */\r\n    Rectangle.southwest = function(rectangle, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('rectangle', rectangle);\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            return new Cartographic(rectangle.west, rectangle.south);\r\n        }\r\n        result.longitude = rectangle.west;\r\n        result.latitude = rectangle.south;\r\n        result.height = 0.0;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the northwest corner of a rectangle.\r\n     *\r\n     * @param {Rectangle} rectangle The rectangle for which to find the corner\r\n     * @param {Cartographic} [result] The object onto which to store the result.\r\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\r\n     */\r\n    Rectangle.northwest = function(rectangle, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('rectangle', rectangle);\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            return new Cartographic(rectangle.west, rectangle.north);\r\n        }\r\n        result.longitude = rectangle.west;\r\n        result.latitude = rectangle.north;\r\n        result.height = 0.0;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the northeast corner of a rectangle.\r\n     *\r\n     * @param {Rectangle} rectangle The rectangle for which to find the corner\r\n     * @param {Cartographic} [result] The object onto which to store the result.\r\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\r\n     */\r\n    Rectangle.northeast = function(rectangle, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('rectangle', rectangle);\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            return new Cartographic(rectangle.east, rectangle.north);\r\n        }\r\n        result.longitude = rectangle.east;\r\n        result.latitude = rectangle.north;\r\n        result.height = 0.0;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the southeast corner of a rectangle.\r\n     *\r\n     * @param {Rectangle} rectangle The rectangle for which to find the corner\r\n     * @param {Cartographic} [result] The object onto which to store the result.\r\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\r\n     */\r\n    Rectangle.southeast = function(rectangle, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('rectangle', rectangle);\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            return new Cartographic(rectangle.east, rectangle.south);\r\n        }\r\n        result.longitude = rectangle.east;\r\n        result.latitude = rectangle.south;\r\n        result.height = 0.0;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the center of a rectangle.\r\n     *\r\n     * @param {Rectangle} rectangle The rectangle for which to find the center\r\n     * @param {Cartographic} [result] The object onto which to store the result.\r\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\r\n     */\r\n    Rectangle.center = function(rectangle, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('rectangle', rectangle);\r\n        //>>includeEnd('debug');\r\n\r\n        var east = rectangle.east;\r\n        var west = rectangle.west;\r\n\r\n        if (east < west) {\r\n            east += CesiumMath.TWO_PI;\r\n        }\r\n\r\n        var longitude = CesiumMath.negativePiToPi((west + east) * 0.5);\r\n        var latitude = (rectangle.south + rectangle.north) * 0.5;\r\n\r\n        if (!defined(result)) {\r\n            return new Cartographic(longitude, latitude);\r\n        }\r\n\r\n        result.longitude = longitude;\r\n        result.latitude = latitude;\r\n        result.height = 0.0;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the intersection of two rectangles.  This function assumes that the rectangle's coordinates are\r\n     * latitude and longitude in radians and produces a correct intersection, taking into account the fact that\r\n     * the same angle can be represented with multiple values as well as the wrapping of longitude at the\r\n     * anti-meridian.  For a simple intersection that ignores these factors and can be used with projected\r\n     * coordinates, see {@link Rectangle.simpleIntersection}.\r\n     *\r\n     * @param {Rectangle} rectangle On rectangle to find an intersection\r\n     * @param {Rectangle} otherRectangle Another rectangle to find an intersection\r\n     * @param {Rectangle} [result] The object onto which to store the result.\r\n     * @returns {Rectangle|undefined} The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.\r\n     */\r\n    Rectangle.intersection = function(rectangle, otherRectangle, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('rectangle', rectangle);\r\n        Check.typeOf.object('otherRectangle', otherRectangle);\r\n        //>>includeEnd('debug');\r\n\r\n        var rectangleEast = rectangle.east;\r\n        var rectangleWest = rectangle.west;\r\n\r\n        var otherRectangleEast = otherRectangle.east;\r\n        var otherRectangleWest = otherRectangle.west;\r\n\r\n        if (rectangleEast < rectangleWest && otherRectangleEast > 0.0) {\r\n            rectangleEast += CesiumMath.TWO_PI;\r\n        } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0.0) {\r\n            otherRectangleEast += CesiumMath.TWO_PI;\r\n        }\r\n\r\n        if (rectangleEast < rectangleWest && otherRectangleWest < 0.0) {\r\n            otherRectangleWest += CesiumMath.TWO_PI;\r\n        } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0.0) {\r\n            rectangleWest += CesiumMath.TWO_PI;\r\n        }\r\n\r\n        var west = CesiumMath.negativePiToPi(Math.max(rectangleWest, otherRectangleWest));\r\n        var east = CesiumMath.negativePiToPi(Math.min(rectangleEast, otherRectangleEast));\r\n\r\n        if ((rectangle.west < rectangle.east || otherRectangle.west < otherRectangle.east) && east <= west) {\r\n            return undefined;\r\n        }\r\n\r\n        var south = Math.max(rectangle.south, otherRectangle.south);\r\n        var north = Math.min(rectangle.north, otherRectangle.north);\r\n\r\n        if (south >= north) {\r\n            return undefined;\r\n        }\r\n\r\n        if (!defined(result)) {\r\n            return new Rectangle(west, south, east, north);\r\n        }\r\n        result.west = west;\r\n        result.south = south;\r\n        result.east = east;\r\n        result.north = north;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes a simple intersection of two rectangles.  Unlike {@link Rectangle.intersection}, this function\r\n     * does not attempt to put the angular coordinates into a consistent range or to account for crossing the\r\n     * anti-meridian.  As such, it can be used for rectangles where the coordinates are not simply latitude\r\n     * and longitude (i.e. projected coordinates).\r\n     *\r\n     * @param {Rectangle} rectangle On rectangle to find an intersection\r\n     * @param {Rectangle} otherRectangle Another rectangle to find an intersection\r\n     * @param {Rectangle} [result] The object onto which to store the result.\r\n     * @returns {Rectangle|undefined} The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.\r\n     */\r\n    Rectangle.simpleIntersection = function(rectangle, otherRectangle, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('rectangle', rectangle);\r\n        Check.typeOf.object('otherRectangle', otherRectangle);\r\n        //>>includeEnd('debug');\r\n\r\n        var west = Math.max(rectangle.west, otherRectangle.west);\r\n        var south = Math.max(rectangle.south, otherRectangle.south);\r\n        var east = Math.min(rectangle.east, otherRectangle.east);\r\n        var north = Math.min(rectangle.north, otherRectangle.north);\r\n\r\n        if (south >= north || west >= east) {\r\n            return undefined;\r\n        }\r\n\r\n        if (!defined(result)) {\r\n            return new Rectangle(west, south, east, north);\r\n        }\r\n\r\n        result.west = west;\r\n        result.south = south;\r\n        result.east = east;\r\n        result.north = north;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes a rectangle that is the union of two rectangles.\r\n     *\r\n     * @param {Rectangle} rectangle A rectangle to enclose in rectangle.\r\n     * @param {Rectangle} otherRectangle A rectangle to enclose in a rectangle.\r\n     * @param {Rectangle} [result] The object onto which to store the result.\r\n     * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\r\n     */\r\n    Rectangle.union = function(rectangle, otherRectangle, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('rectangle', rectangle);\r\n        Check.typeOf.object('otherRectangle', otherRectangle);\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            result = new Rectangle();\r\n        }\r\n\r\n        var rectangleEast = rectangle.east;\r\n        var rectangleWest = rectangle.west;\r\n\r\n        var otherRectangleEast = otherRectangle.east;\r\n        var otherRectangleWest = otherRectangle.west;\r\n\r\n        if (rectangleEast < rectangleWest && otherRectangleEast > 0.0) {\r\n            rectangleEast += CesiumMath.TWO_PI;\r\n        } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0.0) {\r\n            otherRectangleEast += CesiumMath.TWO_PI;\r\n        }\r\n\r\n        if (rectangleEast < rectangleWest && otherRectangleWest < 0.0) {\r\n            otherRectangleWest += CesiumMath.TWO_PI;\r\n        } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0.0) {\r\n            rectangleWest += CesiumMath.TWO_PI;\r\n        }\r\n\r\n        var west = CesiumMath.convertLongitudeRange(Math.min(rectangleWest, otherRectangleWest));\r\n        var east = CesiumMath.convertLongitudeRange(Math.max(rectangleEast, otherRectangleEast));\r\n\r\n        result.west = west;\r\n        result.south = Math.min(rectangle.south, otherRectangle.south);\r\n        result.east = east;\r\n        result.north = Math.max(rectangle.north, otherRectangle.north);\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes a rectangle by enlarging the provided rectangle until it contains the provided cartographic.\r\n     *\r\n     * @param {Rectangle} rectangle A rectangle to expand.\r\n     * @param {Cartographic} cartographic A cartographic to enclose in a rectangle.\r\n     * @param {Rectangle} [result] The object onto which to store the result.\r\n     * @returns {Rectangle} The modified result parameter or a new Rectangle instance if one was not provided.\r\n     */\r\n    Rectangle.expand = function(rectangle, cartographic, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('rectangle', rectangle);\r\n        Check.typeOf.object('cartographic', cartographic);\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            result = new Rectangle();\r\n        }\r\n\r\n        result.west = Math.min(rectangle.west, cartographic.longitude);\r\n        result.south = Math.min(rectangle.south, cartographic.latitude);\r\n        result.east = Math.max(rectangle.east, cartographic.longitude);\r\n        result.north = Math.max(rectangle.north, cartographic.latitude);\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Returns true if the cartographic is on or inside the rectangle, false otherwise.\r\n     *\r\n     * @param {Rectangle} rectangle The rectangle\r\n     * @param {Cartographic} cartographic The cartographic to test.\r\n     * @returns {Boolean} true if the provided cartographic is inside the rectangle, false otherwise.\r\n     */\r\n    Rectangle.contains = function(rectangle, cartographic) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('rectangle', rectangle);\r\n        Check.typeOf.object('cartographic', cartographic);\r\n        //>>includeEnd('debug');\r\n\r\n        var longitude = cartographic.longitude;\r\n        var latitude = cartographic.latitude;\r\n\r\n        var west = rectangle.west;\r\n        var east = rectangle.east;\r\n\r\n        if (east < west) {\r\n            east += CesiumMath.TWO_PI;\r\n            if (longitude < 0.0) {\r\n                longitude += CesiumMath.TWO_PI;\r\n            }\r\n        }\r\n        return (longitude > west || CesiumMath.equalsEpsilon(longitude, west, CesiumMath.EPSILON14)) &&\r\n               (longitude < east || CesiumMath.equalsEpsilon(longitude, east, CesiumMath.EPSILON14)) &&\r\n               latitude >= rectangle.south &&\r\n               latitude <= rectangle.north;\r\n    };\r\n\r\n    var subsampleLlaScratch = new Cartographic();\r\n    /**\r\n     * Samples a rectangle so that it includes a list of Cartesian points suitable for passing to\r\n     * {@link BoundingSphere#fromPoints}.  Sampling is necessary to account\r\n     * for rectangles that cover the poles or cross the equator.\r\n     *\r\n     * @param {Rectangle} rectangle The rectangle to subsample.\r\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.\r\n     * @param {Number} [surfaceHeight=0.0] The height of the rectangle above the ellipsoid.\r\n     * @param {Cartesian3[]} [result] The array of Cartesians onto which to store the result.\r\n     * @returns {Cartesian3[]} The modified result parameter or a new Array of Cartesians instances if none was provided.\r\n     */\r\n    Rectangle.subsample = function(rectangle, ellipsoid, surfaceHeight, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('rectangle', rectangle);\r\n        //>>includeEnd('debug');\r\n\r\n        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n        surfaceHeight = defaultValue(surfaceHeight, 0.0);\r\n\r\n        if (!defined(result)) {\r\n            result = [];\r\n        }\r\n        var length = 0;\r\n\r\n        var north = rectangle.north;\r\n        var south = rectangle.south;\r\n        var east = rectangle.east;\r\n        var west = rectangle.west;\r\n\r\n        var lla = subsampleLlaScratch;\r\n        lla.height = surfaceHeight;\r\n\r\n        lla.longitude = west;\r\n        lla.latitude = north;\r\n        result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\r\n        length++;\r\n\r\n        lla.longitude = east;\r\n        result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\r\n        length++;\r\n\r\n        lla.latitude = south;\r\n        result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\r\n        length++;\r\n\r\n        lla.longitude = west;\r\n        result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\r\n        length++;\r\n\r\n        if (north < 0.0) {\r\n            lla.latitude = north;\r\n        } else if (south > 0.0) {\r\n            lla.latitude = south;\r\n        } else {\r\n            lla.latitude = 0.0;\r\n        }\r\n\r\n        for ( var i = 1; i < 8; ++i) {\r\n            lla.longitude = -Math.PI + i * CesiumMath.PI_OVER_TWO;\r\n            if (Rectangle.contains(rectangle, lla)) {\r\n                result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\r\n                length++;\r\n            }\r\n        }\r\n\r\n        if (lla.latitude === 0.0) {\r\n            lla.longitude = west;\r\n            result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\r\n            length++;\r\n            lla.longitude = east;\r\n            result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\r\n            length++;\r\n        }\r\n        result.length = length;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * The largest possible rectangle.\r\n     *\r\n     * @type {Rectangle}\r\n     * @constant\r\n    */\r\n    Rectangle.MAX_VALUE = Object.freeze(new Rectangle(-Math.PI, -CesiumMath.PI_OVER_TWO, Math.PI, CesiumMath.PI_OVER_TWO));\r\nexport default Rectangle;\r\n","import Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport CesiumMath from './Math.js';\r\n\r\n    /**\r\n     * A 2D Cartesian point.\r\n     * @alias Cartesian2\r\n     * @constructor\r\n     *\r\n     * @param {Number} [x=0.0] The X component.\r\n     * @param {Number} [y=0.0] The Y component.\r\n     *\r\n     * @see Cartesian3\r\n     * @see Cartesian4\r\n     * @see Packable\r\n     */\r\n    function Cartesian2(x, y) {\r\n        /**\r\n         * The X component.\r\n         * @type {Number}\r\n         * @default 0.0\r\n         */\r\n        this.x = defaultValue(x, 0.0);\r\n\r\n        /**\r\n         * The Y component.\r\n         * @type {Number}\r\n         * @default 0.0\r\n         */\r\n        this.y = defaultValue(y, 0.0);\r\n    }\r\n\r\n    /**\r\n     * Creates a Cartesian2 instance from x and y coordinates.\r\n     *\r\n     * @param {Number} x The x coordinate.\r\n     * @param {Number} y The y coordinate.\r\n     * @param {Cartesian2} [result] The object onto which to store the result.\r\n     * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\r\n     */\r\n    Cartesian2.fromElements = function(x, y, result) {\r\n        if (!defined(result)) {\r\n            return new Cartesian2(x, y);\r\n        }\r\n\r\n        result.x = x;\r\n        result.y = y;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Duplicates a Cartesian2 instance.\r\n     *\r\n     * @param {Cartesian2} cartesian The Cartesian to duplicate.\r\n     * @param {Cartesian2} [result] The object onto which to store the result.\r\n     * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided. (Returns undefined if cartesian is undefined)\r\n     */\r\n    Cartesian2.clone = function(cartesian, result) {\r\n        if (!defined(cartesian)) {\r\n            return undefined;\r\n        }\r\n        if (!defined(result)) {\r\n            return new Cartesian2(cartesian.x, cartesian.y);\r\n        }\r\n\r\n        result.x = cartesian.x;\r\n        result.y = cartesian.y;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Creates a Cartesian2 instance from an existing Cartesian3.  This simply takes the\r\n     * x and y properties of the Cartesian3 and drops z.\r\n     * @function\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian3 instance to create a Cartesian2 instance from.\r\n     * @param {Cartesian2} [result] The object onto which to store the result.\r\n     * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\r\n     */\r\n    Cartesian2.fromCartesian3 = Cartesian2.clone;\r\n\r\n    /**\r\n     * Creates a Cartesian2 instance from an existing Cartesian4.  This simply takes the\r\n     * x and y properties of the Cartesian4 and drops z and w.\r\n     * @function\r\n     *\r\n     * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian2 instance from.\r\n     * @param {Cartesian2} [result] The object onto which to store the result.\r\n     * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\r\n     */\r\n    Cartesian2.fromCartesian4 = Cartesian2.clone;\r\n\r\n    /**\r\n     * The number of elements used to pack the object into an array.\r\n     * @type {Number}\r\n     */\r\n    Cartesian2.packedLength = 2;\r\n\r\n    /**\r\n     * Stores the provided instance into the provided array.\r\n     *\r\n     * @param {Cartesian2} value The value to pack.\r\n     * @param {Number[]} array The array to pack into.\r\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n     *\r\n     * @returns {Number[]} The array that was packed into\r\n     */\r\n    Cartesian2.pack = function(value, array, startingIndex) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('value', value);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        array[startingIndex++] = value.x;\r\n        array[startingIndex] = value.y;\r\n\r\n        return array;\r\n    };\r\n\r\n    /**\r\n     * Retrieves an instance from a packed array.\r\n     *\r\n     * @param {Number[]} array The packed array.\r\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n     * @param {Cartesian2} [result] The object into which to store the result.\r\n     * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\r\n     */\r\n    Cartesian2.unpack = function(array, startingIndex, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        if (!defined(result)) {\r\n            result = new Cartesian2();\r\n        }\r\n        result.x = array[startingIndex++];\r\n        result.y = array[startingIndex];\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Flattens an array of Cartesian2s into and array of components.\r\n     *\r\n     * @param {Cartesian2[]} array The array of cartesians to pack.\r\n     * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 2 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 2) elements.\r\n\r\n     * @returns {Number[]} The packed array.\r\n     */\r\n    Cartesian2.packArray = function(array, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        var length = array.length;\r\n        var resultLength = length * 2;\r\n        if (!defined(result)) {\r\n            result = new Array(resultLength);\r\n        } else if (!Array.isArray(result) && result.length !== resultLength) {\r\n            throw new DeveloperError('If result is a typed array, it must have exactly array.length * 2 elements');\r\n        } else if (result.length !== resultLength) {\r\n            result.length = resultLength;\r\n        }\r\n\r\n        for (var i = 0; i < length; ++i) {\r\n            Cartesian2.pack(array[i], result, i * 2);\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Unpacks an array of cartesian components into and array of Cartesian2s.\r\n     *\r\n     * @param {Number[]} array The array of components to unpack.\r\n     * @param {Cartesian2[]} [result] The array onto which to store the result.\r\n     * @returns {Cartesian2[]} The unpacked array.\r\n     */\r\n    Cartesian2.unpackArray = function(array, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('array', array);\r\n        Check.typeOf.number.greaterThanOrEquals('array.length', array.length, 2);\r\n        if (array.length % 2 !== 0) {\r\n            throw new DeveloperError('array length must be a multiple of 2.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var length = array.length;\r\n        if (!defined(result)) {\r\n            result = new Array(length / 2);\r\n        } else {\r\n            result.length = length / 2;\r\n        }\r\n\r\n        for (var i = 0; i < length; i += 2) {\r\n            var index = i / 2;\r\n            result[index] = Cartesian2.unpack(array, i, result[index]);\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Creates a Cartesian2 from two consecutive elements in an array.\r\n     * @function\r\n     *\r\n     * @param {Number[]} array The array whose two consecutive elements correspond to the x and y components, respectively.\r\n     * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\r\n     * @param {Cartesian2} [result] The object onto which to store the result.\r\n     * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\r\n     *\r\n     * @example\r\n     * // Create a Cartesian2 with (1.0, 2.0)\r\n     * var v = [1.0, 2.0];\r\n     * var p = Cesium.Cartesian2.fromArray(v);\r\n     *\r\n     * // Create a Cartesian2 with (1.0, 2.0) using an offset into an array\r\n     * var v2 = [0.0, 0.0, 1.0, 2.0];\r\n     * var p2 = Cesium.Cartesian2.fromArray(v2, 2);\r\n     */\r\n    Cartesian2.fromArray = Cartesian2.unpack;\r\n\r\n    /**\r\n     * Computes the value of the maximum component for the supplied Cartesian.\r\n     *\r\n     * @param {Cartesian2} cartesian The cartesian to use.\r\n     * @returns {Number} The value of the maximum component.\r\n     */\r\n    Cartesian2.maximumComponent = function(cartesian) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('cartesian', cartesian);\r\n        //>>includeEnd('debug');\r\n\r\n        return Math.max(cartesian.x, cartesian.y);\r\n    };\r\n\r\n    /**\r\n     * Computes the value of the minimum component for the supplied Cartesian.\r\n     *\r\n     * @param {Cartesian2} cartesian The cartesian to use.\r\n     * @returns {Number} The value of the minimum component.\r\n     */\r\n    Cartesian2.minimumComponent = function(cartesian) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('cartesian', cartesian);\r\n        //>>includeEnd('debug');\r\n\r\n        return Math.min(cartesian.x, cartesian.y);\r\n    };\r\n\r\n    /**\r\n     * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\r\n     *\r\n     * @param {Cartesian2} first A cartesian to compare.\r\n     * @param {Cartesian2} second A cartesian to compare.\r\n     * @param {Cartesian2} result The object into which to store the result.\r\n     * @returns {Cartesian2} A cartesian with the minimum components.\r\n     */\r\n    Cartesian2.minimumByComponent = function(first, second, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('first', first);\r\n        Check.typeOf.object('second', second);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        result.x = Math.min(first.x, second.x);\r\n        result.y = Math.min(first.y, second.y);\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\r\n     *\r\n     * @param {Cartesian2} first A cartesian to compare.\r\n     * @param {Cartesian2} second A cartesian to compare.\r\n     * @param {Cartesian2} result The object into which to store the result.\r\n     * @returns {Cartesian2} A cartesian with the maximum components.\r\n     */\r\n    Cartesian2.maximumByComponent = function(first, second, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('first', first);\r\n        Check.typeOf.object('second', second);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        result.x = Math.max(first.x, second.x);\r\n        result.y = Math.max(first.y, second.y);\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the provided Cartesian's squared magnitude.\r\n     *\r\n     * @param {Cartesian2} cartesian The Cartesian instance whose squared magnitude is to be computed.\r\n     * @returns {Number} The squared magnitude.\r\n     */\r\n    Cartesian2.magnitudeSquared = function(cartesian) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('cartesian', cartesian);\r\n        //>>includeEnd('debug');\r\n\r\n        return cartesian.x * cartesian.x + cartesian.y * cartesian.y;\r\n    };\r\n\r\n    /**\r\n     * Computes the Cartesian's magnitude (length).\r\n     *\r\n     * @param {Cartesian2} cartesian The Cartesian instance whose magnitude is to be computed.\r\n     * @returns {Number} The magnitude.\r\n     */\r\n    Cartesian2.magnitude = function(cartesian) {\r\n        return Math.sqrt(Cartesian2.magnitudeSquared(cartesian));\r\n    };\r\n\r\n    var distanceScratch = new Cartesian2();\r\n\r\n    /**\r\n     * Computes the distance between two points.\r\n     *\r\n     * @param {Cartesian2} left The first point to compute the distance from.\r\n     * @param {Cartesian2} right The second point to compute the distance to.\r\n     * @returns {Number} The distance between two points.\r\n     *\r\n     * @example\r\n     * // Returns 1.0\r\n     * var d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(2.0, 0.0));\r\n     */\r\n    Cartesian2.distance = function(left, right) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('left', left);\r\n        Check.typeOf.object('right', right);\r\n        //>>includeEnd('debug');\r\n\r\n        Cartesian2.subtract(left, right, distanceScratch);\r\n        return Cartesian2.magnitude(distanceScratch);\r\n    };\r\n\r\n    /**\r\n     * Computes the squared distance between two points.  Comparing squared distances\r\n     * using this function is more efficient than comparing distances using {@link Cartesian2#distance}.\r\n     *\r\n     * @param {Cartesian2} left The first point to compute the distance from.\r\n     * @param {Cartesian2} right The second point to compute the distance to.\r\n     * @returns {Number} The distance between two points.\r\n     *\r\n     * @example\r\n     * // Returns 4.0, not 2.0\r\n     * var d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(3.0, 0.0));\r\n     */\r\n    Cartesian2.distanceSquared = function(left, right) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('left', left);\r\n        Check.typeOf.object('right', right);\r\n        //>>includeEnd('debug');\r\n\r\n        Cartesian2.subtract(left, right, distanceScratch);\r\n        return Cartesian2.magnitudeSquared(distanceScratch);\r\n    };\r\n\r\n    /**\r\n     * Computes the normalized form of the supplied Cartesian.\r\n     *\r\n     * @param {Cartesian2} cartesian The Cartesian to be normalized.\r\n     * @param {Cartesian2} result The object onto which to store the result.\r\n     * @returns {Cartesian2} The modified result parameter.\r\n     */\r\n    Cartesian2.normalize = function(cartesian, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('cartesian', cartesian);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        var magnitude = Cartesian2.magnitude(cartesian);\r\n\r\n        result.x = cartesian.x / magnitude;\r\n        result.y = cartesian.y / magnitude;\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (isNaN(result.x) || isNaN(result.y)) {\r\n            throw new DeveloperError('normalized result is not a number');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the dot (scalar) product of two Cartesians.\r\n     *\r\n     * @param {Cartesian2} left The first Cartesian.\r\n     * @param {Cartesian2} right The second Cartesian.\r\n     * @returns {Number} The dot product.\r\n     */\r\n    Cartesian2.dot = function(left, right) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('left', left);\r\n        Check.typeOf.object('right', right);\r\n        //>>includeEnd('debug');\r\n\r\n        return left.x * right.x + left.y * right.y;\r\n    };\r\n\r\n    /**\r\n     * Computes the componentwise product of two Cartesians.\r\n     *\r\n     * @param {Cartesian2} left The first Cartesian.\r\n     * @param {Cartesian2} right The second Cartesian.\r\n     * @param {Cartesian2} result The object onto which to store the result.\r\n     * @returns {Cartesian2} The modified result parameter.\r\n     */\r\n    Cartesian2.multiplyComponents = function(left, right, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('left', left);\r\n        Check.typeOf.object('right', right);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        result.x = left.x * right.x;\r\n        result.y = left.y * right.y;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the componentwise quotient of two Cartesians.\r\n     *\r\n     * @param {Cartesian2} left The first Cartesian.\r\n     * @param {Cartesian2} right The second Cartesian.\r\n     * @param {Cartesian2} result The object onto which to store the result.\r\n     * @returns {Cartesian2} The modified result parameter.\r\n     */\r\n    Cartesian2.divideComponents = function(left, right, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('left', left);\r\n        Check.typeOf.object('right', right);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        result.x = left.x / right.x;\r\n        result.y = left.y / right.y;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the componentwise sum of two Cartesians.\r\n     *\r\n     * @param {Cartesian2} left The first Cartesian.\r\n     * @param {Cartesian2} right The second Cartesian.\r\n     * @param {Cartesian2} result The object onto which to store the result.\r\n     * @returns {Cartesian2} The modified result parameter.\r\n     */\r\n    Cartesian2.add = function(left, right, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('left', left);\r\n        Check.typeOf.object('right', right);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        result.x = left.x + right.x;\r\n        result.y = left.y + right.y;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the componentwise difference of two Cartesians.\r\n     *\r\n     * @param {Cartesian2} left The first Cartesian.\r\n     * @param {Cartesian2} right The second Cartesian.\r\n     * @param {Cartesian2} result The object onto which to store the result.\r\n     * @returns {Cartesian2} The modified result parameter.\r\n     */\r\n    Cartesian2.subtract = function(left, right, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('left', left);\r\n        Check.typeOf.object('right', right);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        result.x = left.x - right.x;\r\n        result.y = left.y - right.y;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Multiplies the provided Cartesian componentwise by the provided scalar.\r\n     *\r\n     * @param {Cartesian2} cartesian The Cartesian to be scaled.\r\n     * @param {Number} scalar The scalar to multiply with.\r\n     * @param {Cartesian2} result The object onto which to store the result.\r\n     * @returns {Cartesian2} The modified result parameter.\r\n     */\r\n    Cartesian2.multiplyByScalar = function(cartesian, scalar, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('cartesian', cartesian);\r\n        Check.typeOf.number('scalar', scalar);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        result.x = cartesian.x * scalar;\r\n        result.y = cartesian.y * scalar;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Divides the provided Cartesian componentwise by the provided scalar.\r\n     *\r\n     * @param {Cartesian2} cartesian The Cartesian to be divided.\r\n     * @param {Number} scalar The scalar to divide by.\r\n     * @param {Cartesian2} result The object onto which to store the result.\r\n     * @returns {Cartesian2} The modified result parameter.\r\n     */\r\n    Cartesian2.divideByScalar = function(cartesian, scalar, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('cartesian', cartesian);\r\n        Check.typeOf.number('scalar', scalar);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        result.x = cartesian.x / scalar;\r\n        result.y = cartesian.y / scalar;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Negates the provided Cartesian.\r\n     *\r\n     * @param {Cartesian2} cartesian The Cartesian to be negated.\r\n     * @param {Cartesian2} result The object onto which to store the result.\r\n     * @returns {Cartesian2} The modified result parameter.\r\n     */\r\n    Cartesian2.negate = function(cartesian, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('cartesian', cartesian);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        result.x = -cartesian.x;\r\n        result.y = -cartesian.y;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the absolute value of the provided Cartesian.\r\n     *\r\n     * @param {Cartesian2} cartesian The Cartesian whose absolute value is to be computed.\r\n     * @param {Cartesian2} result The object onto which to store the result.\r\n     * @returns {Cartesian2} The modified result parameter.\r\n     */\r\n    Cartesian2.abs = function(cartesian, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('cartesian', cartesian);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        result.x = Math.abs(cartesian.x);\r\n        result.y = Math.abs(cartesian.y);\r\n        return result;\r\n    };\r\n\r\n    var lerpScratch = new Cartesian2();\r\n    /**\r\n     * Computes the linear interpolation or extrapolation at t using the provided cartesians.\r\n     *\r\n     * @param {Cartesian2} start The value corresponding to t at 0.0.\r\n     * @param {Cartesian2} end The value corresponding to t at 1.0.\r\n     * @param {Number} t The point along t at which to interpolate.\r\n     * @param {Cartesian2} result The object onto which to store the result.\r\n     * @returns {Cartesian2} The modified result parameter.\r\n     */\r\n    Cartesian2.lerp = function(start, end, t, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('start', start);\r\n        Check.typeOf.object('end', end);\r\n        Check.typeOf.number('t', t);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        Cartesian2.multiplyByScalar(end, t, lerpScratch);\r\n        result = Cartesian2.multiplyByScalar(start, 1.0 - t, result);\r\n        return Cartesian2.add(lerpScratch, result, result);\r\n    };\r\n\r\n    var angleBetweenScratch = new Cartesian2();\r\n    var angleBetweenScratch2 = new Cartesian2();\r\n    /**\r\n     * Returns the angle, in radians, between the provided Cartesians.\r\n     *\r\n     * @param {Cartesian2} left The first Cartesian.\r\n     * @param {Cartesian2} right The second Cartesian.\r\n     * @returns {Number} The angle between the Cartesians.\r\n     */\r\n    Cartesian2.angleBetween = function(left, right) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('left', left);\r\n        Check.typeOf.object('right', right);\r\n        //>>includeEnd('debug');\r\n\r\n        Cartesian2.normalize(left, angleBetweenScratch);\r\n        Cartesian2.normalize(right, angleBetweenScratch2);\r\n        return CesiumMath.acosClamped(Cartesian2.dot(angleBetweenScratch, angleBetweenScratch2));\r\n    };\r\n\r\n    var mostOrthogonalAxisScratch = new Cartesian2();\r\n    /**\r\n     * Returns the axis that is most orthogonal to the provided Cartesian.\r\n     *\r\n     * @param {Cartesian2} cartesian The Cartesian on which to find the most orthogonal axis.\r\n     * @param {Cartesian2} result The object onto which to store the result.\r\n     * @returns {Cartesian2} The most orthogonal axis.\r\n     */\r\n    Cartesian2.mostOrthogonalAxis = function(cartesian, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('cartesian', cartesian);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        var f = Cartesian2.normalize(cartesian, mostOrthogonalAxisScratch);\r\n        Cartesian2.abs(f, f);\r\n\r\n        if (f.x <= f.y) {\r\n            result = Cartesian2.clone(Cartesian2.UNIT_X, result);\r\n        } else {\r\n            result = Cartesian2.clone(Cartesian2.UNIT_Y, result);\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Compares the provided Cartesians componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {Cartesian2} [left] The first Cartesian.\r\n     * @param {Cartesian2} [right] The second Cartesian.\r\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n     */\r\n    Cartesian2.equals = function(left, right) {\r\n        return (left === right) ||\r\n               ((defined(left)) &&\r\n                (defined(right)) &&\r\n                (left.x === right.x) &&\r\n                (left.y === right.y));\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    Cartesian2.equalsArray = function(cartesian, array, offset) {\r\n        return cartesian.x === array[offset] &&\r\n               cartesian.y === array[offset + 1];\r\n    };\r\n\r\n    /**\r\n     * Compares the provided Cartesians componentwise and returns\r\n     * <code>true</code> if they pass an absolute or relative tolerance test,\r\n     * <code>false</code> otherwise.\r\n     *\r\n     * @param {Cartesian2} [left] The first Cartesian.\r\n     * @param {Cartesian2} [right] The second Cartesian.\r\n     * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\r\n     * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\r\n     * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\r\n     */\r\n    Cartesian2.equalsEpsilon = function(left, right, relativeEpsilon, absoluteEpsilon) {\r\n        return (left === right) ||\r\n               (defined(left) &&\r\n                defined(right) &&\r\n                CesiumMath.equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) &&\r\n                CesiumMath.equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon));\r\n    };\r\n\r\n    /**\r\n     * An immutable Cartesian2 instance initialized to (0.0, 0.0).\r\n     *\r\n     * @type {Cartesian2}\r\n     * @constant\r\n     */\r\n    Cartesian2.ZERO = Object.freeze(new Cartesian2(0.0, 0.0));\r\n\r\n    /**\r\n     * An immutable Cartesian2 instance initialized to (1.0, 0.0).\r\n     *\r\n     * @type {Cartesian2}\r\n     * @constant\r\n     */\r\n    Cartesian2.UNIT_X = Object.freeze(new Cartesian2(1.0, 0.0));\r\n\r\n    /**\r\n     * An immutable Cartesian2 instance initialized to (0.0, 1.0).\r\n     *\r\n     * @type {Cartesian2}\r\n     * @constant\r\n     */\r\n    Cartesian2.UNIT_Y = Object.freeze(new Cartesian2(0.0, 1.0));\r\n\r\n    /**\r\n     * Duplicates this Cartesian2 instance.\r\n     *\r\n     * @param {Cartesian2} [result] The object onto which to store the result.\r\n     * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\r\n     */\r\n    Cartesian2.prototype.clone = function(result) {\r\n        return Cartesian2.clone(this, result);\r\n    };\r\n\r\n    /**\r\n     * Compares this Cartesian against the provided Cartesian componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {Cartesian2} [right] The right hand side Cartesian.\r\n     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     */\r\n    Cartesian2.prototype.equals = function(right) {\r\n        return Cartesian2.equals(this, right);\r\n    };\r\n\r\n    /**\r\n     * Compares this Cartesian against the provided Cartesian componentwise and returns\r\n     * <code>true</code> if they pass an absolute or relative tolerance test,\r\n     * <code>false</code> otherwise.\r\n     *\r\n     * @param {Cartesian2} [right] The right hand side Cartesian.\r\n     * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\r\n     * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\r\n     * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\r\n     */\r\n    Cartesian2.prototype.equalsEpsilon = function(right, relativeEpsilon, absoluteEpsilon) {\r\n        return Cartesian2.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);\r\n    };\r\n\r\n    /**\r\n     * Creates a string representing this Cartesian in the format '(x, y)'.\r\n     *\r\n     * @returns {String} A string representing the provided Cartesian in the format '(x, y)'.\r\n     */\r\n    Cartesian2.prototype.toString = function() {\r\n        return '(' + this.x + ', ' + this.y + ')';\r\n    };\r\nexport default Cartesian2;\r\n"],"names":["Rectangle","west","south","east","north","this","defaultValue","Object","defineProperties","prototype","width","get","computeWidth","height","computeHeight","packedLength","pack","value","array","startingIndex","Check","typeOf","object","defined","unpack","result","rectangle","CesiumMath","TWO_PI","fromDegrees","toRadians","fromRadians","fromCartographicArray","cartographics","Number","MAX_VALUE","westOverIDL","eastOverIDL","i","len","length","position","Math","min","longitude","max","latitude","lonAdjusted","PI","fromCartesianArray","cartesians","ellipsoid","Ellipsoid","WGS84","cartesianToCartographic","clone","equalsEpsilon","left","right","absoluteEpsilon","number","abs","equals","other","epsilon","validate","greaterThanOrEquals","PI_OVER_TWO","lessThanOrEquals","southwest","Cartographic","northwest","northeast","southeast","center","negativePiToPi","intersection","otherRectangle","rectangleEast","rectangleWest","otherRectangleEast","otherRectangleWest","simpleIntersection","union","convertLongitudeRange","expand","cartographic","contains","EPSILON14","subsampleLlaScratch","Cartesian2","x","y","subsample","surfaceHeight","lla","cartographicToCartesian","freeze","fromElements","cartesian","fromCartesian3","fromCartesian4","packArray","resultLength","Array","isArray","DeveloperError","unpackArray","index","fromArray","maximumComponent","minimumComponent","minimumByComponent","first","second","maximumByComponent","magnitudeSquared","magnitude","sqrt","distanceScratch","distance","subtract","distanceSquared","normalize","isNaN","dot","multiplyComponents","divideComponents","add","multiplyByScalar","scalar","divideByScalar","negate","lerpScratch","lerp","start","end","t","angleBetweenScratch","angleBetweenScratch2","angleBetween","acosClamped","mostOrthogonalAxisScratch","mostOrthogonalAxis","f","UNIT_X","UNIT_Y","equalsArray","offset","relativeEpsilon","ZERO","toString"],"mappings":"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"}