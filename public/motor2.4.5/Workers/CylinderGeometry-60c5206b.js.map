{"version":3,"file":"CylinderGeometry-60c5206b.js","sources":["../../../../Source/Core/CylinderGeometry.js"],"sourcesContent":["import arrayFill from './arrayFill.js';\r\nimport BoundingSphere from './BoundingSphere.js';\r\nimport Cartesian2 from './Cartesian2.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport ComponentDatatype from './ComponentDatatype.js';\r\nimport CylinderGeometryLibrary from './CylinderGeometryLibrary.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport Geometry from './Geometry.js';\r\nimport GeometryAttribute from './GeometryAttribute.js';\r\nimport GeometryAttributes from './GeometryAttributes.js';\r\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\r\nimport IndexDatatype from './IndexDatatype.js';\r\nimport CesiumMath from './Math.js';\r\nimport PrimitiveType from './PrimitiveType.js';\r\nimport VertexFormat from './VertexFormat.js';\r\n\r\n    var radiusScratch = new Cartesian2();\r\n    var normalScratch = new Cartesian3();\r\n    var bitangentScratch = new Cartesian3();\r\n    var tangentScratch = new Cartesian3();\r\n    var positionScratch = new Cartesian3();\r\n\r\n    /**\r\n     * A description of a cylinder.\r\n     *\r\n     * @alias CylinderGeometry\r\n     * @constructor\r\n     *\r\n     * @param {Object} options Object with the following properties:\r\n     * @param {Number} options.length The length of the cylinder.\r\n     * @param {Number} options.topRadius The radius of the top of the cylinder.\r\n     * @param {Number} options.bottomRadius The radius of the bottom of the cylinder.\r\n     * @param {Number} [options.slices=128] The number of edges around the perimeter of the cylinder.\r\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\r\n     *\r\n     * @exception {DeveloperError} options.slices must be greater than or equal to 3.\r\n     *\r\n     * @see CylinderGeometry.createGeometry\r\n     *\r\n     * @example\r\n     * // create cylinder geometry\r\n     * var cylinder = new Cesium.CylinderGeometry({\r\n     *     length: 200000,\r\n     *     topRadius: 80000,\r\n     *     bottomRadius: 200000,\r\n     * });\r\n     * var geometry = Cesium.CylinderGeometry.createGeometry(cylinder);\r\n     */\r\n    function CylinderGeometry(options) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n        var length = options.length;\r\n        var topRadius = options.topRadius;\r\n        var bottomRadius = options.bottomRadius;\r\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\r\n        var slices = defaultValue(options.slices, 128);\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(length)) {\r\n            throw new DeveloperError('options.length must be defined.');\r\n        }\r\n        if (!defined(topRadius)) {\r\n            throw new DeveloperError('options.topRadius must be defined.');\r\n        }\r\n        if (!defined(bottomRadius)) {\r\n            throw new DeveloperError('options.bottomRadius must be defined.');\r\n        }\r\n        if (slices < 3) {\r\n            throw new DeveloperError('options.slices must be greater than or equal to 3.');\r\n        }\r\n        if (defined(options.offsetAttribute) && options.offsetAttribute === GeometryOffsetAttribute.TOP) {\r\n            throw new DeveloperError('GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        this._length = length;\r\n        this._topRadius = topRadius;\r\n        this._bottomRadius = bottomRadius;\r\n        this._vertexFormat = VertexFormat.clone(vertexFormat);\r\n        this._slices = slices;\r\n        this._offsetAttribute = options.offsetAttribute;\r\n        this._workerName = 'createCylinderGeometry';\r\n    }\r\n\r\n    /**\r\n     * The number of elements used to pack the object into an array.\r\n     * @type {Number}\r\n     */\r\n    CylinderGeometry.packedLength = VertexFormat.packedLength + 5;\r\n\r\n    /**\r\n     * Stores the provided instance into the provided array.\r\n     *\r\n     * @param {CylinderGeometry} value The value to pack.\r\n     * @param {Number[]} array The array to pack into.\r\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n     *\r\n     * @returns {Number[]} The array that was packed into\r\n     */\r\n    CylinderGeometry.pack = function(value, array, startingIndex) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(value)) {\r\n            throw new DeveloperError('value is required');\r\n        }\r\n        if (!defined(array)) {\r\n            throw new DeveloperError('array is required');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\r\n        startingIndex += VertexFormat.packedLength;\r\n\r\n        array[startingIndex++] = value._length;\r\n        array[startingIndex++] = value._topRadius;\r\n        array[startingIndex++] = value._bottomRadius;\r\n        array[startingIndex++] = value._slices;\r\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\r\n\r\n        return array;\r\n    };\r\n\r\n    var scratchVertexFormat = new VertexFormat();\r\n    var scratchOptions = {\r\n        vertexFormat : scratchVertexFormat,\r\n        length : undefined,\r\n        topRadius : undefined,\r\n        bottomRadius : undefined,\r\n        slices : undefined,\r\n        offsetAttribute : undefined\r\n    };\r\n\r\n    /**\r\n     * Retrieves an instance from a packed array.\r\n     *\r\n     * @param {Number[]} array The packed array.\r\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n     * @param {CylinderGeometry} [result] The object into which to store the result.\r\n     * @returns {CylinderGeometry} The modified result parameter or a new CylinderGeometry instance if one was not provided.\r\n     */\r\n    CylinderGeometry.unpack = function(array, startingIndex, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(array)) {\r\n            throw new DeveloperError('array is required');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\r\n        startingIndex += VertexFormat.packedLength;\r\n\r\n        var length = array[startingIndex++];\r\n        var topRadius = array[startingIndex++];\r\n        var bottomRadius = array[startingIndex++];\r\n        var slices = array[startingIndex++];\r\n        var offsetAttribute = array[startingIndex];\r\n\r\n        if (!defined(result)) {\r\n            scratchOptions.length = length;\r\n            scratchOptions.topRadius = topRadius;\r\n            scratchOptions.bottomRadius = bottomRadius;\r\n            scratchOptions.slices = slices;\r\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\r\n            return new CylinderGeometry(scratchOptions);\r\n        }\r\n\r\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\r\n        result._length = length;\r\n        result._topRadius = topRadius;\r\n        result._bottomRadius = bottomRadius;\r\n        result._slices = slices;\r\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the geometric representation of a cylinder, including its vertices, indices, and a bounding sphere.\r\n     *\r\n     * @param {CylinderGeometry} cylinderGeometry A description of the cylinder.\r\n     * @returns {Geometry|undefined} The computed vertices and indices.\r\n     */\r\n    CylinderGeometry.createGeometry = function(cylinderGeometry) {\r\n        var length = cylinderGeometry._length;\r\n        var topRadius = cylinderGeometry._topRadius;\r\n        var bottomRadius = cylinderGeometry._bottomRadius;\r\n        var vertexFormat = cylinderGeometry._vertexFormat;\r\n        var slices = cylinderGeometry._slices;\r\n\r\n        if ((length <= 0) || (topRadius < 0) || (bottomRadius < 0) || ((topRadius === 0) && (bottomRadius === 0))) {\r\n            return;\r\n        }\r\n\r\n        var twoSlices = slices + slices;\r\n        var threeSlices = slices + twoSlices;\r\n        var numVertices = twoSlices + twoSlices;\r\n\r\n        var positions = CylinderGeometryLibrary.computePositions(length, topRadius, bottomRadius, slices, true);\r\n\r\n        var st = (vertexFormat.st) ? new Float32Array(numVertices * 2) : undefined;\r\n        var normals = (vertexFormat.normal) ? new Float32Array(numVertices * 3) : undefined;\r\n        var tangents = (vertexFormat.tangent) ? new Float32Array(numVertices * 3) : undefined;\r\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(numVertices * 3) : undefined;\r\n\r\n        var i;\r\n        var computeNormal = (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent);\r\n\r\n        if (computeNormal) {\r\n            var computeTangent = (vertexFormat.tangent || vertexFormat.bitangent);\r\n\r\n            var normalIndex = 0;\r\n            var tangentIndex = 0;\r\n            var bitangentIndex = 0;\r\n\r\n            var theta = Math.atan2(bottomRadius - topRadius, length);\r\n            var normal = normalScratch;\r\n            normal.z = Math.sin(theta);\r\n            var normalScale = Math.cos(theta);\r\n            var tangent = tangentScratch;\r\n            var bitangent = bitangentScratch;\r\n\r\n            for (i = 0; i < slices; i++) {\r\n                var angle = i / slices * CesiumMath.TWO_PI;\r\n                var x = normalScale * Math.cos(angle);\r\n                var y = normalScale * Math.sin(angle);\r\n                if (computeNormal) {\r\n                    normal.x = x;\r\n                    normal.y = y;\r\n\r\n                    if (computeTangent) {\r\n                        tangent = Cartesian3.normalize(Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent), tangent);\r\n                    }\r\n\r\n                    if (vertexFormat.normal) {\r\n                        normals[normalIndex++] = normal.x;\r\n                        normals[normalIndex++] = normal.y;\r\n                        normals[normalIndex++] = normal.z;\r\n                        normals[normalIndex++] = normal.x;\r\n                        normals[normalIndex++] = normal.y;\r\n                        normals[normalIndex++] = normal.z;\r\n                    }\r\n\r\n                    if (vertexFormat.tangent) {\r\n                        tangents[tangentIndex++] = tangent.x;\r\n                        tangents[tangentIndex++] = tangent.y;\r\n                        tangents[tangentIndex++] = tangent.z;\r\n                        tangents[tangentIndex++] = tangent.x;\r\n                        tangents[tangentIndex++] = tangent.y;\r\n                        tangents[tangentIndex++] = tangent.z;\r\n                    }\r\n\r\n                    if (vertexFormat.bitangent) {\r\n                        bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\r\n                        bitangents[bitangentIndex++] = bitangent.x;\r\n                        bitangents[bitangentIndex++] = bitangent.y;\r\n                        bitangents[bitangentIndex++] = bitangent.z;\r\n                        bitangents[bitangentIndex++] = bitangent.x;\r\n                        bitangents[bitangentIndex++] = bitangent.y;\r\n                        bitangents[bitangentIndex++] = bitangent.z;\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (i = 0; i < slices; i++) {\r\n                if (vertexFormat.normal) {\r\n                    normals[normalIndex++] = 0;\r\n                    normals[normalIndex++] = 0;\r\n                    normals[normalIndex++] = -1;\r\n                }\r\n                if (vertexFormat.tangent) {\r\n                    tangents[tangentIndex++] = 1;\r\n                    tangents[tangentIndex++] = 0;\r\n                    tangents[tangentIndex++] = 0;\r\n                }\r\n                if (vertexFormat.bitangent) {\r\n                    bitangents[bitangentIndex++] = 0;\r\n                    bitangents[bitangentIndex++] = -1;\r\n                    bitangents[bitangentIndex++] = 0;\r\n                }\r\n            }\r\n\r\n            for (i = 0; i < slices; i++) {\r\n                if (vertexFormat.normal) {\r\n                    normals[normalIndex++] = 0;\r\n                    normals[normalIndex++] = 0;\r\n                    normals[normalIndex++] = 1;\r\n                }\r\n                if (vertexFormat.tangent) {\r\n                    tangents[tangentIndex++] = 1;\r\n                    tangents[tangentIndex++] = 0;\r\n                    tangents[tangentIndex++] = 0;\r\n                }\r\n                if (vertexFormat.bitangent) {\r\n                    bitangents[bitangentIndex++] = 0;\r\n                    bitangents[bitangentIndex++] = 1;\r\n                    bitangents[bitangentIndex++] = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        var numIndices = 12 * slices - 12;\r\n        var indices = IndexDatatype.createTypedArray(numVertices, numIndices);\r\n        var index = 0;\r\n        var j = 0;\r\n        for (i = 0; i < slices - 1; i++) {\r\n            indices[index++] = j;\r\n            indices[index++] = j + 2;\r\n            indices[index++] = j + 3;\r\n\r\n            indices[index++] = j;\r\n            indices[index++] = j + 3;\r\n            indices[index++] = j + 1;\r\n\r\n            j += 2;\r\n        }\r\n\r\n        indices[index++] = twoSlices - 2;\r\n        indices[index++] = 0;\r\n        indices[index++] = 1;\r\n        indices[index++] = twoSlices - 2;\r\n        indices[index++] = 1;\r\n        indices[index++] = twoSlices - 1;\r\n\r\n        for (i = 1; i < slices - 1; i++) {\r\n            indices[index++] = twoSlices + i + 1;\r\n            indices[index++] = twoSlices + i;\r\n            indices[index++] = twoSlices;\r\n        }\r\n\r\n        for (i = 1; i < slices - 1; i++) {\r\n            indices[index++] = threeSlices;\r\n            indices[index++] = threeSlices + i;\r\n            indices[index++] = threeSlices + i + 1;\r\n        }\r\n\r\n        var textureCoordIndex = 0;\r\n        if (vertexFormat.st) {\r\n            var rad = Math.max(topRadius, bottomRadius);\r\n            for (i = 0; i < numVertices; i++) {\r\n                var position = Cartesian3.fromArray(positions, i * 3, positionScratch);\r\n                st[textureCoordIndex++] = (position.x + rad) / (2.0 * rad);\r\n                st[textureCoordIndex++] = (position.y + rad) / (2.0 * rad);\r\n            }\r\n        }\r\n\r\n        var attributes = new GeometryAttributes();\r\n        if (vertexFormat.position) {\r\n            attributes.position = new GeometryAttribute({\r\n                componentDatatype: ComponentDatatype.DOUBLE,\r\n                componentsPerAttribute: 3,\r\n                values: positions\r\n            });\r\n        }\r\n\r\n        if (vertexFormat.normal) {\r\n            attributes.normal = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.FLOAT,\r\n                componentsPerAttribute : 3,\r\n                values : normals\r\n            });\r\n        }\r\n\r\n        if (vertexFormat.tangent) {\r\n            attributes.tangent = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.FLOAT,\r\n                componentsPerAttribute : 3,\r\n                values : tangents\r\n            });\r\n        }\r\n\r\n        if (vertexFormat.bitangent) {\r\n            attributes.bitangent = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.FLOAT,\r\n                componentsPerAttribute : 3,\r\n                values : bitangents\r\n            });\r\n        }\r\n\r\n        if (vertexFormat.st) {\r\n            attributes.st = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.FLOAT,\r\n                componentsPerAttribute : 2,\r\n                values : st\r\n            });\r\n        }\r\n\r\n        radiusScratch.x = length * 0.5;\r\n        radiusScratch.y = Math.max(bottomRadius, topRadius);\r\n\r\n        var boundingSphere = new BoundingSphere(Cartesian3.ZERO, Cartesian2.magnitude(radiusScratch));\r\n\r\n        if (defined(cylinderGeometry._offsetAttribute)) {\r\n            length = positions.length;\r\n            var applyOffset = new Uint8Array(length / 3);\r\n            var offsetValue = cylinderGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\r\n            arrayFill(applyOffset, offsetValue);\r\n            attributes.applyOffset = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\r\n                componentsPerAttribute : 1,\r\n                values: applyOffset\r\n            });\r\n        }\r\n\r\n        return new Geometry({\r\n            attributes : attributes,\r\n            indices : indices,\r\n            primitiveType : PrimitiveType.TRIANGLES,\r\n            boundingSphere : boundingSphere,\r\n            offsetAttribute : cylinderGeometry._offsetAttribute\r\n        });\r\n    };\r\n\r\n    var unitCylinderGeometry;\r\n\r\n    /**\r\n     * Returns the geometric representation of a unit cylinder, including its vertices, indices, and a bounding sphere.\r\n     * @returns {Geometry} The computed vertices and indices.\r\n     *\r\n     * @private\r\n     */\r\n    CylinderGeometry.getUnitCylinder = function() {\r\n        if (!defined(unitCylinderGeometry)) {\r\n            unitCylinderGeometry = CylinderGeometry.createGeometry(new CylinderGeometry({\r\n                topRadius : 1.0,\r\n                bottomRadius : 1.0,\r\n                length : 1.0,\r\n                vertexFormat : VertexFormat.POSITION_ONLY\r\n            }));\r\n        }\r\n        return unitCylinderGeometry;\r\n    };\r\nexport default CylinderGeometry;\r\n"],"names":["radiusScratch","Cartesian2","normalScratch","Cartesian3","bitangentScratch","tangentScratch","positionScratch","CylinderGeometry","options","length","defaultValue","EMPTY_OBJECT","topRadius","bottomRadius","vertexFormat","VertexFormat","DEFAULT","slices","defined","DeveloperError","offsetAttribute","GeometryOffsetAttribute","TOP","this","_length","_topRadius","_bottomRadius","_vertexFormat","clone","_slices","_offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","unitCylinderGeometry","scratchVertexFormat","scratchOptions","undefined","unpack","result","createGeometry","cylinderGeometry","i","twoSlices","threeSlices","numVertices","positions","CylinderGeometryLibrary","computePositions","st","Float32Array","normals","tangents","bitangents","computeNormal","normal","tangent","bitangent","computeTangent","normalIndex","tangentIndex","bitangentIndex","theta","Math","atan2","z","sin","normalScale","cos","angle","CesiumMath","TWO_PI","x","y","normalize","cross","UNIT_Z","numIndices","indices","IndexDatatype","createTypedArray","index","j","textureCoordIndex","rad","max","position","fromArray","attributes","GeometryAttributes","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","FLOAT","boundingSphere","BoundingSphere","ZERO","magnitude","applyOffset","Uint8Array","offsetValue","NONE","arrayFill","UNSIGNED_BYTE","Geometry","primitiveType","PrimitiveType","TRIANGLES","getUnitCylinder","POSITION_ONLY"],"mappings":"kaAkBI,IAAIA,EAAgB,IAAIC,aACpBC,EAAgB,IAAIC,aACpBC,EAAmB,IAAID,aACvBE,EAAiB,IAAIF,aACrBG,EAAkB,IAAIH,aA4B1B,SAASI,EAAiBC,GAGtB,IAAIC,GAFJD,EAAUE,eAAaF,EAASE,eAAaC,eAExBF,OACjBG,EAAYJ,EAAQI,UACpBC,EAAeL,EAAQK,aACvBC,EAAeJ,eAAaF,EAAQM,aAAcC,eAAaC,SAC/DC,EAASP,eAAaF,EAAQS,OAAQ,KAG1C,IAAKC,UAAQT,GACT,MAAM,IAAIU,iBAAe,mCAE7B,IAAKD,UAAQN,GACT,MAAM,IAAIO,iBAAe,sCAE7B,IAAKD,UAAQL,GACT,MAAM,IAAIM,iBAAe,yCAE7B,GAAIF,EAAS,EACT,MAAM,IAAIE,iBAAe,sDAE7B,GAAID,UAAQV,EAAQY,kBAAoBZ,EAAQY,kBAAoBC,0BAAwBC,IACxF,MAAM,IAAIH,iBAAe,6FAI7BI,KAAKC,QAAUf,EACfc,KAAKE,WAAab,EAClBW,KAAKG,cAAgBb,EACrBU,KAAKI,cAAgBZ,eAAaa,MAAMd,GACxCS,KAAKM,QAAUZ,EACfM,KAAKO,iBAAmBtB,EAAQY,gBAChCG,KAAKQ,YAAc,yBAOvBxB,EAAiByB,aAAejB,eAAaiB,aAAe,EAW5DzB,EAAiB0B,KAAO,SAASC,EAAOC,EAAOC,GAE3C,IAAKlB,UAAQgB,GACT,MAAM,IAAIf,iBAAe,qBAE7B,IAAKD,UAAQiB,GACT,MAAM,IAAIhB,iBAAe,qBAe7B,OAXAiB,EAAgB1B,eAAa0B,EAAe,GAE5CrB,eAAakB,KAAKC,EAAMP,cAAeQ,EAAOC,GAC9CA,GAAiBrB,eAAaiB,aAE9BG,EAAMC,KAAmBF,EAAMV,QAC/BW,EAAMC,KAAmBF,EAAMT,WAC/BU,EAAMC,KAAmBF,EAAMR,cAC/BS,EAAMC,KAAmBF,EAAML,QAC/BM,EAAMC,GAAiB1B,eAAawB,EAAMJ,kBAAmB,GAEtDK,GAGX,IAmSIE,EAnSAC,EAAsB,IAAIvB,eAC1BwB,EAAiB,CACjBzB,aAAewB,EACf7B,YAAS+B,EACT5B,eAAY4B,EACZ3B,kBAAe2B,EACfvB,YAASuB,EACTpB,qBAAkBoB,GAWtBjC,EAAiBkC,OAAS,SAASN,EAAOC,EAAeM,GAErD,IAAKxB,UAAQiB,GACT,MAAM,IAAIhB,iBAAe,qBAI7BiB,EAAgB1B,eAAa0B,EAAe,GAE5C,IAAItB,EAAeC,eAAa0B,OAAON,EAAOC,EAAeE,GAC7DF,GAAiBrB,eAAaiB,aAE9B,IAAIvB,EAAS0B,EAAMC,KACfxB,EAAYuB,EAAMC,KAClBvB,EAAesB,EAAMC,KACrBnB,EAASkB,EAAMC,KACfhB,EAAkBe,EAAMC,GAE5B,OAAKlB,UAAQwB,IASbA,EAAOf,cAAgBZ,eAAaa,MAAMd,EAAc4B,EAAOf,eAC/De,EAAOlB,QAAUf,EACjBiC,EAAOjB,WAAab,EACpB8B,EAAOhB,cAAgBb,EACvB6B,EAAOb,QAAUZ,EACjByB,EAAOZ,kBAAwC,IAArBV,OAAyBoB,EAAYpB,EAExDsB,IAfHH,EAAe9B,OAASA,EACxB8B,EAAe3B,UAAYA,EAC3B2B,EAAe1B,aAAeA,EAC9B0B,EAAetB,OAASA,EACxBsB,EAAenB,iBAAuC,IAArBA,OAAyBoB,EAAYpB,EAC/D,IAAIb,EAAiBgC,KAmBpChC,EAAiBoC,eAAiB,SAASC,GACvC,IAAInC,EAASmC,EAAiBpB,QAC1BZ,EAAYgC,EAAiBnB,WAC7BZ,EAAe+B,EAAiBlB,cAChCZ,EAAe8B,EAAiBjB,cAChCV,EAAS2B,EAAiBf,QAE9B,KAAKpB,GAAU,GAAOG,EAAY,GAAOC,EAAe,GAAsB,IAAdD,GAAsC,IAAjBC,GAArF,CAIA,IAWIgC,EAXAC,EAAY7B,EAASA,EACrB8B,EAAc9B,EAAS6B,EACvBE,EAAcF,EAAYA,EAE1BG,EAAYC,0BAAwBC,iBAAiB1C,EAAQG,EAAWC,EAAcI,GAAQ,GAE9FmC,EAAMtC,EAAe,GAAI,IAAIuC,aAA2B,EAAdL,QAAmBR,EAC7Dc,EAAWxC,EAAmB,OAAI,IAAIuC,aAA2B,EAAdL,QAAmBR,EACtEe,EAAYzC,EAAoB,QAAI,IAAIuC,aAA2B,EAAdL,QAAmBR,EACxEgB,EAAc1C,EAAsB,UAAI,IAAIuC,aAA2B,EAAdL,QAAmBR,EAG5EiB,EAAiB3C,EAAa4C,QAAU5C,EAAa6C,SAAW7C,EAAa8C,UAEjF,GAAIH,EAAe,CACf,IAAII,EAAkB/C,EAAa6C,SAAW7C,EAAa8C,UAEvDE,EAAc,EACdC,EAAe,EACfC,EAAiB,EAEjBC,EAAQC,KAAKC,MAAMtD,EAAeD,EAAWH,GAC7CiD,EAASxD,EACbwD,EAAOU,EAAIF,KAAKG,IAAIJ,GACpB,IAAIK,EAAcJ,KAAKK,IAAIN,GACvBN,EAAUtD,EACVuD,EAAYxD,EAEhB,IAAKyC,EAAI,EAAGA,EAAI5B,EAAQ4B,IAAK,CACzB,IAAI2B,EAAQ3B,EAAI5B,EAASwD,aAAWC,OAChCC,EAAIL,EAAcJ,KAAKK,IAAIC,GAC3BI,EAAIN,EAAcJ,KAAKG,IAAIG,GAC3Bf,IACAC,EAAOiB,EAAIA,EACXjB,EAAOkB,EAAIA,EAEPf,IACAF,EAAUxD,aAAW0E,UAAU1E,aAAW2E,MAAM3E,aAAW4E,OAAQrB,EAAQC,GAAUA,IAGrF7C,EAAa4C,SACbJ,EAAQQ,KAAiBJ,EAAOiB,EAChCrB,EAAQQ,KAAiBJ,EAAOkB,EAChCtB,EAAQQ,KAAiBJ,EAAOU,EAChCd,EAAQQ,KAAiBJ,EAAOiB,EAChCrB,EAAQQ,KAAiBJ,EAAOkB,EAChCtB,EAAQQ,KAAiBJ,EAAOU,GAGhCtD,EAAa6C,UACbJ,EAASQ,KAAkBJ,EAAQgB,EACnCpB,EAASQ,KAAkBJ,EAAQiB,EACnCrB,EAASQ,KAAkBJ,EAAQS,EACnCb,EAASQ,KAAkBJ,EAAQgB,EACnCpB,EAASQ,KAAkBJ,EAAQiB,EACnCrB,EAASQ,KAAkBJ,EAAQS,GAGnCtD,EAAa8C,YACbA,EAAYzD,aAAW0E,UAAU1E,aAAW2E,MAAMpB,EAAQC,EAASC,GAAYA,GAC/EJ,EAAWQ,KAAoBJ,EAAUe,EACzCnB,EAAWQ,KAAoBJ,EAAUgB,EACzCpB,EAAWQ,KAAoBJ,EAAUQ,EACzCZ,EAAWQ,KAAoBJ,EAAUe,EACzCnB,EAAWQ,KAAoBJ,EAAUgB,EACzCpB,EAAWQ,KAAoBJ,EAAUQ,IAKrD,IAAKvB,EAAI,EAAGA,EAAI5B,EAAQ4B,IAChB/B,EAAa4C,SACbJ,EAAQQ,KAAiB,EACzBR,EAAQQ,KAAiB,EACzBR,EAAQQ,MAAkB,GAE1BhD,EAAa6C,UACbJ,EAASQ,KAAkB,EAC3BR,EAASQ,KAAkB,EAC3BR,EAASQ,KAAkB,GAE3BjD,EAAa8C,YACbJ,EAAWQ,KAAoB,EAC/BR,EAAWQ,MAAqB,EAChCR,EAAWQ,KAAoB,GAIvC,IAAKnB,EAAI,EAAGA,EAAI5B,EAAQ4B,IAChB/B,EAAa4C,SACbJ,EAAQQ,KAAiB,EACzBR,EAAQQ,KAAiB,EACzBR,EAAQQ,KAAiB,GAEzBhD,EAAa6C,UACbJ,EAASQ,KAAkB,EAC3BR,EAASQ,KAAkB,EAC3BR,EAASQ,KAAkB,GAE3BjD,EAAa8C,YACbJ,EAAWQ,KAAoB,EAC/BR,EAAWQ,KAAoB,EAC/BR,EAAWQ,KAAoB,GAK3C,IAAIgB,EAAa,GAAK/D,EAAS,GAC3BgE,EAAUC,gBAAcC,iBAAiBnC,EAAagC,GACtDI,EAAQ,EACRC,EAAI,EACR,IAAKxC,EAAI,EAAGA,EAAI5B,EAAS,EAAG4B,IACxBoC,EAAQG,KAAWC,EACnBJ,EAAQG,KAAWC,EAAI,EACvBJ,EAAQG,KAAWC,EAAI,EAEvBJ,EAAQG,KAAWC,EACnBJ,EAAQG,KAAWC,EAAI,EACvBJ,EAAQG,KAAWC,EAAI,EAEvBA,GAAK,EAUT,IAPAJ,EAAQG,KAAWtC,EAAY,EAC/BmC,EAAQG,KAAW,EACnBH,EAAQG,KAAW,EACnBH,EAAQG,KAAWtC,EAAY,EAC/BmC,EAAQG,KAAW,EACnBH,EAAQG,KAAWtC,EAAY,EAE1BD,EAAI,EAAGA,EAAI5B,EAAS,EAAG4B,IACxBoC,EAAQG,KAAWtC,EAAYD,EAAI,EACnCoC,EAAQG,KAAWtC,EAAYD,EAC/BoC,EAAQG,KAAWtC,EAGvB,IAAKD,EAAI,EAAGA,EAAI5B,EAAS,EAAG4B,IACxBoC,EAAQG,KAAWrC,EACnBkC,EAAQG,KAAWrC,EAAcF,EACjCoC,EAAQG,KAAWrC,EAAcF,EAAI,EAGzC,IAAIyC,EAAoB,EACxB,GAAIxE,EAAasC,GAAI,CACjB,IAAImC,EAAMrB,KAAKsB,IAAI5E,EAAWC,GAC9B,IAAKgC,EAAI,EAAGA,EAAIG,EAAaH,IAAK,CAC9B,IAAI4C,EAAWtF,aAAWuF,UAAUzC,EAAe,EAAJJ,EAAOvC,GACtD8C,EAAGkC,MAAwBG,EAASd,EAAIY,IAAQ,EAAMA,GACtDnC,EAAGkC,MAAwBG,EAASb,EAAIW,IAAQ,EAAMA,IAI9D,IAAII,EAAa,IAAIC,qBACjB9E,EAAa2E,WACbE,EAAWF,SAAW,IAAII,oBAAkB,CACxCC,kBAAmBC,oBAAkBC,OACrCC,uBAAwB,EACxBC,OAAQjD,KAIZnC,EAAa4C,SACbiC,EAAWjC,OAAS,IAAImC,oBAAkB,CACtCC,kBAAoBC,oBAAkBI,MACtCF,uBAAyB,EACzBC,OAAS5C,KAIbxC,EAAa6C,UACbgC,EAAWhC,QAAU,IAAIkC,oBAAkB,CACvCC,kBAAoBC,oBAAkBI,MACtCF,uBAAyB,EACzBC,OAAS3C,KAIbzC,EAAa8C,YACb+B,EAAW/B,UAAY,IAAIiC,oBAAkB,CACzCC,kBAAoBC,oBAAkBI,MACtCF,uBAAyB,EACzBC,OAAS1C,KAIb1C,EAAasC,KACbuC,EAAWvC,GAAK,IAAIyC,oBAAkB,CAClCC,kBAAoBC,oBAAkBI,MACtCF,uBAAyB,EACzBC,OAAS9C,KAIjBpD,EAAc2E,EAAa,GAATlE,EAClBT,EAAc4E,EAAIV,KAAKsB,IAAI3E,EAAcD,GAEzC,IAAIwF,EAAiB,IAAIC,iBAAelG,aAAWmG,KAAMrG,aAAWsG,UAAUvG,IAE9E,GAAIkB,UAAQ0B,EAAiBd,kBAAmB,CAC5CrB,EAASwC,EAAUxC,OACnB,IAAI+F,EAAc,IAAIC,WAAWhG,EAAS,GACtCiG,GAAc9D,EAAiBd,mBAAqBT,0BAAwBsF,KAAO,EAAI,EAC3FC,YAAUJ,EAAaE,IACvBf,EAAWa,YAAc,IAAIX,oBAAkB,CAC3CC,kBAAoBC,oBAAkBc,cACtCZ,uBAAyB,EACzBC,OAAQM,IAIhB,OAAO,IAAIM,WAAS,CAChBnB,WAAaA,EACbV,QAAUA,EACV8B,cAAgBC,gBAAcC,UAC9Bb,eAAiBA,EACjBhF,gBAAkBwB,EAAiBd,qBAY3CvB,EAAiB2G,gBAAkB,WAS/B,OARKhG,UAAQmB,KACTA,EAAuB9B,EAAiBoC,eAAe,IAAIpC,EAAiB,CACxEK,UAAY,EACZC,aAAe,EACfJ,OAAS,EACTK,aAAeC,eAAaoG,kBAG7B9E"}