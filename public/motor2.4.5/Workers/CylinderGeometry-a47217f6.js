define(["exports","./when-7ef6387a","./Check-ed6a1804","./GeometryOffsetAttribute-5cfc2755","./Math-85667bf9","./Ellipsoid-1cbb4ac9","./Transforms-c20c38d0","./Cartesian2-73569d25","./ComponentDatatype-a863af81","./GeometryAttribute-6b3c7112","./GeometryAttributes-cb18da36","./VertexFormat-d75df48f","./IndexDatatype-f12d39b5","./CylinderGeometryLibrary-e2d41c6a"],(function(t,e,r,a,o,n,i,s,u,d,f,m,p,l){"use strict";var y=new s.Cartesian2,b=new n.Cartesian3,c=new n.Cartesian3,v=new n.Cartesian3,A=new n.Cartesian3;function h(t){var o=(t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT)).length,n=t.topRadius,i=t.bottomRadius,s=e.defaultValue(t.vertexFormat,m.VertexFormat.DEFAULT),u=e.defaultValue(t.slices,128);if(!e.defined(o))throw new r.DeveloperError("options.length must be defined.");if(!e.defined(n))throw new r.DeveloperError("options.topRadius must be defined.");if(!e.defined(i))throw new r.DeveloperError("options.bottomRadius must be defined.");if(u<3)throw new r.DeveloperError("options.slices must be greater than or equal to 3.");if(e.defined(t.offsetAttribute)&&t.offsetAttribute===a.GeometryOffsetAttribute.TOP)throw new r.DeveloperError("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._length=o,this._topRadius=n,this._bottomRadius=i,this._vertexFormat=m.VertexFormat.clone(s),this._slices=u,this._offsetAttribute=t.offsetAttribute,this._workerName="createCylinderGeometry"}h.packedLength=m.VertexFormat.packedLength+5,h.pack=function(t,a,o){if(!e.defined(t))throw new r.DeveloperError("value is required");if(!e.defined(a))throw new r.DeveloperError("array is required");return o=e.defaultValue(o,0),m.VertexFormat.pack(t._vertexFormat,a,o),o+=m.VertexFormat.packedLength,a[o++]=t._length,a[o++]=t._topRadius,a[o++]=t._bottomRadius,a[o++]=t._slices,a[o]=e.defaultValue(t._offsetAttribute,-1),a};var w,g=new m.VertexFormat,x={vertexFormat:g,length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,offsetAttribute:void 0};h.unpack=function(t,a,o){if(!e.defined(t))throw new r.DeveloperError("array is required");a=e.defaultValue(a,0);var n=m.VertexFormat.unpack(t,a,g);a+=m.VertexFormat.packedLength;var i=t[a++],s=t[a++],u=t[a++],d=t[a++],f=t[a];return e.defined(o)?(o._vertexFormat=m.VertexFormat.clone(n,o._vertexFormat),o._length=i,o._topRadius=s,o._bottomRadius=u,o._slices=d,o._offsetAttribute=-1===f?void 0:f,o):(x.length=i,x.topRadius=s,x.bottomRadius=u,x.slices=d,x.offsetAttribute=-1===f?void 0:f,new h(x))},h.createGeometry=function(t){var r=t._length,m=t._topRadius,h=t._bottomRadius,w=t._vertexFormat,g=t._slices;if(!(r<=0||m<0||h<0||0===m&&0===h)){var x,_=g+g,C=g+_,F=_+_,D=l.CylinderGeometryLibrary.computePositions(r,m,h,g,!0),G=w.st?new Float32Array(2*F):void 0,R=w.normal?new Float32Array(3*F):void 0,O=w.tangent?new Float32Array(3*F):void 0,E=w.bitangent?new Float32Array(3*F):void 0,T=w.normal||w.tangent||w.bitangent;if(T){var V=w.tangent||w.bitangent,L=0,P=0,k=0,M=Math.atan2(h-m,r),z=b;z.z=Math.sin(M);var N=Math.cos(M),I=v,U=c;for(x=0;x<g;x++){var S=x/g*o.CesiumMath.TWO_PI,q=N*Math.cos(S),B=N*Math.sin(S);T&&(z.x=q,z.y=B,V&&(I=n.Cartesian3.normalize(n.Cartesian3.cross(n.Cartesian3.UNIT_Z,z,I),I)),w.normal&&(R[L++]=z.x,R[L++]=z.y,R[L++]=z.z,R[L++]=z.x,R[L++]=z.y,R[L++]=z.z),w.tangent&&(O[P++]=I.x,O[P++]=I.y,O[P++]=I.z,O[P++]=I.x,O[P++]=I.y,O[P++]=I.z),w.bitangent&&(U=n.Cartesian3.normalize(n.Cartesian3.cross(z,I,U),U),E[k++]=U.x,E[k++]=U.y,E[k++]=U.z,E[k++]=U.x,E[k++]=U.y,E[k++]=U.z))}for(x=0;x<g;x++)w.normal&&(R[L++]=0,R[L++]=0,R[L++]=-1),w.tangent&&(O[P++]=1,O[P++]=0,O[P++]=0),w.bitangent&&(E[k++]=0,E[k++]=-1,E[k++]=0);for(x=0;x<g;x++)w.normal&&(R[L++]=0,R[L++]=0,R[L++]=1),w.tangent&&(O[P++]=1,O[P++]=0,O[P++]=0),w.bitangent&&(E[k++]=0,E[k++]=1,E[k++]=0)}var Y=12*g-12,Z=p.IndexDatatype.createTypedArray(F,Y),J=0,W=0;for(x=0;x<g-1;x++)Z[J++]=W,Z[J++]=W+2,Z[J++]=W+3,Z[J++]=W,Z[J++]=W+3,Z[J++]=W+1,W+=2;for(Z[J++]=_-2,Z[J++]=0,Z[J++]=1,Z[J++]=_-2,Z[J++]=1,Z[J++]=_-1,x=1;x<g-1;x++)Z[J++]=_+x+1,Z[J++]=_+x,Z[J++]=_;for(x=1;x<g-1;x++)Z[J++]=C,Z[J++]=C+x,Z[J++]=C+x+1;var j=0;if(w.st){var H=Math.max(m,h);for(x=0;x<F;x++){var K=n.Cartesian3.fromArray(D,3*x,A);G[j++]=(K.x+H)/(2*H),G[j++]=(K.y+H)/(2*H)}}var Q=new f.GeometryAttributes;w.position&&(Q.position=new d.GeometryAttribute({componentDatatype:u.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:D})),w.normal&&(Q.normal=new d.GeometryAttribute({componentDatatype:u.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:R})),w.tangent&&(Q.tangent=new d.GeometryAttribute({componentDatatype:u.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:O})),w.bitangent&&(Q.bitangent=new d.GeometryAttribute({componentDatatype:u.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:E})),w.st&&(Q.st=new d.GeometryAttribute({componentDatatype:u.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:G})),y.x=.5*r,y.y=Math.max(h,m);var X=new i.BoundingSphere(n.Cartesian3.ZERO,s.Cartesian2.magnitude(y));if(e.defined(t._offsetAttribute)){r=D.length;var $=new Uint8Array(r/3),tt=t._offsetAttribute===a.GeometryOffsetAttribute.NONE?0:1;a.arrayFill($,tt),Q.applyOffset=new d.GeometryAttribute({componentDatatype:u.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:$})}return new d.Geometry({attributes:Q,indices:Z,primitiveType:d.PrimitiveType.TRIANGLES,boundingSphere:X,offsetAttribute:t._offsetAttribute})}},h.getUnitCylinder=function(){return e.defined(w)||(w=h.createGeometry(new h({topRadius:1,bottomRadius:1,length:1,vertexFormat:m.VertexFormat.POSITION_ONLY}))),w},t.CylinderGeometry=h}));
//# sourceMappingURL=CylinderGeometry-a47217f6.js.map
