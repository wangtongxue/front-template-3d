/**
 * Cesium - https://github.com/AnalyticalGraphicsInc/cesium
 *
 * Copyright 2011-2017 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md for full licensing details.
 */
define(["exports","./when-4ca4e419","./Check-430b3551","./defineProperties-163ddb68","./Cartesian3-32451e63","./Ellipsoid-d2aa3b12","./Transforms-7b04d7e0","./Cartesian2-f49a1383","./ComponentDatatype-329b9462","./GeometryAttribute-b8faa946","./GeometryAttributes-614c63f8","./IndexDatatype-153fdd7f","./arrayFill-11a46844","./VertexFormat-a4fe3a21"],(function(t,e,r,a,n,i,o,s,f,u,l,m,d,p){"use strict";var c=new n.Cartesian3,y=new n.Cartesian3,v=new n.Cartesian3,A=new n.Cartesian3,b=new n.Cartesian3,h=new n.Cartesian3(1,1,1),C=Math.cos,w=Math.sin;function P(t){t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT);var a=e.defaultValue(t.radii,h),i=Math.round(e.defaultValue(t.stackPartitions,64)),o=Math.round(e.defaultValue(t.slicePartitions,64)),s=e.defaultValue(t.vertexFormat,p.VertexFormat.DEFAULT);if(o<3)throw new r.DeveloperError("options.slicePartitions cannot be less than three.");if(i<3)throw new r.DeveloperError("options.stackPartitions cannot be less than three.");if(e.defined(t.offsetAttribute)&&t.offsetAttribute===u.GeometryOffsetAttribute.TOP)throw new r.DeveloperError("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._radii=n.Cartesian3.clone(a),this._stackPartitions=i,this._slicePartitions=o,this._vertexFormat=p.VertexFormat.clone(s),this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidGeometry"}P.packedLength=n.Cartesian3.packedLength+p.VertexFormat.packedLength+3,P.pack=function(t,a,i){if(!e.defined(t))throw new r.DeveloperError("value is required");if(!e.defined(a))throw new r.DeveloperError("array is required");return i=e.defaultValue(i,0),n.Cartesian3.pack(t._radii,a,i),i+=n.Cartesian3.packedLength,p.VertexFormat.pack(t._vertexFormat,a,i),i+=p.VertexFormat.packedLength,a[i++]=t._stackPartitions,a[i++]=t._slicePartitions,a[i]=e.defaultValue(t._offsetAttribute,-1),a};var _,F=new n.Cartesian3,g=new p.VertexFormat,x={radii:F,vertexFormat:g,stackPartitions:void 0,slicePartitions:void 0,offsetAttribute:void 0};P.unpack=function(t,a,i){if(!e.defined(t))throw new r.DeveloperError("array is required");a=e.defaultValue(a,0);var o=n.Cartesian3.unpack(t,a,F);a+=n.Cartesian3.packedLength;var s=p.VertexFormat.unpack(t,a,g);a+=p.VertexFormat.packedLength;var f=t[a++],u=t[a++],l=t[a];return e.defined(i)?(i._radii=n.Cartesian3.clone(o,i._radii),i._vertexFormat=p.VertexFormat.clone(s,i._vertexFormat),i._stackPartitions=f,i._slicePartitions=u,i._offsetAttribute=-1===l?void 0:l,i):(x.stackPartitions=f,x.slicePartitions=u,x.offsetAttribute=-1===l?void 0:l,new P(x))},P.createGeometry=function(t){var r=t._radii;if(!(r.x<=0||r.y<=0||r.z<=0)){var p,h,P=i.Ellipsoid.fromCartesian3(r),_=t._vertexFormat,F=t._slicePartitions+1,g=t._stackPartitions+1,x=g*F,D=new Float64Array(3*x),k=6*(F-1)*(g-2),E=m.IndexDatatype.createTypedArray(x,k),T=_.normal?new Float32Array(3*x):void 0,V=_.tangent?new Float32Array(3*x):void 0,G=_.bitangent?new Float32Array(3*x):void 0,O=_.st?new Float32Array(2*x):void 0,L=new Array(F),M=new Array(F),I=0;for(p=0;p<F;p++){var N=a.CesiumMath.TWO_PI*p/(F-1);L[p]=C(N),M[p]=w(N),D[I++]=0,D[I++]=0,D[I++]=r.z}for(p=1;p<g-1;p++){var z=Math.PI*p/(g-1),S=w(z),U=r.x*S,B=r.y*S,q=r.z*C(z);for(h=0;h<F;h++)D[I++]=L[h]*U,D[I++]=M[h]*B,D[I++]=q}for(p=0;p<F;p++)D[I++]=0,D[I++]=0,D[I++]=-r.z;var Y=new l.GeometryAttributes;_.position&&(Y.position=new u.GeometryAttribute({componentDatatype:f.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:D}));var W,J,R=0,X=0,Z=0,j=0;if(_.st||_.normal||_.tangent||_.bitangent){for(p=0;p<x;p++){var H=n.Cartesian3.fromArray(D,3*p,c),K=P.geodeticSurfaceNormal(H,y);if(_.st){var Q=s.Cartesian2.negate(K,b);s.Cartesian2.magnitude(Q)<a.CesiumMath.EPSILON6&&((I=3*(p+F*Math.floor(.5*g)))>D.length&&(I=3*(p-F*Math.floor(.5*g))),n.Cartesian3.fromArray(D,I,Q),P.geodeticSurfaceNormal(Q,Q),s.Cartesian2.negate(Q,Q)),O[R++]=Math.atan2(Q.y,Q.x)/a.CesiumMath.TWO_PI+.5,O[R++]=Math.asin(K.z)/Math.PI+.5}if(_.normal&&(T[X++]=K.x,T[X++]=K.y,T[X++]=K.z),_.tangent||_.bitangent){var $=v;if(p<F||p>x-F-1?(n.Cartesian3.cross(n.Cartesian3.UNIT_X,K,$),n.Cartesian3.normalize($,$)):(n.Cartesian3.cross(n.Cartesian3.UNIT_Z,K,$),n.Cartesian3.normalize($,$)),_.tangent&&(V[Z++]=$.x,V[Z++]=$.y,V[Z++]=$.z),_.bitangent){var tt=n.Cartesian3.cross(K,$,A);n.Cartesian3.normalize(tt,tt),G[j++]=tt.x,G[j++]=tt.y,G[j++]=tt.z}}}_.st&&(Y.st=new u.GeometryAttribute({componentDatatype:f.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:O})),_.normal&&(Y.normal=new u.GeometryAttribute({componentDatatype:f.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:T})),_.tangent&&(Y.tangent=new u.GeometryAttribute({componentDatatype:f.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:V})),_.bitangent&&(Y.bitangent=new u.GeometryAttribute({componentDatatype:f.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:G}))}if(e.defined(t._offsetAttribute)){var et=D.length,rt=new Uint8Array(et/3),at=t._offsetAttribute===u.GeometryOffsetAttribute.NONE?0:1;d.arrayFill(rt,at),Y.applyOffset=new u.GeometryAttribute({componentDatatype:f.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:rt})}for(I=0,h=0;h<F-1;h++)E[I++]=F+h,E[I++]=F+h+1,E[I++]=h+1;for(p=1;p<g-2;p++)for(W=p*F,J=(p+1)*F,h=0;h<F-1;h++)E[I++]=J+h,E[I++]=J+h+1,E[I++]=W+h+1,E[I++]=J+h,E[I++]=W+h+1,E[I++]=W+h;for(W=(p=g-2)*F,J=(p+1)*F,h=0;h<F-1;h++)E[I++]=J+h,E[I++]=W+h+1,E[I++]=W+h;return new u.Geometry({attributes:Y,indices:E,primitiveType:u.PrimitiveType.TRIANGLES,boundingSphere:o.BoundingSphere.fromEllipsoid(P),offsetAttribute:t._offsetAttribute})}},P.getUnitEllipsoid=function(){return e.defined(_)||(_=P.createGeometry(new P({radii:new n.Cartesian3(1,1,1),vertexFormat:p.VertexFormat.POSITION_ONLY}))),_},t.EllipsoidGeometry=P}));
