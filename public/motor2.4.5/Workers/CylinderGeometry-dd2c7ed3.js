/**
 * Cesium - https://github.com/AnalyticalGraphicsInc/cesium
 *
 * Copyright 2011-2017 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md for full licensing details.
 */
define(["exports","./when-4ca4e419","./Check-430b3551","./defineProperties-163ddb68","./Cartesian3-32451e63","./Transforms-7b04d7e0","./Cartesian2-f49a1383","./ComponentDatatype-329b9462","./GeometryAttribute-b8faa946","./GeometryAttributes-614c63f8","./IndexDatatype-153fdd7f","./arrayFill-11a46844","./VertexFormat-a4fe3a21","./CylinderGeometryLibrary-5646cdc3"],(function(e,t,r,a,o,n,i,s,u,d,f,m,p,l){"use strict";var y=new i.Cartesian2,b=new o.Cartesian3,v=new o.Cartesian3,c=new o.Cartesian3,A=new o.Cartesian3;function h(e){var a=(e=t.defaultValue(e,t.defaultValue.EMPTY_OBJECT)).length,o=e.topRadius,n=e.bottomRadius,i=t.defaultValue(e.vertexFormat,p.VertexFormat.DEFAULT),s=t.defaultValue(e.slices,128);if(!t.defined(a))throw new r.DeveloperError("options.length must be defined.");if(!t.defined(o))throw new r.DeveloperError("options.topRadius must be defined.");if(!t.defined(n))throw new r.DeveloperError("options.bottomRadius must be defined.");if(s<3)throw new r.DeveloperError("options.slices must be greater than or equal to 3.");if(t.defined(e.offsetAttribute)&&e.offsetAttribute===u.GeometryOffsetAttribute.TOP)throw new r.DeveloperError("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._length=a,this._topRadius=o,this._bottomRadius=n,this._vertexFormat=p.VertexFormat.clone(i),this._slices=s,this._offsetAttribute=e.offsetAttribute,this._workerName="createCylinderGeometry"}h.packedLength=p.VertexFormat.packedLength+5,h.pack=function(e,a,o){if(!t.defined(e))throw new r.DeveloperError("value is required");if(!t.defined(a))throw new r.DeveloperError("array is required");return o=t.defaultValue(o,0),p.VertexFormat.pack(e._vertexFormat,a,o),o+=p.VertexFormat.packedLength,a[o++]=e._length,a[o++]=e._topRadius,a[o++]=e._bottomRadius,a[o++]=e._slices,a[o]=t.defaultValue(e._offsetAttribute,-1),a};var w,g=new p.VertexFormat,x={vertexFormat:g,length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,offsetAttribute:void 0};h.unpack=function(e,a,o){if(!t.defined(e))throw new r.DeveloperError("array is required");a=t.defaultValue(a,0);var n=p.VertexFormat.unpack(e,a,g);a+=p.VertexFormat.packedLength;var i=e[a++],s=e[a++],u=e[a++],d=e[a++],f=e[a];return t.defined(o)?(o._vertexFormat=p.VertexFormat.clone(n,o._vertexFormat),o._length=i,o._topRadius=s,o._bottomRadius=u,o._slices=d,o._offsetAttribute=-1===f?void 0:f,o):(x.length=i,x.topRadius=s,x.bottomRadius=u,x.slices=d,x.offsetAttribute=-1===f?void 0:f,new h(x))},h.createGeometry=function(e){var r=e._length,p=e._topRadius,h=e._bottomRadius,w=e._vertexFormat,g=e._slices;if(!(r<=0||p<0||h<0||0===p&&0===h)){var x,_=g+g,C=g+_,F=_+_,D=l.CylinderGeometryLibrary.computePositions(r,p,h,g,!0),G=w.st?new Float32Array(2*F):void 0,R=w.normal?new Float32Array(3*F):void 0,O=w.tangent?new Float32Array(3*F):void 0,T=w.bitangent?new Float32Array(3*F):void 0,V=w.normal||w.tangent||w.bitangent;if(V){var E=w.tangent||w.bitangent,L=0,P=0,k=0,z=Math.atan2(h-p,r),M=b;M.z=Math.sin(z);var N=Math.cos(z),I=c,U=v;for(x=0;x<g;x++){var S=x/g*a.CesiumMath.TWO_PI,q=N*Math.cos(S),B=N*Math.sin(S);V&&(M.x=q,M.y=B,E&&(I=o.Cartesian3.normalize(o.Cartesian3.cross(o.Cartesian3.UNIT_Z,M,I),I)),w.normal&&(R[L++]=M.x,R[L++]=M.y,R[L++]=M.z,R[L++]=M.x,R[L++]=M.y,R[L++]=M.z),w.tangent&&(O[P++]=I.x,O[P++]=I.y,O[P++]=I.z,O[P++]=I.x,O[P++]=I.y,O[P++]=I.z),w.bitangent&&(U=o.Cartesian3.normalize(o.Cartesian3.cross(M,I,U),U),T[k++]=U.x,T[k++]=U.y,T[k++]=U.z,T[k++]=U.x,T[k++]=U.y,T[k++]=U.z))}for(x=0;x<g;x++)w.normal&&(R[L++]=0,R[L++]=0,R[L++]=-1),w.tangent&&(O[P++]=1,O[P++]=0,O[P++]=0),w.bitangent&&(T[k++]=0,T[k++]=-1,T[k++]=0);for(x=0;x<g;x++)w.normal&&(R[L++]=0,R[L++]=0,R[L++]=1),w.tangent&&(O[P++]=1,O[P++]=0,O[P++]=0),w.bitangent&&(T[k++]=0,T[k++]=1,T[k++]=0)}var Y=12*g-12,Z=f.IndexDatatype.createTypedArray(F,Y),J=0,W=0;for(x=0;x<g-1;x++)Z[J++]=W,Z[J++]=W+2,Z[J++]=W+3,Z[J++]=W,Z[J++]=W+3,Z[J++]=W+1,W+=2;for(Z[J++]=_-2,Z[J++]=0,Z[J++]=1,Z[J++]=_-2,Z[J++]=1,Z[J++]=_-1,x=1;x<g-1;x++)Z[J++]=_+x+1,Z[J++]=_+x,Z[J++]=_;for(x=1;x<g-1;x++)Z[J++]=C,Z[J++]=C+x,Z[J++]=C+x+1;var j=0;if(w.st){var H=Math.max(p,h);for(x=0;x<F;x++){var K=o.Cartesian3.fromArray(D,3*x,A);G[j++]=(K.x+H)/(2*H),G[j++]=(K.y+H)/(2*H)}}var Q=new d.GeometryAttributes;w.position&&(Q.position=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:D})),w.normal&&(Q.normal=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:R})),w.tangent&&(Q.tangent=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:O})),w.bitangent&&(Q.bitangent=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:T})),w.st&&(Q.st=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:G})),y.x=.5*r,y.y=Math.max(h,p);var X=new n.BoundingSphere(o.Cartesian3.ZERO,i.Cartesian2.magnitude(y));if(t.defined(e._offsetAttribute)){r=D.length;var $=new Uint8Array(r/3),ee=e._offsetAttribute===u.GeometryOffsetAttribute.NONE?0:1;m.arrayFill($,ee),Q.applyOffset=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:$})}return new u.Geometry({attributes:Q,indices:Z,primitiveType:u.PrimitiveType.TRIANGLES,boundingSphere:X,offsetAttribute:e._offsetAttribute})}},h.getUnitCylinder=function(){return t.defined(w)||(w=h.createGeometry(new h({topRadius:1,bottomRadius:1,length:1,vertexFormat:p.VertexFormat.POSITION_ONLY}))),w},e.CylinderGeometry=h}));
