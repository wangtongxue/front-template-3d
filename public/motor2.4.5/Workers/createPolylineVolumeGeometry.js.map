{"version":3,"file":"createPolylineVolumeGeometry.js","sources":["../../../../Source/Core/oneTimeWarning.js","../../../../Source/Core/PolylineVolumeGeometry.js","../../../../Source/WorkersES6/createPolylineVolumeGeometry.js"],"sourcesContent":["import defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\n\r\n    var warnings = {};\r\n\r\n    /**\r\n     * Logs a one time message to the console.  Use this function instead of\r\n     * <code>console.log</code> directly since this does not log duplicate messages\r\n     * unless it is called from multiple workers.\r\n     *\r\n     * @exports oneTimeWarning\r\n     *\r\n     * @param {String} identifier The unique identifier for this warning.\r\n     * @param {String} [message=identifier] The message to log to the console.\r\n     *\r\n     * @example\r\n     * for(var i=0;i<foo.length;++i) {\r\n     *    if (!defined(foo[i].bar)) {\r\n     *       // Something that can be recovered from but may happen a lot\r\n     *       oneTimeWarning('foo.bar undefined', 'foo.bar is undefined. Setting to 0.');\r\n     *       foo[i].bar = 0;\r\n     *       // ...\r\n     *    }\r\n     * }\r\n     *\r\n     * @private\r\n     */\r\n    function oneTimeWarning(identifier, message) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(identifier)) {\r\n            throw new DeveloperError('identifier is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(warnings[identifier])) {\r\n            warnings[identifier] = true;\r\n            console.warn(defaultValue(message, identifier));\r\n        }\r\n    }\r\n\r\n    oneTimeWarning.geometryOutlines = 'Entity geometry outlines are unsupported on terrain. Outlines will be disabled. To enable outlines, disable geometry terrain clamping by explicitly setting height to 0.';\r\n\r\n    oneTimeWarning.geometryZIndex = 'Entity geometry with zIndex are unsupported when height or extrudedHeight are defined.  zIndex will be ignored';\r\n\r\n    oneTimeWarning.geometryHeightReference = 'Entity corridor, ellipse, polygon or rectangle with heightReference must also have a defined height.  heightReference will be ignored';\r\n    oneTimeWarning.geometryExtrudedHeightReference = 'Entity corridor, ellipse, polygon or rectangle with extrudedHeightReference must also have a defined extrudedHeight.  extrudedHeightReference will be ignored';\r\nexport default oneTimeWarning;\r\n","import arrayRemoveDuplicates from './arrayRemoveDuplicates.js';\r\nimport BoundingRectangle from './BoundingRectangle.js';\r\nimport BoundingSphere from './BoundingSphere.js';\r\nimport Cartesian2 from './Cartesian2.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport ComponentDatatype from './ComponentDatatype.js';\r\nimport CornerType from './CornerType.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport Geometry from './Geometry.js';\r\nimport GeometryAttribute from './GeometryAttribute.js';\r\nimport GeometryAttributes from './GeometryAttributes.js';\r\nimport GeometryPipeline from './GeometryPipeline.js';\r\nimport IndexDatatype from './IndexDatatype.js';\r\nimport CesiumMath from './Math.js';\r\nimport oneTimeWarning from './oneTimeWarning.js';\r\nimport PolygonPipeline from './PolygonPipeline.js';\r\nimport PolylineVolumeGeometryLibrary from './PolylineVolumeGeometryLibrary.js';\r\nimport PrimitiveType from './PrimitiveType.js';\r\nimport VertexFormat from './VertexFormat.js';\r\nimport WindingOrder from './WindingOrder.js';\r\n\r\n    function computeAttributes(combinedPositions, shape, boundingRectangle, vertexFormat) {\r\n        var attributes = new GeometryAttributes();\r\n        if (vertexFormat.position) {\r\n            attributes.position = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.DOUBLE,\r\n                componentsPerAttribute : 3,\r\n                values : combinedPositions\r\n            });\r\n        }\r\n        var shapeLength = shape.length;\r\n        var vertexCount = combinedPositions.length / 3;\r\n        var length = (vertexCount - shapeLength * 2) / (shapeLength * 2);\r\n        var firstEndIndices = PolygonPipeline.triangulate(shape);\r\n\r\n        var indicesCount = (length - 1) * (shapeLength) * 6 + firstEndIndices.length * 2;\r\n        var indices = IndexDatatype.createTypedArray(vertexCount, indicesCount);\r\n        var i, j;\r\n        var ll, ul, ur, lr;\r\n        var offset = shapeLength * 2;\r\n        var index = 0;\r\n        for (i = 0; i < length - 1; i++) {\r\n            for (j = 0; j < shapeLength - 1; j++) {\r\n                ll = j * 2 + i * shapeLength * 2;\r\n                lr = ll + offset;\r\n                ul = ll + 1;\r\n                ur = ul + offset;\r\n\r\n                indices[index++] = ul;\r\n                indices[index++] = ll;\r\n                indices[index++] = ur;\r\n                indices[index++] = ur;\r\n                indices[index++] = ll;\r\n                indices[index++] = lr;\r\n            }\r\n            ll = shapeLength * 2 - 2 + i * shapeLength * 2;\r\n            ul = ll + 1;\r\n            ur = ul + offset;\r\n            lr = ll + offset;\r\n\r\n            indices[index++] = ul;\r\n            indices[index++] = ll;\r\n            indices[index++] = ur;\r\n            indices[index++] = ur;\r\n            indices[index++] = ll;\r\n            indices[index++] = lr;\r\n        }\r\n\r\n        if (vertexFormat.st || vertexFormat.tangent || vertexFormat.bitangent) { // st required for tangent/bitangent calculation\r\n            var st = new Float32Array(vertexCount * 2);\r\n            var lengthSt = 1 / (length - 1);\r\n            var heightSt = 1 / (boundingRectangle.height);\r\n            var heightOffset = boundingRectangle.height / 2;\r\n            var s, t;\r\n            var stindex = 0;\r\n            for (i = 0; i < length; i++) {\r\n                s = i * lengthSt;\r\n                t = heightSt * (shape[0].y + heightOffset);\r\n                st[stindex++] = s;\r\n                st[stindex++] = t;\r\n                for (j = 1; j < shapeLength; j++) {\r\n                    t = heightSt * (shape[j].y + heightOffset);\r\n                    st[stindex++] = s;\r\n                    st[stindex++] = t;\r\n                    st[stindex++] = s;\r\n                    st[stindex++] = t;\r\n                }\r\n                t = heightSt * (shape[0].y + heightOffset);\r\n                st[stindex++] = s;\r\n                st[stindex++] = t;\r\n            }\r\n            for (j = 0; j < shapeLength; j++) {\r\n                s = 0;\r\n                t = heightSt * (shape[j].y + heightOffset);\r\n                st[stindex++] = s;\r\n                st[stindex++] = t;\r\n            }\r\n            for (j = 0; j < shapeLength; j++) {\r\n                s = (length - 1) * lengthSt;\r\n                t = heightSt * (shape[j].y + heightOffset);\r\n                st[stindex++] = s;\r\n                st[stindex++] = t;\r\n            }\r\n\r\n            attributes.st = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.FLOAT,\r\n                componentsPerAttribute : 2,\r\n                values : new Float32Array(st)\r\n            });\r\n        }\r\n\r\n        var endOffset = vertexCount - shapeLength * 2;\r\n        for (i = 0; i < firstEndIndices.length; i += 3) {\r\n            var v0 = firstEndIndices[i] + endOffset;\r\n            var v1 = firstEndIndices[i + 1] + endOffset;\r\n            var v2 = firstEndIndices[i + 2] + endOffset;\r\n\r\n            indices[index++] = v0;\r\n            indices[index++] = v1;\r\n            indices[index++] = v2;\r\n            indices[index++] = v2 + shapeLength;\r\n            indices[index++] = v1 + shapeLength;\r\n            indices[index++] = v0 + shapeLength;\r\n        }\r\n\r\n        var geometry = new Geometry({\r\n            attributes : attributes,\r\n            indices : indices,\r\n            boundingSphere : BoundingSphere.fromVertices(combinedPositions),\r\n            primitiveType : PrimitiveType.TRIANGLES\r\n        });\r\n\r\n        if (vertexFormat.normal) {\r\n            geometry = GeometryPipeline.computeNormal(geometry);\r\n        }\r\n\r\n        if (vertexFormat.tangent || vertexFormat.bitangent) {\r\n            try {\r\n                geometry = GeometryPipeline.computeTangentAndBitangent(geometry);\r\n            } catch (e) {\r\n                oneTimeWarning('polyline-volume-tangent-bitangent', 'Unable to compute tangents and bitangents for polyline volume geometry');\r\n                //TODO https://github.com/CesiumGS/cesium/issues/3609\r\n            }\r\n\r\n            if (!vertexFormat.tangent) {\r\n                geometry.attributes.tangent = undefined;\r\n            }\r\n            if (!vertexFormat.bitangent) {\r\n                geometry.attributes.bitangent = undefined;\r\n            }\r\n            if (!vertexFormat.st) {\r\n                geometry.attributes.st = undefined;\r\n            }\r\n        }\r\n\r\n        return geometry;\r\n    }\r\n\r\n    /**\r\n     * A description of a polyline with a volume (a 2D shape extruded along a polyline).\r\n     *\r\n     * @alias PolylineVolumeGeometry\r\n     * @constructor\r\n     *\r\n     * @param {Object} options Object with the following properties:\r\n     * @param {Cartesian3[]} options.polylinePositions An array of {@link Cartesain3} positions that define the center of the polyline volume.\r\n     * @param {Cartesian2[]} options.shapePositions An array of {@link Cartesian2} positions that define the shape to be extruded along the polyline\r\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\r\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\r\n     * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\r\n     *\r\n     * @see PolylineVolumeGeometry#createGeometry\r\n     *\r\n     * @demo {@link https://sandcastle.cesium.com/index.html?src=Polyline%20Volume.html|Cesium Sandcastle Polyline Volume Demo}\r\n     *\r\n     * @example\r\n     * function computeCircle(radius) {\r\n     *   var positions = [];\r\n     *   for (var i = 0; i < 360; i++) {\r\n     *     var radians = Cesium.Math.toRadians(i);\r\n     *     positions.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));\r\n     *   }\r\n     *   return positions;\r\n     * }\r\n     *\r\n     * var volume = new Cesium.PolylineVolumeGeometry({\r\n     *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\r\n     *   polylinePositions : Cesium.Cartesian3.fromDegreesArray([\r\n     *     -72.0, 40.0,\r\n     *     -70.0, 35.0\r\n     *   ]),\r\n     *   shapePositions : computeCircle(100000.0)\r\n     * });\r\n     */\r\n    function PolylineVolumeGeometry(options) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n        var positions = options.polylinePositions;\r\n        var shape = options.shapePositions;\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(positions)) {\r\n            throw new DeveloperError('options.polylinePositions is required.');\r\n        }\r\n        if (!defined(shape)) {\r\n            throw new DeveloperError('options.shapePositions is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        this._positions = positions;\r\n        this._shape = shape;\r\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\r\n        this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\r\n        this._vertexFormat = VertexFormat.clone(defaultValue(options.vertexFormat, VertexFormat.DEFAULT));\r\n        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\r\n        this._workerName = 'createPolylineVolumeGeometry';\r\n\r\n        var numComponents = 1 + positions.length * Cartesian3.packedLength;\r\n        numComponents += 1 + shape.length * Cartesian2.packedLength;\r\n\r\n        /**\r\n         * The number of elements used to pack the object into an array.\r\n         * @type {Number}\r\n         */\r\n        this.packedLength = numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 2;\r\n    }\r\n\r\n    /**\r\n     * Stores the provided instance into the provided array.\r\n     *\r\n     * @param {PolylineVolumeGeometry} value The value to pack.\r\n     * @param {Number[]} array The array to pack into.\r\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n     *\r\n     * @returns {Number[]} The array that was packed into\r\n     */\r\n    PolylineVolumeGeometry.pack = function(value, array, startingIndex) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(value)) {\r\n            throw new DeveloperError('value is required');\r\n        }\r\n        if (!defined(array)) {\r\n            throw new DeveloperError('array is required');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        var i;\r\n\r\n        var positions = value._positions;\r\n        var length = positions.length;\r\n        array[startingIndex++] = length;\r\n\r\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\r\n            Cartesian3.pack(positions[i], array, startingIndex);\r\n        }\r\n\r\n        var shape = value._shape;\r\n        length = shape.length;\r\n        array[startingIndex++] = length;\r\n\r\n        for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\r\n            Cartesian2.pack(shape[i], array, startingIndex);\r\n        }\r\n\r\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\r\n        startingIndex += Ellipsoid.packedLength;\r\n\r\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\r\n        startingIndex += VertexFormat.packedLength;\r\n\r\n        array[startingIndex++] = value._cornerType;\r\n        array[startingIndex]   = value._granularity;\r\n\r\n        return array;\r\n    };\r\n\r\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\r\n    var scratchVertexFormat = new VertexFormat();\r\n    var scratchOptions = {\r\n        polylinePositions : undefined,\r\n        shapePositions : undefined,\r\n        ellipsoid : scratchEllipsoid,\r\n        vertexFormat : scratchVertexFormat,\r\n        cornerType : undefined,\r\n        granularity : undefined\r\n    };\r\n\r\n    /**\r\n     * Retrieves an instance from a packed array.\r\n     *\r\n     * @param {Number[]} array The packed array.\r\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n     * @param {PolylineVolumeGeometry} [result] The object into which to store the result.\r\n     * @returns {PolylineVolumeGeometry} The modified result parameter or a new PolylineVolumeGeometry instance if one was not provided.\r\n     */\r\n    PolylineVolumeGeometry.unpack = function(array, startingIndex, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(array)) {\r\n            throw new DeveloperError('array is required');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        var i;\r\n\r\n        var length = array[startingIndex++];\r\n        var positions = new Array(length);\r\n\r\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\r\n            positions[i] = Cartesian3.unpack(array, startingIndex);\r\n        }\r\n\r\n        length = array[startingIndex++];\r\n        var shape = new Array(length);\r\n\r\n        for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\r\n            shape[i] = Cartesian2.unpack(array, startingIndex);\r\n        }\r\n\r\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\r\n        startingIndex += Ellipsoid.packedLength;\r\n\r\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\r\n        startingIndex += VertexFormat.packedLength;\r\n\r\n        var cornerType = array[startingIndex++];\r\n        var granularity = array[startingIndex];\r\n\r\n        if (!defined(result)) {\r\n            scratchOptions.polylinePositions = positions;\r\n            scratchOptions.shapePositions = shape;\r\n            scratchOptions.cornerType = cornerType;\r\n            scratchOptions.granularity = granularity;\r\n            return new PolylineVolumeGeometry(scratchOptions);\r\n        }\r\n\r\n        result._positions = positions;\r\n        result._shape = shape;\r\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\r\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\r\n        result._cornerType = cornerType;\r\n        result._granularity = granularity;\r\n\r\n        return result;\r\n    };\r\n\r\n    var brScratch = new BoundingRectangle();\r\n\r\n    /**\r\n     * Computes the geometric representation of a polyline with a volume, including its vertices, indices, and a bounding sphere.\r\n     *\r\n     * @param {PolylineVolumeGeometry} polylineVolumeGeometry A description of the polyline volume.\r\n     * @returns {Geometry|undefined} The computed vertices and indices.\r\n     */\r\n    PolylineVolumeGeometry.createGeometry = function(polylineVolumeGeometry) {\r\n        var positions = polylineVolumeGeometry._positions;\r\n        var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\r\n        var shape2D = polylineVolumeGeometry._shape;\r\n        shape2D = PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(shape2D);\r\n\r\n        if (cleanPositions.length < 2 || shape2D.length < 3) {\r\n            return undefined;\r\n        }\r\n\r\n        if (PolygonPipeline.computeWindingOrder2D(shape2D) === WindingOrder.CLOCKWISE) {\r\n            shape2D.reverse();\r\n        }\r\n        var boundingRectangle = BoundingRectangle.fromPoints(shape2D, brScratch);\r\n\r\n        var computedPositions = PolylineVolumeGeometryLibrary.computePositions(cleanPositions, shape2D, boundingRectangle, polylineVolumeGeometry, true);\r\n        return computeAttributes(computedPositions, shape2D, boundingRectangle, polylineVolumeGeometry._vertexFormat);\r\n    };\r\nexport default PolylineVolumeGeometry;\r\n","import defined from '../Core/defined.js';\r\nimport Ellipsoid from '../Core/Ellipsoid.js';\r\nimport PolylineVolumeGeometry from '../Core/PolylineVolumeGeometry.js';\r\n\r\n    function createPolylineVolumeGeometry(polylineVolumeGeometry, offset) {\r\n        if (defined(offset)) {\r\n            polylineVolumeGeometry = PolylineVolumeGeometry.unpack(polylineVolumeGeometry, offset);\r\n        }\r\n        polylineVolumeGeometry._ellipsoid = Ellipsoid.clone(polylineVolumeGeometry._ellipsoid);\r\n        return PolylineVolumeGeometry.createGeometry(polylineVolumeGeometry);\r\n    }\r\nexport default createPolylineVolumeGeometry;\r\n"],"names":["warnings","oneTimeWarning","identifier","message","defined","DeveloperError","console","warn","defaultValue","PolylineVolumeGeometry","options","positions","EMPTY_OBJECT","polylinePositions","shape","shapePositions","this","_positions","_shape","_ellipsoid","Ellipsoid","clone","ellipsoid","WGS84","_cornerType","cornerType","CornerType","ROUNDED","_vertexFormat","VertexFormat","vertexFormat","DEFAULT","_granularity","granularity","CesiumMath","RADIANS_PER_DEGREE","_workerName","numComponents","length","Cartesian3","packedLength","Cartesian2","geometryOutlines","geometryZIndex","geometryHeightReference","geometryExtrudedHeightReference","pack","value","array","startingIndex","i","scratchEllipsoid","UNIT_SPHERE","scratchVertexFormat","scratchOptions","undefined","unpack","result","Array","brScratch","BoundingRectangle","createGeometry","polylineVolumeGeometry","cleanPositions","arrayRemoveDuplicates","equalsEpsilon","shape2D","PolylineVolumeGeometryLibrary","removeDuplicatesFromShape","PolygonPipeline","computeWindingOrder2D","WindingOrder","CLOCKWISE","reverse","boundingRectangle","fromPoints","combinedPositions","attributes","GeometryAttributes","position","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","j","ll","ul","ur","lr","shapeLength","vertexCount","firstEndIndices","triangulate","indicesCount","indices","IndexDatatype","createTypedArray","offset","index","st","tangent","bitangent","s","t","Float32Array","lengthSt","heightSt","heightOffset","height","stindex","y","FLOAT","endOffset","v0","v1","v2","geometry","Geometry","boundingSphere","BoundingSphere","fromVertices","primitiveType","PrimitiveType","TRIANGLES","normal","GeometryPipeline","computeNormal","computeTangentAndBitangent","e","computeAttributes","computePositions"],"mappings":"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"}