{"version":3,"file":"createVerticesFromGoogleEarthEnterpriseBuffer.js","sources":["../../../../Source/WorkersES6/createVerticesFromGoogleEarthEnterpriseBuffer.js"],"sourcesContent":["import AxisAlignedBoundingBox from '../Core/AxisAlignedBoundingBox.js';\r\nimport BoundingSphere from '../Core/BoundingSphere.js';\r\nimport Cartesian2 from '../Core/Cartesian2.js';\r\nimport Cartesian3 from '../Core/Cartesian3.js';\r\nimport Cartographic from '../Core/Cartographic.js';\r\nimport defaultValue from '../Core/defaultValue.js';\r\nimport defined from '../Core/defined.js';\r\nimport Ellipsoid from '../Core/Ellipsoid.js';\r\nimport EllipsoidalOccluder from '../Core/EllipsoidalOccluder.js';\r\nimport CesiumMath from '../Core/Math.js';\r\nimport Matrix4 from '../Core/Matrix4.js';\r\nimport OrientedBoundingBox from '../Core/OrientedBoundingBox.js';\r\nimport Rectangle from '../Core/Rectangle.js';\r\nimport RuntimeError from '../Core/RuntimeError.js';\r\nimport TerrainEncoding from '../Core/TerrainEncoding.js';\r\nimport Transforms from '../Core/Transforms.js';\r\nimport WebMercatorProjection from '../Core/WebMercatorProjection.js';\r\nimport createTaskProcessorWorker from './createTaskProcessorWorker.js';\r\n\r\n    var sizeOfUint16 = Uint16Array.BYTES_PER_ELEMENT;\r\n    var sizeOfInt32 = Int32Array.BYTES_PER_ELEMENT;\r\n    var sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\r\n    var sizeOfFloat = Float32Array.BYTES_PER_ELEMENT;\r\n    var sizeOfDouble = Float64Array.BYTES_PER_ELEMENT;\r\n\r\n    function indexOfEpsilon(arr, elem, elemType) {\r\n        elemType = defaultValue(elemType, CesiumMath);\r\n        var count = arr.length;\r\n        for (var i = 0; i < count; ++i) {\r\n            if (elemType.equalsEpsilon(arr[i], elem, CesiumMath.EPSILON12)) {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    function createVerticesFromGoogleEarthEnterpriseBuffer(parameters, transferableObjects) {\r\n        parameters.ellipsoid = Ellipsoid.clone(parameters.ellipsoid);\r\n        parameters.rectangle = Rectangle.clone(parameters.rectangle);\r\n\r\n        var statistics = processBuffer(parameters.buffer, parameters.relativeToCenter, parameters.ellipsoid,\r\n            parameters.rectangle, parameters.nativeRectangle, parameters.exaggeration, parameters.skirtHeight,\r\n            parameters.includeWebMercatorT, parameters.negativeAltitudeExponentBias, parameters.negativeElevationThreshold);\r\n        var vertices = statistics.vertices;\r\n        transferableObjects.push(vertices.buffer);\r\n        var indices = statistics.indices;\r\n        transferableObjects.push(indices.buffer);\r\n\r\n        return {\r\n            vertices : vertices.buffer,\r\n            indices : indices.buffer,\r\n            numberOfAttributes : statistics.encoding.getStride(),\r\n            minimumHeight : statistics.minimumHeight,\r\n            maximumHeight : statistics.maximumHeight,\r\n            boundingSphere3D : statistics.boundingSphere3D,\r\n            orientedBoundingBox : statistics.orientedBoundingBox,\r\n            occludeePointInScaledSpace : statistics.occludeePointInScaledSpace,\r\n            encoding : statistics.encoding,\r\n            vertexCountWithoutSkirts : statistics.vertexCountWithoutSkirts,\r\n            indexCountWithoutSkirts : statistics.indexCountWithoutSkirts,\r\n            westIndicesSouthToNorth : statistics.westIndicesSouthToNorth,\r\n            southIndicesEastToWest : statistics.southIndicesEastToWest,\r\n            eastIndicesNorthToSouth : statistics.eastIndicesNorthToSouth,\r\n            northIndicesWestToEast : statistics.northIndicesWestToEast\r\n        };\r\n    }\r\n\r\n    var scratchCartographic = new Cartographic();\r\n    var scratchCartesian = new Cartesian3();\r\n    var minimumScratch = new Cartesian3();\r\n    var maximumScratch = new Cartesian3();\r\n    var matrix4Scratch = new Matrix4();\r\n\r\n    function processBuffer(buffer, relativeToCenter, ellipsoid, rectangle, nativeRectangle, exaggeration, skirtHeight, includeWebMercatorT, negativeAltitudeExponentBias, negativeElevationThreshold) {\r\n        var geographicWest;\r\n        var geographicSouth;\r\n        var geographicEast;\r\n        var geographicNorth;\r\n        var rectangleWidth, rectangleHeight;\r\n\r\n        if (!defined(rectangle)) {\r\n            geographicWest = CesiumMath.toRadians(nativeRectangle.west);\r\n            geographicSouth = CesiumMath.toRadians(nativeRectangle.south);\r\n            geographicEast = CesiumMath.toRadians(nativeRectangle.east);\r\n            geographicNorth = CesiumMath.toRadians(nativeRectangle.north);\r\n            rectangleWidth = CesiumMath.toRadians(rectangle.width);\r\n            rectangleHeight = CesiumMath.toRadians(rectangle.height);\r\n        } else {\r\n            geographicWest = rectangle.west;\r\n            geographicSouth = rectangle.south;\r\n            geographicEast = rectangle.east;\r\n            geographicNorth = rectangle.north;\r\n            rectangleWidth = rectangle.width;\r\n            rectangleHeight = rectangle.height;\r\n        }\r\n\r\n        // Keep track of quad borders so we can remove duplicates around the borders\r\n        var quadBorderLatitudes = [geographicSouth, geographicNorth];\r\n        var quadBorderLongitudes = [geographicWest, geographicEast];\r\n\r\n        var fromENU = Transforms.eastNorthUpToFixedFrame(relativeToCenter, ellipsoid);\r\n        var toENU = Matrix4.inverseTransformation(fromENU, matrix4Scratch);\r\n\r\n        var southMercatorY;\r\n        var oneOverMercatorHeight;\r\n        if (includeWebMercatorT) {\r\n            southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(geographicSouth);\r\n            oneOverMercatorHeight = 1.0 / (WebMercatorProjection.geodeticLatitudeToMercatorAngle(geographicNorth) - southMercatorY);\r\n        }\r\n\r\n        var dv = new DataView(buffer);\r\n\r\n        var minHeight = Number.POSITIVE_INFINITY;\r\n        var maxHeight = Number.NEGATIVE_INFINITY;\r\n\r\n        var minimum = minimumScratch;\r\n        minimum.x = Number.POSITIVE_INFINITY;\r\n        minimum.y = Number.POSITIVE_INFINITY;\r\n        minimum.z = Number.POSITIVE_INFINITY;\r\n\r\n        var maximum = maximumScratch;\r\n        maximum.x = Number.NEGATIVE_INFINITY;\r\n        maximum.y = Number.NEGATIVE_INFINITY;\r\n        maximum.z = Number.NEGATIVE_INFINITY;\r\n\r\n        // Compute sizes\r\n        var offset = 0;\r\n        var size = 0;\r\n        var indicesSize = 0;\r\n        var quadSize;\r\n        var quad;\r\n        for (quad = 0; quad < 4; ++quad) {\r\n            var o = offset;\r\n            quadSize = dv.getUint32(o, true);\r\n            o += sizeOfUint32;\r\n\r\n            var x = CesiumMath.toRadians(dv.getFloat64(o, true) * 180.0);\r\n            o += sizeOfDouble;\r\n            if (indexOfEpsilon(quadBorderLongitudes, x) === -1) {\r\n                quadBorderLongitudes.push(x);\r\n            }\r\n\r\n            var y = CesiumMath.toRadians(dv.getFloat64(o, true) * 180.0);\r\n            o += sizeOfDouble;\r\n            if (indexOfEpsilon(quadBorderLatitudes, y) === -1) {\r\n                quadBorderLatitudes.push(y);\r\n            }\r\n\r\n            o += 2 * sizeOfDouble; // stepX + stepY\r\n\r\n            var c = dv.getInt32(o, true); // Read point count\r\n            o += sizeOfInt32;\r\n            size += c;\r\n\r\n            c = dv.getInt32(o, true); // Read index count\r\n            indicesSize += c * 3;\r\n\r\n            offset += quadSize + sizeOfUint32; // Jump to next quad\r\n        }\r\n\r\n        // Quad Border points to remove duplicates\r\n        var quadBorderPoints = [];\r\n        var quadBorderIndices = [];\r\n\r\n        // Create arrays\r\n        var positions = new Array(size);\r\n        var uvs = new Array(size);\r\n        var heights = new Array(size);\r\n        var webMercatorTs = includeWebMercatorT ? new Array(size) : [];\r\n        var indices = new Array(indicesSize);\r\n\r\n        // Points are laid out in rows starting at SW, so storing border points as we\r\n        //  come across them all points will be adjacent.\r\n        var westBorder = [];\r\n        var southBorder = [];\r\n        var eastBorder = [];\r\n        var northBorder = [];\r\n\r\n        // Each tile is split into 4 parts\r\n        var pointOffset = 0;\r\n        var indicesOffset = 0;\r\n        offset = 0;\r\n        for (quad = 0; quad < 4; ++quad) {\r\n            quadSize = dv.getUint32(offset, true);\r\n            offset += sizeOfUint32;\r\n            var startQuad = offset;\r\n\r\n            var originX = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\r\n            offset += sizeOfDouble;\r\n\r\n            var originY = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\r\n            offset += sizeOfDouble;\r\n\r\n            var stepX = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\r\n            var halfStepX = stepX * 0.5;\r\n            offset += sizeOfDouble;\r\n\r\n            var stepY = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\r\n            var halfStepY = stepY * 0.5;\r\n            offset += sizeOfDouble;\r\n\r\n            var numPoints = dv.getInt32(offset, true);\r\n            offset += sizeOfInt32;\r\n\r\n            var numFaces = dv.getInt32(offset, true);\r\n            offset += sizeOfInt32;\r\n\r\n            //var level = dv.getInt32(offset, true);\r\n            offset += sizeOfInt32;\r\n\r\n            // Keep track of quad indices to overall tile indices\r\n            var indicesMapping = new Array(numPoints);\r\n            for (var i = 0; i < numPoints; ++i) {\r\n                var longitude = originX + dv.getUint8(offset++) * stepX;\r\n                scratchCartographic.longitude = longitude;\r\n                var latitude = originY + dv.getUint8(offset++) * stepY;\r\n                scratchCartographic.latitude = latitude;\r\n\r\n                var height = dv.getFloat32(offset, true);\r\n                offset += sizeOfFloat;\r\n\r\n                // In order to support old clients, negative altitude values are stored as\r\n                // height/-2^32. Old clients see the value as really close to 0 but new clients multiply\r\n                // by -2^32 to get the real negative altitude value.\r\n                if (height !== 0 && height < negativeElevationThreshold) {\r\n                    height *= -Math.pow(2, negativeAltitudeExponentBias);\r\n                }\r\n\r\n                // Height is stored in units of (1/EarthRadius) or (1/6371010.0)\r\n                height *= 6371010.0 * exaggeration;\r\n\r\n                scratchCartographic.height = height;\r\n\r\n                // Is it along a quad border - if so check if already exists and use that index\r\n                if (indexOfEpsilon(quadBorderLongitudes, longitude) !== -1 ||\r\n                    indexOfEpsilon(quadBorderLatitudes, latitude) !== -1) {\r\n                    var index = indexOfEpsilon(quadBorderPoints, scratchCartographic, Cartographic);\r\n                    if (index === -1) {\r\n                        quadBorderPoints.push(Cartographic.clone(scratchCartographic));\r\n                        quadBorderIndices.push(pointOffset);\r\n                    } else {\r\n                        indicesMapping[i] = quadBorderIndices[index];\r\n                        continue;\r\n                    }\r\n                }\r\n                indicesMapping[i] = pointOffset;\r\n\r\n                if (Math.abs(longitude - geographicWest) < halfStepX) {\r\n                    westBorder.push({\r\n                        index : pointOffset,\r\n                        cartographic : Cartographic.clone(scratchCartographic)\r\n                    });\r\n                } else if (Math.abs(longitude - geographicEast) < halfStepX) {\r\n                    eastBorder.push({\r\n                        index : pointOffset,\r\n                        cartographic : Cartographic.clone(scratchCartographic)\r\n                    });\r\n                } else if (Math.abs(latitude - geographicSouth) < halfStepY) {\r\n                    southBorder.push({\r\n                        index : pointOffset,\r\n                        cartographic : Cartographic.clone(scratchCartographic)\r\n                    });\r\n                } else if (Math.abs(latitude - geographicNorth) < halfStepY) {\r\n                    northBorder.push({\r\n                        index : pointOffset,\r\n                        cartographic : Cartographic.clone(scratchCartographic)\r\n                    });\r\n                }\r\n\r\n                minHeight = Math.min(height, minHeight);\r\n                maxHeight = Math.max(height, maxHeight);\r\n                heights[pointOffset] = height;\r\n\r\n                var pos = ellipsoid.cartographicToCartesian(scratchCartographic);\r\n                positions[pointOffset] = pos;\r\n\r\n                if (includeWebMercatorT) {\r\n                    webMercatorTs[pointOffset] = (WebMercatorProjection.geodeticLatitudeToMercatorAngle(latitude) - southMercatorY) * oneOverMercatorHeight;\r\n                }\r\n\r\n                Matrix4.multiplyByPoint(toENU, pos, scratchCartesian);\r\n\r\n                Cartesian3.minimumByComponent(scratchCartesian, minimum, minimum);\r\n                Cartesian3.maximumByComponent(scratchCartesian, maximum, maximum);\r\n\r\n                var u = (longitude - geographicWest) / (geographicEast - geographicWest);\r\n                u = CesiumMath.clamp(u, 0.0, 1.0);\r\n                var v = (latitude - geographicSouth) / (geographicNorth - geographicSouth);\r\n                v = CesiumMath.clamp(v, 0.0, 1.0);\r\n\r\n                uvs[pointOffset] = new Cartesian2(u, v);\r\n                ++pointOffset;\r\n            }\r\n\r\n            var facesElementCount = numFaces * 3;\r\n            for (var j = 0; j < facesElementCount; ++j, ++indicesOffset) {\r\n                indices[indicesOffset] = indicesMapping[dv.getUint16(offset, true)];\r\n                offset += sizeOfUint16;\r\n            }\r\n\r\n            if (quadSize !== (offset - startQuad)) {\r\n                throw new RuntimeError('Invalid terrain tile.');\r\n            }\r\n        }\r\n\r\n        positions.length = pointOffset;\r\n        uvs.length = pointOffset;\r\n        heights.length = pointOffset;\r\n        if (includeWebMercatorT) {\r\n            webMercatorTs.length = pointOffset;\r\n        }\r\n\r\n        var vertexCountWithoutSkirts = pointOffset;\r\n        var indexCountWithoutSkirts = indicesOffset;\r\n\r\n        // Add skirt points\r\n        var skirtOptions = {\r\n            hMin : minHeight,\r\n            lastBorderPoint : undefined,\r\n            skirtHeight : skirtHeight,\r\n            toENU : toENU,\r\n            ellipsoid : ellipsoid,\r\n            minimum : minimum,\r\n            maximum : maximum\r\n        };\r\n\r\n        // Sort counter clockwise from NW corner\r\n        // Corner points are in the east/west arrays\r\n        westBorder.sort(function(a, b) {\r\n            return b.cartographic.latitude - a.cartographic.latitude;\r\n        });\r\n        southBorder.sort(function(a, b) {\r\n            return a.cartographic.longitude - b.cartographic.longitude;\r\n        });\r\n        eastBorder.sort(function(a, b) {\r\n            return a.cartographic.latitude - b.cartographic.latitude;\r\n        });\r\n        northBorder.sort(function(a, b) {\r\n            return b.cartographic.longitude - a.cartographic.longitude;\r\n        });\r\n\r\n        var percentage = 0.00001;\r\n        addSkirt(positions, heights, uvs, webMercatorTs, indices, skirtOptions,\r\n            westBorder, -percentage * rectangleWidth, true, -percentage * rectangleHeight);\r\n        addSkirt(positions, heights, uvs, webMercatorTs, indices, skirtOptions,\r\n            southBorder, -percentage * rectangleHeight, false);\r\n        addSkirt(positions, heights, uvs, webMercatorTs, indices, skirtOptions,\r\n            eastBorder, percentage * rectangleWidth, true, percentage * rectangleHeight);\r\n        addSkirt(positions, heights, uvs, webMercatorTs, indices, skirtOptions,\r\n            northBorder, percentage * rectangleHeight, false);\r\n\r\n        // Since the corner between the north and west sides is in the west array, generate the last\r\n        //  two triangles between the last north vertex and the first west vertex\r\n        if (westBorder.length > 0 && northBorder.length > 0) {\r\n            var firstBorderIndex = westBorder[0].index;\r\n            var firstSkirtIndex = vertexCountWithoutSkirts;\r\n            var lastBorderIndex = northBorder[northBorder.length - 1].index;\r\n            var lastSkirtIndex = positions.length - 1;\r\n\r\n            indices.push(lastBorderIndex, lastSkirtIndex, firstSkirtIndex, firstSkirtIndex, firstBorderIndex, lastBorderIndex);\r\n        }\r\n\r\n        size = positions.length; // Get new size with skirt vertices\r\n\r\n        var boundingSphere3D = BoundingSphere.fromPoints(positions);\r\n        var orientedBoundingBox;\r\n        if (defined(rectangle)) {\r\n            orientedBoundingBox = OrientedBoundingBox.fromRectangle(rectangle, minHeight, maxHeight, ellipsoid);\r\n        }\r\n\r\n        var occluder = new EllipsoidalOccluder(ellipsoid);\r\n        var occludeePointInScaledSpace = occluder.computeHorizonCullingPointPossiblyUnderEllipsoid(relativeToCenter, positions, minHeight);\r\n\r\n        var aaBox = new AxisAlignedBoundingBox(minimum, maximum, relativeToCenter);\r\n        var encoding = new TerrainEncoding(aaBox, skirtOptions.hMin, maxHeight, fromENU, false, includeWebMercatorT);\r\n        var vertices = new Float32Array(size * encoding.getStride());\r\n\r\n        var bufferIndex = 0;\r\n        for (var k = 0; k < size; ++k) {\r\n            bufferIndex = encoding.encode(vertices, bufferIndex, positions[k], uvs[k], heights[k], undefined, webMercatorTs[k]);\r\n        }\r\n\r\n        var westIndicesSouthToNorth = westBorder.map(function(vertex) { return vertex.index; }).reverse();\r\n        var southIndicesEastToWest = southBorder.map(function(vertex) { return vertex.index; }).reverse();\r\n        var eastIndicesNorthToSouth = eastBorder.map(function(vertex) { return vertex.index; }).reverse();\r\n        var northIndicesWestToEast = northBorder.map(function(vertex) { return vertex.index; }).reverse();\r\n\r\n        southIndicesEastToWest.unshift(eastIndicesNorthToSouth[eastIndicesNorthToSouth.length - 1]);\r\n        southIndicesEastToWest.push(westIndicesSouthToNorth[0]);\r\n\r\n        northIndicesWestToEast.unshift(westIndicesSouthToNorth[westIndicesSouthToNorth.length - 1]);\r\n        northIndicesWestToEast.push(eastIndicesNorthToSouth[0]);\r\n\r\n        return {\r\n            vertices : vertices,\r\n            indices : new Uint16Array(indices),\r\n            maximumHeight : maxHeight,\r\n            minimumHeight : minHeight,\r\n            encoding : encoding,\r\n            boundingSphere3D : boundingSphere3D,\r\n            orientedBoundingBox : orientedBoundingBox,\r\n            occludeePointInScaledSpace : occludeePointInScaledSpace,\r\n            vertexCountWithoutSkirts : vertexCountWithoutSkirts,\r\n            indexCountWithoutSkirts : indexCountWithoutSkirts,\r\n            westIndicesSouthToNorth : westIndicesSouthToNorth,\r\n            southIndicesEastToWest : southIndicesEastToWest,\r\n            eastIndicesNorthToSouth : eastIndicesNorthToSouth,\r\n            northIndicesWestToEast : northIndicesWestToEast\r\n        };\r\n    }\r\n\r\n    function addSkirt(positions, heights, uvs, webMercatorTs, indices, skirtOptions,\r\n                      borderPoints, fudgeFactor, eastOrWest, cornerFudge) {\r\n        var count = borderPoints.length;\r\n        for (var j = 0; j < count; ++j) {\r\n            var borderPoint = borderPoints[j];\r\n            var borderCartographic = borderPoint.cartographic;\r\n            var borderIndex = borderPoint.index;\r\n            var currentIndex = positions.length;\r\n\r\n            var longitude = borderCartographic.longitude;\r\n            var latitude = borderCartographic.latitude;\r\n            latitude = CesiumMath.clamp(latitude, -CesiumMath.PI_OVER_TWO, CesiumMath.PI_OVER_TWO); // Don't go over the poles\r\n            var height = borderCartographic.height - skirtOptions.skirtHeight;\r\n            skirtOptions.hMin = Math.min(skirtOptions.hMin, height);\r\n\r\n            Cartographic.fromRadians(longitude, latitude, height, scratchCartographic);\r\n\r\n            // Adjust sides to angle out\r\n            if (eastOrWest) {\r\n                scratchCartographic.longitude += fudgeFactor;\r\n            }\r\n\r\n            // Adjust top or bottom to angle out\r\n            // Since corners are in the east/west arrays angle the first and last points as well\r\n            if (!eastOrWest) {\r\n                scratchCartographic.latitude += fudgeFactor;\r\n            } else if (j === (count - 1)) {\r\n                scratchCartographic.latitude += cornerFudge;\r\n            } else if (j === 0) {\r\n                scratchCartographic.latitude -= cornerFudge;\r\n            }\r\n\r\n            var pos = skirtOptions.ellipsoid.cartographicToCartesian(scratchCartographic);\r\n            positions.push(pos);\r\n            heights.push(height);\r\n            uvs.push(Cartesian2.clone(uvs[borderIndex])); // Copy UVs from border point\r\n            if (webMercatorTs.length > 0) {\r\n                webMercatorTs.push(webMercatorTs[borderIndex]);\r\n            }\r\n\r\n            Matrix4.multiplyByPoint(skirtOptions.toENU, pos, scratchCartesian);\r\n\r\n            var minimum = skirtOptions.minimum;\r\n            var maximum = skirtOptions.maximum;\r\n            Cartesian3.minimumByComponent(scratchCartesian, minimum, minimum);\r\n            Cartesian3.maximumByComponent(scratchCartesian, maximum, maximum);\r\n\r\n            var lastBorderPoint = skirtOptions.lastBorderPoint;\r\n            if (defined(lastBorderPoint)) {\r\n                var lastBorderIndex = lastBorderPoint.index;\r\n                indices.push(lastBorderIndex, currentIndex - 1, currentIndex, currentIndex, borderIndex, lastBorderIndex);\r\n            }\r\n\r\n            skirtOptions.lastBorderPoint = borderPoint;\r\n        }\r\n    }\r\nexport default createTaskProcessorWorker(createVerticesFromGoogleEarthEnterpriseBuffer);\r\n"],"names":["sizeOfUint16","Uint16Array","BYTES_PER_ELEMENT","sizeOfInt32","Int32Array","sizeOfUint32","Uint32Array","sizeOfFloat","Float32Array","sizeOfDouble","Float64Array","indexOfEpsilon","arr","elem","elemType","defaultValue","CesiumMath","count","length","i","equalsEpsilon","EPSILON12","scratchCartographic","Cartographic","scratchCartesian","Cartesian3","minimumScratch","maximumScratch","matrix4Scratch","Matrix4","addSkirt","positions","heights","uvs","webMercatorTs","indices","skirtOptions","borderPoints","fudgeFactor","eastOrWest","cornerFudge","j","borderPoint","borderCartographic","cartographic","borderIndex","index","currentIndex","longitude","latitude","clamp","PI_OVER_TWO","height","skirtHeight","hMin","Math","min","fromRadians","pos","ellipsoid","cartographicToCartesian","push","Cartesian2","clone","multiplyByPoint","toENU","minimum","maximum","minimumByComponent","maximumByComponent","lastBorderPoint","defined","lastBorderIndex","createTaskProcessorWorker","parameters","transferableObjects","Ellipsoid","rectangle","Rectangle","statistics","buffer","relativeToCenter","nativeRectangle","exaggeration","includeWebMercatorT","negativeAltitudeExponentBias","negativeElevationThreshold","geographicWest","geographicSouth","geographicEast","geographicNorth","rectangleWidth","rectangleHeight","west","south","east","north","width","toRadians","southMercatorY","oneOverMercatorHeight","quadBorderLatitudes","quadBorderLongitudes","fromENU","Transforms","eastNorthUpToFixedFrame","inverseTransformation","WebMercatorProjection","geodeticLatitudeToMercatorAngle","dv","DataView","minHeight","Number","POSITIVE_INFINITY","maxHeight","NEGATIVE_INFINITY","x","y","z","quadSize","quad","offset","size","indicesSize","o","getUint32","getFloat64","c","getInt32","quadBorderPoints","quadBorderIndices","Array","westBorder","southBorder","eastBorder","northBorder","pointOffset","indicesOffset","startQuad","originX","originY","stepX","halfStepX","stepY","halfStepY","numPoints","numFaces","indicesMapping","getUint8","getFloat32","pow","abs","max","u","v","facesElementCount","getUint16","RuntimeError","vertexCountWithoutSkirts","indexCountWithoutSkirts","undefined","sort","a","b","firstBorderIndex","firstSkirtIndex","lastSkirtIndex","orientedBoundingBox","boundingSphere3D","BoundingSphere","fromPoints","OrientedBoundingBox","fromRectangle","occludeePointInScaledSpace","EllipsoidalOccluder","computeHorizonCullingPointPossiblyUnderEllipsoid","aaBox","AxisAlignedBoundingBox","encoding","TerrainEncoding","vertices","getStride","bufferIndex","k","encode","westIndicesSouthToNorth","map","vertex","reverse","southIndicesEastToWest","eastIndicesNorthToSouth","northIndicesWestToEast","unshift","maximumHeight","minimumHeight","processBuffer","numberOfAttributes"],"mappings":"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"}