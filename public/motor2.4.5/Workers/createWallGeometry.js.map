{"version":3,"file":"createWallGeometry.js","sources":["../../../../Source/Core/WallGeometry.js","../../../../Source/WorkersES6/createWallGeometry.js"],"sourcesContent":["import BoundingSphere from './BoundingSphere.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport ComponentDatatype from './ComponentDatatype.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport Geometry from './Geometry.js';\r\nimport GeometryAttribute from './GeometryAttribute.js';\r\nimport GeometryAttributes from './GeometryAttributes.js';\r\nimport IndexDatatype from './IndexDatatype.js';\r\nimport CesiumMath from './Math.js';\r\nimport PrimitiveType from './PrimitiveType.js';\r\nimport VertexFormat from './VertexFormat.js';\r\nimport WallGeometryLibrary from './WallGeometryLibrary.js';\r\n\r\n    var scratchCartesian3Position1 = new Cartesian3();\r\n    var scratchCartesian3Position2 = new Cartesian3();\r\n    var scratchCartesian3Position3 = new Cartesian3();\r\n    var scratchCartesian3Position4 = new Cartesian3();\r\n    var scratchCartesian3Position5 = new Cartesian3();\r\n    var scratchBitangent = new Cartesian3();\r\n    var scratchTangent = new Cartesian3();\r\n    var scratchNormal = new Cartesian3();\r\n\r\n    /**\r\n     * A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,\r\n     * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\r\n     *\r\n     * @alias WallGeometry\r\n     * @constructor\r\n     *\r\n     * @param {Object} options Object with the following properties:\r\n     * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\r\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n     * @param {Number[]} [options.maximumHeights] An array parallel to <code>positions</code> that give the maximum height of the\r\n     *        wall at <code>positions</code>. If undefined, the height of each position in used.\r\n     * @param {Number[]} [options.minimumHeights] An array parallel to <code>positions</code> that give the minimum height of the\r\n     *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\r\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid for coordinate manipulation\r\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\r\n     *\r\n     * @exception {DeveloperError} positions length must be greater than or equal to 2.\r\n     * @exception {DeveloperError} positions and maximumHeights must have the same length.\r\n     * @exception {DeveloperError} positions and minimumHeights must have the same length.\r\n     *\r\n     * @see WallGeometry#createGeometry\r\n     * @see WallGeometry#fromConstantHeight\r\n     *\r\n     * @demo {@link https://sandcastle.cesium.com/index.html?src=Wall.html|Cesium Sandcastle Wall Demo}\r\n     *\r\n     * @example\r\n     * // create a wall that spans from ground level to 10000 meters\r\n     * var wall = new Cesium.WallGeometry({\r\n     *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\r\n     *     19.0, 47.0, 10000.0,\r\n     *     19.0, 48.0, 10000.0,\r\n     *     20.0, 48.0, 10000.0,\r\n     *     20.0, 47.0, 10000.0,\r\n     *     19.0, 47.0, 10000.0\r\n     *   ])\r\n     * });\r\n     * var geometry = Cesium.WallGeometry.createGeometry(wall);\r\n     */\r\n    function WallGeometry(options) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n        var wallPositions = options.positions;\r\n        var maximumHeights = options.maximumHeights;\r\n        var minimumHeights = options.minimumHeights;\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(wallPositions)) {\r\n            throw new DeveloperError('options.positions is required.');\r\n        }\r\n        if (defined(maximumHeights) && maximumHeights.length !== wallPositions.length) {\r\n            throw new DeveloperError('options.positions and options.maximumHeights must have the same length.');\r\n        }\r\n        if (defined(minimumHeights) && minimumHeights.length !== wallPositions.length) {\r\n            throw new DeveloperError('options.positions and options.minimumHeights must have the same length.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\r\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\r\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n\r\n        this._positions = wallPositions;\r\n        this._minimumHeights = minimumHeights;\r\n        this._maximumHeights = maximumHeights;\r\n        this._vertexFormat = VertexFormat.clone(vertexFormat);\r\n        this._granularity = granularity;\r\n        this._ellipsoid = Ellipsoid.clone(ellipsoid);\r\n        this._workerName = 'createWallGeometry';\r\n\r\n        var numComponents = 1 + wallPositions.length * Cartesian3.packedLength + 2;\r\n        if (defined(minimumHeights)) {\r\n            numComponents += minimumHeights.length;\r\n        }\r\n        if (defined(maximumHeights)) {\r\n            numComponents += maximumHeights.length;\r\n        }\r\n\r\n        /**\r\n         * The number of elements used to pack the object into an array.\r\n         * @type {Number}\r\n         */\r\n        this.packedLength = numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 1;\r\n    }\r\n\r\n    /**\r\n     * Stores the provided instance into the provided array.\r\n     *\r\n     * @param {WallGeometry} value The value to pack.\r\n     * @param {Number[]} array The array to pack into.\r\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n     *\r\n     * @returns {Number[]} The array that was packed into\r\n     */\r\n    WallGeometry.pack = function(value, array, startingIndex) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(value)) {\r\n            throw new DeveloperError('value is required');\r\n        }\r\n        if (!defined(array)) {\r\n            throw new DeveloperError('array is required');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        var i;\r\n\r\n        var positions = value._positions;\r\n        var length = positions.length;\r\n        array[startingIndex++] = length;\r\n\r\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\r\n            Cartesian3.pack(positions[i], array, startingIndex);\r\n        }\r\n\r\n        var minimumHeights = value._minimumHeights;\r\n        length = defined(minimumHeights) ? minimumHeights.length : 0;\r\n        array[startingIndex++] = length;\r\n\r\n        if (defined(minimumHeights)) {\r\n            for (i = 0; i < length; ++i) {\r\n                array[startingIndex++] = minimumHeights[i];\r\n            }\r\n        }\r\n\r\n        var maximumHeights = value._maximumHeights;\r\n        length = defined(maximumHeights) ? maximumHeights.length : 0;\r\n        array[startingIndex++] = length;\r\n\r\n        if (defined(maximumHeights)) {\r\n            for (i = 0; i < length; ++i) {\r\n                array[startingIndex++] = maximumHeights[i];\r\n            }\r\n        }\r\n\r\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\r\n        startingIndex += Ellipsoid.packedLength;\r\n\r\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\r\n        startingIndex += VertexFormat.packedLength;\r\n\r\n        array[startingIndex] = value._granularity;\r\n\r\n        return array;\r\n    };\r\n\r\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\r\n    var scratchVertexFormat = new VertexFormat();\r\n    var scratchOptions = {\r\n        positions : undefined,\r\n        minimumHeights : undefined,\r\n        maximumHeights : undefined,\r\n        ellipsoid : scratchEllipsoid,\r\n        vertexFormat : scratchVertexFormat,\r\n        granularity : undefined\r\n    };\r\n\r\n    /**\r\n     * Retrieves an instance from a packed array.\r\n     *\r\n     * @param {Number[]} array The packed array.\r\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n     * @param {WallGeometry} [result] The object into which to store the result.\r\n     * @returns {WallGeometry} The modified result parameter or a new WallGeometry instance if one was not provided.\r\n     */\r\n    WallGeometry.unpack = function(array, startingIndex, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(array)) {\r\n            throw new DeveloperError('array is required');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        var i;\r\n\r\n        var length = array[startingIndex++];\r\n        var positions = new Array(length);\r\n\r\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\r\n            positions[i] = Cartesian3.unpack(array, startingIndex);\r\n        }\r\n\r\n        length = array[startingIndex++];\r\n        var minimumHeights;\r\n\r\n        if (length > 0) {\r\n            minimumHeights = new Array(length);\r\n            for (i = 0; i < length; ++i) {\r\n                minimumHeights[i] = array[startingIndex++];\r\n            }\r\n        }\r\n\r\n        length = array[startingIndex++];\r\n        var maximumHeights;\r\n\r\n        if (length > 0) {\r\n            maximumHeights = new Array(length);\r\n            for (i = 0; i < length; ++i) {\r\n                maximumHeights[i] = array[startingIndex++];\r\n            }\r\n        }\r\n\r\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\r\n        startingIndex += Ellipsoid.packedLength;\r\n\r\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\r\n        startingIndex += VertexFormat.packedLength;\r\n\r\n        var granularity = array[startingIndex];\r\n\r\n        if (!defined(result)) {\r\n            scratchOptions.positions = positions;\r\n            scratchOptions.minimumHeights = minimumHeights;\r\n            scratchOptions.maximumHeights = maximumHeights;\r\n            scratchOptions.granularity = granularity;\r\n            return new WallGeometry(scratchOptions);\r\n        }\r\n\r\n        result._positions = positions;\r\n        result._minimumHeights = minimumHeights;\r\n        result._maximumHeights = maximumHeights;\r\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\r\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\r\n        result._granularity = granularity;\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,\r\n     * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\r\n     *\r\n     * @param {Object} options Object with the following properties:\r\n     * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\r\n     * @param {Number} [options.maximumHeight] A constant that defines the maximum height of the\r\n     *        wall at <code>positions</code>. If undefined, the height of each position in used.\r\n     * @param {Number} [options.minimumHeight] A constant that defines the minimum height of the\r\n     *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\r\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid for coordinate manipulation\r\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\r\n     * @returns {WallGeometry}\r\n     *\r\n     *\r\n     * @example\r\n     * // create a wall that spans from 10000 meters to 20000 meters\r\n     * var wall = Cesium.WallGeometry.fromConstantHeights({\r\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\r\n     *     19.0, 47.0,\r\n     *     19.0, 48.0,\r\n     *     20.0, 48.0,\r\n     *     20.0, 47.0,\r\n     *     19.0, 47.0,\r\n     *   ]),\r\n     *   minimumHeight : 20000.0,\r\n     *   maximumHeight : 10000.0\r\n     * });\r\n     * var geometry = Cesium.WallGeometry.createGeometry(wall);\r\n     *\r\n     * @see WallGeometry#createGeometry\r\n     */\r\n    WallGeometry.fromConstantHeights = function(options) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n        var positions = options.positions;\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(positions)) {\r\n            throw new DeveloperError('options.positions is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var minHeights;\r\n        var maxHeights;\r\n\r\n        var min = options.minimumHeight;\r\n        var max = options.maximumHeight;\r\n\r\n        var doMin = defined(min);\r\n        var doMax = defined(max);\r\n        if (doMin || doMax) {\r\n            var length = positions.length;\r\n            minHeights = (doMin) ? new Array(length) : undefined;\r\n            maxHeights = (doMax) ? new Array(length) : undefined;\r\n\r\n            for (var i = 0; i < length; ++i) {\r\n                if (doMin) {\r\n                    minHeights[i] = min;\r\n                }\r\n\r\n                if (doMax) {\r\n                    maxHeights[i] = max;\r\n                }\r\n            }\r\n        }\r\n\r\n        var newOptions = {\r\n            positions : positions,\r\n            maximumHeights : maxHeights,\r\n            minimumHeights : minHeights,\r\n            ellipsoid : options.ellipsoid,\r\n            vertexFormat : options.vertexFormat\r\n        };\r\n        return new WallGeometry(newOptions);\r\n    };\r\n\r\n    /**\r\n     * Computes the geometric representation of a wall, including its vertices, indices, and a bounding sphere.\r\n     *\r\n     * @param {WallGeometry} wallGeometry A description of the wall.\r\n     * @returns {Geometry|undefined} The computed vertices and indices.\r\n     */\r\n    WallGeometry.createGeometry = function(wallGeometry) {\r\n        var wallPositions = wallGeometry._positions;\r\n        var minimumHeights = wallGeometry._minimumHeights;\r\n        var maximumHeights = wallGeometry._maximumHeights;\r\n        var vertexFormat = wallGeometry._vertexFormat;\r\n        var granularity = wallGeometry._granularity;\r\n        var ellipsoid = wallGeometry._ellipsoid;\r\n\r\n        var pos = WallGeometryLibrary.computePositions(ellipsoid, wallPositions, maximumHeights, minimumHeights, granularity, true);\r\n        if (!defined(pos)) {\r\n            return;\r\n        }\r\n\r\n        var bottomPositions = pos.bottomPositions;\r\n        var topPositions = pos.topPositions;\r\n        var numCorners = pos.numCorners;\r\n\r\n        var length = topPositions.length;\r\n        var size = length * 2;\r\n\r\n        var positions = vertexFormat.position ? new Float64Array(size) : undefined;\r\n        var normals = vertexFormat.normal ? new Float32Array(size) : undefined;\r\n        var tangents = vertexFormat.tangent ? new Float32Array(size) : undefined;\r\n        var bitangents = vertexFormat.bitangent ? new Float32Array(size) : undefined;\r\n        var textureCoordinates = vertexFormat.st ? new Float32Array(size / 3 * 2) : undefined;\r\n\r\n        var positionIndex = 0;\r\n        var normalIndex = 0;\r\n        var bitangentIndex = 0;\r\n        var tangentIndex = 0;\r\n        var stIndex = 0;\r\n\r\n        // add lower and upper points one after the other, lower\r\n        // points being even and upper points being odd\r\n        var normal = scratchNormal;\r\n        var tangent = scratchTangent;\r\n        var bitangent = scratchBitangent;\r\n        var recomputeNormal = true;\r\n        length /= 3;\r\n        var i;\r\n        var s = 0;\r\n        var ds = 1/(length - wallPositions.length + 1);\r\n        for (i = 0; i < length; ++i) {\r\n            var i3 = i * 3;\r\n            var topPosition = Cartesian3.fromArray(topPositions, i3, scratchCartesian3Position1);\r\n            var bottomPosition = Cartesian3.fromArray(bottomPositions, i3, scratchCartesian3Position2);\r\n            if (vertexFormat.position) {\r\n                // insert the lower point\r\n                positions[positionIndex++] = bottomPosition.x;\r\n                positions[positionIndex++] = bottomPosition.y;\r\n                positions[positionIndex++] = bottomPosition.z;\r\n\r\n                // insert the upper point\r\n                positions[positionIndex++] = topPosition.x;\r\n                positions[positionIndex++] = topPosition.y;\r\n                positions[positionIndex++] = topPosition.z;\r\n            }\r\n\r\n            if (vertexFormat.st) {\r\n                textureCoordinates[stIndex++] = s;\r\n                textureCoordinates[stIndex++] = 0.0;\r\n\r\n                textureCoordinates[stIndex++] = s;\r\n                textureCoordinates[stIndex++] = 1.0;\r\n            }\r\n\r\n            if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\r\n                var nextPosition;\r\n                var nextTop = Cartesian3.clone(Cartesian3.ZERO, scratchCartesian3Position5);\r\n                var groundPosition = ellipsoid.scaleToGeodeticSurface(Cartesian3.fromArray(topPositions, i3, scratchCartesian3Position2), scratchCartesian3Position2);\r\n                if (i + 1 < length) {\r\n                    nextPosition = ellipsoid.scaleToGeodeticSurface(Cartesian3.fromArray(topPositions, i3 + 3, scratchCartesian3Position3), scratchCartesian3Position3);\r\n                    nextTop = Cartesian3.fromArray(topPositions, i3 + 3, scratchCartesian3Position5);\r\n                }\r\n\r\n                if (recomputeNormal) {\r\n                    var scalednextPosition = Cartesian3.subtract(nextTop, topPosition, scratchCartesian3Position4);\r\n                    var scaledGroundPosition = Cartesian3.subtract(groundPosition, topPosition, scratchCartesian3Position1);\r\n                    normal = Cartesian3.normalize(Cartesian3.cross(scaledGroundPosition, scalednextPosition, normal), normal);\r\n                    recomputeNormal = false;\r\n                }\r\n\r\n                if (Cartesian3.equalsEpsilon(nextPosition, groundPosition, CesiumMath.EPSILON10)) {\r\n                    recomputeNormal = true;\r\n                } else {\r\n                    s += ds;\r\n                    if (vertexFormat.tangent) {\r\n                        tangent = Cartesian3.normalize(Cartesian3.subtract(nextPosition, groundPosition, tangent), tangent);\r\n                    }\r\n                    if (vertexFormat.bitangent) {\r\n                        bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\r\n                    }\r\n                }\r\n\r\n                if (vertexFormat.normal) {\r\n                    normals[normalIndex++] = normal.x;\r\n                    normals[normalIndex++] = normal.y;\r\n                    normals[normalIndex++] = normal.z;\r\n\r\n                    normals[normalIndex++] = normal.x;\r\n                    normals[normalIndex++] = normal.y;\r\n                    normals[normalIndex++] = normal.z;\r\n                }\r\n\r\n                if (vertexFormat.tangent) {\r\n                    tangents[tangentIndex++] = tangent.x;\r\n                    tangents[tangentIndex++] = tangent.y;\r\n                    tangents[tangentIndex++] = tangent.z;\r\n\r\n                    tangents[tangentIndex++] = tangent.x;\r\n                    tangents[tangentIndex++] = tangent.y;\r\n                    tangents[tangentIndex++] = tangent.z;\r\n                }\r\n\r\n                if (vertexFormat.bitangent) {\r\n                    bitangents[bitangentIndex++] = bitangent.x;\r\n                    bitangents[bitangentIndex++] = bitangent.y;\r\n                    bitangents[bitangentIndex++] = bitangent.z;\r\n\r\n                    bitangents[bitangentIndex++] = bitangent.x;\r\n                    bitangents[bitangentIndex++] = bitangent.y;\r\n                    bitangents[bitangentIndex++] = bitangent.z;\r\n                }\r\n            }\r\n        }\r\n\r\n        var attributes = new GeometryAttributes();\r\n\r\n        if (vertexFormat.position) {\r\n            attributes.position = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.DOUBLE,\r\n                componentsPerAttribute : 3,\r\n                values : positions\r\n            });\r\n        }\r\n\r\n        if (vertexFormat.normal) {\r\n            attributes.normal = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.FLOAT,\r\n                componentsPerAttribute : 3,\r\n                values : normals\r\n            });\r\n        }\r\n\r\n        if (vertexFormat.tangent) {\r\n            attributes.tangent = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.FLOAT,\r\n                componentsPerAttribute : 3,\r\n                values : tangents\r\n            });\r\n        }\r\n\r\n        if (vertexFormat.bitangent) {\r\n            attributes.bitangent = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.FLOAT,\r\n                componentsPerAttribute : 3,\r\n                values : bitangents\r\n            });\r\n        }\r\n\r\n        if (vertexFormat.st) {\r\n            attributes.st = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.FLOAT,\r\n                componentsPerAttribute : 2,\r\n                values : textureCoordinates\r\n            });\r\n        }\r\n\r\n        // prepare the side walls, two triangles for each wall\r\n        //\r\n        //    A (i+1)  B (i+3) E\r\n        //    +--------+-------+\r\n        //    |      / |      /|    triangles:  A C B\r\n        //    |     /  |     / |                B C D\r\n        //    |    /   |    /  |\r\n        //    |   /    |   /   |\r\n        //    |  /     |  /    |\r\n        //    | /      | /     |\r\n        //    +--------+-------+\r\n        //    C (i)    D (i+2) F\r\n        //\r\n\r\n        var numVertices = size / 3;\r\n        size -= 6 * (numCorners + 1);\r\n        var indices = IndexDatatype.createTypedArray(numVertices, size);\r\n\r\n        var edgeIndex = 0;\r\n        for (i = 0; i < numVertices - 2; i += 2) {\r\n            var LL = i;\r\n            var LR = i + 2;\r\n            var pl = Cartesian3.fromArray(positions, LL * 3, scratchCartesian3Position1);\r\n            var pr = Cartesian3.fromArray(positions, LR * 3, scratchCartesian3Position2);\r\n            if (Cartesian3.equalsEpsilon(pl, pr, CesiumMath.EPSILON10)) {\r\n                continue;\r\n            }\r\n            var UL = i + 1;\r\n            var UR = i + 3;\r\n\r\n            indices[edgeIndex++] = UL;\r\n            indices[edgeIndex++] = LL;\r\n            indices[edgeIndex++] = UR;\r\n            indices[edgeIndex++] = UR;\r\n            indices[edgeIndex++] = LL;\r\n            indices[edgeIndex++] = LR;\r\n        }\r\n\r\n        return new Geometry({\r\n            attributes : attributes,\r\n            indices : indices,\r\n            primitiveType : PrimitiveType.TRIANGLES,\r\n            boundingSphere : new BoundingSphere.fromVertices(positions)\r\n        });\r\n    };\r\nexport default WallGeometry;\r\n","import defined from '../Core/defined.js';\r\nimport Ellipsoid from '../Core/Ellipsoid.js';\r\nimport WallGeometry from '../Core/WallGeometry.js';\r\n\r\n    function createWallGeometry(wallGeometry, offset) {\r\n        if (defined(offset)) {\r\n            wallGeometry = WallGeometry.unpack(wallGeometry, offset);\r\n        }\r\n        wallGeometry._ellipsoid = Ellipsoid.clone(wallGeometry._ellipsoid);\r\n        return WallGeometry.createGeometry(wallGeometry);\r\n    }\r\nexport default createWallGeometry;\r\n"],"names":["scratchCartesian3Position1","Cartesian3","scratchCartesian3Position2","scratchCartesian3Position3","scratchCartesian3Position4","scratchCartesian3Position5","scratchBitangent","scratchTangent","scratchNormal","WallGeometry","options","wallPositions","defaultValue","EMPTY_OBJECT","positions","maximumHeights","minimumHeights","defined","DeveloperError","length","vertexFormat","VertexFormat","DEFAULT","granularity","CesiumMath","RADIANS_PER_DEGREE","ellipsoid","Ellipsoid","WGS84","this","_positions","_minimumHeights","_maximumHeights","_vertexFormat","clone","_granularity","_ellipsoid","_workerName","numComponents","packedLength","pack","value","array","startingIndex","i","scratchEllipsoid","UNIT_SPHERE","scratchVertexFormat","scratchOptions","undefined","unpack","result","Array","fromConstantHeights","minHeights","maxHeights","min","minimumHeight","max","maximumHeight","doMin","doMax","createGeometry","wallGeometry","pos","WallGeometryLibrary","computePositions","bottomPositions","topPositions","numCorners","size","position","Float64Array","normals","normal","Float32Array","tangents","tangent","bitangents","bitangent","textureCoordinates","st","positionIndex","normalIndex","bitangentIndex","tangentIndex","stIndex","recomputeNormal","s","ds","i3","topPosition","fromArray","bottomPosition","x","y","z","nextPosition","nextTop","ZERO","groundPosition","scaleToGeodeticSurface","scalednextPosition","subtract","scaledGroundPosition","normalize","cross","equalsEpsilon","EPSILON10","attributes","GeometryAttributes","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","FLOAT","numVertices","indices","IndexDatatype","createTypedArray","edgeIndex","LL","LR","pl","pr","UL","UR","Geometry","primitiveType","PrimitiveType","TRIANGLES","boundingSphere","BoundingSphere","fromVertices","offset"],"mappings":"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"}