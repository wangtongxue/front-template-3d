{"version":3,"file":"OrientedBoundingBox-565e6407.js","sources":["../../../../Source/Core/OrientedBoundingBox.js"],"sourcesContent":["import BoundingSphere from './BoundingSphere.js';\r\nimport Cartesian2 from './Cartesian2.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport Cartographic from './Cartographic.js';\r\nimport Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport EllipsoidTangentPlane from './EllipsoidTangentPlane.js';\r\nimport Intersect from './Intersect.js';\r\nimport Interval from './Interval.js';\r\nimport CesiumMath from './Math.js';\r\nimport Matrix3 from './Matrix3.js';\r\nimport Plane from './Plane.js';\r\nimport Rectangle from './Rectangle.js';\r\n\r\n    /**\r\n     * Creates an instance of an OrientedBoundingBox.\r\n     * An OrientedBoundingBox of some object is a closed and convex cuboid. It can provide a tighter bounding volume than {@link BoundingSphere} or {@link AxisAlignedBoundingBox} in many cases.\r\n     * @alias OrientedBoundingBox\r\n     * @constructor\r\n     *\r\n     * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the box.\r\n     * @param {Matrix3} [halfAxes=Matrix3.ZERO] The three orthogonal half-axes of the bounding box.\r\n     *                                          Equivalently, the transformation matrix, to rotate and scale a 0x0x0\r\n     *                                          cube centered at the origin.\r\n     *\r\n     *\r\n     * @example\r\n     * // Create an OrientedBoundingBox using a transformation matrix, a position where the box will be translated, and a scale.\r\n     * var center = new Cesium.Cartesian3(1.0, 0.0, 0.0);\r\n     * var halfAxes = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(1.0, 3.0, 2.0), new Cesium.Matrix3());\r\n     *\r\n     * var obb = new Cesium.OrientedBoundingBox(center, halfAxes);\r\n     *\r\n     * @see BoundingSphere\r\n     * @see BoundingRectangle\r\n     */\r\n    function OrientedBoundingBox(center, halfAxes) {\r\n        /**\r\n         * The center of the box.\r\n         * @type {Cartesian3}\r\n         * @default {@link Cartesian3.ZERO}\r\n         */\r\n        this.center = Cartesian3.clone(defaultValue(center, Cartesian3.ZERO));\r\n        /**\r\n         * The transformation matrix, to rotate the box to the right position.\r\n         * @type {Matrix3}\r\n         * @default {@link Matrix3.ZERO}\r\n         */\r\n        this.halfAxes = Matrix3.clone(defaultValue(halfAxes, Matrix3.ZERO));\r\n    }\r\n\r\n    /**\r\n     * The number of elements used to pack the object into an array.\r\n     * @type {Number}\r\n     */\r\n    OrientedBoundingBox.packedLength = Cartesian3.packedLength + Matrix3.packedLength;\r\n\r\n    /**\r\n     * Stores the provided instance into the provided array.\r\n     *\r\n     * @param {OrientedBoundingBox} value The value to pack.\r\n     * @param {Number[]} array The array to pack into.\r\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n     *\r\n     * @returns {Number[]} The array that was packed into\r\n     */\r\n    OrientedBoundingBox.pack = function(value, array, startingIndex) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('value', value);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        Cartesian3.pack(value.center, array, startingIndex);\r\n        Matrix3.pack(value.halfAxes, array, startingIndex + Cartesian3.packedLength);\r\n\r\n        return array;\r\n    };\r\n\r\n    /**\r\n     * Retrieves an instance from a packed array.\r\n     *\r\n     * @param {Number[]} array The packed array.\r\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n     * @param {OrientedBoundingBox} [result] The object into which to store the result.\r\n     * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\r\n     */\r\n    OrientedBoundingBox.unpack = function(array, startingIndex, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        if (!defined(result)) {\r\n            result = new OrientedBoundingBox();\r\n        }\r\n\r\n        Cartesian3.unpack(array, startingIndex, result.center);\r\n        Matrix3.unpack(array, startingIndex + Cartesian3.packedLength, result.halfAxes);\r\n        return result;\r\n    };\r\n\r\n    var scratchCartesian1 = new Cartesian3();\r\n    var scratchCartesian2 = new Cartesian3();\r\n    var scratchCartesian3 = new Cartesian3();\r\n    var scratchCartesian4 = new Cartesian3();\r\n    var scratchCartesian5 = new Cartesian3();\r\n    var scratchCartesian6 = new Cartesian3();\r\n    var scratchCovarianceResult = new Matrix3();\r\n    var scratchEigenResult = {\r\n        unitary : new Matrix3(),\r\n        diagonal : new Matrix3()\r\n    };\r\n\r\n    /**\r\n     * Computes an instance of an OrientedBoundingBox of the given positions.\r\n     * This is an implementation of Stefan Gottschalk's Collision Queries using Oriented Bounding Boxes solution (PHD thesis).\r\n     * Reference: http://gamma.cs.unc.edu/users/gottschalk/main.pdf\r\n     *\r\n     * @param {Cartesian3[]} [positions] List of {@link Cartesian3} points that the bounding box will enclose.\r\n     * @param {OrientedBoundingBox} [result] The object onto which to store the result.\r\n     * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\r\n     *\r\n     * @example\r\n     * // Compute an object oriented bounding box enclosing two points.\r\n     * var box = Cesium.OrientedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);\r\n     */\r\n    OrientedBoundingBox.fromPoints = function(positions, result) {\r\n        if (!defined(result)) {\r\n            result = new OrientedBoundingBox();\r\n        }\r\n\r\n        if (!defined(positions) || positions.length === 0) {\r\n            result.halfAxes = Matrix3.ZERO;\r\n            result.center = Cartesian3.ZERO;\r\n            return result;\r\n        }\r\n\r\n        var i;\r\n        var length = positions.length;\r\n\r\n        var meanPoint = Cartesian3.clone(positions[0], scratchCartesian1);\r\n        for (i = 1; i < length; i++) {\r\n            Cartesian3.add(meanPoint, positions[i], meanPoint);\r\n        }\r\n        var invLength = 1.0 / length;\r\n        Cartesian3.multiplyByScalar(meanPoint, invLength, meanPoint);\r\n\r\n        var exx = 0.0;\r\n        var exy = 0.0;\r\n        var exz = 0.0;\r\n        var eyy = 0.0;\r\n        var eyz = 0.0;\r\n        var ezz = 0.0;\r\n        var p;\r\n\r\n        for (i = 0; i < length; i++) {\r\n            p = Cartesian3.subtract(positions[i], meanPoint, scratchCartesian2);\r\n            exx += p.x * p.x;\r\n            exy += p.x * p.y;\r\n            exz += p.x * p.z;\r\n            eyy += p.y * p.y;\r\n            eyz += p.y * p.z;\r\n            ezz += p.z * p.z;\r\n        }\r\n\r\n        exx *= invLength;\r\n        exy *= invLength;\r\n        exz *= invLength;\r\n        eyy *= invLength;\r\n        eyz *= invLength;\r\n        ezz *= invLength;\r\n\r\n        var covarianceMatrix = scratchCovarianceResult;\r\n        covarianceMatrix[0] = exx;\r\n        covarianceMatrix[1] = exy;\r\n        covarianceMatrix[2] = exz;\r\n        covarianceMatrix[3] = exy;\r\n        covarianceMatrix[4] = eyy;\r\n        covarianceMatrix[5] = eyz;\r\n        covarianceMatrix[6] = exz;\r\n        covarianceMatrix[7] = eyz;\r\n        covarianceMatrix[8] = ezz;\r\n\r\n        var eigenDecomposition = Matrix3.computeEigenDecomposition(covarianceMatrix, scratchEigenResult);\r\n        var rotation = Matrix3.clone(eigenDecomposition.unitary, result.halfAxes);\r\n\r\n        var v1 = Matrix3.getColumn(rotation, 0, scratchCartesian4);\r\n        var v2 = Matrix3.getColumn(rotation, 1, scratchCartesian5);\r\n        var v3 = Matrix3.getColumn(rotation, 2, scratchCartesian6);\r\n\r\n        var u1 = -Number.MAX_VALUE;\r\n        var u2 = -Number.MAX_VALUE;\r\n        var u3 = -Number.MAX_VALUE;\r\n        var l1 = Number.MAX_VALUE;\r\n        var l2 = Number.MAX_VALUE;\r\n        var l3 = Number.MAX_VALUE;\r\n\r\n        for (i = 0; i < length; i++) {\r\n            p = positions[i];\r\n            u1 = Math.max(Cartesian3.dot(v1, p), u1);\r\n            u2 = Math.max(Cartesian3.dot(v2, p), u2);\r\n            u3 = Math.max(Cartesian3.dot(v3, p), u3);\r\n\r\n            l1 = Math.min(Cartesian3.dot(v1, p), l1);\r\n            l2 = Math.min(Cartesian3.dot(v2, p), l2);\r\n            l3 = Math.min(Cartesian3.dot(v3, p), l3);\r\n        }\r\n\r\n        v1 = Cartesian3.multiplyByScalar(v1, 0.5 * (l1 + u1), v1);\r\n        v2 = Cartesian3.multiplyByScalar(v2, 0.5 * (l2 + u2), v2);\r\n        v3 = Cartesian3.multiplyByScalar(v3, 0.5 * (l3 + u3), v3);\r\n\r\n        var center = Cartesian3.add(v1, v2, result.center);\r\n        Cartesian3.add(center, v3, center);\r\n\r\n        var scale = scratchCartesian3;\r\n        scale.x = u1 - l1;\r\n        scale.y = u2 - l2;\r\n        scale.z = u3 - l3;\r\n        Cartesian3.multiplyByScalar(scale, 0.5, scale);\r\n        Matrix3.multiplyByScale(result.halfAxes, scale, result.halfAxes);\r\n\r\n        return result;\r\n    };\r\n\r\n    var scratchOffset = new Cartesian3();\r\n    var scratchScale = new Cartesian3();\r\n    function fromPlaneExtents(planeOrigin, planeXAxis, planeYAxis, planeZAxis, minimumX, maximumX, minimumY, maximumY, minimumZ, maximumZ, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(minimumX) ||\r\n            !defined(maximumX) ||\r\n            !defined(minimumY) ||\r\n            !defined(maximumY) ||\r\n            !defined(minimumZ) ||\r\n            !defined(maximumZ)) {\r\n            throw new DeveloperError('all extents (minimum/maximum X/Y/Z) are required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            result = new OrientedBoundingBox();\r\n        }\r\n\r\n        var halfAxes = result.halfAxes;\r\n        Matrix3.setColumn(halfAxes, 0, planeXAxis, halfAxes);\r\n        Matrix3.setColumn(halfAxes, 1, planeYAxis, halfAxes);\r\n        Matrix3.setColumn(halfAxes, 2, planeZAxis, halfAxes);\r\n\r\n        var centerOffset = scratchOffset;\r\n        centerOffset.x = (minimumX + maximumX) / 2.0;\r\n        centerOffset.y = (minimumY + maximumY) / 2.0;\r\n        centerOffset.z = (minimumZ + maximumZ) / 2.0;\r\n\r\n        var scale = scratchScale;\r\n        scale.x = (maximumX - minimumX) / 2.0;\r\n        scale.y = (maximumY - minimumY) / 2.0;\r\n        scale.z = (maximumZ - minimumZ) / 2.0;\r\n\r\n        var center = result.center;\r\n        centerOffset = Matrix3.multiplyByVector(halfAxes, centerOffset, centerOffset);\r\n        Cartesian3.add(planeOrigin, centerOffset, center);\r\n        Matrix3.multiplyByScale(halfAxes, scale, halfAxes);\r\n\r\n        return result;\r\n    }\r\n\r\n    var scratchRectangleCenterCartographic = new Cartographic();\r\n    var scratchRectangleCenter = new Cartesian3();\r\n    var scratchPerimeterCartographicNC = new Cartographic();\r\n    var scratchPerimeterCartographicNW = new Cartographic();\r\n    var scratchPerimeterCartographicCW = new Cartographic();\r\n    var scratchPerimeterCartographicSW = new Cartographic();\r\n    var scratchPerimeterCartographicSC = new Cartographic();\r\n    var scratchPerimeterCartesianNC = new Cartesian3();\r\n    var scratchPerimeterCartesianNW = new Cartesian3();\r\n    var scratchPerimeterCartesianCW = new Cartesian3();\r\n    var scratchPerimeterCartesianSW = new Cartesian3();\r\n    var scratchPerimeterCartesianSC = new Cartesian3();\r\n    var scratchPerimeterProjectedNC = new Cartesian2();\r\n    var scratchPerimeterProjectedNW = new Cartesian2();\r\n    var scratchPerimeterProjectedCW = new Cartesian2();\r\n    var scratchPerimeterProjectedSW = new Cartesian2();\r\n    var scratchPerimeterProjectedSC = new Cartesian2();\r\n\r\n    var scratchPlaneOrigin = new Cartesian3();\r\n    var scratchPlaneNormal = new Cartesian3();\r\n    var scratchPlaneXAxis = new Cartesian3();\r\n    var scratchHorizonCartesian = new Cartesian3();\r\n    var scratchHorizonProjected = new Cartesian2();\r\n    var scratchMaxY = new Cartesian3();\r\n    var scratchMinY = new Cartesian3();\r\n    var scratchZ = new Cartesian3();\r\n    var scratchPlane = new Plane(Cartesian3.UNIT_X, 0.0);\r\n\r\n    /**\r\n     * Computes an OrientedBoundingBox that bounds a {@link Rectangle} on the surface of an {@link Ellipsoid}.\r\n     * There are no guarantees about the orientation of the bounding box.\r\n     *\r\n     * @param {Rectangle} rectangle The cartographic rectangle on the surface of the ellipsoid.\r\n     * @param {Number} [minimumHeight=0.0] The minimum height (elevation) within the tile.\r\n     * @param {Number} [maximumHeight=0.0] The maximum height (elevation) within the tile.\r\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle is defined.\r\n     * @param {OrientedBoundingBox} [result] The object onto which to store the result.\r\n     * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided.\r\n     *\r\n     * @exception {DeveloperError} rectangle.width must be between 0 and pi.\r\n     * @exception {DeveloperError} rectangle.height must be between 0 and pi.\r\n     * @exception {DeveloperError} ellipsoid must be an ellipsoid of revolution (<code>radii.x == radii.y</code>)\r\n     */\r\n    OrientedBoundingBox.fromRectangle = function(rectangle, minimumHeight, maximumHeight, ellipsoid, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(rectangle)) {\r\n            throw new DeveloperError('rectangle is required');\r\n        }\r\n        if (rectangle.width < 0.0 || rectangle.width > CesiumMath.TWO_PI) {\r\n            throw new DeveloperError('Rectangle width must be between 0 and 2*pi');\r\n        }\r\n        if (rectangle.height < 0.0 || rectangle.height > CesiumMath.PI) {\r\n            throw new DeveloperError('Rectangle height must be between 0 and pi');\r\n        }\r\n        if (defined(ellipsoid) && !CesiumMath.equalsEpsilon(ellipsoid.radii.x, ellipsoid.radii.y, CesiumMath.EPSILON15)) {\r\n            throw new DeveloperError('Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        minimumHeight = defaultValue(minimumHeight, 0.0);\r\n        maximumHeight = defaultValue(maximumHeight, 0.0);\r\n        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n\r\n        var minX, maxX, minY, maxY, minZ, maxZ, plane;\r\n\r\n        if (rectangle.width <= CesiumMath.PI) {\r\n            // The bounding box will be aligned with the tangent plane at the center of the rectangle.\r\n            var tangentPointCartographic = Rectangle.center(rectangle, scratchRectangleCenterCartographic);\r\n            var tangentPoint = ellipsoid.cartographicToCartesian(tangentPointCartographic, scratchRectangleCenter);\r\n            var tangentPlane = new EllipsoidTangentPlane(tangentPoint, ellipsoid);\r\n            plane = tangentPlane.plane;\r\n\r\n            // If the rectangle spans the equator, CW is instead aligned with the equator (because it sticks out the farthest at the equator).\r\n            var lonCenter = tangentPointCartographic.longitude;\r\n            var latCenter = (rectangle.south < 0.0 && rectangle.north > 0.0) ? 0.0 : tangentPointCartographic.latitude;\r\n\r\n            // Compute XY extents using the rectangle at maximum height\r\n            var perimeterCartographicNC = Cartographic.fromRadians(lonCenter, rectangle.north, maximumHeight, scratchPerimeterCartographicNC);\r\n            var perimeterCartographicNW = Cartographic.fromRadians(rectangle.west, rectangle.north, maximumHeight, scratchPerimeterCartographicNW);\r\n            var perimeterCartographicCW = Cartographic.fromRadians(rectangle.west, latCenter, maximumHeight, scratchPerimeterCartographicCW);\r\n            var perimeterCartographicSW = Cartographic.fromRadians(rectangle.west, rectangle.south, maximumHeight, scratchPerimeterCartographicSW);\r\n            var perimeterCartographicSC = Cartographic.fromRadians(lonCenter, rectangle.south, maximumHeight, scratchPerimeterCartographicSC);\r\n\r\n            var perimeterCartesianNC = ellipsoid.cartographicToCartesian(perimeterCartographicNC, scratchPerimeterCartesianNC);\r\n            var perimeterCartesianNW = ellipsoid.cartographicToCartesian(perimeterCartographicNW, scratchPerimeterCartesianNW);\r\n            var perimeterCartesianCW = ellipsoid.cartographicToCartesian(perimeterCartographicCW, scratchPerimeterCartesianCW);\r\n            var perimeterCartesianSW = ellipsoid.cartographicToCartesian(perimeterCartographicSW, scratchPerimeterCartesianSW);\r\n            var perimeterCartesianSC = ellipsoid.cartographicToCartesian(perimeterCartographicSC, scratchPerimeterCartesianSC);\r\n\r\n            var perimeterProjectedNC = tangentPlane.projectPointToNearestOnPlane(perimeterCartesianNC, scratchPerimeterProjectedNC);\r\n            var perimeterProjectedNW = tangentPlane.projectPointToNearestOnPlane(perimeterCartesianNW, scratchPerimeterProjectedNW);\r\n            var perimeterProjectedCW = tangentPlane.projectPointToNearestOnPlane(perimeterCartesianCW, scratchPerimeterProjectedCW);\r\n            var perimeterProjectedSW = tangentPlane.projectPointToNearestOnPlane(perimeterCartesianSW, scratchPerimeterProjectedSW);\r\n            var perimeterProjectedSC = tangentPlane.projectPointToNearestOnPlane(perimeterCartesianSC, scratchPerimeterProjectedSC);\r\n\r\n            minX = Math.min(perimeterProjectedNW.x, perimeterProjectedCW.x, perimeterProjectedSW.x);\r\n            maxX = -minX; // symmetrical\r\n\r\n            maxY = Math.max(perimeterProjectedNW.y, perimeterProjectedNC.y);\r\n            minY = Math.min(perimeterProjectedSW.y, perimeterProjectedSC.y);\r\n\r\n            // Compute minimum Z using the rectangle at minimum height, since it will be deeper than the maximum height\r\n            perimeterCartographicNW.height = perimeterCartographicSW.height = minimumHeight;\r\n            perimeterCartesianNW = ellipsoid.cartographicToCartesian(perimeterCartographicNW, scratchPerimeterCartesianNW);\r\n            perimeterCartesianSW = ellipsoid.cartographicToCartesian(perimeterCartographicSW, scratchPerimeterCartesianSW);\r\n\r\n            minZ = Math.min(Plane.getPointDistance(plane, perimeterCartesianNW), Plane.getPointDistance(plane, perimeterCartesianSW));\r\n            maxZ = maximumHeight;  // Since the tangent plane touches the surface at height = 0, this is okay\r\n\r\n            return fromPlaneExtents(tangentPlane.origin, tangentPlane.xAxis, tangentPlane.yAxis, tangentPlane.zAxis, minX, maxX, minY, maxY, minZ, maxZ, result);\r\n        }\r\n\r\n        // Handle the case where rectangle width is greater than PI (wraps around more than half the ellipsoid).\r\n        var fullyAboveEquator = rectangle.south > 0.0;\r\n        var fullyBelowEquator = rectangle.north < 0.0;\r\n        var latitudeNearestToEquator = fullyAboveEquator ? rectangle.south : (fullyBelowEquator ? rectangle.north : 0.0);\r\n        var centerLongitude = Rectangle.center(rectangle, scratchRectangleCenterCartographic).longitude;\r\n\r\n        // Plane is located at the rectangle's center longitude and the rectangle's latitude that is closest to the equator. It rotates around the Z axis.\r\n        // This results in a better fit than the obb approach for smaller rectangles, which orients with the rectangle's center normal.\r\n        var planeOrigin = Cartesian3.fromRadians(centerLongitude, latitudeNearestToEquator, maximumHeight, ellipsoid, scratchPlaneOrigin);\r\n        planeOrigin.z = 0.0; // center the plane on the equator to simpify plane normal calculation\r\n        var isPole = Math.abs(planeOrigin.x) < CesiumMath.EPSILON10 && Math.abs(planeOrigin.y) < CesiumMath.EPSILON10;\r\n        var planeNormal = !isPole ? Cartesian3.normalize(planeOrigin, scratchPlaneNormal) : Cartesian3.UNIT_X;\r\n        var planeYAxis = Cartesian3.UNIT_Z;\r\n        var planeXAxis = Cartesian3.cross(planeNormal, planeYAxis, scratchPlaneXAxis);\r\n        plane = Plane.fromPointNormal(planeOrigin, planeNormal, scratchPlane);\r\n\r\n        // Get the horizon point relative to the center. This will be the farthest extent in the plane's X dimension.\r\n        var horizonCartesian = Cartesian3.fromRadians(centerLongitude + CesiumMath.PI_OVER_TWO, latitudeNearestToEquator, maximumHeight, ellipsoid, scratchHorizonCartesian);\r\n        maxX = Cartesian3.dot(Plane.projectPointOntoPlane(plane, horizonCartesian, scratchHorizonProjected), planeXAxis);\r\n        minX = -maxX; // symmetrical\r\n\r\n        // Get the min and max Y, using the height that will give the largest extent\r\n        maxY = Cartesian3.fromRadians(0.0, rectangle.north, fullyBelowEquator ? minimumHeight : maximumHeight, ellipsoid, scratchMaxY).z;\r\n        minY = Cartesian3.fromRadians(0.0, rectangle.south, fullyAboveEquator ? minimumHeight : maximumHeight, ellipsoid, scratchMinY).z;\r\n\r\n        var farZ = Cartesian3.fromRadians(rectangle.east, latitudeNearestToEquator, maximumHeight, ellipsoid, scratchZ);\r\n        minZ = Plane.getPointDistance(plane, farZ);\r\n        maxZ = 0.0; // plane origin starts at maxZ already\r\n\r\n        // min and max are local to the plane axes\r\n        return fromPlaneExtents(planeOrigin, planeXAxis, planeYAxis, planeNormal, minX, maxX, minY, maxY, minZ, maxZ, result);\r\n    };\r\n\r\n    /**\r\n     * Duplicates a OrientedBoundingBox instance.\r\n     *\r\n     * @param {OrientedBoundingBox} box The bounding box to duplicate.\r\n     * @param {OrientedBoundingBox} [result] The object onto which to store the result.\r\n     * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided. (Returns undefined if box is undefined)\r\n     */\r\n    OrientedBoundingBox.clone = function(box, result) {\r\n        if (!defined(box)) {\r\n            return undefined;\r\n        }\r\n\r\n        if (!defined(result)) {\r\n            return new OrientedBoundingBox(box.center, box.halfAxes);\r\n        }\r\n\r\n        Cartesian3.clone(box.center, result.center);\r\n        Matrix3.clone(box.halfAxes, result.halfAxes);\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Determines which side of a plane the oriented bounding box is located.\r\n     *\r\n     * @param {OrientedBoundingBox} box The oriented bounding box to test.\r\n     * @param {Plane} plane The plane to test against.\r\n     * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\r\n     *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\r\n     *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\r\n     *                      intersects the plane.\r\n     */\r\n    OrientedBoundingBox.intersectPlane = function(box, plane) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(box)) {\r\n            throw new DeveloperError('box is required.');\r\n        }\r\n\r\n        if (!defined(plane)) {\r\n            throw new DeveloperError('plane is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var center = box.center;\r\n        var normal = plane.normal;\r\n        var halfAxes = box.halfAxes;\r\n        var normalX = normal.x, normalY = normal.y, normalZ = normal.z;\r\n        // plane is used as if it is its normal; the first three components are assumed to be normalized\r\n        var radEffective = Math.abs(normalX * halfAxes[Matrix3.COLUMN0ROW0] + normalY * halfAxes[Matrix3.COLUMN0ROW1] + normalZ * halfAxes[Matrix3.COLUMN0ROW2]) +\r\n                           Math.abs(normalX * halfAxes[Matrix3.COLUMN1ROW0] + normalY * halfAxes[Matrix3.COLUMN1ROW1] + normalZ * halfAxes[Matrix3.COLUMN1ROW2]) +\r\n                           Math.abs(normalX * halfAxes[Matrix3.COLUMN2ROW0] + normalY * halfAxes[Matrix3.COLUMN2ROW1] + normalZ * halfAxes[Matrix3.COLUMN2ROW2]);\r\n        var distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;\r\n\r\n        if (distanceToPlane <= -radEffective) {\r\n            // The entire box is on the negative side of the plane normal\r\n            return Intersect.OUTSIDE;\r\n        } else if (distanceToPlane >= radEffective) {\r\n            // The entire box is on the positive side of the plane normal\r\n            return Intersect.INSIDE;\r\n        }\r\n        return Intersect.INTERSECTING;\r\n    };\r\n\r\n    var scratchCartesianU = new Cartesian3();\r\n    var scratchCartesianV = new Cartesian3();\r\n    var scratchCartesianW = new Cartesian3();\r\n    var scratchPPrime = new Cartesian3();\r\n\r\n    /**\r\n     * Computes the estimated distance squared from the closest point on a bounding box to a point.\r\n     *\r\n     * @param {OrientedBoundingBox} box The box.\r\n     * @param {Cartesian3} cartesian The point\r\n     * @returns {Number} The estimated distance squared from the bounding sphere to the point.\r\n     *\r\n     * @example\r\n     * // Sort bounding boxes from back to front\r\n     * boxes.sort(function(a, b) {\r\n     *     return Cesium.OrientedBoundingBox.distanceSquaredTo(b, camera.positionWC) - Cesium.OrientedBoundingBox.distanceSquaredTo(a, camera.positionWC);\r\n     * });\r\n     */\r\n    OrientedBoundingBox.distanceSquaredTo = function(box, cartesian) {\r\n        // See Geometric Tools for Computer Graphics 10.4.2\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(box)) {\r\n            throw new DeveloperError('box is required.');\r\n        }\r\n        if (!defined(cartesian)) {\r\n            throw new DeveloperError('cartesian is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var offset = Cartesian3.subtract(cartesian, box.center, scratchOffset);\r\n\r\n        var halfAxes = box.halfAxes;\r\n        var u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\r\n        var v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\r\n        var w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\r\n\r\n        var uHalf = Cartesian3.magnitude(u);\r\n        var vHalf = Cartesian3.magnitude(v);\r\n        var wHalf = Cartesian3.magnitude(w);\r\n\r\n        Cartesian3.normalize(u, u);\r\n        Cartesian3.normalize(v, v);\r\n        Cartesian3.normalize(w, w);\r\n\r\n        var pPrime = scratchPPrime;\r\n        pPrime.x = Cartesian3.dot(offset, u);\r\n        pPrime.y = Cartesian3.dot(offset, v);\r\n        pPrime.z = Cartesian3.dot(offset, w);\r\n\r\n        var distanceSquared = 0.0;\r\n        var d;\r\n\r\n        if (pPrime.x < -uHalf) {\r\n            d = pPrime.x + uHalf;\r\n            distanceSquared += d * d;\r\n        } else if (pPrime.x > uHalf) {\r\n            d = pPrime.x - uHalf;\r\n            distanceSquared += d * d;\r\n        }\r\n\r\n        if (pPrime.y < -vHalf) {\r\n            d = pPrime.y + vHalf;\r\n            distanceSquared += d * d;\r\n        } else if (pPrime.y > vHalf) {\r\n            d = pPrime.y - vHalf;\r\n            distanceSquared += d * d;\r\n        }\r\n\r\n        if (pPrime.z < -wHalf) {\r\n            d = pPrime.z + wHalf;\r\n            distanceSquared += d * d;\r\n        } else if (pPrime.z > wHalf) {\r\n            d = pPrime.z - wHalf;\r\n            distanceSquared += d * d;\r\n        }\r\n\r\n        return distanceSquared;\r\n    };\r\n\r\n    var scratchCorner = new Cartesian3();\r\n    var scratchToCenter = new Cartesian3();\r\n\r\n    /**\r\n     * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\r\n     * <br>\r\n     * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\r\n     * closest and farthest planes from position that intersect the bounding box.\r\n     *\r\n     * @param {OrientedBoundingBox} box The bounding box to calculate the distance to.\r\n     * @param {Cartesian3} position The position to calculate the distance from.\r\n     * @param {Cartesian3} direction The direction from position.\r\n     * @param {Interval} [result] A Interval to store the nearest and farthest distances.\r\n     * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\r\n     */\r\n    OrientedBoundingBox.computePlaneDistances = function(box, position, direction, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(box)) {\r\n            throw new DeveloperError('box is required.');\r\n        }\r\n\r\n        if (!defined(position)) {\r\n            throw new DeveloperError('position is required.');\r\n        }\r\n\r\n        if (!defined(direction)) {\r\n            throw new DeveloperError('direction is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            result = new Interval();\r\n        }\r\n\r\n        var minDist = Number.POSITIVE_INFINITY;\r\n        var maxDist = Number.NEGATIVE_INFINITY;\r\n\r\n        var center = box.center;\r\n        var halfAxes = box.halfAxes;\r\n\r\n        var u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\r\n        var v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\r\n        var w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\r\n\r\n        // project first corner\r\n        var corner = Cartesian3.add(u, v, scratchCorner);\r\n        Cartesian3.add(corner, w, corner);\r\n        Cartesian3.add(corner, center, corner);\r\n\r\n        var toCenter = Cartesian3.subtract(corner, position, scratchToCenter);\r\n        var mag = Cartesian3.dot(direction, toCenter);\r\n\r\n        minDist = Math.min(mag, minDist);\r\n        maxDist = Math.max(mag, maxDist);\r\n\r\n        // project second corner\r\n        Cartesian3.add(center, u, corner);\r\n        Cartesian3.add(corner, v, corner);\r\n        Cartesian3.subtract(corner, w, corner);\r\n\r\n        Cartesian3.subtract(corner, position, toCenter);\r\n        mag = Cartesian3.dot(direction, toCenter);\r\n\r\n        minDist = Math.min(mag, minDist);\r\n        maxDist = Math.max(mag, maxDist);\r\n\r\n        // project third corner\r\n        Cartesian3.add(center, u, corner);\r\n        Cartesian3.subtract(corner, v, corner);\r\n        Cartesian3.add(corner, w, corner);\r\n\r\n        Cartesian3.subtract(corner, position, toCenter);\r\n        mag = Cartesian3.dot(direction, toCenter);\r\n\r\n        minDist = Math.min(mag, minDist);\r\n        maxDist = Math.max(mag, maxDist);\r\n\r\n        // project fourth corner\r\n        Cartesian3.add(center, u, corner);\r\n        Cartesian3.subtract(corner, v, corner);\r\n        Cartesian3.subtract(corner, w, corner);\r\n\r\n        Cartesian3.subtract(corner, position, toCenter);\r\n        mag = Cartesian3.dot(direction, toCenter);\r\n\r\n        minDist = Math.min(mag, minDist);\r\n        maxDist = Math.max(mag, maxDist);\r\n\r\n        // project fifth corner\r\n        Cartesian3.subtract(center, u, corner);\r\n        Cartesian3.add(corner, v, corner);\r\n        Cartesian3.add(corner, w, corner);\r\n\r\n        Cartesian3.subtract(corner, position, toCenter);\r\n        mag = Cartesian3.dot(direction, toCenter);\r\n\r\n        minDist = Math.min(mag, minDist);\r\n        maxDist = Math.max(mag, maxDist);\r\n\r\n        // project sixth corner\r\n        Cartesian3.subtract(center, u, corner);\r\n        Cartesian3.add(corner, v, corner);\r\n        Cartesian3.subtract(corner, w, corner);\r\n\r\n        Cartesian3.subtract(corner, position, toCenter);\r\n        mag = Cartesian3.dot(direction, toCenter);\r\n\r\n        minDist = Math.min(mag, minDist);\r\n        maxDist = Math.max(mag, maxDist);\r\n\r\n        // project seventh corner\r\n        Cartesian3.subtract(center, u, corner);\r\n        Cartesian3.subtract(corner, v, corner);\r\n        Cartesian3.add(corner, w, corner);\r\n\r\n        Cartesian3.subtract(corner, position, toCenter);\r\n        mag = Cartesian3.dot(direction, toCenter);\r\n\r\n        minDist = Math.min(mag, minDist);\r\n        maxDist = Math.max(mag, maxDist);\r\n\r\n        // project eighth corner\r\n        Cartesian3.subtract(center, u, corner);\r\n        Cartesian3.subtract(corner, v, corner);\r\n        Cartesian3.subtract(corner, w, corner);\r\n\r\n        Cartesian3.subtract(corner, position, toCenter);\r\n        mag = Cartesian3.dot(direction, toCenter);\r\n\r\n        minDist = Math.min(mag, minDist);\r\n        maxDist = Math.max(mag, maxDist);\r\n\r\n        result.start = minDist;\r\n        result.stop = maxDist;\r\n        return result;\r\n    };\r\n\r\n    var scratchBoundingSphere = new BoundingSphere();\r\n\r\n    /**\r\n     * Determines whether or not a bounding box is hidden from view by the occluder.\r\n     *\r\n     * @param {OrientedBoundingBox} box The bounding box surrounding the occludee object.\r\n     * @param {Occluder} occluder The occluder.\r\n     * @returns {Boolean} <code>true</code> if the box is not visible; otherwise <code>false</code>.\r\n     */\r\n    OrientedBoundingBox.isOccluded = function(box, occluder) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(box)) {\r\n            throw new DeveloperError('box is required.');\r\n        }\r\n        if (!defined(occluder)) {\r\n            throw new DeveloperError('occluder is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var sphere = BoundingSphere.fromOrientedBoundingBox(box, scratchBoundingSphere);\r\n\r\n        return !occluder.isBoundingSphereVisible(sphere);\r\n    };\r\n\r\n    /**\r\n     * Determines which side of a plane the oriented bounding box is located.\r\n     *\r\n     * @param {Plane} plane The plane to test against.\r\n     * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\r\n     *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\r\n     *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\r\n     *                      intersects the plane.\r\n     */\r\n    OrientedBoundingBox.prototype.intersectPlane = function(plane) {\r\n        return OrientedBoundingBox.intersectPlane(this, plane);\r\n    };\r\n\r\n    /**\r\n     * Computes the estimated distance squared from the closest point on a bounding box to a point.\r\n     *\r\n     * @param {Cartesian3} cartesian The point\r\n     * @returns {Number} The estimated distance squared from the bounding sphere to the point.\r\n     *\r\n     * @example\r\n     * // Sort bounding boxes from back to front\r\n     * boxes.sort(function(a, b) {\r\n     *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\r\n     * });\r\n     */\r\n    OrientedBoundingBox.prototype.distanceSquaredTo = function(cartesian) {\r\n        return OrientedBoundingBox.distanceSquaredTo(this, cartesian);\r\n    };\r\n\r\n    /**\r\n     * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\r\n     * <br>\r\n     * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\r\n     * closest and farthest planes from position that intersect the bounding box.\r\n     *\r\n     * @param {Cartesian3} position The position to calculate the distance from.\r\n     * @param {Cartesian3} direction The direction from position.\r\n     * @param {Interval} [result] A Interval to store the nearest and farthest distances.\r\n     * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\r\n     */\r\n    OrientedBoundingBox.prototype.computePlaneDistances = function(position, direction, result) {\r\n        return OrientedBoundingBox.computePlaneDistances(this, position, direction, result);\r\n    };\r\n\r\n    /**\r\n     * Determines whether or not a bounding box is hidden from view by the occluder.\r\n     *\r\n     * @param {Occluder} occluder The occluder.\r\n     * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\r\n     */\r\n    OrientedBoundingBox.prototype.isOccluded = function(occluder) {\r\n        return OrientedBoundingBox.isOccluded(this, occluder);\r\n    };\r\n\r\n    /**\r\n     * Compares the provided OrientedBoundingBox componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {OrientedBoundingBox} left The first OrientedBoundingBox.\r\n     * @param {OrientedBoundingBox} right The second OrientedBoundingBox.\r\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n     */\r\n    OrientedBoundingBox.equals = function(left, right) {\r\n        return (left === right) ||\r\n                ((defined(left)) &&\r\n                 (defined(right)) &&\r\n                 Cartesian3.equals(left.center, right.center) &&\r\n                 Matrix3.equals(left.halfAxes, right.halfAxes));\r\n    };\r\n\r\n    /**\r\n     * Duplicates this OrientedBoundingBox instance.\r\n     *\r\n     * @param {OrientedBoundingBox} [result] The object onto which to store the result.\r\n     * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\r\n     */\r\n    OrientedBoundingBox.prototype.clone = function(result) {\r\n        return OrientedBoundingBox.clone(this, result);\r\n    };\r\n\r\n    /**\r\n     * Compares this OrientedBoundingBox against the provided OrientedBoundingBox componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {OrientedBoundingBox} [right] The right hand side OrientedBoundingBox.\r\n     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     */\r\n    OrientedBoundingBox.prototype.equals = function(right) {\r\n        return OrientedBoundingBox.equals(this, right);\r\n    };\r\nexport default OrientedBoundingBox;\r\n"],"names":["OrientedBoundingBox","center","halfAxes","this","Cartesian3","clone","defaultValue","ZERO","Matrix3","packedLength","pack","value","array","startingIndex","Check","typeOf","object","defined","unpack","result","scratchCartesian1","scratchCartesian2","scratchCartesian3","scratchCartesian4","scratchCartesian5","scratchCartesian6","scratchCovarianceResult","scratchEigenResult","unitary","diagonal","fromPoints","positions","length","i","meanPoint","add","invLength","multiplyByScalar","p","exx","exy","exz","eyy","eyz","ezz","subtract","x","y","z","covarianceMatrix","eigenDecomposition","computeEigenDecomposition","rotation","v1","getColumn","v2","v3","u1","Number","MAX_VALUE","u2","u3","l1","l2","l3","Math","max","dot","min","scale","multiplyByScale","scratchOffset","scratchScale","fromPlaneExtents","planeOrigin","planeXAxis","planeYAxis","planeZAxis","minimumX","maximumX","minimumY","maximumY","minimumZ","maximumZ","DeveloperError","setColumn","centerOffset","multiplyByVector","scratchRectangleCenterCartographic","Cartographic","scratchRectangleCenter","scratchPerimeterCartographicNC","scratchPerimeterCartographicNW","scratchPerimeterCartographicCW","scratchPerimeterCartographicSW","scratchPerimeterCartographicSC","scratchPerimeterCartesianNC","scratchPerimeterCartesianNW","scratchPerimeterCartesianCW","scratchPerimeterCartesianSW","scratchPerimeterCartesianSC","scratchPerimeterProjectedNC","Cartesian2","scratchPerimeterProjectedNW","scratchPerimeterProjectedCW","scratchPerimeterProjectedSW","scratchPerimeterProjectedSC","scratchPlaneOrigin","scratchPlaneNormal","scratchPlaneXAxis","scratchHorizonCartesian","scratchHorizonProjected","scratchMaxY","scratchMinY","scratchZ","scratchPlane","Plane","UNIT_X","fromRectangle","rectangle","minimumHeight","maximumHeight","ellipsoid","width","CesiumMath","TWO_PI","height","PI","equalsEpsilon","radii","EPSILON15","minX","maxX","minY","maxY","minZ","maxZ","plane","Ellipsoid","WGS84","tangentPointCartographic","Rectangle","tangentPoint","cartographicToCartesian","tangentPlane","EllipsoidTangentPlane","lonCenter","longitude","latCenter","south","north","latitude","perimeterCartographicNC","fromRadians","perimeterCartographicNW","west","perimeterCartographicCW","perimeterCartographicSW","perimeterCartographicSC","perimeterCartesianNC","perimeterCartesianNW","perimeterCartesianCW","perimeterCartesianSW","perimeterCartesianSC","perimeterProjectedNC","projectPointToNearestOnPlane","perimeterProjectedNW","perimeterProjectedCW","perimeterProjectedSW","perimeterProjectedSC","getPointDistance","origin","xAxis","yAxis","zAxis","fullyAboveEquator","fullyBelowEquator","latitudeNearestToEquator","centerLongitude","planeNormal","abs","EPSILON10","normalize","UNIT_Z","cross","fromPointNormal","horizonCartesian","PI_OVER_TWO","projectPointOntoPlane","farZ","east","box","intersectPlane","normal","normalX","normalY","normalZ","radEffective","COLUMN0ROW0","COLUMN0ROW1","COLUMN0ROW2","COLUMN1ROW0","COLUMN1ROW1","COLUMN1ROW2","COLUMN2ROW0","COLUMN2ROW1","COLUMN2ROW2","distanceToPlane","distance","Intersect","OUTSIDE","INSIDE","INTERSECTING","scratchCartesianU","scratchCartesianV","scratchCartesianW","scratchPPrime","distanceSquaredTo","cartesian","offset","u","v","w","uHalf","magnitude","vHalf","wHalf","pPrime","d","distanceSquared","scratchCorner","scratchToCenter","computePlaneDistances","position","direction","Interval","minDist","POSITIVE_INFINITY","maxDist","NEGATIVE_INFINITY","corner","toCenter","mag","start","stop","scratchBoundingSphere","BoundingSphere","isOccluded","occluder","sphere","fromOrientedBoundingBox","isBoundingSphereVisible","prototype","equals","left","right"],"mappings":"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"}