{"version":3,"file":"createSimplePolylineGeometry.js","sources":["../../../../Source/Core/SimplePolylineGeometry.js","../../../../Source/WorkersES6/createSimplePolylineGeometry.js"],"sourcesContent":["import ArcType from './ArcType.js';\r\nimport BoundingSphere from './BoundingSphere.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport Color from './Color.js';\r\nimport ComponentDatatype from './ComponentDatatype.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport Geometry from './Geometry.js';\r\nimport GeometryAttribute from './GeometryAttribute.js';\r\nimport GeometryAttributes from './GeometryAttributes.js';\r\nimport IndexDatatype from './IndexDatatype.js';\r\nimport CesiumMath from './Math.js';\r\nimport PolylinePipeline from './PolylinePipeline.js';\r\nimport PrimitiveType from './PrimitiveType.js';\r\n\r\n    function interpolateColors(p0, p1, color0, color1, minDistance, array, offset) {\r\n        var numPoints = PolylinePipeline.numberOfPoints(p0, p1, minDistance);\r\n        var i;\r\n\r\n        var r0 = color0.red;\r\n        var g0 = color0.green;\r\n        var b0 = color0.blue;\r\n        var a0 = color0.alpha;\r\n\r\n        var r1 = color1.red;\r\n        var g1 = color1.green;\r\n        var b1 = color1.blue;\r\n        var a1 = color1.alpha;\r\n\r\n        if (Color.equals(color0, color1)) {\r\n            for (i = 0; i < numPoints; i++) {\r\n                array[offset++] = Color.floatToByte(r0);\r\n                array[offset++] = Color.floatToByte(g0);\r\n                array[offset++] = Color.floatToByte(b0);\r\n                array[offset++] = Color.floatToByte(a0);\r\n            }\r\n            return offset;\r\n        }\r\n\r\n        var redPerVertex = (r1 - r0) / numPoints;\r\n        var greenPerVertex = (g1 - g0) / numPoints;\r\n        var bluePerVertex = (b1 - b0) / numPoints;\r\n        var alphaPerVertex = (a1 - a0) / numPoints;\r\n\r\n        var index = offset;\r\n        for (i = 0; i < numPoints; i++) {\r\n            array[index++] = Color.floatToByte(r0 + i * redPerVertex);\r\n            array[index++] = Color.floatToByte(g0 + i * greenPerVertex);\r\n            array[index++] = Color.floatToByte(b0 + i * bluePerVertex);\r\n            array[index++] = Color.floatToByte(a0 + i * alphaPerVertex);\r\n        }\r\n\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * A description of a polyline modeled as a line strip; the first two positions define a line segment,\r\n     * and each additional position defines a line segment from the previous position.\r\n     *\r\n     * @alias SimplePolylineGeometry\r\n     * @constructor\r\n     *\r\n     * @param {Object} options Object with the following properties:\r\n     * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the positions in the polyline as a line strip.\r\n     * @param {Color[]} [options.colors] An Array of {@link Color} defining the per vertex or per segment colors.\r\n     * @param {Boolean} [options.colorsPerVertex=false] A boolean that determines whether the colors will be flat across each segment of the line or interpolated across the vertices.\r\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow.\r\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude if options.arcType is not ArcType.NONE. Determines the number of positions in the buffer.\r\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\r\n     *\r\n     * @exception {DeveloperError} At least two positions are required.\r\n     * @exception {DeveloperError} colors has an invalid length.\r\n     *\r\n     * @see SimplePolylineGeometry#createGeometry\r\n     *\r\n     * @example\r\n     * // A polyline with two connected line segments\r\n     * var polyline = new Cesium.SimplePolylineGeometry({\r\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\r\n     *     0.0, 0.0,\r\n     *     5.0, 0.0,\r\n     *     5.0, 5.0\r\n     *   ])\r\n     * });\r\n     * var geometry = Cesium.SimplePolylineGeometry.createGeometry(polyline);\r\n     */\r\n    function SimplePolylineGeometry(options) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n        var positions = options.positions;\r\n        var colors = options.colors;\r\n        var colorsPerVertex = defaultValue(options.colorsPerVertex, false);\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if ((!defined(positions)) || (positions.length < 2)) {\r\n            throw new DeveloperError('At least two positions are required.');\r\n        }\r\n        if (defined(colors) && ((colorsPerVertex && colors.length < positions.length) || (!colorsPerVertex && colors.length < positions.length - 1))) {\r\n            throw new DeveloperError('colors has an invalid length.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        this._positions = positions;\r\n        this._colors = colors;\r\n        this._colorsPerVertex = colorsPerVertex;\r\n\r\n        this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);\r\n        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\r\n        this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n        this._workerName = 'createSimplePolylineGeometry';\r\n\r\n        var numComponents = 1 + positions.length * Cartesian3.packedLength;\r\n        numComponents += defined(colors) ? 1 + colors.length * Color.packedLength : 1;\r\n\r\n        /**\r\n         * The number of elements used to pack the object into an array.\r\n         * @type {Number}\r\n         */\r\n        this.packedLength = numComponents + Ellipsoid.packedLength + 3;\r\n    }\r\n\r\n    /**\r\n     * Stores the provided instance into the provided array.\r\n     *\r\n     * @param {SimplePolylineGeometry} value The value to pack.\r\n     * @param {Number[]} array The array to pack into.\r\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n     *\r\n     * @returns {Number[]} The array that was packed into\r\n     */\r\n    SimplePolylineGeometry.pack = function(value, array, startingIndex) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(value)) {\r\n            throw new DeveloperError('value is required');\r\n        }\r\n        if (!defined(array)) {\r\n            throw new DeveloperError('array is required');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        var i;\r\n\r\n        var positions = value._positions;\r\n        var length = positions.length;\r\n        array[startingIndex++] = length;\r\n\r\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\r\n            Cartesian3.pack(positions[i], array, startingIndex);\r\n        }\r\n\r\n        var colors = value._colors;\r\n        length = defined(colors) ? colors.length : 0.0;\r\n        array[startingIndex++] = length;\r\n\r\n        for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\r\n            Color.pack(colors[i], array, startingIndex);\r\n        }\r\n\r\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\r\n        startingIndex += Ellipsoid.packedLength;\r\n\r\n        array[startingIndex++] = value._colorsPerVertex ? 1.0 : 0.0;\r\n        array[startingIndex++] = value._arcType;\r\n        array[startingIndex]   = value._granularity;\r\n\r\n        return array;\r\n    };\r\n\r\n    /**\r\n     * Retrieves an instance from a packed array.\r\n     *\r\n     * @param {Number[]} array The packed array.\r\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n     * @param {SimplePolylineGeometry} [result] The object into which to store the result.\r\n     * @returns {SimplePolylineGeometry} The modified result parameter or a new SimplePolylineGeometry instance if one was not provided.\r\n     */\r\n    SimplePolylineGeometry.unpack = function(array, startingIndex, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(array)) {\r\n            throw new DeveloperError('array is required');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        var i;\r\n\r\n        var length = array[startingIndex++];\r\n        var positions = new Array(length);\r\n\r\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\r\n            positions[i] = Cartesian3.unpack(array, startingIndex);\r\n        }\r\n\r\n        length = array[startingIndex++];\r\n        var colors = length > 0 ? new Array(length) : undefined;\r\n\r\n        for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\r\n            colors[i] = Color.unpack(array, startingIndex);\r\n        }\r\n\r\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex);\r\n        startingIndex += Ellipsoid.packedLength;\r\n\r\n        var colorsPerVertex = array[startingIndex++] === 1.0;\r\n        var arcType = array[startingIndex++];\r\n        var granularity = array[startingIndex];\r\n\r\n        if (!defined(result)) {\r\n            return new SimplePolylineGeometry({\r\n                positions : positions,\r\n                colors : colors,\r\n                ellipsoid : ellipsoid,\r\n                colorsPerVertex : colorsPerVertex,\r\n                arcType : arcType,\r\n                granularity : granularity\r\n            });\r\n        }\r\n\r\n        result._positions = positions;\r\n        result._colors = colors;\r\n        result._ellipsoid = ellipsoid;\r\n        result._colorsPerVertex = colorsPerVertex;\r\n        result._arcType = arcType;\r\n        result._granularity = granularity;\r\n\r\n        return result;\r\n    };\r\n\r\n    var scratchArray1 = new Array(2);\r\n    var scratchArray2 = new Array(2);\r\n    var generateArcOptionsScratch = {\r\n        positions : scratchArray1,\r\n        height: scratchArray2,\r\n        ellipsoid: undefined,\r\n        minDistance : undefined,\r\n        granularity : undefined\r\n    };\r\n\r\n    /**\r\n     * Computes the geometric representation of a simple polyline, including its vertices, indices, and a bounding sphere.\r\n     *\r\n     * @param {SimplePolylineGeometry} simplePolylineGeometry A description of the polyline.\r\n     * @returns {Geometry} The computed vertices and indices.\r\n     */\r\n    SimplePolylineGeometry.createGeometry = function(simplePolylineGeometry) {\r\n        var positions = simplePolylineGeometry._positions;\r\n        var colors = simplePolylineGeometry._colors;\r\n        var colorsPerVertex = simplePolylineGeometry._colorsPerVertex;\r\n        var arcType = simplePolylineGeometry._arcType;\r\n        var granularity = simplePolylineGeometry._granularity;\r\n        var ellipsoid = simplePolylineGeometry._ellipsoid;\r\n\r\n        var minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\r\n        var perSegmentColors = defined(colors) && !colorsPerVertex;\r\n\r\n        var i;\r\n        var length = positions.length;\r\n\r\n        var positionValues;\r\n        var numberOfPositions;\r\n        var colorValues;\r\n        var color;\r\n        var offset = 0;\r\n\r\n        if (arcType === ArcType.GEODESIC || arcType === ArcType.RHUMB) {\r\n            var subdivisionSize;\r\n            var numberOfPointsFunction;\r\n            var generateArcFunction;\r\n            if (arcType === ArcType.GEODESIC) {\r\n                subdivisionSize = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\r\n                numberOfPointsFunction = PolylinePipeline.numberOfPoints;\r\n                generateArcFunction = PolylinePipeline.generateArc;\r\n            } else {\r\n                subdivisionSize = granularity;\r\n                numberOfPointsFunction = PolylinePipeline.numberOfPointsRhumbLine;\r\n                generateArcFunction = PolylinePipeline.generateRhumbArc;\r\n            }\r\n\r\n            var heights = PolylinePipeline.extractHeights(positions, ellipsoid);\r\n\r\n            var generateArcOptions = generateArcOptionsScratch;\r\n            if (arcType === ArcType.GEODESIC) {\r\n                generateArcOptions.minDistance = minDistance;\r\n            } else {\r\n                generateArcOptions.granularity = granularity;\r\n            }\r\n            generateArcOptions.ellipsoid = ellipsoid;\r\n\r\n            if (perSegmentColors) {\r\n                var positionCount = 0;\r\n                for (i = 0; i < length - 1; i++) {\r\n                    positionCount += numberOfPointsFunction(positions[i], positions[i+1], subdivisionSize) + 1;\r\n                }\r\n\r\n                positionValues = new Float64Array(positionCount * 3);\r\n                colorValues = new Uint8Array(positionCount * 4);\r\n\r\n                generateArcOptions.positions = scratchArray1;\r\n                generateArcOptions.height= scratchArray2;\r\n\r\n                var ci = 0;\r\n                for (i = 0; i < length - 1; ++i) {\r\n                    scratchArray1[0] = positions[i];\r\n                    scratchArray1[1] = positions[i + 1];\r\n\r\n                    scratchArray2[0] = heights[i];\r\n                    scratchArray2[1] = heights[i + 1];\r\n\r\n                    var pos = generateArcFunction(generateArcOptions);\r\n\r\n                    if (defined(colors)) {\r\n                        var segLen = pos.length / 3;\r\n                        color = colors[i];\r\n                        for(var k = 0; k < segLen; ++k) {\r\n                            colorValues[ci++] = Color.floatToByte(color.red);\r\n                            colorValues[ci++] = Color.floatToByte(color.green);\r\n                            colorValues[ci++] = Color.floatToByte(color.blue);\r\n                            colorValues[ci++] = Color.floatToByte(color.alpha);\r\n                        }\r\n                    }\r\n\r\n                    positionValues.set(pos, offset);\r\n                    offset += pos.length;\r\n                }\r\n            } else {\r\n                generateArcOptions.positions = positions;\r\n                generateArcOptions.height= heights;\r\n                positionValues = new Float64Array(generateArcFunction(generateArcOptions));\r\n\r\n                if (defined(colors)) {\r\n                    colorValues = new Uint8Array(positionValues.length / 3 * 4);\r\n\r\n                    for (i = 0; i < length - 1; ++i) {\r\n                        var p0 = positions[i];\r\n                        var p1 = positions[i + 1];\r\n                        var c0 = colors[i];\r\n                        var c1 = colors[i + 1];\r\n                        offset = interpolateColors(p0, p1, c0, c1, minDistance, colorValues, offset);\r\n                    }\r\n\r\n                    var lastColor = colors[length - 1];\r\n                    colorValues[offset++] = Color.floatToByte(lastColor.red);\r\n                    colorValues[offset++] = Color.floatToByte(lastColor.green);\r\n                    colorValues[offset++] = Color.floatToByte(lastColor.blue);\r\n                    colorValues[offset++] = Color.floatToByte(lastColor.alpha);\r\n                }\r\n            }\r\n        } else {\r\n            numberOfPositions = perSegmentColors ? length * 2 - 2 : length;\r\n            positionValues = new Float64Array(numberOfPositions * 3);\r\n            colorValues = defined(colors) ? new Uint8Array(numberOfPositions * 4) : undefined;\r\n\r\n            var positionIndex = 0;\r\n            var colorIndex = 0;\r\n\r\n            for (i = 0; i < length; ++i) {\r\n                var p = positions[i];\r\n\r\n                if (perSegmentColors && i > 0) {\r\n                    Cartesian3.pack(p, positionValues, positionIndex);\r\n                    positionIndex += 3;\r\n\r\n                    color = colors[i - 1];\r\n                    colorValues[colorIndex++] = Color.floatToByte(color.red);\r\n                    colorValues[colorIndex++] = Color.floatToByte(color.green);\r\n                    colorValues[colorIndex++] = Color.floatToByte(color.blue);\r\n                    colorValues[colorIndex++] = Color.floatToByte(color.alpha);\r\n                }\r\n\r\n                if (perSegmentColors && i === length - 1) {\r\n                    break;\r\n                }\r\n\r\n                Cartesian3.pack(p, positionValues, positionIndex);\r\n                positionIndex += 3;\r\n\r\n                if (defined(colors)) {\r\n                    color = colors[i];\r\n                    colorValues[colorIndex++] = Color.floatToByte(color.red);\r\n                    colorValues[colorIndex++] = Color.floatToByte(color.green);\r\n                    colorValues[colorIndex++] = Color.floatToByte(color.blue);\r\n                    colorValues[colorIndex++] = Color.floatToByte(color.alpha);\r\n                }\r\n            }\r\n        }\r\n\r\n        var attributes = new GeometryAttributes();\r\n        attributes.position = new GeometryAttribute({\r\n            componentDatatype : ComponentDatatype.DOUBLE,\r\n            componentsPerAttribute : 3,\r\n            values : positionValues\r\n        });\r\n\r\n        if (defined(colors)) {\r\n            attributes.color = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\r\n                componentsPerAttribute : 4,\r\n                values : colorValues,\r\n                normalize : true\r\n            });\r\n        }\r\n\r\n        numberOfPositions = positionValues.length / 3;\r\n        var numberOfIndices = (numberOfPositions - 1) * 2;\r\n        var indices = IndexDatatype.createTypedArray(numberOfPositions, numberOfIndices);\r\n\r\n        var index = 0;\r\n        for (i = 0; i < numberOfPositions - 1; ++i) {\r\n            indices[index++] = i;\r\n            indices[index++] = i + 1;\r\n        }\r\n\r\n        return new Geometry({\r\n            attributes : attributes,\r\n            indices : indices,\r\n            primitiveType : PrimitiveType.LINES,\r\n            boundingSphere : BoundingSphere.fromPoints(positions)\r\n        });\r\n    };\r\nexport default SimplePolylineGeometry;\r\n","import defined from '../Core/defined.js';\r\nimport Ellipsoid from '../Core/Ellipsoid.js';\r\nimport SimplePolylineGeometry from '../Core/SimplePolylineGeometry.js';\r\n\r\n    function createSimplePolylineGeometry(simplePolylineGeometry, offset) {\r\n        if (defined(offset)) {\r\n            simplePolylineGeometry = SimplePolylineGeometry.unpack(simplePolylineGeometry, offset);\r\n        }\r\n        simplePolylineGeometry._ellipsoid = Ellipsoid.clone(simplePolylineGeometry._ellipsoid);\r\n        return SimplePolylineGeometry.createGeometry(simplePolylineGeometry);\r\n    }\r\nexport default createSimplePolylineGeometry;\r\n"],"names":["interpolateColors","p0","p1","color0","color1","minDistance","array","offset","i","numPoints","PolylinePipeline","numberOfPoints","r0","red","g0","green","b0","blue","a0","alpha","r1","g1","b1","a1","Color","equals","floatToByte","redPerVertex","greenPerVertex","bluePerVertex","alphaPerVertex","index","SimplePolylineGeometry","options","positions","defaultValue","EMPTY_OBJECT","colors","colorsPerVertex","defined","length","DeveloperError","this","_positions","_colors","_colorsPerVertex","_arcType","arcType","ArcType","GEODESIC","_granularity","granularity","CesiumMath","RADIANS_PER_DEGREE","_ellipsoid","ellipsoid","Ellipsoid","WGS84","_workerName","numComponents","Cartesian3","packedLength","pack","value","startingIndex","unpack","result","Array","undefined","scratchArray1","scratchArray2","generateArcOptionsScratch","height","createGeometry","simplePolylineGeometry","positionValues","numberOfPositions","colorValues","color","chordLength","maximumRadius","perSegmentColors","RHUMB","subdivisionSize","numberOfPointsFunction","generateArcFunction","generateArc","numberOfPointsRhumbLine","generateRhumbArc","heights","extractHeights","generateArcOptions","positionCount","Float64Array","Uint8Array","ci","pos","segLen","k","set","lastColor","positionIndex","colorIndex","p","attributes","GeometryAttributes","position","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","UNSIGNED_BYTE","normalize","numberOfIndices","indices","IndexDatatype","createTypedArray","Geometry","primitiveType","PrimitiveType","LINES","boundingSphere","BoundingSphere","fromPoints","clone"],"mappings":"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"}