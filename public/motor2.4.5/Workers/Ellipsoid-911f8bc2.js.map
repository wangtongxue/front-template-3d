{"version":3,"file":"Ellipsoid-911f8bc2.js","sources":["../../../../Source/Core/Cartesian3.js","../../../../Source/Core/scaleToGeodeticSurface.js","../../../../Source/Core/Cartographic.js","../../../../Source/Core/Ellipsoid.js"],"sourcesContent":["import Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport CesiumMath from './Math.js';\r\n\r\n    /**\r\n     * A 3D Cartesian point.\r\n     * @alias Cartesian3\r\n     * @constructor\r\n     *\r\n     * @param {Number} [x=0.0] The X component.\r\n     * @param {Number} [y=0.0] The Y component.\r\n     * @param {Number} [z=0.0] The Z component.\r\n     *\r\n     * @see Cartesian2\r\n     * @see Cartesian4\r\n     * @see Packable\r\n     */\r\n    function Cartesian3(x, y, z) {\r\n        /**\r\n         * The X component.\r\n         * @type {Number}\r\n         * @default 0.0\r\n         */\r\n        this.x = defaultValue(x, 0.0);\r\n\r\n        /**\r\n         * The Y component.\r\n         * @type {Number}\r\n         * @default 0.0\r\n         */\r\n        this.y = defaultValue(y, 0.0);\r\n\r\n        /**\r\n         * The Z component.\r\n         * @type {Number}\r\n         * @default 0.0\r\n         */\r\n        this.z = defaultValue(z, 0.0);\r\n    }\r\n\r\n    /**\r\n     * Converts the provided Spherical into Cartesian3 coordinates.\r\n     *\r\n     * @param {Spherical} spherical The Spherical to be converted to Cartesian3.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\r\n     */\r\n    Cartesian3.fromSpherical = function(spherical, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('spherical', spherical);\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n\r\n        var clock = spherical.clock;\r\n        var cone = spherical.cone;\r\n        var magnitude = defaultValue(spherical.magnitude, 1.0);\r\n        var radial = magnitude * Math.sin(cone);\r\n        result.x = radial * Math.cos(clock);\r\n        result.y = radial * Math.sin(clock);\r\n        result.z = magnitude * Math.cos(cone);\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Creates a Cartesian3 instance from x, y and z coordinates.\r\n     *\r\n     * @param {Number} x The x coordinate.\r\n     * @param {Number} y The y coordinate.\r\n     * @param {Number} z The z coordinate.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\r\n     */\r\n    Cartesian3.fromElements = function(x, y, z, result) {\r\n        if (!defined(result)) {\r\n            return new Cartesian3(x, y, z);\r\n        }\r\n\r\n        result.x = x;\r\n        result.y = y;\r\n        result.z = z;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Duplicates a Cartesian3 instance.\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian to duplicate.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided. (Returns undefined if cartesian is undefined)\r\n     */\r\n    Cartesian3.clone = function(cartesian, result) {\r\n        if (!defined(cartesian)) {\r\n            return undefined;\r\n        }\r\n        if (!defined(result)) {\r\n            return new Cartesian3(cartesian.x, cartesian.y, cartesian.z);\r\n        }\r\n\r\n        result.x = cartesian.x;\r\n        result.y = cartesian.y;\r\n        result.z = cartesian.z;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Creates a Cartesian3 instance from an existing Cartesian4.  This simply takes the\r\n     * x, y, and z properties of the Cartesian4 and drops w.\r\n     * @function\r\n     *\r\n     * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian3 instance from.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\r\n     */\r\n    Cartesian3.fromCartesian4 = Cartesian3.clone;\r\n\r\n    /**\r\n     * The number of elements used to pack the object into an array.\r\n     * @type {Number}\r\n     */\r\n    Cartesian3.packedLength = 3;\r\n\r\n    /**\r\n     * Stores the provided instance into the provided array.\r\n     *\r\n     * @param {Cartesian3} value The value to pack.\r\n     * @param {Number[]} array The array to pack into.\r\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n     *\r\n     * @returns {Number[]} The array that was packed into\r\n     */\r\n    Cartesian3.pack = function(value, array, startingIndex) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('value', value);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        array[startingIndex++] = value.x;\r\n        array[startingIndex++] = value.y;\r\n        array[startingIndex] = value.z;\r\n\r\n        return array;\r\n    };\r\n\r\n    /**\r\n     * Retrieves an instance from a packed array.\r\n     *\r\n     * @param {Number[]} array The packed array.\r\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n     * @param {Cartesian3} [result] The object into which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\r\n     */\r\n    Cartesian3.unpack = function(array, startingIndex, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n        result.x = array[startingIndex++];\r\n        result.y = array[startingIndex++];\r\n        result.z = array[startingIndex];\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Flattens an array of Cartesian3s into an array of components.\r\n     *\r\n     * @param {Cartesian3[]} array The array of cartesians to pack.\r\n     * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 3 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 3) elements.\r\n     * @returns {Number[]} The packed array.\r\n     */\r\n    Cartesian3.packArray = function(array, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        var length = array.length;\r\n        var resultLength = length * 3;\r\n        if (!defined(result)) {\r\n            result = new Array(resultLength);\r\n        } else if (!Array.isArray(result) && result.length !== resultLength) {\r\n            throw new DeveloperError('If result is a typed array, it must have exactly array.length * 3 elements');\r\n        } else if (result.length !== resultLength) {\r\n            result.length = resultLength;\r\n        }\r\n\r\n        for (var i = 0; i < length; ++i) {\r\n            Cartesian3.pack(array[i], result, i * 3);\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Unpacks an array of cartesian components into an array of Cartesian3s.\r\n     *\r\n     * @param {Number[]} array The array of components to unpack.\r\n     * @param {Cartesian3[]} [result] The array onto which to store the result.\r\n     * @returns {Cartesian3[]} The unpacked array.\r\n     */\r\n    Cartesian3.unpackArray = function(array, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('array', array);\r\n        Check.typeOf.number.greaterThanOrEquals('array.length', array.length, 3);\r\n        if (array.length % 3 !== 0) {\r\n            throw new DeveloperError('array length must be a multiple of 3.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var length = array.length;\r\n        if (!defined(result)) {\r\n            result = new Array(length / 3);\r\n        } else {\r\n            result.length = length / 3;\r\n        }\r\n\r\n        for (var i = 0; i < length; i += 3) {\r\n            var index = i / 3;\r\n            result[index] = Cartesian3.unpack(array, i, result[index]);\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Creates a Cartesian3 from three consecutive elements in an array.\r\n     * @function\r\n     *\r\n     * @param {Number[]} array The array whose three consecutive elements correspond to the x, y, and z components, respectively.\r\n     * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\r\n     *\r\n     * @example\r\n     * // Create a Cartesian3 with (1.0, 2.0, 3.0)\r\n     * var v = [1.0, 2.0, 3.0];\r\n     * var p = Cesium.Cartesian3.fromArray(v);\r\n     *\r\n     * // Create a Cartesian3 with (1.0, 2.0, 3.0) using an offset into an array\r\n     * var v2 = [0.0, 0.0, 1.0, 2.0, 3.0];\r\n     * var p2 = Cesium.Cartesian3.fromArray(v2, 2);\r\n     */\r\n    Cartesian3.fromArray = Cartesian3.unpack;\r\n\r\n    /**\r\n     * Computes the value of the maximum component for the supplied Cartesian.\r\n     *\r\n     * @param {Cartesian3} cartesian The cartesian to use.\r\n     * @returns {Number} The value of the maximum component.\r\n     */\r\n    Cartesian3.maximumComponent = function(cartesian) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('cartesian', cartesian);\r\n        //>>includeEnd('debug');\r\n\r\n        return Math.max(cartesian.x, cartesian.y, cartesian.z);\r\n    };\r\n\r\n    /**\r\n     * Computes the value of the minimum component for the supplied Cartesian.\r\n     *\r\n     * @param {Cartesian3} cartesian The cartesian to use.\r\n     * @returns {Number} The value of the minimum component.\r\n     */\r\n    Cartesian3.minimumComponent = function(cartesian) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('cartesian', cartesian);\r\n        //>>includeEnd('debug');\r\n\r\n        return Math.min(cartesian.x, cartesian.y, cartesian.z);\r\n    };\r\n\r\n    /**\r\n     * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\r\n     *\r\n     * @param {Cartesian3} first A cartesian to compare.\r\n     * @param {Cartesian3} second A cartesian to compare.\r\n     * @param {Cartesian3} result The object into which to store the result.\r\n     * @returns {Cartesian3} A cartesian with the minimum components.\r\n     */\r\n    Cartesian3.minimumByComponent = function(first, second, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('first', first);\r\n        Check.typeOf.object('second', second);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        result.x = Math.min(first.x, second.x);\r\n        result.y = Math.min(first.y, second.y);\r\n        result.z = Math.min(first.z, second.z);\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\r\n     *\r\n     * @param {Cartesian3} first A cartesian to compare.\r\n     * @param {Cartesian3} second A cartesian to compare.\r\n     * @param {Cartesian3} result The object into which to store the result.\r\n     * @returns {Cartesian3} A cartesian with the maximum components.\r\n     */\r\n    Cartesian3.maximumByComponent = function(first, second, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('first', first);\r\n        Check.typeOf.object('second', second);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        result.x = Math.max(first.x, second.x);\r\n        result.y = Math.max(first.y, second.y);\r\n        result.z = Math.max(first.z, second.z);\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the provided Cartesian's squared magnitude.\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian instance whose squared magnitude is to be computed.\r\n     * @returns {Number} The squared magnitude.\r\n     */\r\n    Cartesian3.magnitudeSquared = function(cartesian) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('cartesian', cartesian);\r\n        //>>includeEnd('debug');\r\n\r\n        return cartesian.x * cartesian.x + cartesian.y * cartesian.y + cartesian.z * cartesian.z;\r\n    };\r\n\r\n    /**\r\n     * Computes the Cartesian's magnitude (length).\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian instance whose magnitude is to be computed.\r\n     * @returns {Number} The magnitude.\r\n     */\r\n    Cartesian3.magnitude = function(cartesian) {\r\n        return Math.sqrt(Cartesian3.magnitudeSquared(cartesian));\r\n    };\r\n\r\n    var distanceScratch = new Cartesian3();\r\n\r\n    /**\r\n     * Computes the distance between two points.\r\n     *\r\n     * @param {Cartesian3} left The first point to compute the distance from.\r\n     * @param {Cartesian3} right The second point to compute the distance to.\r\n     * @returns {Number} The distance between two points.\r\n     *\r\n     * @example\r\n     * // Returns 1.0\r\n     * var d = Cesium.Cartesian3.distance(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(2.0, 0.0, 0.0));\r\n     */\r\n    Cartesian3.distance = function(left, right) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('left', left);\r\n        Check.typeOf.object('right', right);\r\n        //>>includeEnd('debug');\r\n\r\n        Cartesian3.subtract(left, right, distanceScratch);\r\n        return Cartesian3.magnitude(distanceScratch);\r\n    };\r\n\r\n    /**\r\n     * Computes the squared distance between two points.  Comparing squared distances\r\n     * using this function is more efficient than comparing distances using {@link Cartesian3#distance}.\r\n     *\r\n     * @param {Cartesian3} left The first point to compute the distance from.\r\n     * @param {Cartesian3} right The second point to compute the distance to.\r\n     * @returns {Number} The distance between two points.\r\n     *\r\n     * @example\r\n     * // Returns 4.0, not 2.0\r\n     * var d = Cesium.Cartesian3.distanceSquared(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(3.0, 0.0, 0.0));\r\n     */\r\n    Cartesian3.distanceSquared = function(left, right) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('left', left);\r\n        Check.typeOf.object('right', right);\r\n        //>>includeEnd('debug');\r\n\r\n        Cartesian3.subtract(left, right, distanceScratch);\r\n        return Cartesian3.magnitudeSquared(distanceScratch);\r\n    };\r\n\r\n    /**\r\n     * Computes the normalized form of the supplied Cartesian.\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian to be normalized.\r\n     * @param {Cartesian3} result The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter.\r\n     */\r\n    Cartesian3.normalize = function(cartesian, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('cartesian', cartesian);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        var magnitude = Cartesian3.magnitude(cartesian);\r\n\r\n        result.x = cartesian.x / magnitude;\r\n        result.y = cartesian.y / magnitude;\r\n        result.z = cartesian.z / magnitude;\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (isNaN(result.x) || isNaN(result.y) || isNaN(result.z)) {\r\n            throw new DeveloperError('normalized result is not a number');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the dot (scalar) product of two Cartesians.\r\n     *\r\n     * @param {Cartesian3} left The first Cartesian.\r\n     * @param {Cartesian3} right The second Cartesian.\r\n     * @returns {Number} The dot product.\r\n     */\r\n    Cartesian3.dot = function(left, right) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('left', left);\r\n        Check.typeOf.object('right', right);\r\n        //>>includeEnd('debug');\r\n\r\n        return left.x * right.x + left.y * right.y + left.z * right.z;\r\n    };\r\n\r\n    /**\r\n     * Computes the componentwise product of two Cartesians.\r\n     *\r\n     * @param {Cartesian3} left The first Cartesian.\r\n     * @param {Cartesian3} right The second Cartesian.\r\n     * @param {Cartesian3} result The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter.\r\n     */\r\n    Cartesian3.multiplyComponents = function(left, right, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('left', left);\r\n        Check.typeOf.object('right', right);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        result.x = left.x * right.x;\r\n        result.y = left.y * right.y;\r\n        result.z = left.z * right.z;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the componentwise quotient of two Cartesians.\r\n     *\r\n     * @param {Cartesian3} left The first Cartesian.\r\n     * @param {Cartesian3} right The second Cartesian.\r\n     * @param {Cartesian3} result The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter.\r\n     */\r\n    Cartesian3.divideComponents = function(left, right, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('left', left);\r\n        Check.typeOf.object('right', right);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        result.x = left.x / right.x;\r\n        result.y = left.y / right.y;\r\n        result.z = left.z / right.z;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the componentwise sum of two Cartesians.\r\n     *\r\n     * @param {Cartesian3} left The first Cartesian.\r\n     * @param {Cartesian3} right The second Cartesian.\r\n     * @param {Cartesian3} result The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter.\r\n     */\r\n    Cartesian3.add = function(left, right, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('left', left);\r\n        Check.typeOf.object('right', right);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        result.x = left.x + right.x;\r\n        result.y = left.y + right.y;\r\n        result.z = left.z + right.z;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the componentwise difference of two Cartesians.\r\n     *\r\n     * @param {Cartesian3} left The first Cartesian.\r\n     * @param {Cartesian3} right The second Cartesian.\r\n     * @param {Cartesian3} result The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter.\r\n     */\r\n    Cartesian3.subtract = function(left, right, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('left', left);\r\n        Check.typeOf.object('right', right);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        result.x = left.x - right.x;\r\n        result.y = left.y - right.y;\r\n        result.z = left.z - right.z;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Multiplies the provided Cartesian componentwise by the provided scalar.\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian to be scaled.\r\n     * @param {Number} scalar The scalar to multiply with.\r\n     * @param {Cartesian3} result The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter.\r\n     */\r\n    Cartesian3.multiplyByScalar = function(cartesian, scalar, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('cartesian', cartesian);\r\n        Check.typeOf.number('scalar', scalar);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        result.x = cartesian.x * scalar;\r\n        result.y = cartesian.y * scalar;\r\n        result.z = cartesian.z * scalar;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Divides the provided Cartesian componentwise by the provided scalar.\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian to be divided.\r\n     * @param {Number} scalar The scalar to divide by.\r\n     * @param {Cartesian3} result The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter.\r\n     */\r\n    Cartesian3.divideByScalar = function(cartesian, scalar, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('cartesian', cartesian);\r\n        Check.typeOf.number('scalar', scalar);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        result.x = cartesian.x / scalar;\r\n        result.y = cartesian.y / scalar;\r\n        result.z = cartesian.z / scalar;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Negates the provided Cartesian.\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian to be negated.\r\n     * @param {Cartesian3} result The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter.\r\n     */\r\n    Cartesian3.negate = function(cartesian, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('cartesian', cartesian);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        result.x = -cartesian.x;\r\n        result.y = -cartesian.y;\r\n        result.z = -cartesian.z;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the absolute value of the provided Cartesian.\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian whose absolute value is to be computed.\r\n     * @param {Cartesian3} result The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter.\r\n     */\r\n    Cartesian3.abs = function(cartesian, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('cartesian', cartesian);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        result.x = Math.abs(cartesian.x);\r\n        result.y = Math.abs(cartesian.y);\r\n        result.z = Math.abs(cartesian.z);\r\n        return result;\r\n    };\r\n\r\n    var lerpScratch = new Cartesian3();\r\n    /**\r\n     * Computes the linear interpolation or extrapolation at t using the provided cartesians.\r\n     *\r\n     * @param {Cartesian3} start The value corresponding to t at 0.0.\r\n     * @param {Cartesian3} end The value corresponding to t at 1.0.\r\n     * @param {Number} t The point along t at which to interpolate.\r\n     * @param {Cartesian3} result The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter.\r\n     */\r\n    Cartesian3.lerp = function(start, end, t, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('start', start);\r\n        Check.typeOf.object('end', end);\r\n        Check.typeOf.number('t', t);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        Cartesian3.multiplyByScalar(end, t, lerpScratch);\r\n        result = Cartesian3.multiplyByScalar(start, 1.0 - t, result);\r\n        return Cartesian3.add(lerpScratch, result, result);\r\n    };\r\n\r\n    var angleBetweenScratch = new Cartesian3();\r\n    var angleBetweenScratch2 = new Cartesian3();\r\n    /**\r\n     * Returns the angle, in radians, between the provided Cartesians.\r\n     *\r\n     * @param {Cartesian3} left The first Cartesian.\r\n     * @param {Cartesian3} right The second Cartesian.\r\n     * @returns {Number} The angle between the Cartesians.\r\n     */\r\n    Cartesian3.angleBetween = function(left, right) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('left', left);\r\n        Check.typeOf.object('right', right);\r\n        //>>includeEnd('debug');\r\n\r\n        Cartesian3.normalize(left, angleBetweenScratch);\r\n        Cartesian3.normalize(right, angleBetweenScratch2);\r\n        var cosine = Cartesian3.dot(angleBetweenScratch, angleBetweenScratch2);\r\n        var sine = Cartesian3.magnitude(Cartesian3.cross(angleBetweenScratch, angleBetweenScratch2, angleBetweenScratch));\r\n        return Math.atan2(sine, cosine);\r\n    };\r\n\r\n    var mostOrthogonalAxisScratch = new Cartesian3();\r\n    /**\r\n     * Returns the axis that is most orthogonal to the provided Cartesian.\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian on which to find the most orthogonal axis.\r\n     * @param {Cartesian3} result The object onto which to store the result.\r\n     * @returns {Cartesian3} The most orthogonal axis.\r\n     */\r\n    Cartesian3.mostOrthogonalAxis = function(cartesian, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('cartesian', cartesian);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        var f = Cartesian3.normalize(cartesian, mostOrthogonalAxisScratch);\r\n        Cartesian3.abs(f, f);\r\n\r\n        if (f.x <= f.y) {\r\n            if (f.x <= f.z) {\r\n                result = Cartesian3.clone(Cartesian3.UNIT_X, result);\r\n            } else {\r\n                result = Cartesian3.clone(Cartesian3.UNIT_Z, result);\r\n            }\r\n        } else if (f.y <= f.z) {\r\n            result = Cartesian3.clone(Cartesian3.UNIT_Y, result);\r\n        } else {\r\n            result = Cartesian3.clone(Cartesian3.UNIT_Z, result);\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Projects vector a onto vector b\r\n     * @param {Cartesian3} a The vector that needs projecting\r\n     * @param {Cartesian3} b The vector to project onto\r\n     * @param {Cartesian3} result The result cartesian\r\n     * @returns {Cartesian3} The modified result parameter\r\n     */\r\n    Cartesian3.projectVector = function(a, b, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('a', a);\r\n        Check.defined('b', b);\r\n        Check.defined('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        var scalar = Cartesian3.dot(a, b) / Cartesian3.dot(b, b);\r\n        return Cartesian3.multiplyByScalar(b, scalar, result);\r\n    };\r\n\r\n    /**\r\n     * Compares the provided Cartesians componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {Cartesian3} [left] The first Cartesian.\r\n     * @param {Cartesian3} [right] The second Cartesian.\r\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n     */\r\n    Cartesian3.equals = function(left, right) {\r\n            return (left === right) ||\r\n              ((defined(left)) &&\r\n               (defined(right)) &&\r\n               (left.x === right.x) &&\r\n               (left.y === right.y) &&\r\n               (left.z === right.z));\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    Cartesian3.equalsArray = function(cartesian, array, offset) {\r\n        return cartesian.x === array[offset] &&\r\n               cartesian.y === array[offset + 1] &&\r\n               cartesian.z === array[offset + 2];\r\n    };\r\n\r\n    /**\r\n     * Compares the provided Cartesians componentwise and returns\r\n     * <code>true</code> if they pass an absolute or relative tolerance test,\r\n     * <code>false</code> otherwise.\r\n     *\r\n     * @param {Cartesian3} [left] The first Cartesian.\r\n     * @param {Cartesian3} [right] The second Cartesian.\r\n     * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\r\n     * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\r\n     * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\r\n     */\r\n    Cartesian3.equalsEpsilon = function(left, right, relativeEpsilon, absoluteEpsilon) {\r\n        return (left === right) ||\r\n               (defined(left) &&\r\n                defined(right) &&\r\n                CesiumMath.equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) &&\r\n                CesiumMath.equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon) &&\r\n                CesiumMath.equalsEpsilon(left.z, right.z, relativeEpsilon, absoluteEpsilon));\r\n    };\r\n\r\n    /**\r\n     * Computes the cross (outer) product of two Cartesians.\r\n     *\r\n     * @param {Cartesian3} left The first Cartesian.\r\n     * @param {Cartesian3} right The second Cartesian.\r\n     * @param {Cartesian3} result The object onto which to store the result.\r\n     * @returns {Cartesian3} The cross product.\r\n     */\r\n    Cartesian3.cross = function(left, right, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('left', left);\r\n        Check.typeOf.object('right', right);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        var leftX = left.x;\r\n        var leftY = left.y;\r\n        var leftZ = left.z;\r\n        var rightX = right.x;\r\n        var rightY = right.y;\r\n        var rightZ = right.z;\r\n\r\n        var x = leftY * rightZ - leftZ * rightY;\r\n        var y = leftZ * rightX - leftX * rightZ;\r\n        var z = leftX * rightY - leftY * rightX;\r\n\r\n        result.x = x;\r\n        result.y = y;\r\n        result.z = z;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the midpoint between the right and left Cartesian.\r\n     * @param {Cartesian3} left The first Cartesian.\r\n     * @param {Cartesian3} right The second Cartesian.\r\n     * @param {Cartesian3} result The object onto which to store the result.\r\n     * @returns {Cartesian3} The midpoint.\r\n     */\r\n    Cartesian3.midpoint = function(left, right, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('left', left);\r\n        Check.typeOf.object('right', right);\r\n        Check.typeOf.object('result', result);\r\n        //>>includeEnd('debug');\r\n\r\n        result.x = (left.x + right.x) * 0.5;\r\n        result.y = (left.y + right.y) * 0.5;\r\n        result.z = (left.z + right.z) * 0.5;\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Returns a Cartesian3 position from longitude and latitude values given in degrees.\r\n     *\r\n     * @param {Number} longitude The longitude, in degrees\r\n     * @param {Number} latitude The latitude, in degrees\r\n     * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\r\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The position\r\n     *\r\n     * @example\r\n     * var position = Cesium.Cartesian3.fromDegrees(-115.0, 37.0);\r\n     */\r\n    Cartesian3.fromDegrees = function(longitude, latitude, height, ellipsoid, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.number('longitude', longitude);\r\n        Check.typeOf.number('latitude', latitude);\r\n        //>>includeEnd('debug');\r\n\r\n        longitude = CesiumMath.toRadians(longitude);\r\n        latitude = CesiumMath.toRadians(latitude);\r\n        return Cartesian3.fromRadians(longitude, latitude, height, ellipsoid, result);\r\n    };\r\n\r\n    var scratchN = new Cartesian3();\r\n    var scratchK = new Cartesian3();\r\n    var wgs84RadiiSquared = new Cartesian3(6378137.0 * 6378137.0, 6378137.0 * 6378137.0, 6356752.3142451793 * 6356752.3142451793);\r\n\r\n    /**\r\n     * Returns a Cartesian3 position from longitude and latitude values given in radians.\r\n     *\r\n     * @param {Number} longitude The longitude, in radians\r\n     * @param {Number} latitude The latitude, in radians\r\n     * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\r\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The position\r\n     *\r\n     * @example\r\n     * var position = Cesium.Cartesian3.fromRadians(-2.007, 0.645);\r\n     */\r\n    Cartesian3.fromRadians = function(longitude, latitude, height, ellipsoid, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.number('longitude', longitude);\r\n        Check.typeOf.number('latitude', latitude);\r\n        //>>includeEnd('debug');\r\n\r\n        height = defaultValue(height, 0.0);\r\n        var radiiSquared = defined(ellipsoid) ? ellipsoid.radiiSquared : wgs84RadiiSquared;\r\n\r\n        var cosLatitude = Math.cos(latitude);\r\n        scratchN.x = cosLatitude * Math.cos(longitude);\r\n        scratchN.y = cosLatitude * Math.sin(longitude);\r\n        scratchN.z = Math.sin(latitude);\r\n        scratchN = Cartesian3.normalize(scratchN, scratchN);\r\n\r\n        Cartesian3.multiplyComponents(radiiSquared, scratchN, scratchK);\r\n        var gamma = Math.sqrt(Cartesian3.dot(scratchN, scratchK));\r\n        scratchK = Cartesian3.divideByScalar(scratchK, gamma, scratchK);\r\n        scratchN = Cartesian3.multiplyByScalar(scratchN, height, scratchN);\r\n\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n        return Cartesian3.add(scratchK, scratchN, result);\r\n    };\r\n\r\n    /**\r\n     * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in degrees.\r\n     *\r\n     * @param {Number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].\r\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the coordinates lie.\r\n     * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\r\n     * @returns {Cartesian3[]} The array of positions.\r\n     *\r\n     * @example\r\n     * var positions = Cesium.Cartesian3.fromDegreesArray([-115.0, 37.0, -107.0, 33.0]);\r\n     */\r\n    Cartesian3.fromDegreesArray = function(coordinates, ellipsoid, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('coordinates', coordinates);\r\n        if (coordinates.length < 2 || coordinates.length % 2 !== 0) {\r\n            throw new DeveloperError('the number of coordinates must be a multiple of 2 and at least 2');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var length = coordinates.length;\r\n        if (!defined(result)) {\r\n            result = new Array(length / 2);\r\n        } else {\r\n            result.length = length / 2;\r\n        }\r\n\r\n        for (var i = 0; i < length; i += 2) {\r\n            var longitude = coordinates[i];\r\n            var latitude = coordinates[i + 1];\r\n            var index = i / 2;\r\n            result[index] = Cartesian3.fromDegrees(longitude, latitude, 0, ellipsoid, result[index]);\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in radians.\r\n     *\r\n     * @param {Number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].\r\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the coordinates lie.\r\n     * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\r\n     * @returns {Cartesian3[]} The array of positions.\r\n     *\r\n     * @example\r\n     * var positions = Cesium.Cartesian3.fromRadiansArray([-2.007, 0.645, -1.867, .575]);\r\n     */\r\n    Cartesian3.fromRadiansArray = function(coordinates, ellipsoid, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('coordinates', coordinates);\r\n        if (coordinates.length < 2 || coordinates.length % 2 !== 0) {\r\n            throw new DeveloperError('the number of coordinates must be a multiple of 2 and at least 2');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var length = coordinates.length;\r\n        if (!defined(result)) {\r\n            result = new Array(length / 2);\r\n        } else {\r\n            result.length = length / 2;\r\n        }\r\n\r\n        for (var i = 0; i < length; i += 2) {\r\n            var longitude = coordinates[i];\r\n            var latitude = coordinates[i + 1];\r\n            var index = i / 2;\r\n            result[index] = Cartesian3.fromRadians(longitude, latitude, 0, ellipsoid, result[index]);\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in degrees.\r\n     *\r\n     * @param {Number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].\r\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\r\n     * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\r\n     * @returns {Cartesian3[]} The array of positions.\r\n     *\r\n     * @example\r\n     * var positions = Cesium.Cartesian3.fromDegreesArrayHeights([-115.0, 37.0, 100000.0, -107.0, 33.0, 150000.0]);\r\n     */\r\n    Cartesian3.fromDegreesArrayHeights = function(coordinates, ellipsoid, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('coordinates', coordinates);\r\n        if (coordinates.length < 3 || coordinates.length % 3 !== 0) {\r\n            throw new DeveloperError('the number of coordinates must be a multiple of 3 and at least 3');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var length = coordinates.length;\r\n        if (!defined(result)) {\r\n            result = new Array(length / 3);\r\n        } else {\r\n            result.length = length / 3;\r\n        }\r\n\r\n        for (var i = 0; i < length; i += 3) {\r\n            var longitude = coordinates[i];\r\n            var latitude = coordinates[i + 1];\r\n            var height = coordinates[i + 2];\r\n            var index = i / 3;\r\n            result[index] = Cartesian3.fromDegrees(longitude, latitude, height, ellipsoid, result[index]);\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in radians.\r\n     *\r\n     * @param {Number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].\r\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\r\n     * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\r\n     * @returns {Cartesian3[]} The array of positions.\r\n     *\r\n     * @example\r\n     * var positions = Cesium.Cartesian3.fromRadiansArrayHeights([-2.007, 0.645, 100000.0, -1.867, .575, 150000.0]);\r\n     */\r\n    Cartesian3.fromRadiansArrayHeights = function(coordinates, ellipsoid, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('coordinates', coordinates);\r\n        if (coordinates.length < 3 || coordinates.length % 3 !== 0) {\r\n            throw new DeveloperError('the number of coordinates must be a multiple of 3 and at least 3');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var length = coordinates.length;\r\n        if (!defined(result)) {\r\n            result = new Array(length / 3);\r\n        } else {\r\n            result.length = length / 3;\r\n        }\r\n\r\n        for (var i = 0; i < length; i += 3) {\r\n            var longitude = coordinates[i];\r\n            var latitude = coordinates[i + 1];\r\n            var height = coordinates[i + 2];\r\n            var index = i / 3;\r\n            result[index] = Cartesian3.fromRadians(longitude, latitude, height, ellipsoid, result[index]);\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * An immutable Cartesian3 instance initialized to (0.0, 0.0, 0.0).\r\n     *\r\n     * @type {Cartesian3}\r\n     * @constant\r\n     */\r\n    Cartesian3.ZERO = Object.freeze(new Cartesian3(0.0, 0.0, 0.0));\r\n\r\n    /**\r\n     * An immutable Cartesian3 instance initialized to (1.0, 0.0, 0.0).\r\n     *\r\n     * @type {Cartesian3}\r\n     * @constant\r\n     */\r\n    Cartesian3.UNIT_X = Object.freeze(new Cartesian3(1.0, 0.0, 0.0));\r\n\r\n    /**\r\n     * An immutable Cartesian3 instance initialized to (0.0, 1.0, 0.0).\r\n     *\r\n     * @type {Cartesian3}\r\n     * @constant\r\n     */\r\n    Cartesian3.UNIT_Y = Object.freeze(new Cartesian3(0.0, 1.0, 0.0));\r\n\r\n    /**\r\n     * An immutable Cartesian3 instance initialized to (0.0, 0.0, 1.0).\r\n     *\r\n     * @type {Cartesian3}\r\n     * @constant\r\n     */\r\n    Cartesian3.UNIT_Z = Object.freeze(new Cartesian3(0.0, 0.0, 1.0));\r\n\r\n    /**\r\n     * Duplicates this Cartesian3 instance.\r\n     *\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\r\n     */\r\n    Cartesian3.prototype.clone = function(result) {\r\n        return Cartesian3.clone(this, result);\r\n    };\r\n\r\n    /**\r\n     * Compares this Cartesian against the provided Cartesian componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {Cartesian3} [right] The right hand side Cartesian.\r\n     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     */\r\n    Cartesian3.prototype.equals = function(right) {\r\n        return Cartesian3.equals(this, right);\r\n    };\r\n\r\n    /**\r\n     * Compares this Cartesian against the provided Cartesian componentwise and returns\r\n     * <code>true</code> if they pass an absolute or relative tolerance test,\r\n     * <code>false</code> otherwise.\r\n     *\r\n     * @param {Cartesian3} [right] The right hand side Cartesian.\r\n     * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\r\n     * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\r\n     * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\r\n     */\r\n    Cartesian3.prototype.equalsEpsilon = function(right, relativeEpsilon, absoluteEpsilon) {\r\n        return Cartesian3.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);\r\n    };\r\n\r\n    /**\r\n     * Creates a string representing this Cartesian in the format '(x, y, z)'.\r\n     *\r\n     * @returns {String} A string representing this Cartesian in the format '(x, y, z)'.\r\n     */\r\n    Cartesian3.prototype.toString = function() {\r\n        return '(' + this.x + ', ' + this.y + ', ' + this.z + ')';\r\n    };\r\nexport default Cartesian3;\r\n","import Cartesian3 from './Cartesian3.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport CesiumMath from './Math.js';\r\n\r\n    var scaleToGeodeticSurfaceIntersection = new Cartesian3();\r\n    var scaleToGeodeticSurfaceGradient = new Cartesian3();\r\n\r\n    /**\r\n     * Scales the provided Cartesian position along the geodetic surface normal\r\n     * so that it is on the surface of this ellipsoid.  If the position is\r\n     * at the center of the ellipsoid, this function returns undefined.\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian position to scale.\r\n     * @param {Cartesian3} oneOverRadii One over radii of the ellipsoid.\r\n     * @param {Cartesian3} oneOverRadiiSquared One over radii squared of the ellipsoid.\r\n     * @param {Number} centerToleranceSquared Tolerance for closeness to the center.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.\r\n     *\r\n     * @exports scaleToGeodeticSurface\r\n     *\r\n     * @private\r\n     */\r\n    function scaleToGeodeticSurface(cartesian, oneOverRadii, oneOverRadiiSquared, centerToleranceSquared, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(cartesian)) {\r\n            throw new DeveloperError('cartesian is required.');\r\n        }\r\n        if (!defined(oneOverRadii)) {\r\n            throw new DeveloperError('oneOverRadii is required.');\r\n        }\r\n        if (!defined(oneOverRadiiSquared)) {\r\n            throw new DeveloperError('oneOverRadiiSquared is required.');\r\n        }\r\n        if (!defined(centerToleranceSquared)) {\r\n            throw new DeveloperError('centerToleranceSquared is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var positionX = cartesian.x;\r\n        var positionY = cartesian.y;\r\n        var positionZ = cartesian.z;\r\n\r\n        var oneOverRadiiX = oneOverRadii.x;\r\n        var oneOverRadiiY = oneOverRadii.y;\r\n        var oneOverRadiiZ = oneOverRadii.z;\r\n\r\n        var x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;\r\n        var y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;\r\n        var z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;\r\n\r\n        // Compute the squared ellipsoid norm.\r\n        var squaredNorm = x2 + y2 + z2;\r\n        var ratio = Math.sqrt(1.0 / squaredNorm);\r\n\r\n        // As an initial approximation, assume that the radial intersection is the projection point.\r\n        var intersection = Cartesian3.multiplyByScalar(cartesian, ratio, scaleToGeodeticSurfaceIntersection);\r\n\r\n        // If the position is near the center, the iteration will not converge.\r\n        if (squaredNorm < centerToleranceSquared) {\r\n            return !isFinite(ratio) ? undefined : Cartesian3.clone(intersection, result);\r\n        }\r\n\r\n        var oneOverRadiiSquaredX = oneOverRadiiSquared.x;\r\n        var oneOverRadiiSquaredY = oneOverRadiiSquared.y;\r\n        var oneOverRadiiSquaredZ = oneOverRadiiSquared.z;\r\n\r\n        // Use the gradient at the intersection point in place of the true unit normal.\r\n        // The difference in magnitude will be absorbed in the multiplier.\r\n        var gradient = scaleToGeodeticSurfaceGradient;\r\n        gradient.x = intersection.x * oneOverRadiiSquaredX * 2.0;\r\n        gradient.y = intersection.y * oneOverRadiiSquaredY * 2.0;\r\n        gradient.z = intersection.z * oneOverRadiiSquaredZ * 2.0;\r\n\r\n        // Compute the initial guess at the normal vector multiplier, lambda.\r\n        var lambda = (1.0 - ratio) * Cartesian3.magnitude(cartesian) / (0.5 * Cartesian3.magnitude(gradient));\r\n        var correction = 0.0;\r\n\r\n        var func;\r\n        var denominator;\r\n        var xMultiplier;\r\n        var yMultiplier;\r\n        var zMultiplier;\r\n        var xMultiplier2;\r\n        var yMultiplier2;\r\n        var zMultiplier2;\r\n        var xMultiplier3;\r\n        var yMultiplier3;\r\n        var zMultiplier3;\r\n\r\n        do {\r\n            lambda -= correction;\r\n\r\n            xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);\r\n            yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);\r\n            zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);\r\n\r\n            xMultiplier2 = xMultiplier * xMultiplier;\r\n            yMultiplier2 = yMultiplier * yMultiplier;\r\n            zMultiplier2 = zMultiplier * zMultiplier;\r\n\r\n            xMultiplier3 = xMultiplier2 * xMultiplier;\r\n            yMultiplier3 = yMultiplier2 * yMultiplier;\r\n            zMultiplier3 = zMultiplier2 * zMultiplier;\r\n\r\n            func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;\r\n\r\n            // \"denominator\" here refers to the use of this expression in the velocity and acceleration\r\n            // computations in the sections to follow.\r\n            denominator = x2 * xMultiplier3 * oneOverRadiiSquaredX + y2 * yMultiplier3 * oneOverRadiiSquaredY + z2 * zMultiplier3 * oneOverRadiiSquaredZ;\r\n\r\n            var derivative = -2.0 * denominator;\r\n\r\n            correction = func / derivative;\r\n        } while (Math.abs(func) > CesiumMath.EPSILON12);\r\n\r\n        if (!defined(result)) {\r\n            return new Cartesian3(positionX * xMultiplier, positionY * yMultiplier, positionZ * zMultiplier);\r\n        }\r\n        result.x = positionX * xMultiplier;\r\n        result.y = positionY * yMultiplier;\r\n        result.z = positionZ * zMultiplier;\r\n        return result;\r\n    }\r\nexport default scaleToGeodeticSurface;\r\n","import Cartesian3 from './Cartesian3.js';\r\nimport Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport CesiumMath from './Math.js';\r\nimport scaleToGeodeticSurface from './scaleToGeodeticSurface.js';\r\n\r\n    /**\r\n     * A position defined by longitude, latitude, and height.\r\n     * @alias Cartographic\r\n     * @constructor\r\n     *\r\n     * @param {Number} [longitude=0.0] The longitude, in radians.\r\n     * @param {Number} [latitude=0.0] The latitude, in radians.\r\n     * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\r\n     *\r\n     * @see Ellipsoid\r\n     */\r\n    function Cartographic(longitude, latitude, height) {\r\n        /**\r\n         * The longitude, in radians.\r\n         * @type {Number}\r\n         * @default 0.0\r\n         */\r\n        this.longitude = defaultValue(longitude, 0.0);\r\n\r\n        /**\r\n         * The latitude, in radians.\r\n         * @type {Number}\r\n         * @default 0.0\r\n         */\r\n        this.latitude = defaultValue(latitude, 0.0);\r\n\r\n        /**\r\n         * The height, in meters, above the ellipsoid.\r\n         * @type {Number}\r\n         * @default 0.0\r\n         */\r\n        this.height = defaultValue(height, 0.0);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Cartographic instance from longitude and latitude\r\n     * specified in radians.\r\n     *\r\n     * @param {Number} longitude The longitude, in radians.\r\n     * @param {Number} latitude The latitude, in radians.\r\n     * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\r\n     * @param {Cartographic} [result] The object onto which to store the result.\r\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\r\n     */\r\n    Cartographic.fromRadians = function(longitude, latitude, height, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.number('longitude', longitude);\r\n        Check.typeOf.number('latitude', latitude);\r\n        //>>includeEnd('debug');\r\n\r\n        height = defaultValue(height, 0.0);\r\n\r\n        if (!defined(result)) {\r\n            return new Cartographic(longitude, latitude, height);\r\n        }\r\n\r\n        result.longitude = longitude;\r\n        result.latitude = latitude;\r\n        result.height = height;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Creates a new Cartographic instance from longitude and latitude\r\n     * specified in degrees.  The values in the resulting object will\r\n     * be in radians.\r\n     *\r\n     * @param {Number} longitude The longitude, in degrees.\r\n     * @param {Number} latitude The latitude, in degrees.\r\n     * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\r\n     * @param {Cartographic} [result] The object onto which to store the result.\r\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\r\n     */\r\n    Cartographic.fromDegrees = function(longitude, latitude, height, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.number('longitude', longitude);\r\n        Check.typeOf.number('latitude', latitude);\r\n        //>>includeEnd('debug');\r\n        longitude = CesiumMath.toRadians(longitude);\r\n        latitude = CesiumMath.toRadians(latitude);\r\n\r\n        return Cartographic.fromRadians(longitude, latitude, height, result);\r\n    };\r\n\r\n    var cartesianToCartographicN = new Cartesian3();\r\n    var cartesianToCartographicP = new Cartesian3();\r\n    var cartesianToCartographicH = new Cartesian3();\r\n    var wgs84OneOverRadii = new Cartesian3(1.0 / 6378137.0, 1.0 / 6378137.0, 1.0 / 6356752.3142451793);\r\n    var wgs84OneOverRadiiSquared = new Cartesian3(1.0 / (6378137.0 * 6378137.0), 1.0 / (6378137.0 * 6378137.0), 1.0 / (6356752.3142451793 * 6356752.3142451793));\r\n    var wgs84CenterToleranceSquared = CesiumMath.EPSILON1;\r\n\r\n    /**\r\n     * Creates a new Cartographic instance from a Cartesian position. The values in the\r\n     * resulting object will be in radians.\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.\r\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\r\n     * @param {Cartographic} [result] The object onto which to store the result.\r\n     * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.\r\n     */\r\n    Cartographic.fromCartesian = function(cartesian, ellipsoid, result) {\r\n        var oneOverRadii = defined(ellipsoid) ? ellipsoid.oneOverRadii : wgs84OneOverRadii;\r\n        var oneOverRadiiSquared = defined(ellipsoid) ? ellipsoid.oneOverRadiiSquared : wgs84OneOverRadiiSquared;\r\n        var centerToleranceSquared = defined(ellipsoid) ? ellipsoid._centerToleranceSquared : wgs84CenterToleranceSquared;\r\n\r\n        //`cartesian is required.` is thrown from scaleToGeodeticSurface\r\n        var p = scaleToGeodeticSurface(cartesian, oneOverRadii, oneOverRadiiSquared, centerToleranceSquared, cartesianToCartographicP);\r\n\r\n        if (!defined(p)) {\r\n            return undefined;\r\n        }\r\n\r\n        var n = Cartesian3.multiplyComponents(p, oneOverRadiiSquared, cartesianToCartographicN);\r\n        n = Cartesian3.normalize(n, n);\r\n\r\n        var h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);\r\n\r\n        var longitude = Math.atan2(n.y, n.x);\r\n        var latitude = Math.asin(n.z);\r\n        var height = CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);\r\n\r\n        if (!defined(result)) {\r\n            return new Cartographic(longitude, latitude, height);\r\n        }\r\n        result.longitude = longitude;\r\n        result.latitude = latitude;\r\n        result.height = height;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Creates a new Cartesian3 instance from a Cartographic input. The values in the inputted\r\n     * object should be in radians.\r\n     *\r\n     * @param {Cartographic} cartographic Input to be converted into a Cartesian3 output.\r\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The position\r\n     */\r\n    Cartographic.toCartesian = function(cartographic, ellipsoid, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('cartographic', cartographic);\r\n        //>>includeEnd('debug');\r\n\r\n        return Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, cartographic.height, ellipsoid, result);\r\n    };\r\n\r\n    /**\r\n     * Duplicates a Cartographic instance.\r\n     *\r\n     * @param {Cartographic} cartographic The cartographic to duplicate.\r\n     * @param {Cartographic} [result] The object onto which to store the result.\r\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided. (Returns undefined if cartographic is undefined)\r\n     */\r\n    Cartographic.clone = function(cartographic, result) {\r\n        if (!defined(cartographic)) {\r\n            return undefined;\r\n        }\r\n        if (!defined(result)) {\r\n            return new Cartographic(cartographic.longitude, cartographic.latitude, cartographic.height);\r\n        }\r\n        result.longitude = cartographic.longitude;\r\n        result.latitude = cartographic.latitude;\r\n        result.height = cartographic.height;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Compares the provided cartographics componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {Cartographic} [left] The first cartographic.\r\n     * @param {Cartographic} [right] The second cartographic.\r\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n     */\r\n    Cartographic.equals = function(left, right) {\r\n        return (left === right) ||\r\n                ((defined(left)) &&\r\n                 (defined(right)) &&\r\n                 (left.longitude === right.longitude) &&\r\n                 (left.latitude === right.latitude) &&\r\n                 (left.height === right.height));\r\n    };\r\n\r\n    /**\r\n     * Compares the provided cartographics componentwise and returns\r\n     * <code>true</code> if they are within the provided epsilon,\r\n     * <code>false</code> otherwise.\r\n     *\r\n     * @param {Cartographic} [left] The first cartographic.\r\n     * @param {Cartographic} [right] The second cartographic.\r\n     * @param {Number} epsilon The epsilon to use for equality testing.\r\n     * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\r\n     */\r\n    Cartographic.equalsEpsilon = function(left, right, epsilon) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.number('epsilon', epsilon);\r\n        //>>includeEnd('debug');\r\n\r\n        return (left === right) ||\r\n               ((defined(left)) &&\r\n                (defined(right)) &&\r\n                (Math.abs(left.longitude - right.longitude) <= epsilon) &&\r\n                (Math.abs(left.latitude - right.latitude) <= epsilon) &&\r\n                (Math.abs(left.height - right.height) <= epsilon));\r\n    };\r\n\r\n    /**\r\n     * An immutable Cartographic instance initialized to (0.0, 0.0, 0.0).\r\n     *\r\n     * @type {Cartographic}\r\n     * @constant\r\n     */\r\n    Cartographic.ZERO = Object.freeze(new Cartographic(0.0, 0.0, 0.0));\r\n\r\n    /**\r\n     * Duplicates this instance.\r\n     *\r\n     * @param {Cartographic} [result] The object onto which to store the result.\r\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\r\n     */\r\n    Cartographic.prototype.clone = function(result) {\r\n        return Cartographic.clone(this, result);\r\n    };\r\n\r\n    /**\r\n     * Compares the provided against this cartographic componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {Cartographic} [right] The second cartographic.\r\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n     */\r\n    Cartographic.prototype.equals = function(right) {\r\n        return Cartographic.equals(this, right);\r\n    };\r\n\r\n    /**\r\n     * Compares the provided against this cartographic componentwise and returns\r\n     * <code>true</code> if they are within the provided epsilon,\r\n     * <code>false</code> otherwise.\r\n     *\r\n     * @param {Cartographic} [right] The second cartographic.\r\n     * @param {Number} epsilon The epsilon to use for equality testing.\r\n     * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\r\n     */\r\n    Cartographic.prototype.equalsEpsilon = function(right, epsilon) {\r\n        return Cartographic.equalsEpsilon(this, right, epsilon);\r\n    };\r\n\r\n    /**\r\n     * Creates a string representing this cartographic in the format '(longitude, latitude, height)'.\r\n     *\r\n     * @returns {String} A string representing the provided cartographic in the format '(longitude, latitude, height)'.\r\n     */\r\n    Cartographic.prototype.toString = function() {\r\n        return '(' + this.longitude + ', ' + this.latitude + ', ' + this.height + ')';\r\n    };\r\nexport default Cartographic;\r\n","import Cartesian3 from './Cartesian3.js';\r\nimport Cartographic from './Cartographic.js';\r\nimport Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport CesiumMath from './Math.js';\r\nimport scaleToGeodeticSurface from './scaleToGeodeticSurface.js';\r\n\r\n    function initialize(ellipsoid, x, y, z) {\r\n        x = defaultValue(x, 0.0);\r\n        y = defaultValue(y, 0.0);\r\n        z = defaultValue(z, 0.0);\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.number.greaterThanOrEquals('x', x, 0.0);\r\n        Check.typeOf.number.greaterThanOrEquals('y', y, 0.0);\r\n        Check.typeOf.number.greaterThanOrEquals('z', z, 0.0);\r\n        //>>includeEnd('debug');\r\n\r\n        ellipsoid._radii = new Cartesian3(x, y, z);\r\n\r\n        ellipsoid._radiiSquared = new Cartesian3(x * x,\r\n                                            y * y,\r\n                                            z * z);\r\n\r\n        ellipsoid._radiiToTheFourth = new Cartesian3(x * x * x * x,\r\n                                                y * y * y * y,\r\n                                                z * z * z * z);\r\n\r\n        ellipsoid._oneOverRadii = new Cartesian3(x === 0.0 ? 0.0 : 1.0 / x,\r\n                                            y === 0.0 ? 0.0 : 1.0 / y,\r\n                                            z === 0.0 ? 0.0 : 1.0 / z);\r\n\r\n        ellipsoid._oneOverRadiiSquared = new Cartesian3(x === 0.0 ? 0.0 : 1.0 / (x * x),\r\n                                                   y === 0.0 ? 0.0 : 1.0 / (y * y),\r\n                                                   z === 0.0 ? 0.0 : 1.0 / (z * z));\r\n\r\n        ellipsoid._minimumRadius = Math.min(x, y, z);\r\n\r\n        ellipsoid._maximumRadius = Math.max(x, y, z);\r\n\r\n        ellipsoid._centerToleranceSquared = CesiumMath.EPSILON1;\r\n\r\n        if (ellipsoid._radiiSquared.z !== 0) {\r\n            ellipsoid._squaredXOverSquaredZ = ellipsoid._radiiSquared.x / ellipsoid._radiiSquared.z;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * A quadratic surface defined in Cartesian coordinates by the equation\r\n     * <code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>.  Primarily used\r\n     * by Cesium to represent the shape of planetary bodies.\r\n     *\r\n     * Rather than constructing this object directly, one of the provided\r\n     * constants is normally used.\r\n     * @alias Ellipsoid\r\n     * @constructor\r\n     *\r\n     * @param {Number} [x=0] The radius in the x direction.\r\n     * @param {Number} [y=0] The radius in the y direction.\r\n     * @param {Number} [z=0] The radius in the z direction.\r\n     *\r\n     * @exception {DeveloperError} All radii components must be greater than or equal to zero.\r\n     *\r\n     * @see Ellipsoid.fromCartesian3\r\n     * @see Ellipsoid.WGS84\r\n     * @see Ellipsoid.UNIT_SPHERE\r\n     */\r\n    function Ellipsoid(x, y, z) {\r\n        this._radii = undefined;\r\n        this._radiiSquared = undefined;\r\n        this._radiiToTheFourth = undefined;\r\n        this._oneOverRadii = undefined;\r\n        this._oneOverRadiiSquared = undefined;\r\n        this._minimumRadius = undefined;\r\n        this._maximumRadius = undefined;\r\n        this._centerToleranceSquared = undefined;\r\n        this._squaredXOverSquaredZ = undefined;\r\n\r\n        initialize(this, x, y, z);\r\n    }\r\n\r\n    Object.defineProperties(Ellipsoid.prototype, {\r\n        /**\r\n         * Gets the radii of the ellipsoid.\r\n         * @memberof Ellipsoid.prototype\r\n         * @type {Cartesian3}\r\n         * @readonly\r\n         */\r\n        radii : {\r\n            get: function() {\r\n                return this._radii;\r\n            }\r\n        },\r\n        /**\r\n         * Gets the squared radii of the ellipsoid.\r\n         * @memberof Ellipsoid.prototype\r\n         * @type {Cartesian3}\r\n         * @readonly\r\n         */\r\n        radiiSquared : {\r\n            get : function() {\r\n                return this._radiiSquared;\r\n            }\r\n        },\r\n        /**\r\n         * Gets the radii of the ellipsoid raise to the fourth power.\r\n         * @memberof Ellipsoid.prototype\r\n         * @type {Cartesian3}\r\n         * @readonly\r\n         */\r\n        radiiToTheFourth : {\r\n            get : function() {\r\n                return this._radiiToTheFourth;\r\n            }\r\n        },\r\n        /**\r\n         * Gets one over the radii of the ellipsoid.\r\n         * @memberof Ellipsoid.prototype\r\n         * @type {Cartesian3}\r\n         * @readonly\r\n         */\r\n        oneOverRadii : {\r\n            get : function() {\r\n                return this._oneOverRadii;\r\n            }\r\n        },\r\n        /**\r\n         * Gets one over the squared radii of the ellipsoid.\r\n         * @memberof Ellipsoid.prototype\r\n         * @type {Cartesian3}\r\n         * @readonly\r\n         */\r\n        oneOverRadiiSquared : {\r\n            get : function() {\r\n                return this._oneOverRadiiSquared;\r\n            }\r\n        },\r\n        /**\r\n         * Gets the minimum radius of the ellipsoid.\r\n         * @memberof Ellipsoid.prototype\r\n         * @type {Number}\r\n         * @readonly\r\n         */\r\n        minimumRadius : {\r\n            get : function() {\r\n                return this._minimumRadius;\r\n            }\r\n        },\r\n        /**\r\n         * Gets the maximum radius of the ellipsoid.\r\n         * @memberof Ellipsoid.prototype\r\n         * @type {Number}\r\n         * @readonly\r\n         */\r\n        maximumRadius : {\r\n            get : function() {\r\n                return this._maximumRadius;\r\n            }\r\n        }\r\n    });\r\n\r\n    /**\r\n     * Duplicates an Ellipsoid instance.\r\n     *\r\n     * @param {Ellipsoid} ellipsoid The ellipsoid to duplicate.\r\n     * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\r\n     *                    instance should be created.\r\n     * @returns {Ellipsoid} The cloned Ellipsoid. (Returns undefined if ellipsoid is undefined)\r\n     */\r\n    Ellipsoid.clone = function(ellipsoid, result) {\r\n        if (!defined(ellipsoid)) {\r\n            return undefined;\r\n        }\r\n        var radii = ellipsoid._radii;\r\n\r\n        if (!defined(result)) {\r\n            return new Ellipsoid(radii.x, radii.y, radii.z);\r\n        }\r\n\r\n        Cartesian3.clone(radii, result._radii);\r\n        Cartesian3.clone(ellipsoid._radiiSquared, result._radiiSquared);\r\n        Cartesian3.clone(ellipsoid._radiiToTheFourth, result._radiiToTheFourth);\r\n        Cartesian3.clone(ellipsoid._oneOverRadii, result._oneOverRadii);\r\n        Cartesian3.clone(ellipsoid._oneOverRadiiSquared, result._oneOverRadiiSquared);\r\n        result._minimumRadius = ellipsoid._minimumRadius;\r\n        result._maximumRadius = ellipsoid._maximumRadius;\r\n        result._centerToleranceSquared = ellipsoid._centerToleranceSquared;\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions.\r\n     *\r\n     * @param {Cartesian3} [cartesian=Cartesian3.ZERO] The ellipsoid's radius in the x, y, and z directions.\r\n     * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\r\n     *                    instance should be created.\r\n     * @returns {Ellipsoid} A new Ellipsoid instance.\r\n     *\r\n     * @exception {DeveloperError} All radii components must be greater than or equal to zero.\r\n     *\r\n     * @see Ellipsoid.WGS84\r\n     * @see Ellipsoid.UNIT_SPHERE\r\n     */\r\n    Ellipsoid.fromCartesian3 = function(cartesian, result) {\r\n        if (!defined(result)) {\r\n            result = new Ellipsoid();\r\n        }\r\n\r\n        if (!defined(cartesian)) {\r\n            return result;\r\n        }\r\n\r\n        initialize(result, cartesian.x, cartesian.y, cartesian.z);\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * An Ellipsoid instance initialized to the WGS84 standard.\r\n     *\r\n     * @type {Ellipsoid}\r\n     * @constant\r\n     */\r\n    Ellipsoid.WGS84 = Object.freeze(new Ellipsoid(6378137.0, 6378137.0, 6356752.3142451793));\r\n\r\n    /**\r\n     * An Ellipsoid instance initialized to radii of (1.0, 1.0, 1.0).\r\n     *\r\n     * @type {Ellipsoid}\r\n     * @constant\r\n     */\r\n    Ellipsoid.UNIT_SPHERE = Object.freeze(new Ellipsoid(1.0, 1.0, 1.0));\r\n\r\n    /**\r\n     * An Ellipsoid instance initialized to a sphere with the lunar radius.\r\n     *\r\n     * @type {Ellipsoid}\r\n     * @constant\r\n     */\r\n    Ellipsoid.MOON = Object.freeze(new Ellipsoid(CesiumMath.LUNAR_RADIUS, CesiumMath.LUNAR_RADIUS, CesiumMath.LUNAR_RADIUS));\r\n\r\n    /**\r\n     * Duplicates an Ellipsoid instance.\r\n     *\r\n     * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\r\n     *                    instance should be created.\r\n     * @returns {Ellipsoid} The cloned Ellipsoid.\r\n     */\r\n    Ellipsoid.prototype.clone = function(result) {\r\n        return Ellipsoid.clone(this, result);\r\n    };\r\n\r\n    /**\r\n     * The number of elements used to pack the object into an array.\r\n     * @type {Number}\r\n     */\r\n    Ellipsoid.packedLength = Cartesian3.packedLength;\r\n\r\n    /**\r\n     * Stores the provided instance into the provided array.\r\n     *\r\n     * @param {Ellipsoid} value The value to pack.\r\n     * @param {Number[]} array The array to pack into.\r\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n     *\r\n     * @returns {Number[]} The array that was packed into\r\n     */\r\n    Ellipsoid.pack = function(value, array, startingIndex) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('value', value);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        Cartesian3.pack(value._radii, array, startingIndex);\r\n\r\n        return array;\r\n    };\r\n\r\n    /**\r\n     * Retrieves an instance from a packed array.\r\n     *\r\n     * @param {Number[]} array The packed array.\r\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n     * @param {Ellipsoid} [result] The object into which to store the result.\r\n     * @returns {Ellipsoid} The modified result parameter or a new Ellipsoid instance if one was not provided.\r\n     */\r\n    Ellipsoid.unpack = function(array, startingIndex, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        var radii = Cartesian3.unpack(array, startingIndex);\r\n        return Ellipsoid.fromCartesian3(radii, result);\r\n    };\r\n\r\n    /**\r\n     * Computes the unit vector directed from the center of this ellipsoid toward the provided Cartesian position.\r\n     * @function\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian for which to to determine the geocentric normal.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\r\n     */\r\n    Ellipsoid.prototype.geocentricSurfaceNormal = Cartesian3.normalize;\r\n\r\n    /**\r\n     * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\r\n     *\r\n     * @param {Cartographic} cartographic The cartographic position for which to to determine the geodetic normal.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\r\n     */\r\n    Ellipsoid.prototype.geodeticSurfaceNormalCartographic = function(cartographic, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('cartographic', cartographic);\r\n        //>>includeEnd('debug');\r\n\r\n        var longitude = cartographic.longitude;\r\n        var latitude = cartographic.latitude;\r\n        var cosLatitude = Math.cos(latitude);\r\n\r\n        var x = cosLatitude * Math.cos(longitude);\r\n        var y = cosLatitude * Math.sin(longitude);\r\n        var z = Math.sin(latitude);\r\n\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n        result.x = x;\r\n        result.y = y;\r\n        result.z = z;\r\n        return Cartesian3.normalize(result, result);\r\n    };\r\n\r\n    /**\r\n     * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian position for which to to determine the surface normal.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\r\n     */\r\n    Ellipsoid.prototype.geodeticSurfaceNormal = function(cartesian, result) {\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n        result = Cartesian3.multiplyComponents(cartesian, this._oneOverRadiiSquared, result);\r\n        return Cartesian3.normalize(result, result);\r\n    };\r\n\r\n    var cartographicToCartesianNormal = new Cartesian3();\r\n    var cartographicToCartesianK = new Cartesian3();\r\n\r\n    /**\r\n     * Converts the provided cartographic to Cartesian representation.\r\n     *\r\n     * @param {Cartographic} cartographic The cartographic position.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\r\n     *\r\n     * @example\r\n     * //Create a Cartographic and determine it's Cartesian representation on a WGS84 ellipsoid.\r\n     * var position = new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 5000);\r\n     * var cartesianPosition = Cesium.Ellipsoid.WGS84.cartographicToCartesian(position);\r\n     */\r\n    Ellipsoid.prototype.cartographicToCartesian = function(cartographic, result) {\r\n        //`cartographic is required` is thrown from geodeticSurfaceNormalCartographic.\r\n        var n = cartographicToCartesianNormal;\r\n        var k = cartographicToCartesianK;\r\n        this.geodeticSurfaceNormalCartographic(cartographic, n);\r\n        Cartesian3.multiplyComponents(this._radiiSquared, n, k);\r\n        var gamma = Math.sqrt(Cartesian3.dot(n, k));\r\n        Cartesian3.divideByScalar(k, gamma, k);\r\n        Cartesian3.multiplyByScalar(n, cartographic.height, n);\r\n\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n        return Cartesian3.add(k, n, result);\r\n    };\r\n\r\n    /**\r\n     * Converts the provided array of cartographics to an array of Cartesians.\r\n     *\r\n     * @param {Cartographic[]} cartographics An array of cartographic positions.\r\n     * @param {Cartesian3[]} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3[]} The modified result parameter or a new Array instance if none was provided.\r\n     *\r\n     * @example\r\n     * //Convert an array of Cartographics and determine their Cartesian representation on a WGS84 ellipsoid.\r\n     * var positions = [new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 0),\r\n     *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.321), Cesium.Math.toRadians(78.123), 100),\r\n     *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.645), Cesium.Math.toRadians(78.456), 250)];\r\n     * var cartesianPositions = Cesium.Ellipsoid.WGS84.cartographicArrayToCartesianArray(positions);\r\n     */\r\n    Ellipsoid.prototype.cartographicArrayToCartesianArray = function(cartographics, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('cartographics', cartographics);\r\n        //>>includeEnd('debug')\r\n\r\n        var length = cartographics.length;\r\n        if (!defined(result)) {\r\n            result = new Array(length);\r\n        } else {\r\n            result.length = length;\r\n        }\r\n        for ( var i = 0; i < length; i++) {\r\n            result[i] = this.cartographicToCartesian(cartographics[i], result[i]);\r\n        }\r\n        return result;\r\n    };\r\n\r\n    var cartesianToCartographicN = new Cartesian3();\r\n    var cartesianToCartographicP = new Cartesian3();\r\n    var cartesianToCartographicH = new Cartesian3();\r\n\r\n    /**\r\n     * Converts the provided cartesian to cartographic representation.\r\n     * The cartesian is undefined at the center of the ellipsoid.\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.\r\n     * @param {Cartographic} [result] The object onto which to store the result.\r\n     * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.\r\n     *\r\n     * @example\r\n     * //Create a Cartesian and determine it's Cartographic representation on a WGS84 ellipsoid.\r\n     * var position = new Cesium.Cartesian3(17832.12, 83234.52, 952313.73);\r\n     * var cartographicPosition = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);\r\n     */\r\n    Ellipsoid.prototype.cartesianToCartographic = function(cartesian, result) {\r\n        //`cartesian is required.` is thrown from scaleToGeodeticSurface\r\n        var p = this.scaleToGeodeticSurface(cartesian, cartesianToCartographicP);\r\n\r\n        if (!defined(p)) {\r\n            return undefined;\r\n        }\r\n\r\n        var n = this.geodeticSurfaceNormal(p, cartesianToCartographicN);\r\n        var h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);\r\n\r\n        var longitude = Math.atan2(n.y, n.x);\r\n        var latitude = Math.asin(n.z);\r\n        var height = CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);\r\n\r\n        if (!defined(result)) {\r\n            return new Cartographic(longitude, latitude, height);\r\n        }\r\n        result.longitude = longitude;\r\n        result.latitude = latitude;\r\n        result.height = height;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Converts the provided array of cartesians to an array of cartographics.\r\n     *\r\n     * @param {Cartesian3[]} cartesians An array of Cartesian positions.\r\n     * @param {Cartographic[]} [result] The object onto which to store the result.\r\n     * @returns {Cartographic[]} The modified result parameter or a new Array instance if none was provided.\r\n     *\r\n     * @example\r\n     * //Create an array of Cartesians and determine their Cartographic representation on a WGS84 ellipsoid.\r\n     * var positions = [new Cesium.Cartesian3(17832.12, 83234.52, 952313.73),\r\n     *                  new Cesium.Cartesian3(17832.13, 83234.53, 952313.73),\r\n     *                  new Cesium.Cartesian3(17832.14, 83234.54, 952313.73)]\r\n     * var cartographicPositions = Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(positions);\r\n     */\r\n    Ellipsoid.prototype.cartesianArrayToCartographicArray = function(cartesians, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('cartesians', cartesians);\r\n        //>>includeEnd('debug');\r\n\r\n        var length = cartesians.length;\r\n        if (!defined(result)) {\r\n            result = new Array(length);\r\n        } else {\r\n            result.length = length;\r\n        }\r\n        for ( var i = 0; i < length; ++i) {\r\n            result[i] = this.cartesianToCartographic(cartesians[i], result[i]);\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Scales the provided Cartesian position along the geodetic surface normal\r\n     * so that it is on the surface of this ellipsoid.  If the position is\r\n     * at the center of the ellipsoid, this function returns undefined.\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian position to scale.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.\r\n     */\r\n    Ellipsoid.prototype.scaleToGeodeticSurface = function(cartesian, result) {\r\n        return scaleToGeodeticSurface(cartesian, this._oneOverRadii, this._oneOverRadiiSquared, this._centerToleranceSquared, result);\r\n    };\r\n\r\n    /**\r\n     * Scales the provided Cartesian position along the geocentric surface normal\r\n     * so that it is on the surface of this ellipsoid.\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian position to scale.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\r\n     */\r\n    Ellipsoid.prototype.scaleToGeocentricSurface = function(cartesian, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('cartesian', cartesian);\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n\r\n        var positionX = cartesian.x;\r\n        var positionY = cartesian.y;\r\n        var positionZ = cartesian.z;\r\n        var oneOverRadiiSquared = this._oneOverRadiiSquared;\r\n\r\n        var beta = 1.0 / Math.sqrt((positionX * positionX) * oneOverRadiiSquared.x +\r\n                                   (positionY * positionY) * oneOverRadiiSquared.y +\r\n                                   (positionZ * positionZ) * oneOverRadiiSquared.z);\r\n\r\n        return Cartesian3.multiplyByScalar(cartesian, beta, result);\r\n    };\r\n\r\n    /**\r\n     * Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying\r\n     * its components by the result of {@link Ellipsoid#oneOverRadii}.\r\n     *\r\n     * @param {Cartesian3} position The position to transform.\r\n     * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\r\n     *        return a new instance.\r\n     * @returns {Cartesian3} The position expressed in the scaled space.  The returned instance is the\r\n     *          one passed as the result parameter if it is not undefined, or a new instance of it is.\r\n     */\r\n    Ellipsoid.prototype.transformPositionToScaledSpace = function(position, result) {\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n\r\n        return Cartesian3.multiplyComponents(position, this._oneOverRadii, result);\r\n    };\r\n\r\n    /**\r\n     * Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying\r\n     * its components by the result of {@link Ellipsoid#radii}.\r\n     *\r\n     * @param {Cartesian3} position The position to transform.\r\n     * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\r\n     *        return a new instance.\r\n     * @returns {Cartesian3} The position expressed in the unscaled space.  The returned instance is the\r\n     *          one passed as the result parameter if it is not undefined, or a new instance of it is.\r\n     */\r\n    Ellipsoid.prototype.transformPositionFromScaledSpace = function(position, result) {\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n\r\n        return Cartesian3.multiplyComponents(position, this._radii, result);\r\n    };\r\n\r\n    /**\r\n     * Compares this Ellipsoid against the provided Ellipsoid componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {Ellipsoid} [right] The other Ellipsoid.\r\n     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     */\r\n    Ellipsoid.prototype.equals = function(right) {\r\n        return (this === right) ||\r\n               (defined(right) &&\r\n                Cartesian3.equals(this._radii, right._radii));\r\n    };\r\n\r\n    /**\r\n     * Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'.\r\n     *\r\n     * @returns {String} A string representing this ellipsoid in the format '(radii.x, radii.y, radii.z)'.\r\n     */\r\n    Ellipsoid.prototype.toString = function() {\r\n        return this._radii.toString();\r\n    };\r\n\r\n    /**\r\n     * Computes a point which is the intersection of the surface normal with the z-axis.\r\n     *\r\n     * @param {Cartesian3} position the position. must be on the surface of the ellipsoid.\r\n     * @param {Number} [buffer = 0.0] A buffer to subtract from the ellipsoid size when checking if the point is inside the ellipsoid.\r\n     *                                In earth case, with common earth datums, there is no need for this buffer since the intersection point is always (relatively) very close to the center.\r\n     *                                In WGS84 datum, intersection point is at max z = +-42841.31151331382 (0.673% of z-axis).\r\n     *                                Intersection point could be outside the ellipsoid if the ratio of MajorAxis / AxisOfRotation is bigger than the square root of 2\r\n     * @param {Cartesian3} [result] The cartesian to which to copy the result, or undefined to create and\r\n     *        return a new instance.\r\n     * @returns {Cartesian3 | undefined} the intersection point if it's inside the ellipsoid, undefined otherwise\r\n     *\r\n     * @exception {DeveloperError} position is required.\r\n     * @exception {DeveloperError} Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y).\r\n     * @exception {DeveloperError} Ellipsoid.radii.z must be greater than 0.\r\n     */\r\n    Ellipsoid.prototype.getSurfaceNormalIntersectionWithZAxis = function(position, buffer, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('position', position);\r\n\r\n        if (!CesiumMath.equalsEpsilon(this._radii.x, this._radii.y, CesiumMath.EPSILON15)) {\r\n            throw new DeveloperError('Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)');\r\n        }\r\n\r\n        Check.typeOf.number.greaterThan('Ellipsoid.radii.z', this._radii.z, 0);\r\n        //>>includeEnd('debug');\r\n\r\n        buffer = defaultValue(buffer, 0.0);\r\n\r\n        var squaredXOverSquaredZ = this._squaredXOverSquaredZ;\r\n\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n\r\n        result.x = 0.0;\r\n        result.y = 0.0;\r\n        result.z = position.z * (1 - squaredXOverSquaredZ);\r\n\r\n        if (Math.abs(result.z) >= this._radii.z - buffer) {\r\n            return undefined;\r\n        }\r\n\r\n        return result;\r\n    };\r\nexport default Ellipsoid;\r\n"],"names":["Cartesian3","x","y","z","this","defaultValue","fromSpherical","spherical","result","Check","typeOf","object","defined","clock","cone","magnitude","radial","Math","sin","cos","fromElements","clone","cartesian","fromCartesian4","packedLength","pack","value","array","startingIndex","unpack","packArray","length","resultLength","Array","isArray","DeveloperError","i","unpackArray","number","greaterThanOrEquals","index","fromArray","maximumComponent","max","minimumComponent","min","minimumByComponent","first","second","maximumByComponent","magnitudeSquared","sqrt","distanceScratch","distance","left","right","subtract","distanceSquared","normalize","isNaN","dot","multiplyComponents","divideComponents","add","multiplyByScalar","scalar","divideByScalar","negate","abs","lerpScratch","lerp","start","end","t","angleBetweenScratch","angleBetweenScratch2","angleBetween","cosine","sine","cross","atan2","mostOrthogonalAxisScratch","mostOrthogonalAxis","f","UNIT_X","UNIT_Z","UNIT_Y","projectVector","a","b","equals","equalsArray","offset","equalsEpsilon","relativeEpsilon","absoluteEpsilon","CesiumMath","leftX","leftY","leftZ","rightX","rightY","rightZ","midpoint","fromDegrees","longitude","latitude","height","ellipsoid","toRadians","fromRadians","scratchN","scratchK","wgs84RadiiSquared","radiiSquared","cosLatitude","gamma","fromDegreesArray","coordinates","fromRadiansArray","fromDegreesArrayHeights","fromRadiansArrayHeights","ZERO","Object","freeze","prototype","toString","scaleToGeodeticSurfaceIntersection","scaleToGeodeticSurfaceGradient","scaleToGeodeticSurface","oneOverRadii","oneOverRadiiSquared","centerToleranceSquared","positionX","positionY","positionZ","oneOverRadiiX","oneOverRadiiY","oneOverRadiiZ","x2","y2","z2","squaredNorm","ratio","intersection","isFinite","undefined","oneOverRadiiSquaredX","oneOverRadiiSquaredY","oneOverRadiiSquaredZ","gradient","func","xMultiplier","yMultiplier","zMultiplier","xMultiplier2","yMultiplier2","zMultiplier2","lambda","correction","EPSILON12","Cartographic","cartesianToCartographicN","cartesianToCartographicP","cartesianToCartographicH","wgs84OneOverRadii","wgs84OneOverRadiiSquared","wgs84CenterToleranceSquared","EPSILON1","initialize","_radii","_radiiSquared","_radiiToTheFourth","_oneOverRadii","_oneOverRadiiSquared","_minimumRadius","_maximumRadius","_centerToleranceSquared","_squaredXOverSquaredZ","Ellipsoid","fromCartesian","p","n","h","asin","sign","toCartesian","cartographic","epsilon","defineProperties","radii","get","radiiToTheFourth","minimumRadius","maximumRadius","fromCartesian3","WGS84","UNIT_SPHERE","MOON","LUNAR_RADIUS","geocentricSurfaceNormal","geodeticSurfaceNormalCartographic","geodeticSurfaceNormal","cartographicToCartesianNormal","cartographicToCartesianK","cartographicToCartesian","k","cartographicArrayToCartesianArray","cartographics","cartesianToCartographic","cartesianArrayToCartographicArray","cartesians","scaleToGeocentricSurface","beta","transformPositionToScaledSpace","position","transformPositionFromScaledSpace","getSurfaceNormalIntersectionWithZAxis","buffer","EPSILON15","greaterThan","squaredXOverSquaredZ"],"mappings":"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"}