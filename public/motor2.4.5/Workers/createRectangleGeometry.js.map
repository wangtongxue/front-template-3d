{"version":3,"file":"createRectangleGeometry.js","sources":["../../../../Source/Core/RectangleGeometry.js","../../../../Source/WorkersES6/createRectangleGeometry.js"],"sourcesContent":["import arrayFill from './arrayFill.js';\r\nimport BoundingSphere from './BoundingSphere.js';\r\nimport Cartesian2 from './Cartesian2.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport Cartographic from './Cartographic.js';\r\nimport Check from './Check.js';\r\nimport ComponentDatatype from './ComponentDatatype.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport Geometry from './Geometry.js';\r\nimport GeometryAttribute from './GeometryAttribute.js';\r\nimport GeometryAttributes from './GeometryAttributes.js';\r\nimport GeometryInstance from './GeometryInstance.js';\r\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\r\nimport GeometryPipeline from './GeometryPipeline.js';\r\nimport IndexDatatype from './IndexDatatype.js';\r\nimport CesiumMath from './Math.js';\r\nimport Matrix2 from './Matrix2.js';\r\nimport Matrix3 from './Matrix3.js';\r\nimport PolygonPipeline from './PolygonPipeline.js';\r\nimport PrimitiveType from './PrimitiveType.js';\r\nimport Quaternion from './Quaternion.js';\r\nimport Rectangle from './Rectangle.js';\r\nimport RectangleGeometryLibrary from './RectangleGeometryLibrary.js';\r\nimport VertexFormat from './VertexFormat.js';\r\n\r\n    var positionScratch = new Cartesian3();\r\n    var normalScratch = new Cartesian3();\r\n    var tangentScratch = new Cartesian3();\r\n    var bitangentScratch = new Cartesian3();\r\n    var rectangleScratch = new Rectangle();\r\n    var stScratch = new Cartesian2();\r\n    var bottomBoundingSphere = new BoundingSphere();\r\n    var topBoundingSphere = new BoundingSphere();\r\n\r\n    function createAttributes(vertexFormat, attributes) {\r\n        var geo = new Geometry({\r\n            attributes : new GeometryAttributes(),\r\n            primitiveType : PrimitiveType.TRIANGLES\r\n        });\r\n\r\n        geo.attributes.position = new GeometryAttribute({\r\n            componentDatatype : ComponentDatatype.DOUBLE,\r\n            componentsPerAttribute : 3,\r\n            values : attributes.positions\r\n        });\r\n        if (vertexFormat.normal) {\r\n            geo.attributes.normal = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.FLOAT,\r\n                componentsPerAttribute : 3,\r\n                values : attributes.normals\r\n            });\r\n        }\r\n        if (vertexFormat.tangent) {\r\n            geo.attributes.tangent = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.FLOAT,\r\n                componentsPerAttribute : 3,\r\n                values : attributes.tangents\r\n            });\r\n        }\r\n        if (vertexFormat.bitangent) {\r\n            geo.attributes.bitangent = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.FLOAT,\r\n                componentsPerAttribute : 3,\r\n                values : attributes.bitangents\r\n            });\r\n        }\r\n        return geo;\r\n    }\r\n\r\n    function calculateAttributes(positions, vertexFormat, ellipsoid, tangentRotationMatrix) {\r\n        var length = positions.length;\r\n\r\n        var normals = (vertexFormat.normal) ? new Float32Array(length) : undefined;\r\n        var tangents = (vertexFormat.tangent) ? new Float32Array(length) : undefined;\r\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(length) : undefined;\r\n\r\n        var attrIndex = 0;\r\n        var bitangent = bitangentScratch;\r\n        var tangent = tangentScratch;\r\n        var normal = normalScratch;\r\n        if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\r\n            for (var i = 0; i < length; i += 3) {\r\n                var p = Cartesian3.fromArray(positions, i, positionScratch);\r\n                var attrIndex1 = attrIndex + 1;\r\n                var attrIndex2 = attrIndex + 2;\r\n\r\n                normal = ellipsoid.geodeticSurfaceNormal(p, normal);\r\n                if (vertexFormat.tangent || vertexFormat.bitangent) {\r\n                    Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);\r\n                    Matrix3.multiplyByVector(tangentRotationMatrix, tangent, tangent);\r\n                    Cartesian3.normalize(tangent, tangent);\r\n\r\n                    if (vertexFormat.bitangent) {\r\n                        Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\r\n                    }\r\n                }\r\n\r\n                if (vertexFormat.normal) {\r\n                    normals[attrIndex] = normal.x;\r\n                    normals[attrIndex1] = normal.y;\r\n                    normals[attrIndex2] = normal.z;\r\n                }\r\n                if (vertexFormat.tangent) {\r\n                    tangents[attrIndex] = tangent.x;\r\n                    tangents[attrIndex1] = tangent.y;\r\n                    tangents[attrIndex2] = tangent.z;\r\n                }\r\n                if (vertexFormat.bitangent) {\r\n                    bitangents[attrIndex] = bitangent.x;\r\n                    bitangents[attrIndex1] = bitangent.y;\r\n                    bitangents[attrIndex2] = bitangent.z;\r\n                }\r\n                attrIndex += 3;\r\n            }\r\n        }\r\n        return createAttributes(vertexFormat, {\r\n            positions : positions,\r\n            normals : normals,\r\n            tangents : tangents,\r\n            bitangents : bitangents\r\n        });\r\n    }\r\n\r\n    var v1Scratch = new Cartesian3();\r\n    var v2Scratch = new Cartesian3();\r\n\r\n    function calculateAttributesWall(positions, vertexFormat, ellipsoid) {\r\n        var length = positions.length;\r\n\r\n        var normals = (vertexFormat.normal) ? new Float32Array(length) : undefined;\r\n        var tangents = (vertexFormat.tangent) ? new Float32Array(length) : undefined;\r\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(length) : undefined;\r\n\r\n        var normalIndex = 0;\r\n        var tangentIndex = 0;\r\n        var bitangentIndex = 0;\r\n        var recomputeNormal = true;\r\n\r\n        var bitangent = bitangentScratch;\r\n        var tangent = tangentScratch;\r\n        var normal = normalScratch;\r\n        if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\r\n            for (var i = 0; i < length; i += 6) {\r\n                var p = Cartesian3.fromArray(positions, i, positionScratch);\r\n                var p1 = Cartesian3.fromArray(positions, (i + 6) % length, v1Scratch);\r\n                if (recomputeNormal) {\r\n                    var p2 = Cartesian3.fromArray(positions, (i + 3) % length, v2Scratch);\r\n                    Cartesian3.subtract(p1, p, p1);\r\n                    Cartesian3.subtract(p2, p, p2);\r\n                    normal = Cartesian3.normalize(Cartesian3.cross(p2, p1, normal), normal);\r\n                    recomputeNormal = false;\r\n                }\r\n\r\n                if (Cartesian3.equalsEpsilon(p1, p, CesiumMath.EPSILON10)) { // if we've reached a corner\r\n                    recomputeNormal = true;\r\n                }\r\n\r\n                if (vertexFormat.tangent || vertexFormat.bitangent) {\r\n                    bitangent = ellipsoid.geodeticSurfaceNormal(p, bitangent);\r\n                    if (vertexFormat.tangent) {\r\n                        tangent = Cartesian3.normalize(Cartesian3.cross(bitangent, normal, tangent), tangent);\r\n                    }\r\n                }\r\n\r\n                if (vertexFormat.normal) {\r\n                    normals[normalIndex++] = normal.x;\r\n                    normals[normalIndex++] = normal.y;\r\n                    normals[normalIndex++] = normal.z;\r\n                    normals[normalIndex++] = normal.x;\r\n                    normals[normalIndex++] = normal.y;\r\n                    normals[normalIndex++] = normal.z;\r\n                }\r\n\r\n                if (vertexFormat.tangent) {\r\n                    tangents[tangentIndex++] = tangent.x;\r\n                    tangents[tangentIndex++] = tangent.y;\r\n                    tangents[tangentIndex++] = tangent.z;\r\n                    tangents[tangentIndex++] = tangent.x;\r\n                    tangents[tangentIndex++] = tangent.y;\r\n                    tangents[tangentIndex++] = tangent.z;\r\n                }\r\n\r\n                if (vertexFormat.bitangent) {\r\n                    bitangents[bitangentIndex++] = bitangent.x;\r\n                    bitangents[bitangentIndex++] = bitangent.y;\r\n                    bitangents[bitangentIndex++] = bitangent.z;\r\n                    bitangents[bitangentIndex++] = bitangent.x;\r\n                    bitangents[bitangentIndex++] = bitangent.y;\r\n                    bitangents[bitangentIndex++] = bitangent.z;\r\n                }\r\n            }\r\n        }\r\n\r\n        return createAttributes(vertexFormat, {\r\n            positions : positions,\r\n            normals : normals,\r\n            tangents : tangents,\r\n            bitangents : bitangents\r\n        });\r\n    }\r\n\r\n    function constructRectangle(rectangleGeometry, computedOptions) {\r\n        var vertexFormat = rectangleGeometry._vertexFormat;\r\n        var ellipsoid = rectangleGeometry._ellipsoid;\r\n        var height = computedOptions.height;\r\n        var width = computedOptions.width;\r\n        var northCap = computedOptions.northCap;\r\n        var southCap = computedOptions.southCap;\r\n\r\n        var rowStart = 0;\r\n        var rowEnd = height;\r\n        var rowHeight = height;\r\n        var size = 0;\r\n        if (northCap) {\r\n            rowStart = 1;\r\n            rowHeight -= 1;\r\n            size += 1;\r\n        }\r\n        if (southCap) {\r\n            rowEnd -= 1;\r\n            rowHeight -= 1;\r\n            size += 1;\r\n        }\r\n        size += (width * rowHeight);\r\n\r\n        var positions = (vertexFormat.position) ? new Float64Array(size * 3) : undefined;\r\n        var textureCoordinates = (vertexFormat.st) ? new Float32Array(size * 2) : undefined;\r\n\r\n        var posIndex = 0;\r\n        var stIndex = 0;\r\n\r\n        var position = positionScratch;\r\n        var st = stScratch;\r\n\r\n        var minX = Number.MAX_VALUE;\r\n        var minY = Number.MAX_VALUE;\r\n        var maxX = -Number.MAX_VALUE;\r\n        var maxY = -Number.MAX_VALUE;\r\n\r\n        for (var row = rowStart; row < rowEnd; ++row) {\r\n            for (var col = 0; col < width; ++col) {\r\n                RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, vertexFormat.st, row, col, position, st);\r\n\r\n                positions[posIndex++] = position.x;\r\n                positions[posIndex++] = position.y;\r\n                positions[posIndex++] = position.z;\r\n\r\n                if (vertexFormat.st) {\r\n                    textureCoordinates[stIndex++] = st.x;\r\n                    textureCoordinates[stIndex++] = st.y;\r\n\r\n                    minX = Math.min(minX, st.x);\r\n                    minY = Math.min(minY, st.y);\r\n                    maxX = Math.max(maxX, st.x);\r\n                    maxY = Math.max(maxY, st.y);\r\n                }\r\n            }\r\n        }\r\n        if (northCap) {\r\n            RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, vertexFormat.st, 0, 0, position, st);\r\n\r\n            positions[posIndex++] = position.x;\r\n            positions[posIndex++] = position.y;\r\n            positions[posIndex++] = position.z;\r\n\r\n            if (vertexFormat.st) {\r\n                textureCoordinates[stIndex++] = st.x;\r\n                textureCoordinates[stIndex++] = st.y;\r\n\r\n                minX = st.x;\r\n                minY = st.y;\r\n                maxX = st.x;\r\n                maxY = st.y;\r\n            }\r\n        }\r\n        if (southCap) {\r\n            RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, vertexFormat.st, height - 1, 0, position, st);\r\n\r\n            positions[posIndex++] = position.x;\r\n            positions[posIndex++] = position.y;\r\n            positions[posIndex] = position.z;\r\n\r\n            if (vertexFormat.st) {\r\n                textureCoordinates[stIndex++] = st.x;\r\n                textureCoordinates[stIndex] = st.y;\r\n\r\n                minX = Math.min(minX, st.x);\r\n                minY = Math.min(minY, st.y);\r\n                maxX = Math.max(maxX, st.x);\r\n                maxY = Math.max(maxY, st.y);\r\n            }\r\n        }\r\n\r\n        if (vertexFormat.st && (minX < 0.0 || minY < 0.0 || maxX > 1.0 || maxY > 1.0)) {\r\n            for (var k = 0; k < textureCoordinates.length; k += 2) {\r\n                textureCoordinates[k] = (textureCoordinates[k] - minX) / (maxX - minX);\r\n                textureCoordinates[k + 1] = (textureCoordinates[k + 1] - minY) / (maxY - minY);\r\n            }\r\n        }\r\n\r\n        var geo = calculateAttributes(positions, vertexFormat, ellipsoid, computedOptions.tangentRotationMatrix);\r\n\r\n        var indicesSize = 6 * (width - 1) * (rowHeight - 1);\r\n        if (northCap) {\r\n            indicesSize += 3 * (width - 1);\r\n        }\r\n        if (southCap) {\r\n            indicesSize += 3 * (width - 1);\r\n        }\r\n        var indices = IndexDatatype.createTypedArray(size, indicesSize);\r\n        var index = 0;\r\n        var indicesIndex = 0;\r\n        var i;\r\n        for (i = 0; i < rowHeight - 1; ++i) {\r\n            for (var j = 0; j < width - 1; ++j) {\r\n                var upperLeft = index;\r\n                var lowerLeft = upperLeft + width;\r\n                var lowerRight = lowerLeft + 1;\r\n                var upperRight = upperLeft + 1;\r\n                indices[indicesIndex++] = upperLeft;\r\n                indices[indicesIndex++] = lowerLeft;\r\n                indices[indicesIndex++] = upperRight;\r\n                indices[indicesIndex++] = upperRight;\r\n                indices[indicesIndex++] = lowerLeft;\r\n                indices[indicesIndex++] = lowerRight;\r\n                ++index;\r\n            }\r\n            ++index;\r\n        }\r\n        if (northCap || southCap) {\r\n            var northIndex = size - 1;\r\n            var southIndex = size - 1;\r\n            if (northCap && southCap) {\r\n                northIndex = size - 2;\r\n            }\r\n\r\n            var p1;\r\n            var p2;\r\n            index = 0;\r\n\r\n            if (northCap) {\r\n                for (i = 0; i < width - 1; i++) {\r\n                    p1 = index;\r\n                    p2 = p1 + 1;\r\n                    indices[indicesIndex++] = northIndex;\r\n                    indices[indicesIndex++] = p1;\r\n                    indices[indicesIndex++] = p2;\r\n                    ++index;\r\n                }\r\n            }\r\n            if (southCap) {\r\n                index = (rowHeight - 1) * (width);\r\n                for (i = 0; i < width - 1; i++) {\r\n                    p1 = index;\r\n                    p2 = p1 + 1;\r\n                    indices[indicesIndex++] = p1;\r\n                    indices[indicesIndex++] = southIndex;\r\n                    indices[indicesIndex++] = p2;\r\n                    ++index;\r\n                }\r\n            }\r\n        }\r\n\r\n        geo.indices = indices;\r\n        if (vertexFormat.st) {\r\n            geo.attributes.st = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.FLOAT,\r\n                componentsPerAttribute : 2,\r\n                values : textureCoordinates\r\n            });\r\n        }\r\n\r\n        return geo;\r\n    }\r\n\r\n    function addWallPositions(wallPositions, posIndex, i, topPositions, bottomPositions) {\r\n        wallPositions[posIndex++] = topPositions[i];\r\n        wallPositions[posIndex++] = topPositions[i + 1];\r\n        wallPositions[posIndex++] = topPositions[i + 2];\r\n        wallPositions[posIndex++] = bottomPositions[i];\r\n        wallPositions[posIndex++] = bottomPositions[i + 1];\r\n        wallPositions[posIndex] = bottomPositions[i + 2];\r\n        return wallPositions;\r\n    }\r\n\r\n    function addWallTextureCoordinates(wallTextures, stIndex, i, st) {\r\n        wallTextures[stIndex++] = st[i];\r\n        wallTextures[stIndex++] = st[i + 1];\r\n        wallTextures[stIndex++] = st[i];\r\n        wallTextures[stIndex] = st[i + 1];\r\n        return wallTextures;\r\n    }\r\n\r\n    var scratchVertexFormat = new VertexFormat();\r\n\r\n    function constructExtrudedRectangle(rectangleGeometry, computedOptions) {\r\n        var shadowVolume = rectangleGeometry._shadowVolume;\r\n        var offsetAttributeValue = rectangleGeometry._offsetAttribute;\r\n        var vertexFormat = rectangleGeometry._vertexFormat;\r\n        var minHeight = rectangleGeometry._extrudedHeight;\r\n        var maxHeight = rectangleGeometry._surfaceHeight;\r\n        var ellipsoid = rectangleGeometry._ellipsoid;\r\n\r\n        var height = computedOptions.height;\r\n        var width = computedOptions.width;\r\n\r\n        var i;\r\n\r\n        if (shadowVolume) {\r\n            var newVertexFormat = VertexFormat.clone(vertexFormat, scratchVertexFormat);\r\n            newVertexFormat.normal = true;\r\n            rectangleGeometry._vertexFormat = newVertexFormat;\r\n        }\r\n\r\n        var topBottomGeo = constructRectangle(rectangleGeometry, computedOptions);\r\n\r\n        if (shadowVolume) {\r\n            rectangleGeometry._vertexFormat = vertexFormat;\r\n        }\r\n\r\n        var topPositions = PolygonPipeline.scaleToGeodeticHeight(topBottomGeo.attributes.position.values, maxHeight, ellipsoid, false);\r\n        topPositions = new Float64Array(topPositions);\r\n        var length = topPositions.length;\r\n        var newLength = length * 2;\r\n        var positions = new Float64Array(newLength);\r\n        positions.set(topPositions);\r\n        var bottomPositions = PolygonPipeline.scaleToGeodeticHeight(topBottomGeo.attributes.position.values, minHeight, ellipsoid);\r\n        positions.set(bottomPositions, length);\r\n        topBottomGeo.attributes.position.values = positions;\r\n\r\n        var normals = (vertexFormat.normal) ? new Float32Array(newLength) : undefined;\r\n        var tangents = (vertexFormat.tangent) ? new Float32Array(newLength) : undefined;\r\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(newLength) : undefined;\r\n        var textures = (vertexFormat.st) ? new Float32Array(newLength / 3 * 2) : undefined;\r\n        var topSt;\r\n        var topNormals;\r\n        if (vertexFormat.normal) {\r\n            topNormals = topBottomGeo.attributes.normal.values;\r\n            normals.set(topNormals);\r\n            for (i = 0; i < length; i++) {\r\n                topNormals[i] = -topNormals[i];\r\n            }\r\n            normals.set(topNormals, length);\r\n            topBottomGeo.attributes.normal.values = normals;\r\n        }\r\n        if (shadowVolume) {\r\n            topNormals = topBottomGeo.attributes.normal.values;\r\n            if (!vertexFormat.normal) {\r\n                topBottomGeo.attributes.normal = undefined;\r\n            }\r\n            var extrudeNormals = new Float32Array(newLength);\r\n            for (i = 0; i < length; i++) {\r\n                topNormals[i] = -topNormals[i];\r\n            }\r\n            extrudeNormals.set(topNormals, length); //only get normals for bottom layer that's going to be pushed down\r\n            topBottomGeo.attributes.extrudeDirection = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.FLOAT,\r\n                componentsPerAttribute : 3,\r\n                values : extrudeNormals\r\n            });\r\n        }\r\n\r\n        var offsetValue;\r\n        var hasOffsets = defined(offsetAttributeValue);\r\n        if (hasOffsets) {\r\n            var size = length / 3 * 2;\r\n            var offsetAttribute = new Uint8Array(size);\r\n            if (offsetAttributeValue === GeometryOffsetAttribute.TOP) {\r\n                offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\r\n            } else {\r\n                offsetValue = offsetAttributeValue === GeometryOffsetAttribute.NONE ? 0 : 1;\r\n                offsetAttribute = arrayFill(offsetAttribute, offsetValue);\r\n            }\r\n\r\n            topBottomGeo.attributes.applyOffset = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\r\n                componentsPerAttribute : 1,\r\n                values : offsetAttribute\r\n            });\r\n        }\r\n\r\n        if (vertexFormat.tangent) {\r\n            var topTangents = topBottomGeo.attributes.tangent.values;\r\n            tangents.set(topTangents);\r\n            for (i = 0; i < length; i++) {\r\n                topTangents[i] = -topTangents[i];\r\n            }\r\n            tangents.set(topTangents, length);\r\n            topBottomGeo.attributes.tangent.values = tangents;\r\n        }\r\n        if (vertexFormat.bitangent) {\r\n            var topBitangents = topBottomGeo.attributes.bitangent.values;\r\n            bitangents.set(topBitangents);\r\n            bitangents.set(topBitangents, length);\r\n            topBottomGeo.attributes.bitangent.values = bitangents;\r\n        }\r\n        if (vertexFormat.st) {\r\n            topSt = topBottomGeo.attributes.st.values;\r\n            textures.set(topSt);\r\n            textures.set(topSt, length / 3 * 2);\r\n            topBottomGeo.attributes.st.values = textures;\r\n        }\r\n\r\n        var indices = topBottomGeo.indices;\r\n        var indicesLength = indices.length;\r\n        var posLength = length / 3;\r\n        var newIndices = IndexDatatype.createTypedArray(newLength / 3, indicesLength * 2);\r\n        newIndices.set(indices);\r\n        for (i = 0; i < indicesLength; i += 3) {\r\n            newIndices[i + indicesLength] = indices[i + 2] + posLength;\r\n            newIndices[i + 1 + indicesLength] = indices[i + 1] + posLength;\r\n            newIndices[i + 2 + indicesLength] = indices[i] + posLength;\r\n        }\r\n        topBottomGeo.indices = newIndices;\r\n\r\n        var northCap = computedOptions.northCap;\r\n        var southCap = computedOptions.southCap;\r\n\r\n        var rowHeight = height;\r\n        var widthMultiplier = 2;\r\n        var perimeterPositions = 0;\r\n        var corners = 4;\r\n        var dupliateCorners = 4;\r\n        if (northCap) {\r\n            widthMultiplier -= 1;\r\n            rowHeight -= 1;\r\n            perimeterPositions += 1;\r\n            corners -= 2;\r\n            dupliateCorners -= 1;\r\n        }\r\n        if (southCap) {\r\n            widthMultiplier -= 1;\r\n            rowHeight -= 1;\r\n            perimeterPositions += 1;\r\n            corners -= 2;\r\n            dupliateCorners -= 1;\r\n        }\r\n        perimeterPositions += (widthMultiplier * width + 2 * rowHeight - corners);\r\n\r\n        var wallCount = (perimeterPositions + dupliateCorners) * 2;\r\n\r\n        var wallPositions = new Float64Array(wallCount * 3);\r\n        var wallExtrudeNormals = shadowVolume ? new Float32Array(wallCount * 3) : undefined;\r\n        var wallOffsetAttribute = hasOffsets ? new Uint8Array(wallCount) : undefined;\r\n        var wallTextures = (vertexFormat.st) ? new Float32Array(wallCount * 2) : undefined;\r\n\r\n        var computeTopOffsets = offsetAttributeValue === GeometryOffsetAttribute.TOP;\r\n        if (hasOffsets && !computeTopOffsets) {\r\n            offsetValue = offsetAttributeValue === GeometryOffsetAttribute.ALL ? 1 : 0;\r\n            wallOffsetAttribute = arrayFill(wallOffsetAttribute, offsetValue);\r\n        }\r\n\r\n        var posIndex = 0;\r\n        var stIndex = 0;\r\n        var extrudeNormalIndex = 0;\r\n        var wallOffsetIndex = 0;\r\n        var area = width * rowHeight;\r\n        var threeI;\r\n        for (i = 0; i < area; i += width) {\r\n            threeI = i * 3;\r\n            wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\r\n            posIndex += 6;\r\n            if (vertexFormat.st) {\r\n                wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i * 2, topSt);\r\n                stIndex += 4;\r\n            }\r\n            if (shadowVolume) {\r\n                extrudeNormalIndex += 3;\r\n                wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\r\n                wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\r\n                wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\r\n            }\r\n            if (computeTopOffsets) {\r\n                wallOffsetAttribute[wallOffsetIndex++] = 1;\r\n                wallOffsetIndex += 1;\r\n            }\r\n        }\r\n\r\n        if (!southCap) {\r\n            for (i = area - width; i < area; i++) {\r\n                threeI = i * 3;\r\n                wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\r\n                posIndex += 6;\r\n                if (vertexFormat.st) {\r\n                    wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i * 2, topSt);\r\n                    stIndex += 4;\r\n                }\r\n                if (shadowVolume) {\r\n                    extrudeNormalIndex += 3;\r\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\r\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\r\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\r\n                }\r\n                if (computeTopOffsets) {\r\n                    wallOffsetAttribute[wallOffsetIndex++] = 1;\r\n                    wallOffsetIndex += 1;\r\n                }\r\n            }\r\n        } else {\r\n            var southIndex = northCap ? area + 1 : area;\r\n            threeI = southIndex * 3;\r\n\r\n            for (i = 0; i < 2; i++) { // duplicate corner points\r\n                wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\r\n                posIndex += 6;\r\n                if (vertexFormat.st) {\r\n                    wallTextures = addWallTextureCoordinates(wallTextures, stIndex, southIndex * 2, topSt);\r\n                    stIndex += 4;\r\n                }\r\n                if (shadowVolume) {\r\n                    extrudeNormalIndex += 3;\r\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\r\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\r\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\r\n                }\r\n                if (computeTopOffsets) {\r\n                    wallOffsetAttribute[wallOffsetIndex++] = 1;\r\n                    wallOffsetIndex += 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        for (i = area - 1; i > 0; i -= width) {\r\n            threeI = i * 3;\r\n            wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\r\n            posIndex += 6;\r\n            if (vertexFormat.st) {\r\n                wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i * 2, topSt);\r\n                stIndex += 4;\r\n            }\r\n            if (shadowVolume) {\r\n                extrudeNormalIndex += 3;\r\n                wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\r\n                wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\r\n                wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\r\n            }\r\n            if (computeTopOffsets) {\r\n                wallOffsetAttribute[wallOffsetIndex++] = 1;\r\n                wallOffsetIndex += 1;\r\n            }\r\n\r\n        }\r\n\r\n        if (!northCap) {\r\n            for (i = width - 1; i >= 0; i--) {\r\n                threeI = i * 3;\r\n                wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\r\n                posIndex += 6;\r\n                if (vertexFormat.st) {\r\n                    wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i * 2, topSt);\r\n                    stIndex += 4;\r\n                }\r\n                if (shadowVolume) {\r\n                    extrudeNormalIndex += 3;\r\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\r\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\r\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\r\n                }\r\n                if (computeTopOffsets) {\r\n                    wallOffsetAttribute[wallOffsetIndex++] = 1;\r\n                    wallOffsetIndex += 1;\r\n                }\r\n            }\r\n        } else {\r\n            var northIndex = area;\r\n            threeI = northIndex * 3;\r\n\r\n            for (i = 0; i < 2; i++) { // duplicate corner points\r\n                wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\r\n                posIndex += 6;\r\n                if (vertexFormat.st) {\r\n                    wallTextures = addWallTextureCoordinates(wallTextures, stIndex, northIndex * 2, topSt);\r\n                    stIndex += 4;\r\n                }\r\n                if (shadowVolume) {\r\n                    extrudeNormalIndex += 3;\r\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\r\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\r\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\r\n                }\r\n                if (computeTopOffsets) {\r\n                    wallOffsetAttribute[wallOffsetIndex++] = 1;\r\n                    wallOffsetIndex += 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        var geo = calculateAttributesWall(wallPositions, vertexFormat, ellipsoid);\r\n\r\n        if (vertexFormat.st) {\r\n            geo.attributes.st = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.FLOAT,\r\n                componentsPerAttribute : 2,\r\n                values : wallTextures\r\n            });\r\n        }\r\n        if (shadowVolume) {\r\n            geo.attributes.extrudeDirection = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.FLOAT,\r\n                componentsPerAttribute : 3,\r\n                values : wallExtrudeNormals\r\n            });\r\n        }\r\n        if (hasOffsets) {\r\n            geo.attributes.applyOffset = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\r\n                componentsPerAttribute : 1,\r\n                values : wallOffsetAttribute\r\n            });\r\n        }\r\n\r\n        var wallIndices = IndexDatatype.createTypedArray(wallCount, perimeterPositions * 6);\r\n\r\n        var upperLeft;\r\n        var lowerLeft;\r\n        var lowerRight;\r\n        var upperRight;\r\n        length = wallPositions.length / 3;\r\n        var index = 0;\r\n        for (i = 0; i < length - 1; i += 2) {\r\n            upperLeft = i;\r\n            upperRight = (upperLeft + 2) % length;\r\n            var p1 = Cartesian3.fromArray(wallPositions, upperLeft * 3, v1Scratch);\r\n            var p2 = Cartesian3.fromArray(wallPositions, upperRight * 3, v2Scratch);\r\n            if (Cartesian3.equalsEpsilon(p1, p2, CesiumMath.EPSILON10)) {\r\n                continue;\r\n            }\r\n            lowerLeft = (upperLeft + 1) % length;\r\n            lowerRight = (lowerLeft + 2) % length;\r\n            wallIndices[index++] = upperLeft;\r\n            wallIndices[index++] = lowerLeft;\r\n            wallIndices[index++] = upperRight;\r\n            wallIndices[index++] = upperRight;\r\n            wallIndices[index++] = lowerLeft;\r\n            wallIndices[index++] = lowerRight;\r\n        }\r\n\r\n        geo.indices = wallIndices;\r\n\r\n        geo = GeometryPipeline.combineInstances([\r\n            new GeometryInstance({\r\n                geometry : topBottomGeo\r\n            }),\r\n            new GeometryInstance({\r\n                geometry : geo\r\n            })\r\n        ]);\r\n\r\n        return geo[0];\r\n    }\r\n\r\n    var scratchRectanglePoints = [new Cartesian3(), new Cartesian3(), new Cartesian3(), new Cartesian3()];\r\n    var nwScratch = new Cartographic();\r\n    var stNwScratch = new Cartographic();\r\n    function computeRectangle(rectangle, granularity, rotation, ellipsoid, result) {\r\n        if (rotation === 0.0) {\r\n            return Rectangle.clone(rectangle, result);\r\n        }\r\n\r\n        var computedOptions = RectangleGeometryLibrary.computeOptions(rectangle, granularity, rotation, 0, rectangleScratch, nwScratch);\r\n\r\n        var height = computedOptions.height;\r\n        var width = computedOptions.width;\r\n\r\n        var positions = scratchRectanglePoints;\r\n        RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, 0, 0, positions[0]);\r\n        RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, 0, width - 1, positions[1]);\r\n        RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, height - 1, 0, positions[2]);\r\n        RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, height - 1, width - 1, positions[3]);\r\n\r\n        return Rectangle.fromCartesianArray(positions, ellipsoid, result);\r\n    }\r\n\r\n    /**\r\n     * A description of a cartographic rectangle on an ellipsoid centered at the origin. Rectangle geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\r\n     *\r\n     * @alias RectangleGeometry\r\n     * @constructor\r\n     *\r\n     * @param {Object} options Object with the following properties:\r\n     * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\r\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\r\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle lies.\r\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n     * @param {Number} [options.height=0.0] The distance in meters between the rectangle and the ellipsoid surface.\r\n     * @param {Number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\r\n     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\r\n     * @param {Number} [options.extrudedHeight] The distance in meters between the rectangle's extruded face and the ellipsoid surface.\r\n     *\r\n     * @exception {DeveloperError} <code>options.rectangle.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\r\n     * @exception {DeveloperError} <code>options.rectangle.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\r\n     * @exception {DeveloperError} <code>options.rectangle.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\r\n     * @exception {DeveloperError} <code>options.rectangle.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\r\n     * @exception {DeveloperError} <code>options.rectangle.north</code> must be greater than <code>options.rectangle.south</code>.\r\n     *\r\n     * @see RectangleGeometry#createGeometry\r\n     *\r\n     * @demo {@link https://sandcastle.cesium.com/index.html?src=Rectangle.html|Cesium Sandcastle Rectangle Demo}\r\n     *\r\n     * @example\r\n     * // 1. create a rectangle\r\n     * var rectangle = new Cesium.RectangleGeometry({\r\n     *   ellipsoid : Cesium.Ellipsoid.WGS84,\r\n     *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\r\n     *   height : 10000.0\r\n     * });\r\n     * var geometry = Cesium.RectangleGeometry.createGeometry(rectangle);\r\n     *\r\n     * // 2. create an extruded rectangle without a top\r\n     * var rectangle = new Cesium.RectangleGeometry({\r\n     *   ellipsoid : Cesium.Ellipsoid.WGS84,\r\n     *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\r\n     *   height : 10000.0,\r\n     *   extrudedHeight: 300000\r\n     * });\r\n     * var geometry = Cesium.RectangleGeometry.createGeometry(rectangle);\r\n     */\r\n    function RectangleGeometry(options) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n        var rectangle = options.rectangle;\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('rectangle', rectangle);\r\n        Rectangle.validate(rectangle);\r\n        if (rectangle.north < rectangle.south) {\r\n            throw new DeveloperError('options.rectangle.north must be greater than or equal to options.rectangle.south');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var height = defaultValue(options.height, 0.0);\r\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\r\n\r\n        this._rectangle = Rectangle.clone(rectangle);\r\n        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\r\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\r\n        this._surfaceHeight = Math.max(height, extrudedHeight);\r\n        this._rotation = defaultValue(options.rotation, 0.0);\r\n        this._stRotation = defaultValue(options.stRotation, 0.0);\r\n        this._vertexFormat = VertexFormat.clone(defaultValue(options.vertexFormat, VertexFormat.DEFAULT));\r\n        this._extrudedHeight = Math.min(height, extrudedHeight);\r\n        this._shadowVolume = defaultValue(options.shadowVolume, false);\r\n        this._workerName = 'createRectangleGeometry';\r\n        this._offsetAttribute = options.offsetAttribute;\r\n        this._rotatedRectangle = undefined;\r\n\r\n        this._textureCoordinateRotationPoints = undefined;\r\n    }\r\n\r\n    /**\r\n     * The number of elements used to pack the object into an array.\r\n     * @type {Number}\r\n     */\r\n    RectangleGeometry.packedLength = Rectangle.packedLength + Ellipsoid.packedLength + VertexFormat.packedLength + 7;\r\n\r\n    /**\r\n     * Stores the provided instance into the provided array.\r\n     *\r\n     * @param {RectangleGeometry} value The value to pack.\r\n     * @param {Number[]} array The array to pack into.\r\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n     *\r\n     * @returns {Number[]} The array that was packed into\r\n     */\r\n    RectangleGeometry.pack = function(value, array, startingIndex) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('value', value);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        Rectangle.pack(value._rectangle, array, startingIndex);\r\n        startingIndex += Rectangle.packedLength;\r\n\r\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\r\n        startingIndex += Ellipsoid.packedLength;\r\n\r\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\r\n        startingIndex += VertexFormat.packedLength;\r\n\r\n        array[startingIndex++] = value._granularity;\r\n        array[startingIndex++] = value._surfaceHeight;\r\n        array[startingIndex++] = value._rotation;\r\n        array[startingIndex++] = value._stRotation;\r\n        array[startingIndex++] = value._extrudedHeight;\r\n        array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\r\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\r\n\r\n        return array;\r\n    };\r\n\r\n    var scratchRectangle = new Rectangle();\r\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\r\n    var scratchOptions = {\r\n        rectangle : scratchRectangle,\r\n        ellipsoid : scratchEllipsoid,\r\n        vertexFormat : scratchVertexFormat,\r\n        granularity : undefined,\r\n        height : undefined,\r\n        rotation : undefined,\r\n        stRotation : undefined,\r\n        extrudedHeight : undefined,\r\n        shadowVolume : undefined,\r\n        offsetAttribute: undefined\r\n    };\r\n\r\n    /**\r\n     * Retrieves an instance from a packed array.\r\n     *\r\n     * @param {Number[]} array The packed array.\r\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n     * @param {RectangleGeometry} [result] The object into which to store the result.\r\n     * @returns {RectangleGeometry} The modified result parameter or a new RectangleGeometry instance if one was not provided.\r\n     */\r\n    RectangleGeometry.unpack = function(array, startingIndex, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        var rectangle = Rectangle.unpack(array, startingIndex, scratchRectangle);\r\n        startingIndex += Rectangle.packedLength;\r\n\r\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\r\n        startingIndex += Ellipsoid.packedLength;\r\n\r\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\r\n        startingIndex += VertexFormat.packedLength;\r\n\r\n        var granularity = array[startingIndex++];\r\n        var surfaceHeight = array[startingIndex++];\r\n        var rotation = array[startingIndex++];\r\n        var stRotation = array[startingIndex++];\r\n        var extrudedHeight = array[startingIndex++];\r\n        var shadowVolume = array[startingIndex++] === 1.0;\r\n        var offsetAttribute = array[startingIndex];\r\n\r\n        if (!defined(result)) {\r\n            scratchOptions.granularity = granularity;\r\n            scratchOptions.height = surfaceHeight;\r\n            scratchOptions.rotation = rotation;\r\n            scratchOptions.stRotation = stRotation;\r\n            scratchOptions.extrudedHeight = extrudedHeight;\r\n            scratchOptions.shadowVolume = shadowVolume;\r\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\r\n\r\n            return new RectangleGeometry(scratchOptions);\r\n        }\r\n\r\n        result._rectangle = Rectangle.clone(rectangle, result._rectangle);\r\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\r\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\r\n        result._granularity = granularity;\r\n        result._surfaceHeight = surfaceHeight;\r\n        result._rotation = rotation;\r\n        result._stRotation = stRotation;\r\n        result._extrudedHeight = extrudedHeight;\r\n        result._shadowVolume = shadowVolume;\r\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the bounding rectangle based on the provided options\r\n     *\r\n     * @param {Object} options Object with the following properties:\r\n     * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\r\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle lies.\r\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n     * @param {Number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\r\n     * @param {Rectangle} [result] An object in which to store the result.\r\n     *\r\n     * @returns {Rectangle} The result rectangle\r\n     */\r\n    RectangleGeometry.computeRectangle = function(options, result) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n        var rectangle = options.rectangle;\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('rectangle', rectangle);\r\n        Rectangle.validate(rectangle);\r\n        if (rectangle.north < rectangle.south) {\r\n            throw new DeveloperError('options.rectangle.north must be greater than or equal to options.rectangle.south');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\r\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n        var rotation = defaultValue(options.rotation, 0.0);\r\n\r\n        return computeRectangle(rectangle, granularity, rotation, ellipsoid, result);\r\n    };\r\n\r\n    var tangentRotationMatrixScratch = new Matrix3();\r\n    var quaternionScratch = new Quaternion();\r\n    var centerScratch = new Cartographic();\r\n    /**\r\n     * Computes the geometric representation of a rectangle, including its vertices, indices, and a bounding sphere.\r\n     *\r\n     * @param {RectangleGeometry} rectangleGeometry A description of the rectangle.\r\n     * @returns {Geometry|undefined} The computed vertices and indices.\r\n     *\r\n     * @exception {DeveloperError} Rotated rectangle is invalid.\r\n     */\r\n    RectangleGeometry.createGeometry = function(rectangleGeometry) {\r\n        if ((CesiumMath.equalsEpsilon(rectangleGeometry._rectangle.north, rectangleGeometry._rectangle.south, CesiumMath.EPSILON10) ||\r\n             (CesiumMath.equalsEpsilon(rectangleGeometry._rectangle.east, rectangleGeometry._rectangle.west, CesiumMath.EPSILON10)))) {\r\n            return undefined;\r\n        }\r\n\r\n        var rectangle = rectangleGeometry._rectangle;\r\n        var ellipsoid = rectangleGeometry._ellipsoid;\r\n        var rotation = rectangleGeometry._rotation;\r\n        var stRotation = rectangleGeometry._stRotation;\r\n        var vertexFormat = rectangleGeometry._vertexFormat;\r\n\r\n        var computedOptions = RectangleGeometryLibrary.computeOptions(rectangle, rectangleGeometry._granularity, rotation, stRotation, rectangleScratch, nwScratch, stNwScratch);\r\n\r\n        var tangentRotationMatrix = tangentRotationMatrixScratch;\r\n        if (stRotation !== 0 || rotation !== 0) {\r\n            var center = Rectangle.center(rectangle, centerScratch);\r\n            var axis = ellipsoid.geodeticSurfaceNormalCartographic(center, v1Scratch);\r\n            Quaternion.fromAxisAngle(axis, -stRotation, quaternionScratch);\r\n            Matrix3.fromQuaternion(quaternionScratch, tangentRotationMatrix);\r\n        } else {\r\n            Matrix3.clone(Matrix3.IDENTITY, tangentRotationMatrix);\r\n        }\r\n\r\n        var surfaceHeight = rectangleGeometry._surfaceHeight;\r\n        var extrudedHeight = rectangleGeometry._extrudedHeight;\r\n        var extrude = !CesiumMath.equalsEpsilon(surfaceHeight, extrudedHeight, 0, CesiumMath.EPSILON2);\r\n\r\n        computedOptions.lonScalar = 1.0 / rectangleGeometry._rectangle.width;\r\n        computedOptions.latScalar = 1.0 / rectangleGeometry._rectangle.height;\r\n        computedOptions.tangentRotationMatrix = tangentRotationMatrix;\r\n\r\n        var geometry;\r\n        var boundingSphere;\r\n        rectangle = rectangleGeometry._rectangle;\r\n        if (extrude) {\r\n            geometry = constructExtrudedRectangle(rectangleGeometry, computedOptions);\r\n            var topBS = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, surfaceHeight, topBoundingSphere);\r\n            var bottomBS = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, extrudedHeight, bottomBoundingSphere);\r\n            boundingSphere = BoundingSphere.union(topBS, bottomBS);\r\n        } else {\r\n            geometry = constructRectangle(rectangleGeometry, computedOptions);\r\n            geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(geometry.attributes.position.values, surfaceHeight, ellipsoid, false);\r\n\r\n            if (defined(rectangleGeometry._offsetAttribute)) {\r\n                var length = geometry.attributes.position.values.length;\r\n                var applyOffset = new Uint8Array(length / 3);\r\n                var offsetValue = rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\r\n                arrayFill(applyOffset, offsetValue);\r\n                geometry.attributes.applyOffset = new GeometryAttribute({\r\n                    componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\r\n                    componentsPerAttribute : 1,\r\n                    values: applyOffset\r\n                });\r\n            }\r\n\r\n            boundingSphere = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, surfaceHeight);\r\n        }\r\n\r\n        if (!vertexFormat.position) {\r\n            delete geometry.attributes.position;\r\n        }\r\n\r\n        return new Geometry({\r\n            attributes : geometry.attributes,\r\n            indices : geometry.indices,\r\n            primitiveType : geometry.primitiveType,\r\n            boundingSphere : boundingSphere,\r\n            offsetAttribute : rectangleGeometry._offsetAttribute\r\n        });\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    RectangleGeometry.createShadowVolume = function(rectangleGeometry, minHeightFunc, maxHeightFunc) {\r\n        var granularity = rectangleGeometry._granularity;\r\n        var ellipsoid = rectangleGeometry._ellipsoid;\r\n\r\n        var minHeight = minHeightFunc(granularity, ellipsoid);\r\n        var maxHeight = maxHeightFunc(granularity, ellipsoid);\r\n\r\n        return new RectangleGeometry({\r\n            rectangle : rectangleGeometry._rectangle,\r\n            rotation : rectangleGeometry._rotation,\r\n            ellipsoid : ellipsoid,\r\n            stRotation : rectangleGeometry._stRotation,\r\n            granularity : granularity,\r\n            extrudedHeight : maxHeight,\r\n            height : minHeight,\r\n            vertexFormat : VertexFormat.POSITION_ONLY,\r\n            shadowVolume : true\r\n        });\r\n    };\r\n\r\n    var unrotatedTextureRectangleScratch = new Rectangle();\r\n    var points2DScratch = [new Cartesian2(), new Cartesian2(), new Cartesian2()];\r\n    var rotation2DScratch = new Matrix2();\r\n    var rectangleCenterScratch = new Cartographic();\r\n\r\n    function textureCoordinateRotationPoints(rectangleGeometry) {\r\n        if (rectangleGeometry._stRotation === 0.0) {\r\n            return [0, 0, 0, 1, 1, 0];\r\n        }\r\n\r\n        var rectangle = Rectangle.clone(rectangleGeometry._rectangle, unrotatedTextureRectangleScratch);\r\n        var granularity = rectangleGeometry._granularity;\r\n        var ellipsoid = rectangleGeometry._ellipsoid;\r\n\r\n        // Rotate to align the texture coordinates with ENU\r\n        var rotation = rectangleGeometry._rotation - rectangleGeometry._stRotation;\r\n\r\n        var unrotatedTextureRectangle = computeRectangle(rectangle, granularity, rotation, ellipsoid, unrotatedTextureRectangleScratch);\r\n\r\n        // Assume a computed \"east-north\" texture coordinate system based on spherical or planar tricks, bounded by `boundingRectangle`.\r\n        // The \"desired\" texture coordinate system forms an oriented rectangle (un-oriented computed) around the geometry that completely and tightly bounds it.\r\n        // We want to map from the \"east-north\" texture coordinate system into the \"desired\" system using a pair of lines (analagous planes in 2D)\r\n        // Compute 3 corners of the \"desired\" texture coordinate system in \"east-north\" texture space by the following in cartographic space:\r\n        // - rotate 3 of the corners in unrotatedTextureRectangle by stRotation around the center of the bounding rectangle\r\n        // - apply the \"east-north\" system's normalization formula to the rotated cartographics, even though this is likely to produce values outside [0-1].\r\n        // This gives us a set of points in the \"east-north\" texture coordinate system that can be used to map \"east-north\" texture coordinates to \"desired.\"\r\n\r\n        var points2D = points2DScratch;\r\n        points2D[0].x = unrotatedTextureRectangle.west;\r\n        points2D[0].y = unrotatedTextureRectangle.south;\r\n\r\n        points2D[1].x = unrotatedTextureRectangle.west;\r\n        points2D[1].y = unrotatedTextureRectangle.north;\r\n\r\n        points2D[2].x = unrotatedTextureRectangle.east;\r\n        points2D[2].y = unrotatedTextureRectangle.south;\r\n\r\n        var boundingRectangle = rectangleGeometry.rectangle;\r\n        var toDesiredInComputed = Matrix2.fromRotation(rectangleGeometry._stRotation, rotation2DScratch);\r\n        var boundingRectangleCenter = Rectangle.center(boundingRectangle, rectangleCenterScratch);\r\n\r\n        for (var i = 0; i < 3; ++i) {\r\n            var point2D = points2D[i];\r\n            point2D.x -= boundingRectangleCenter.longitude;\r\n            point2D.y -= boundingRectangleCenter.latitude;\r\n            Matrix2.multiplyByVector(toDesiredInComputed, point2D, point2D);\r\n            point2D.x += boundingRectangleCenter.longitude;\r\n            point2D.y += boundingRectangleCenter.latitude;\r\n\r\n            // Convert point into east-north texture coordinate space\r\n            point2D.x = (point2D.x - boundingRectangle.west) / boundingRectangle.width;\r\n            point2D.y = (point2D.y - boundingRectangle.south) / boundingRectangle.height;\r\n        }\r\n\r\n        var minXYCorner = points2D[0];\r\n        var maxYCorner = points2D[1];\r\n        var maxXCorner = points2D[2];\r\n        var result = new Array(6);\r\n        Cartesian2.pack(minXYCorner, result);\r\n        Cartesian2.pack(maxYCorner, result, 2);\r\n        Cartesian2.pack(maxXCorner, result, 4);\r\n        return result;\r\n    }\r\n\r\n    Object.defineProperties(RectangleGeometry.prototype, {\r\n        /**\r\n         * @private\r\n         */\r\n        rectangle : {\r\n            get : function() {\r\n                if (!defined(this._rotatedRectangle)) {\r\n                    this._rotatedRectangle = computeRectangle(this._rectangle, this._granularity, this._rotation, this._ellipsoid);\r\n                }\r\n                return this._rotatedRectangle;\r\n            }\r\n        },\r\n        /**\r\n         * For remapping texture coordinates when rendering RectangleGeometries as GroundPrimitives.\r\n         * This version permits skew in textures by computing offsets directly in cartographic space and\r\n         * more accurately approximates rendering RectangleGeometries with height as standard Primitives.\r\n         * @see Geometry#_textureCoordinateRotationPoints\r\n         * @private\r\n         */\r\n        textureCoordinateRotationPoints : {\r\n            get : function() {\r\n                if (!defined(this._textureCoordinateRotationPoints)) {\r\n                    this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(this);\r\n                }\r\n                return this._textureCoordinateRotationPoints;\r\n            }\r\n        }\r\n    });\r\nexport default RectangleGeometry;\r\n","import defined from '../Core/defined.js';\r\nimport Ellipsoid from '../Core/Ellipsoid.js';\r\nimport Rectangle from '../Core/Rectangle.js';\r\nimport RectangleGeometry from '../Core/RectangleGeometry.js';\r\n\r\n    function createRectangleGeometry(rectangleGeometry, offset) {\r\n        if (defined(offset)) {\r\n            rectangleGeometry = RectangleGeometry.unpack(rectangleGeometry, offset);\r\n        }\r\n        rectangleGeometry._ellipsoid = Ellipsoid.clone(rectangleGeometry._ellipsoid);\r\n        rectangleGeometry._rectangle = Rectangle.clone(rectangleGeometry._rectangle);\r\n        return RectangleGeometry.createGeometry(rectangleGeometry);\r\n    }\r\nexport default createRectangleGeometry;\r\n"],"names":["positionScratch","Cartesian3","normalScratch","tangentScratch","bitangentScratch","rectangleScratch","Rectangle","stScratch","Cartesian2","bottomBoundingSphere","BoundingSphere","topBoundingSphere","createAttributes","vertexFormat","attributes","geo","Geometry","GeometryAttributes","primitiveType","PrimitiveType","TRIANGLES","position","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","positions","normal","FLOAT","normals","tangent","tangents","bitangent","bitangents","v1Scratch","v2Scratch","constructRectangle","rectangleGeometry","computedOptions","_vertexFormat","ellipsoid","_ellipsoid","height","width","northCap","southCap","rowStart","rowEnd","rowHeight","size","Float64Array","undefined","textureCoordinates","Float32Array","posIndex","stIndex","st","minX","Number","MAX_VALUE","minY","maxX","maxY","row","col","RectangleGeometryLibrary","computePosition","x","y","z","Math","min","max","k","length","tangentRotationMatrix","attrIndex","i","p","fromArray","attrIndex1","attrIndex2","geodeticSurfaceNormal","cross","UNIT_Z","Matrix3","multiplyByVector","normalize","calculateAttributes","indicesSize","indices","IndexDatatype","createTypedArray","index","indicesIndex","j","upperLeft","lowerLeft","lowerRight","upperRight","p1","p2","northIndex","southIndex","addWallPositions","wallPositions","topPositions","bottomPositions","addWallTextureCoordinates","wallTextures","scratchVertexFormat","VertexFormat","constructExtrudedRectangle","shadowVolume","_shadowVolume","offsetAttributeValue","_offsetAttribute","minHeight","_extrudedHeight","maxHeight","_surfaceHeight","newVertexFormat","clone","topBottomGeo","PolygonPipeline","scaleToGeodeticHeight","newLength","set","topSt","topNormals","offsetValue","textures","extrudeNormals","extrudeDirection","hasOffsets","defined","offsetAttribute","Uint8Array","GeometryOffsetAttribute","TOP","arrayFill","NONE","applyOffset","UNSIGNED_BYTE","topTangents","topBitangents","indicesLength","posLength","newIndices","widthMultiplier","perimeterPositions","corners","dupliateCorners","wallCount","wallExtrudeNormals","wallOffsetAttribute","computeTopOffsets","ALL","threeI","extrudeNormalIndex","wallOffsetIndex","area","normalIndex","tangentIndex","bitangentIndex","recomputeNormal","subtract","equalsEpsilon","CesiumMath","EPSILON10","calculateAttributesWall","wallIndices","GeometryPipeline","combineInstances","GeometryInstance","geometry","scratchRectanglePoints","nwScratch","Cartographic","stNwScratch","computeRectangle","rectangle","granularity","rotation","result","computeOptions","fromCartesianArray","RectangleGeometry","options","defaultValue","EMPTY_OBJECT","Check","typeOf","object","validate","north","south","DeveloperError","extrudedHeight","this","_rectangle","_granularity","RADIANS_PER_DEGREE","Ellipsoid","WGS84","_rotation","_stRotation","stRotation","DEFAULT","_workerName","_rotatedRectangle","_textureCoordinateRotationPoints","packedLength","pack","value","array","startingIndex","scratchRectangle","scratchEllipsoid","UNIT_SPHERE","scratchOptions","unpack","surfaceHeight","tangentRotationMatrixScratch","quaternionScratch","Quaternion","centerScratch","createGeometry","east","west","center","axis","geodeticSurfaceNormalCartographic","fromAxisAngle","fromQuaternion","IDENTITY","boundingSphere","extrude","EPSILON2","lonScalar","latScalar","topBS","fromRectangle3D","bottomBS","union","createShadowVolume","minHeightFunc","maxHeightFunc","POSITION_ONLY","unrotatedTextureRectangleScratch","points2DScratch","rotation2DScratch","Matrix2","rectangleCenterScratch","Object","defineProperties","prototype","get","textureCoordinateRotationPoints","unrotatedTextureRectangle","points2D","boundingRectangle","toDesiredInComputed","fromRotation","boundingRectangleCenter","point2D","longitude","latitude","minXYCorner","maxYCorner","maxXCorner","Array","offset"],"mappings":"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"}