{"version":3,"file":"createGroundPolylineGeometry.js","sources":["../../../../Source/Core/GeographicTilingScheme.js","../../../../Source/Core/ApproximateTerrainHeights.js","../../../../Source/Core/GroundPolylineGeometry.js","../../../../Source/WorkersES6/createGroundPolylineGeometry.js"],"sourcesContent":["import Cartesian2 from './Cartesian2.js';\r\nimport Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport GeographicProjection from './GeographicProjection.js';\r\nimport CesiumMath from './Math.js';\r\nimport Rectangle from './Rectangle.js';\r\n\r\n    /**\r\n     * A tiling scheme for geometry referenced to a simple {@link GeographicProjection} where\r\n     * longitude and latitude are directly mapped to X and Y.  This projection is commonly\r\n     * known as geographic, equirectangular, equidistant cylindrical, or plate carr√©e.\r\n     *\r\n     * @alias GeographicTilingScheme\r\n     * @constructor\r\n     *\r\n     * @param {Object} [options] Object with the following properties:\r\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid whose surface is being tiled. Defaults to\r\n     * the WGS84 ellipsoid.\r\n     * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the tiling scheme.\r\n     * @param {Number} [options.numberOfLevelZeroTilesX=2] The number of tiles in the X direction at level zero of\r\n     * the tile tree.\r\n     * @param {Number} [options.numberOfLevelZeroTilesY=1] The number of tiles in the Y direction at level zero of\r\n     * the tile tree.\r\n     */\r\n    function GeographicTilingScheme(options) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n        this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n        this._rectangle = defaultValue(options.rectangle, Rectangle.MAX_VALUE);\r\n        this._projection = new GeographicProjection(this._ellipsoid);\r\n        this._numberOfLevelZeroTilesX = defaultValue(options.numberOfLevelZeroTilesX, 2);\r\n        this._numberOfLevelZeroTilesY = defaultValue(options.numberOfLevelZeroTilesY, 1);\r\n    }\r\n\r\n    Object.defineProperties(GeographicTilingScheme.prototype, {\r\n        /**\r\n         * Gets the ellipsoid that is tiled by this tiling scheme.\r\n         * @memberof GeographicTilingScheme.prototype\r\n         * @type {Ellipsoid}\r\n         */\r\n        ellipsoid : {\r\n            get : function() {\r\n                return this._ellipsoid;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Gets the rectangle, in radians, covered by this tiling scheme.\r\n         * @memberof GeographicTilingScheme.prototype\r\n         * @type {Rectangle}\r\n         */\r\n        rectangle : {\r\n            get : function() {\r\n                return this._rectangle;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Gets the map projection used by this tiling scheme.\r\n         * @memberof GeographicTilingScheme.prototype\r\n         * @type {MapProjection}\r\n         */\r\n        projection : {\r\n            get : function() {\r\n                return this._projection;\r\n            }\r\n        }\r\n    });\r\n\r\n    /**\r\n     * Gets the total number of tiles in the X direction at a specified level-of-detail.\r\n     *\r\n     * @param {Number} level The level-of-detail.\r\n     * @returns {Number} The number of tiles in the X direction at the given level.\r\n     */\r\n    GeographicTilingScheme.prototype.getNumberOfXTilesAtLevel = function(level) {\r\n        return this._numberOfLevelZeroTilesX << level;\r\n    };\r\n\r\n    /**\r\n     * Gets the total number of tiles in the Y direction at a specified level-of-detail.\r\n     *\r\n     * @param {Number} level The level-of-detail.\r\n     * @returns {Number} The number of tiles in the Y direction at the given level.\r\n     */\r\n    GeographicTilingScheme.prototype.getNumberOfYTilesAtLevel = function(level) {\r\n        return this._numberOfLevelZeroTilesY << level;\r\n    };\r\n\r\n    /**\r\n     * Transforms a rectangle specified in geodetic radians to the native coordinate system\r\n     * of this tiling scheme.\r\n     *\r\n     * @param {Rectangle} rectangle The rectangle to transform.\r\n     * @param {Rectangle} [result] The instance to which to copy the result, or undefined if a new instance\r\n     *        should be created.\r\n     * @returns {Rectangle} The specified 'result', or a new object containing the native rectangle if 'result'\r\n     *          is undefined.\r\n     */\r\n    GeographicTilingScheme.prototype.rectangleToNativeRectangle = function(rectangle, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('rectangle', rectangle);\r\n        //>>includeEnd('debug');\r\n\r\n        var west = CesiumMath.toDegrees(rectangle.west);\r\n        var south = CesiumMath.toDegrees(rectangle.south);\r\n        var east = CesiumMath.toDegrees(rectangle.east);\r\n        var north = CesiumMath.toDegrees(rectangle.north);\r\n\r\n        if (!defined(result)) {\r\n            return new Rectangle(west, south, east, north);\r\n        }\r\n\r\n        result.west = west;\r\n        result.south = south;\r\n        result.east = east;\r\n        result.north = north;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Converts tile x, y coordinates and level to a rectangle expressed in the native coordinates\r\n     * of the tiling scheme.\r\n     *\r\n     * @param {Number} x The integer x coordinate of the tile.\r\n     * @param {Number} y The integer y coordinate of the tile.\r\n     * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\r\n     * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance\r\n     *        should be created.\r\n     * @returns {Rectangle} The specified 'result', or a new object containing the rectangle\r\n     *          if 'result' is undefined.\r\n     */\r\n    GeographicTilingScheme.prototype.tileXYToNativeRectangle = function(x, y, level, result) {\r\n        var rectangleRadians = this.tileXYToRectangle(x, y, level, result);\r\n        rectangleRadians.west = CesiumMath.toDegrees(rectangleRadians.west);\r\n        rectangleRadians.south = CesiumMath.toDegrees(rectangleRadians.south);\r\n        rectangleRadians.east = CesiumMath.toDegrees(rectangleRadians.east);\r\n        rectangleRadians.north = CesiumMath.toDegrees(rectangleRadians.north);\r\n        return rectangleRadians;\r\n    };\r\n\r\n    /**\r\n     * Converts tile x, y coordinates and level to a cartographic rectangle in radians.\r\n     *\r\n     * @param {Number} x The integer x coordinate of the tile.\r\n     * @param {Number} y The integer y coordinate of the tile.\r\n     * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\r\n     * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance\r\n     *        should be created.\r\n     * @returns {Rectangle} The specified 'result', or a new object containing the rectangle\r\n     *          if 'result' is undefined.\r\n     */\r\n    GeographicTilingScheme.prototype.tileXYToRectangle = function(x, y, level, result) {\r\n        var rectangle = this._rectangle;\r\n\r\n        var xTiles = this.getNumberOfXTilesAtLevel(level);\r\n        var yTiles = this.getNumberOfYTilesAtLevel(level);\r\n\r\n        var xTileWidth = rectangle.width / xTiles;\r\n        var west = x * xTileWidth + rectangle.west;\r\n        var east = (x + 1) * xTileWidth + rectangle.west;\r\n\r\n        var yTileHeight = rectangle.height / yTiles;\r\n        var north = rectangle.north - y * yTileHeight;\r\n        var south = rectangle.north - (y + 1) * yTileHeight;\r\n\r\n        if (!defined(result)) {\r\n            result = new Rectangle(west, south, east, north);\r\n        }\r\n\r\n        result.west = west;\r\n        result.south = south;\r\n        result.east = east;\r\n        result.north = north;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Calculates the tile x, y coordinates of the tile containing\r\n     * a given cartographic position.\r\n     *\r\n     * @param {Cartographic} position The position.\r\n     * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\r\n     * @param {Cartesian2} [result] The instance to which to copy the result, or undefined if a new instance\r\n     *        should be created.\r\n     * @returns {Cartesian2} The specified 'result', or a new object containing the tile x, y coordinates\r\n     *          if 'result' is undefined.\r\n     */\r\n    GeographicTilingScheme.prototype.positionToTileXY = function(position, level, result) {\r\n        var rectangle = this._rectangle;\r\n        if (!Rectangle.contains(rectangle, position)) {\r\n            // outside the bounds of the tiling scheme\r\n            return undefined;\r\n        }\r\n\r\n        var xTiles = this.getNumberOfXTilesAtLevel(level);\r\n        var yTiles = this.getNumberOfYTilesAtLevel(level);\r\n\r\n        var xTileWidth = rectangle.width / xTiles;\r\n        var yTileHeight = rectangle.height / yTiles;\r\n\r\n        var longitude = position.longitude;\r\n        if (rectangle.east < rectangle.west) {\r\n            longitude += CesiumMath.TWO_PI;\r\n        }\r\n\r\n        var xTileCoordinate = (longitude - rectangle.west) / xTileWidth | 0;\r\n        if (xTileCoordinate >= xTiles) {\r\n            xTileCoordinate = xTiles - 1;\r\n        }\r\n\r\n        var yTileCoordinate = (rectangle.north - position.latitude) / yTileHeight | 0;\r\n        if (yTileCoordinate >= yTiles) {\r\n            yTileCoordinate = yTiles - 1;\r\n        }\r\n\r\n        if (!defined(result)) {\r\n            return new Cartesian2(xTileCoordinate, yTileCoordinate);\r\n        }\r\n\r\n        result.x = xTileCoordinate;\r\n        result.y = yTileCoordinate;\r\n        return result;\r\n    };\r\nexport default GeographicTilingScheme;\r\n","import BoundingSphere from './BoundingSphere.js';\r\nimport buildModuleUrl from './buildModuleUrl.js';\r\nimport Cartesian2 from './Cartesian2.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport Cartographic from './Cartographic.js';\r\nimport Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport GeographicTilingScheme from './GeographicTilingScheme.js';\r\nimport Rectangle from './Rectangle.js';\r\nimport Resource from './Resource.js';\r\n\r\n    var scratchDiagonalCartesianNE = new Cartesian3();\r\n    var scratchDiagonalCartesianSW = new Cartesian3();\r\n    var scratchDiagonalCartographic = new Cartographic();\r\n    var scratchCenterCartesian = new Cartesian3();\r\n    var scratchSurfaceCartesian = new Cartesian3();\r\n\r\n    var scratchBoundingSphere = new BoundingSphere();\r\n    var tilingScheme = new GeographicTilingScheme();\r\n    var scratchCorners = [new Cartographic(), new Cartographic(), new Cartographic(), new Cartographic()];\r\n    var scratchTileXY = new Cartesian2();\r\n\r\n    /**\r\n     * A collection of functions for approximating terrain height\r\n     * @private\r\n     */\r\n    var ApproximateTerrainHeights = {};\r\n\r\n    /**\r\n     * Initializes the minimum and maximum terrain heights\r\n     * @return {Promise}\r\n     */\r\n    ApproximateTerrainHeights.initialize = function() {\r\n        var initPromise = ApproximateTerrainHeights._initPromise;\r\n        if (defined(initPromise)) {\r\n            return initPromise;\r\n        }\r\n\r\n        initPromise = Resource.fetchJson(buildModuleUrl('Assets/approximateTerrainHeights.json'))\r\n            .then(function(json) {\r\n                ApproximateTerrainHeights._terrainHeights = json;\r\n            });\r\n        ApproximateTerrainHeights._initPromise = initPromise;\r\n\r\n        return initPromise;\r\n    };\r\n\r\n    /**\r\n     * Computes the minimum and maximum terrain heights for a given rectangle\r\n     * @param {Rectangle} rectangle The bounding rectangle\r\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid\r\n     * @return {{minimumTerrainHeight: Number, maximumTerrainHeight: Number}}\r\n     */\r\n    ApproximateTerrainHeights.getMinimumMaximumHeights = function(rectangle, ellipsoid) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('rectangle', rectangle);\r\n        if (!defined(ApproximateTerrainHeights._terrainHeights)) {\r\n            throw new DeveloperError('You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function');\r\n        }\r\n        //>>includeEnd('debug');\r\n        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n\r\n        var xyLevel = getTileXYLevel(rectangle);\r\n\r\n        // Get the terrain min/max for that tile\r\n        var minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\r\n        var maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\r\n        if (defined(xyLevel)) {\r\n            var key = xyLevel.level + '-' + xyLevel.x + '-' + xyLevel.y;\r\n            var heights = ApproximateTerrainHeights._terrainHeights[key];\r\n            if (defined(heights)) {\r\n                minTerrainHeight = heights[0];\r\n                maxTerrainHeight = heights[1];\r\n            }\r\n\r\n            // Compute min by taking the center of the NE->SW diagonal and finding distance to the surface\r\n            ellipsoid.cartographicToCartesian(Rectangle.northeast(rectangle, scratchDiagonalCartographic),\r\n                scratchDiagonalCartesianNE);\r\n            ellipsoid.cartographicToCartesian(Rectangle.southwest(rectangle, scratchDiagonalCartographic),\r\n                scratchDiagonalCartesianSW);\r\n\r\n            Cartesian3.midpoint(scratchDiagonalCartesianSW, scratchDiagonalCartesianNE, scratchCenterCartesian);\r\n            var surfacePosition = ellipsoid.scaleToGeodeticSurface(scratchCenterCartesian, scratchSurfaceCartesian);\r\n            if (defined(surfacePosition)) {\r\n                var distance = Cartesian3.distance(scratchCenterCartesian, surfacePosition);\r\n                minTerrainHeight = Math.min(minTerrainHeight, -distance);\r\n            } else {\r\n                minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\r\n            }\r\n        }\r\n\r\n        minTerrainHeight = Math.max(ApproximateTerrainHeights._defaultMinTerrainHeight, minTerrainHeight);\r\n\r\n        return {\r\n            minimumTerrainHeight: minTerrainHeight,\r\n            maximumTerrainHeight: maxTerrainHeight\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Computes the bounding sphere based on the tile heights in the rectangle\r\n     * @param {Rectangle} rectangle The bounding rectangle\r\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid\r\n     * @return {BoundingSphere} The result bounding sphere\r\n     */\r\n    ApproximateTerrainHeights.getBoundingSphere = function(rectangle, ellipsoid) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('rectangle', rectangle);\r\n        if (!defined(ApproximateTerrainHeights._terrainHeights)) {\r\n            throw new DeveloperError('You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function');\r\n        }\r\n        //>>includeEnd('debug');\r\n        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n\r\n        var xyLevel = getTileXYLevel(rectangle);\r\n\r\n        // Get the terrain max for that tile\r\n        var maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\r\n        if (defined(xyLevel)) {\r\n            var key = xyLevel.level + '-' + xyLevel.x + '-' + xyLevel.y;\r\n            var heights = ApproximateTerrainHeights._terrainHeights[key];\r\n            if (defined(heights)) {\r\n                maxTerrainHeight = heights[1];\r\n            }\r\n        }\r\n\r\n        var result = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, 0.0);\r\n        BoundingSphere.fromRectangle3D(rectangle, ellipsoid, maxTerrainHeight, scratchBoundingSphere);\r\n\r\n        return BoundingSphere.union(result, scratchBoundingSphere, result);\r\n    };\r\n\r\n    function getTileXYLevel(rectangle) {\r\n        Cartographic.fromRadians(rectangle.east, rectangle.north, 0.0, scratchCorners[0]);\r\n        Cartographic.fromRadians(rectangle.west, rectangle.north, 0.0, scratchCorners[1]);\r\n        Cartographic.fromRadians(rectangle.east, rectangle.south, 0.0, scratchCorners[2]);\r\n        Cartographic.fromRadians(rectangle.west, rectangle.south, 0.0, scratchCorners[3]);\r\n\r\n        // Determine which tile the bounding rectangle is in\r\n        var lastLevelX = 0, lastLevelY = 0;\r\n        var currentX = 0, currentY = 0;\r\n        var maxLevel = ApproximateTerrainHeights._terrainHeightsMaxLevel;\r\n        var i;\r\n        for(i = 0; i <= maxLevel; ++i) {\r\n            var failed = false;\r\n            for(var j = 0; j < 4; ++j) {\r\n                var corner = scratchCorners[j];\r\n                tilingScheme.positionToTileXY(corner, i, scratchTileXY);\r\n                if (j === 0) {\r\n                    currentX = scratchTileXY.x;\r\n                    currentY = scratchTileXY.y;\r\n                } else if(currentX !== scratchTileXY.x || currentY !== scratchTileXY.y) {\r\n                    failed = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (failed) {\r\n                break;\r\n            }\r\n\r\n            lastLevelX = currentX;\r\n            lastLevelY = currentY;\r\n        }\r\n\r\n        if (i === 0) {\r\n            return undefined;\r\n        }\r\n\r\n        return {\r\n            x : lastLevelX,\r\n            y : lastLevelY,\r\n            level : (i > maxLevel) ? maxLevel : (i - 1)\r\n        };\r\n    }\r\n\r\n    ApproximateTerrainHeights._terrainHeightsMaxLevel = 6;\r\n    ApproximateTerrainHeights._defaultMaxTerrainHeight = 9000.0;\r\n    ApproximateTerrainHeights._defaultMinTerrainHeight = -100000.0;\r\n    ApproximateTerrainHeights._terrainHeights = undefined;\r\n    ApproximateTerrainHeights._initPromise = undefined;\r\n\r\n    Object.defineProperties(ApproximateTerrainHeights, {\r\n        /**\r\n         * Determines if the terrain heights are initialized and ready to use. To initialize the terrain heights,\r\n         * call {@link ApproximateTerrainHeights#initialize} and wait for the returned promise to resolve.\r\n         * @type {Boolean}\r\n         * @readonly\r\n         * @memberof ApproximateTerrainHeights\r\n         */\r\n        initialized: {\r\n            get: function() {\r\n                return defined(ApproximateTerrainHeights._terrainHeights);\r\n            }\r\n        }\r\n    });\r\nexport default ApproximateTerrainHeights;\r\n","import ApproximateTerrainHeights from './ApproximateTerrainHeights.js';\r\nimport ArcType from './ArcType.js';\r\nimport arrayRemoveDuplicates from './arrayRemoveDuplicates.js';\r\nimport BoundingSphere from './BoundingSphere.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport Cartographic from './Cartographic.js';\r\nimport Check from './Check.js';\r\nimport ComponentDatatype from './ComponentDatatype.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport EllipsoidGeodesic from './EllipsoidGeodesic.js';\r\nimport EllipsoidRhumbLine from './EllipsoidRhumbLine.js';\r\nimport EncodedCartesian3 from './EncodedCartesian3.js';\r\nimport GeographicProjection from './GeographicProjection.js';\r\nimport Geometry from './Geometry.js';\r\nimport GeometryAttribute from './GeometryAttribute.js';\r\nimport IntersectionTests from './IntersectionTests.js';\r\nimport CesiumMath from './Math.js';\r\nimport Matrix3 from './Matrix3.js';\r\nimport Plane from './Plane.js';\r\nimport Quaternion from './Quaternion.js';\r\nimport Rectangle from './Rectangle.js';\r\nimport WebMercatorProjection from './WebMercatorProjection.js';\r\n\r\n    var PROJECTIONS = [GeographicProjection, WebMercatorProjection];\r\n    var PROJECTION_COUNT = PROJECTIONS.length;\r\n\r\n    var MITER_BREAK_SMALL = Math.cos(CesiumMath.toRadians(30.0));\r\n    var MITER_BREAK_LARGE = Math.cos(CesiumMath.toRadians(150.0));\r\n\r\n    // Initial heights for constructing the wall.\r\n    // Keeping WALL_INITIAL_MIN_HEIGHT near the ellipsoid surface helps\r\n    // prevent precision problems with planes in the shader.\r\n    // Putting the start point of a plane at ApproximateTerrainHeights._defaultMinTerrainHeight,\r\n    // which is a highly conservative bound, usually puts the plane origin several thousands\r\n    // of meters away from the actual terrain, causing floating point problems when checking\r\n    // fragments on terrain against the plane.\r\n    // Ellipsoid height is generally much closer.\r\n    // The initial max height is arbitrary.\r\n    // Both heights are corrected using ApproximateTerrainHeights for computing the actual volume geometry.\r\n    var WALL_INITIAL_MIN_HEIGHT = 0.0;\r\n    var WALL_INITIAL_MAX_HEIGHT = 1000.0;\r\n\r\n    /**\r\n     * A description of a polyline on terrain or 3D Tiles. Only to be used with {@link GroundPolylinePrimitive}.\r\n     *\r\n     * @alias GroundPolylineGeometry\r\n     * @constructor\r\n     *\r\n     * @param {Object} options Options with the following properties:\r\n     * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the polyline's points. Heights above the ellipsoid will be ignored.\r\n     * @param {Number} [options.width=1.0] The screen space width in pixels.\r\n     * @param {Number} [options.granularity=9999.0] The distance interval in meters used for interpolating options.points. Defaults to 9999.0 meters. Zero indicates no interpolation.\r\n     * @param {Boolean} [options.loop=false] Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.\r\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\r\n     *\r\n     * @exception {DeveloperError} At least two positions are required.\r\n     *\r\n     * @see GroundPolylinePrimitive\r\n     *\r\n     * @example\r\n     * var positions = Cesium.Cartesian3.fromDegreesArray([\r\n     *   -112.1340164450331, 36.05494287836128,\r\n     *   -112.08821010582645, 36.097804071380715,\r\n     *   -112.13296079730024, 36.168769146801104\r\n     * ]);\r\n     *\r\n     * var geometry = new Cesium.GroundPolylineGeometry({\r\n     *   positions : positions\r\n     * });\r\n     */\r\n    function GroundPolylineGeometry(options) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n        var positions = options.positions;\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if ((!defined(positions)) || (positions.length < 2)) {\r\n            throw new DeveloperError('At least two positions are required.');\r\n        }\r\n        if (defined(options.arcType) && options.arcType !== ArcType.GEODESIC && options.arcType !== ArcType.RHUMB) {\r\n            throw new DeveloperError('Valid options for arcType are ArcType.GEODESIC and ArcType.RHUMB.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        /**\r\n         * The screen space width in pixels.\r\n         * @type {Number}\r\n         */\r\n        this.width = defaultValue(options.width, 1.0); // Doesn't get packed, not necessary for computing geometry.\r\n\r\n        this._positions = positions;\r\n\r\n        /**\r\n         * The distance interval used for interpolating options.points. Zero indicates no interpolation.\r\n         * Default of 9999.0 allows centimeter accuracy with 32 bit floating point.\r\n         * @type {Boolean}\r\n         * @default 9999.0\r\n         */\r\n        this.granularity = defaultValue(options.granularity, 9999.0);\r\n\r\n        /**\r\n         * Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.\r\n         * If the geometry has two positions this parameter will be ignored.\r\n         * @type {Boolean}\r\n         * @default false\r\n         */\r\n        this.loop = defaultValue(options.loop, false);\r\n\r\n        /**\r\n         * The type of path the polyline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\r\n         * @type {ArcType}\r\n         * @default ArcType.GEODESIC\r\n         */\r\n        this.arcType = defaultValue(options.arcType, ArcType.GEODESIC);\r\n\r\n        this._ellipsoid = Ellipsoid.WGS84;\r\n\r\n        // MapProjections can't be packed, so store the index to a known MapProjection.\r\n        this._projectionIndex = 0;\r\n        this._workerName = 'createGroundPolylineGeometry';\r\n\r\n        // Used by GroundPolylinePrimitive to signal worker that scenemode is 3D only.\r\n        this._scene3DOnly = false;\r\n    }\r\n\r\n    Object.defineProperties(GroundPolylineGeometry.prototype, {\r\n        /**\r\n         * The number of elements used to pack the object into an array.\r\n         * @memberof GroundPolylineGeometry.prototype\r\n         * @type {Number}\r\n         * @readonly\r\n         * @private\r\n         */\r\n        packedLength: {\r\n            get: function() {\r\n                return 1.0 + this._positions.length * 3 + 1.0 + 1.0 + 1.0 + Ellipsoid.packedLength + 1.0 + 1.0;\r\n            }\r\n        }\r\n    });\r\n\r\n    /**\r\n     * Set the GroundPolylineGeometry's projection and ellipsoid.\r\n     * Used by GroundPolylinePrimitive to signal scene information to the geometry for generating 2D attributes.\r\n     *\r\n     * @param {GroundPolylineGeometry} groundPolylineGeometry GroundPolylinGeometry describing a polyline on terrain or 3D Tiles.\r\n     * @param {Projection} mapProjection A MapProjection used for projecting cartographic coordinates to 2D.\r\n     * @private\r\n     */\r\n    GroundPolylineGeometry.setProjectionAndEllipsoid = function(groundPolylineGeometry, mapProjection) {\r\n        var projectionIndex = 0;\r\n        for (var i = 0; i < PROJECTION_COUNT; i++) {\r\n            if (mapProjection instanceof PROJECTIONS[i]) {\r\n                projectionIndex = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        groundPolylineGeometry._projectionIndex = projectionIndex;\r\n        groundPolylineGeometry._ellipsoid = mapProjection.ellipsoid;\r\n    };\r\n\r\n    var cart3Scratch1 = new Cartesian3();\r\n    var cart3Scratch2 = new Cartesian3();\r\n    var cart3Scratch3 = new Cartesian3();\r\n    function computeRightNormal(start, end, maxHeight, ellipsoid, result) {\r\n        var startBottom = getPosition(ellipsoid, start, 0.0, cart3Scratch1);\r\n        var startTop = getPosition(ellipsoid, start, maxHeight, cart3Scratch2);\r\n        var endBottom = getPosition(ellipsoid, end, 0.0, cart3Scratch3);\r\n\r\n        var up = direction(startTop, startBottom, cart3Scratch2);\r\n        var forward = direction(endBottom, startBottom, cart3Scratch3);\r\n\r\n        Cartesian3.cross(forward, up, result);\r\n        return Cartesian3.normalize(result, result);\r\n    }\r\n\r\n    var interpolatedCartographicScratch = new Cartographic();\r\n    var interpolatedBottomScratch = new Cartesian3();\r\n    var interpolatedTopScratch = new Cartesian3();\r\n    var interpolatedNormalScratch = new Cartesian3();\r\n    function interpolateSegment(start, end, minHeight, maxHeight, granularity, arcType, ellipsoid, normalsArray, bottomPositionsArray, topPositionsArray, cartographicsArray) {\r\n        if (granularity === 0.0) {\r\n            return;\r\n        }\r\n\r\n        var ellipsoidLine;\r\n        if (arcType === ArcType.GEODESIC) {\r\n            ellipsoidLine = new EllipsoidGeodesic(start, end, ellipsoid);\r\n        } else if (arcType === ArcType.RHUMB) {\r\n            ellipsoidLine = new EllipsoidRhumbLine(start, end, ellipsoid);\r\n        }\r\n\r\n        var surfaceDistance = ellipsoidLine.surfaceDistance;\r\n        if (surfaceDistance < granularity) {\r\n            return;\r\n        }\r\n\r\n        // Compute rightwards normal applicable at all interpolated points\r\n        var interpolatedNormal = computeRightNormal(start, end, maxHeight, ellipsoid, interpolatedNormalScratch);\r\n\r\n        var segments = Math.ceil(surfaceDistance / granularity);\r\n        var interpointDistance = surfaceDistance / segments;\r\n        var distanceFromStart = interpointDistance;\r\n        var pointsToAdd = segments - 1;\r\n        var packIndex = normalsArray.length;\r\n        for (var i = 0; i < pointsToAdd; i++) {\r\n            var interpolatedCartographic = ellipsoidLine.interpolateUsingSurfaceDistance(distanceFromStart, interpolatedCartographicScratch);\r\n            var interpolatedBottom = getPosition(ellipsoid, interpolatedCartographic, minHeight, interpolatedBottomScratch);\r\n            var interpolatedTop = getPosition(ellipsoid, interpolatedCartographic, maxHeight, interpolatedTopScratch);\r\n\r\n            Cartesian3.pack(interpolatedNormal, normalsArray, packIndex);\r\n            Cartesian3.pack(interpolatedBottom, bottomPositionsArray, packIndex);\r\n            Cartesian3.pack(interpolatedTop, topPositionsArray, packIndex);\r\n            cartographicsArray.push(interpolatedCartographic.latitude);\r\n            cartographicsArray.push(interpolatedCartographic.longitude);\r\n\r\n            packIndex += 3;\r\n            distanceFromStart += interpointDistance;\r\n        }\r\n    }\r\n\r\n    var heightlessCartographicScratch = new Cartographic();\r\n    function getPosition(ellipsoid, cartographic, height, result) {\r\n        Cartographic.clone(cartographic, heightlessCartographicScratch);\r\n        heightlessCartographicScratch.height = height;\r\n        return Cartographic.toCartesian(heightlessCartographicScratch, ellipsoid, result);\r\n    }\r\n\r\n    /**\r\n     * Stores the provided instance into the provided array.\r\n     *\r\n     * @param {PolygonGeometry} value The value to pack.\r\n     * @param {Number[]} array The array to pack into.\r\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n     *\r\n     * @returns {Number[]} The array that was packed into\r\n     */\r\n    GroundPolylineGeometry.pack = function(value, array, startingIndex) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('value', value);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        var index = defaultValue(startingIndex, 0);\r\n\r\n        var positions = value._positions;\r\n        var positionsLength = positions.length;\r\n\r\n        array[index++] = positionsLength;\r\n\r\n        for (var i = 0; i < positionsLength; ++i) {\r\n            var cartesian = positions[i];\r\n            Cartesian3.pack(cartesian, array, index);\r\n            index += 3;\r\n        }\r\n\r\n        array[index++] = value.granularity;\r\n        array[index++] = value.loop ? 1.0 : 0.0;\r\n        array[index++] = value.arcType;\r\n\r\n        Ellipsoid.pack(value._ellipsoid, array, index);\r\n        index += Ellipsoid.packedLength;\r\n\r\n        array[index++] = value._projectionIndex;\r\n        array[index++] = value._scene3DOnly ? 1.0 : 0.0;\r\n\r\n        return array;\r\n    };\r\n\r\n    /**\r\n     * Retrieves an instance from a packed array.\r\n     *\r\n     * @param {Number[]} array The packed array.\r\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n     * @param {PolygonGeometry} [result] The object into which to store the result.\r\n     */\r\n    GroundPolylineGeometry.unpack = function(array, startingIndex, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        var index = defaultValue(startingIndex, 0);\r\n        var positionsLength = array[index++];\r\n        var positions = new Array(positionsLength);\r\n\r\n        for (var i = 0; i < positionsLength; i++) {\r\n            positions[i] = Cartesian3.unpack(array, index);\r\n            index += 3;\r\n        }\r\n\r\n        var granularity = array[index++];\r\n        var loop = array[index++] === 1.0;\r\n        var arcType = array[index++];\r\n\r\n        var ellipsoid = Ellipsoid.unpack(array, index);\r\n        index += Ellipsoid.packedLength;\r\n\r\n        var projectionIndex = array[index++];\r\n        var scene3DOnly = (array[index++] === 1.0);\r\n\r\n        if (!defined(result)) {\r\n            result = new GroundPolylineGeometry({\r\n                positions : positions\r\n            });\r\n        }\r\n\r\n        result._positions = positions;\r\n        result.granularity = granularity;\r\n        result.loop = loop;\r\n        result.arcType = arcType;\r\n        result._ellipsoid = ellipsoid;\r\n        result._projectionIndex = projectionIndex;\r\n        result._scene3DOnly = scene3DOnly;\r\n\r\n        return result;\r\n    };\r\n\r\n    function direction(target, origin, result) {\r\n        Cartesian3.subtract(target, origin, result);\r\n        Cartesian3.normalize(result, result);\r\n        return result;\r\n    }\r\n\r\n    function tangentDirection(target, origin, up, result) {\r\n        result = direction(target, origin, result);\r\n\r\n        // orthogonalize\r\n        result = Cartesian3.cross(result, up, result);\r\n        result = Cartesian3.normalize(result, result);\r\n        result = Cartesian3.cross(up, result, result);\r\n        return result;\r\n    }\r\n\r\n    var toPreviousScratch = new Cartesian3();\r\n    var toNextScratch = new Cartesian3();\r\n    var forwardScratch = new Cartesian3();\r\n    var vertexUpScratch = new Cartesian3();\r\n    var cosine90 = 0.0;\r\n    var cosine180 = -1.0;\r\n    function computeVertexMiterNormal(previousBottom, vertexBottom, vertexTop, nextBottom, result) {\r\n        var up = direction(vertexTop, vertexBottom, vertexUpScratch);\r\n\r\n        // Compute vectors pointing towards neighboring points but tangent to this point on the ellipsoid\r\n        var toPrevious = tangentDirection(previousBottom, vertexBottom, up, toPreviousScratch);\r\n        var toNext = tangentDirection(nextBottom, vertexBottom, up, toNextScratch);\r\n\r\n        // Check if tangents are almost opposite - if so, no need to miter.\r\n        if (CesiumMath.equalsEpsilon(Cartesian3.dot(toPrevious, toNext), cosine180, CesiumMath.EPSILON5)) {\r\n             result = Cartesian3.cross(up, toPrevious, result);\r\n             result = Cartesian3.normalize(result, result);\r\n             return result;\r\n        }\r\n\r\n        // Average directions to previous and to next in the plane of Up\r\n        result = Cartesian3.add(toNext, toPrevious, result);\r\n        result = Cartesian3.normalize(result, result);\r\n\r\n        // Flip the normal if it isn't pointing roughly bound right (aka if forward is pointing more \"backwards\")\r\n        var forward = Cartesian3.cross(up, result, forwardScratch);\r\n        if (Cartesian3.dot(toNext, forward) < cosine90) {\r\n            result = Cartesian3.negate(result, result);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    var XZ_PLANE = Plane.fromPointNormal(Cartesian3.ZERO, Cartesian3.UNIT_Y);\r\n\r\n    var previousBottomScratch = new Cartesian3();\r\n    var vertexBottomScratch = new Cartesian3();\r\n    var vertexTopScratch = new Cartesian3();\r\n    var nextBottomScratch = new Cartesian3();\r\n    var vertexNormalScratch = new Cartesian3();\r\n    var intersectionScratch = new Cartesian3();\r\n    var cartographicScratch0 = new Cartographic();\r\n    var cartographicScratch1 = new Cartographic();\r\n    var cartographicIntersectionScratch = new Cartographic();\r\n    /**\r\n     * Computes shadow volumes for the ground polyline, consisting of its vertices, indices, and a bounding sphere.\r\n     * Vertices are \"fat,\" packing all the data needed in each volume to describe a line on terrain or 3D Tiles.\r\n     * Should not be called independent of {@link GroundPolylinePrimitive}.\r\n     *\r\n     * @param {GroundPolylineGeometry} groundPolylineGeometry\r\n     * @private\r\n     */\r\n    GroundPolylineGeometry.createGeometry = function(groundPolylineGeometry) {\r\n        var compute2dAttributes = !groundPolylineGeometry._scene3DOnly;\r\n        var loop = groundPolylineGeometry.loop;\r\n        var ellipsoid = groundPolylineGeometry._ellipsoid;\r\n        var granularity = groundPolylineGeometry.granularity;\r\n        var arcType = groundPolylineGeometry.arcType;\r\n        var projection = new PROJECTIONS[groundPolylineGeometry._projectionIndex](ellipsoid);\r\n\r\n        var minHeight = WALL_INITIAL_MIN_HEIGHT;\r\n        var maxHeight = WALL_INITIAL_MAX_HEIGHT;\r\n\r\n        var index;\r\n        var i;\r\n\r\n        var positions = groundPolylineGeometry._positions;\r\n        var positionsLength = positions.length;\r\n\r\n        if (positionsLength === 2) {\r\n            loop = false;\r\n        }\r\n\r\n        // Split positions across the IDL and the Prime Meridian as well.\r\n        // Split across prime meridian because very large geometries crossing the Prime Meridian but not the IDL\r\n        // may get split by the plane of IDL + Prime Meridian.\r\n        var p0;\r\n        var p1;\r\n        var c0;\r\n        var c1;\r\n        var rhumbLine = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\r\n        var intersection;\r\n        var intersectionCartographic;\r\n        var intersectionLongitude;\r\n        var splitPositions = [positions[0]];\r\n        for (i = 0; i < positionsLength - 1; i++) {\r\n            p0 = positions[i];\r\n            p1 = positions[i + 1];\r\n            intersection = IntersectionTests.lineSegmentPlane(p0, p1, XZ_PLANE, intersectionScratch);\r\n            if (defined(intersection) &&\r\n                !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\r\n                !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)) {\r\n                if (groundPolylineGeometry.arcType === ArcType.GEODESIC) {\r\n                    splitPositions.push(Cartesian3.clone(intersection));\r\n                } else if (groundPolylineGeometry.arcType === ArcType.RHUMB) {\r\n                    intersectionLongitude = ellipsoid.cartesianToCartographic(intersection, cartographicScratch0).longitude;\r\n                    c0 = ellipsoid.cartesianToCartographic(p0, cartographicScratch0);\r\n                    c1 = ellipsoid.cartesianToCartographic(p1, cartographicScratch1);\r\n                    rhumbLine.setEndPoints(c0, c1);\r\n                    intersectionCartographic = rhumbLine.findIntersectionWithLongitude(intersectionLongitude, cartographicIntersectionScratch);\r\n                    intersection = ellipsoid.cartographicToCartesian(intersectionCartographic, intersectionScratch);\r\n                    if (defined(intersection) &&\r\n                        !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\r\n                        !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)) {\r\n                        splitPositions.push(Cartesian3.clone(intersection));\r\n                    }\r\n                }\r\n            }\r\n            splitPositions.push(p1);\r\n        }\r\n\r\n        if (loop) {\r\n            p0 = positions[positionsLength - 1];\r\n            p1 = positions[0];\r\n            intersection = IntersectionTests.lineSegmentPlane(p0, p1, XZ_PLANE, intersectionScratch);\r\n            if (defined(intersection) &&\r\n                !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\r\n                !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)) {\r\n                if (groundPolylineGeometry.arcType === ArcType.GEODESIC) {\r\n                    splitPositions.push(Cartesian3.clone(intersection));\r\n                } else if (groundPolylineGeometry.arcType === ArcType.RHUMB) {\r\n                    intersectionLongitude = ellipsoid.cartesianToCartographic(intersection, cartographicScratch0).longitude;\r\n                    c0 = ellipsoid.cartesianToCartographic(p0, cartographicScratch0);\r\n                    c1 = ellipsoid.cartesianToCartographic(p1, cartographicScratch1);\r\n                    rhumbLine.setEndPoints(c0, c1);\r\n                    intersectionCartographic = rhumbLine.findIntersectionWithLongitude(intersectionLongitude, cartographicIntersectionScratch);\r\n                    intersection = ellipsoid.cartographicToCartesian(intersectionCartographic, intersectionScratch);\r\n                    if (defined(intersection) &&\r\n                        !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\r\n                        !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)) {\r\n                        splitPositions.push(Cartesian3.clone(intersection));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        var cartographicsLength = splitPositions.length;\r\n\r\n        var cartographics = new Array(cartographicsLength);\r\n        for (i = 0; i < cartographicsLength; i++) {\r\n            var cartographic = Cartographic.fromCartesian(splitPositions[i], ellipsoid);\r\n            cartographic.height = 0.0;\r\n            cartographics[i] = cartographic;\r\n        }\r\n\r\n        cartographics = arrayRemoveDuplicates(cartographics, Cartographic.equalsEpsilon);\r\n        cartographicsLength = cartographics.length;\r\n\r\n        if (cartographicsLength < 2) {\r\n            return undefined;\r\n        }\r\n\r\n        /**** Build heap-side arrays for positions, interpolated cartographics, and normals from which to compute vertices ****/\r\n        // We build a \"wall\" and then decompose it into separately connected component \"volumes\" because we need a lot\r\n        // of information about the wall. Also, this simplifies interpolation.\r\n        // Convention: \"next\" and \"end\" are locally forward to each segment of the wall,\r\n        // and we are computing normals pointing towards the local right side of the vertices in each segment.\r\n        var cartographicsArray = [];\r\n        var normalsArray = [];\r\n        var bottomPositionsArray = [];\r\n        var topPositionsArray = [];\r\n\r\n        var previousBottom = previousBottomScratch;\r\n        var vertexBottom = vertexBottomScratch;\r\n        var vertexTop = vertexTopScratch;\r\n        var nextBottom = nextBottomScratch;\r\n        var vertexNormal = vertexNormalScratch;\r\n\r\n        // First point - either loop or attach a \"perpendicular\" normal\r\n        var startCartographic = cartographics[0];\r\n        var nextCartographic = cartographics[1];\r\n\r\n        var prestartCartographic = cartographics[cartographicsLength - 1];\r\n        previousBottom = getPosition(ellipsoid, prestartCartographic, minHeight, previousBottom);\r\n        nextBottom = getPosition(ellipsoid, nextCartographic, minHeight, nextBottom);\r\n        vertexBottom = getPosition(ellipsoid, startCartographic, minHeight, vertexBottom);\r\n        vertexTop = getPosition(ellipsoid, startCartographic, maxHeight, vertexTop);\r\n\r\n        if (loop) {\r\n            vertexNormal = computeVertexMiterNormal(previousBottom, vertexBottom, vertexTop, nextBottom, vertexNormal);\r\n        } else {\r\n            vertexNormal = computeRightNormal(startCartographic, nextCartographic, maxHeight, ellipsoid, vertexNormal);\r\n        }\r\n\r\n        Cartesian3.pack(vertexNormal, normalsArray, 0);\r\n        Cartesian3.pack(vertexBottom, bottomPositionsArray, 0);\r\n        Cartesian3.pack(vertexTop, topPositionsArray, 0);\r\n        cartographicsArray.push(startCartographic.latitude);\r\n        cartographicsArray.push(startCartographic.longitude);\r\n\r\n        interpolateSegment(startCartographic, nextCartographic, minHeight, maxHeight, granularity, arcType, ellipsoid, normalsArray, bottomPositionsArray, topPositionsArray, cartographicsArray);\r\n\r\n        // All inbetween points\r\n        for (i = 1; i < cartographicsLength - 1; ++i) {\r\n            previousBottom = Cartesian3.clone(vertexBottom, previousBottom);\r\n            vertexBottom = Cartesian3.clone(nextBottom, vertexBottom);\r\n            var vertexCartographic = cartographics[i];\r\n            getPosition(ellipsoid, vertexCartographic, maxHeight, vertexTop);\r\n            getPosition(ellipsoid, cartographics[i + 1], minHeight, nextBottom);\r\n\r\n            computeVertexMiterNormal(previousBottom, vertexBottom, vertexTop, nextBottom, vertexNormal);\r\n\r\n            index = normalsArray.length;\r\n            Cartesian3.pack(vertexNormal, normalsArray, index);\r\n            Cartesian3.pack(vertexBottom, bottomPositionsArray, index);\r\n            Cartesian3.pack(vertexTop, topPositionsArray, index);\r\n            cartographicsArray.push(vertexCartographic.latitude);\r\n            cartographicsArray.push(vertexCartographic.longitude);\r\n\r\n            interpolateSegment(cartographics[i], cartographics[i + 1], minHeight, maxHeight, granularity, arcType, ellipsoid, normalsArray, bottomPositionsArray, topPositionsArray, cartographicsArray);\r\n        }\r\n\r\n        // Last point - either loop or attach a normal \"perpendicular\" to the wall.\r\n        var endCartographic = cartographics[cartographicsLength - 1];\r\n        var preEndCartographic = cartographics[cartographicsLength - 2];\r\n\r\n        vertexBottom = getPosition(ellipsoid, endCartographic, minHeight, vertexBottom);\r\n        vertexTop = getPosition(ellipsoid, endCartographic, maxHeight, vertexTop);\r\n\r\n        if (loop) {\r\n            var postEndCartographic = cartographics[0];\r\n            previousBottom = getPosition(ellipsoid, preEndCartographic, minHeight, previousBottom);\r\n            nextBottom = getPosition(ellipsoid, postEndCartographic, minHeight, nextBottom);\r\n\r\n            vertexNormal = computeVertexMiterNormal(previousBottom, vertexBottom, vertexTop, nextBottom, vertexNormal);\r\n        } else {\r\n            vertexNormal = computeRightNormal(preEndCartographic, endCartographic, maxHeight, ellipsoid, vertexNormal);\r\n        }\r\n\r\n        index = normalsArray.length;\r\n        Cartesian3.pack(vertexNormal, normalsArray, index);\r\n        Cartesian3.pack(vertexBottom, bottomPositionsArray, index);\r\n        Cartesian3.pack(vertexTop, topPositionsArray, index);\r\n        cartographicsArray.push(endCartographic.latitude);\r\n        cartographicsArray.push(endCartographic.longitude);\r\n\r\n        if (loop) {\r\n            interpolateSegment(endCartographic, startCartographic, minHeight, maxHeight, granularity, arcType, ellipsoid, normalsArray, bottomPositionsArray, topPositionsArray, cartographicsArray);\r\n            index = normalsArray.length;\r\n            for (i = 0; i < 3; ++i) {\r\n                normalsArray[index + i] = normalsArray[i];\r\n                bottomPositionsArray[index + i] = bottomPositionsArray[i];\r\n                topPositionsArray[index + i] = topPositionsArray[i];\r\n            }\r\n            cartographicsArray.push(startCartographic.latitude);\r\n            cartographicsArray.push(startCartographic.longitude);\r\n        }\r\n\r\n        return generateGeometryAttributes(loop, projection, bottomPositionsArray, topPositionsArray, normalsArray, cartographicsArray, compute2dAttributes);\r\n    };\r\n\r\n    // If the end normal angle is too steep compared to the direction of the line segment,\r\n    // \"break\" the miter by rotating the normal 90 degrees around the \"up\" direction at the point\r\n    // For ultra precision we would want to project into a plane, but in practice this is sufficient.\r\n    var lineDirectionScratch = new Cartesian3();\r\n    var matrix3Scratch = new Matrix3();\r\n    var quaternionScratch = new Quaternion();\r\n    function breakMiter(endGeometryNormal, startBottom, endBottom, endTop) {\r\n        var lineDirection = direction(endBottom, startBottom, lineDirectionScratch);\r\n\r\n        var dot = Cartesian3.dot(lineDirection, endGeometryNormal);\r\n        if (dot > MITER_BREAK_SMALL || dot < MITER_BREAK_LARGE) {\r\n            var vertexUp = direction(endTop, endBottom, vertexUpScratch);\r\n            var angle = dot < MITER_BREAK_LARGE ? CesiumMath.PI_OVER_TWO : -CesiumMath.PI_OVER_TWO;\r\n            var quaternion = Quaternion.fromAxisAngle(vertexUp, angle, quaternionScratch);\r\n            var rotationMatrix = Matrix3.fromQuaternion(quaternion, matrix3Scratch);\r\n            Matrix3.multiplyByVector(rotationMatrix, endGeometryNormal, endGeometryNormal);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    var endPosCartographicScratch = new Cartographic();\r\n    var normalStartpointScratch = new Cartesian3();\r\n    var normalEndpointScratch = new Cartesian3();\r\n    function projectNormal(projection, cartographic, normal, projectedPosition, result) {\r\n        var position = Cartographic.toCartesian(cartographic, projection._ellipsoid, normalStartpointScratch);\r\n        var normalEndpoint = Cartesian3.add(position, normal, normalEndpointScratch);\r\n        var flipNormal = false;\r\n\r\n        var ellipsoid = projection._ellipsoid;\r\n        var normalEndpointCartographic = ellipsoid.cartesianToCartographic(normalEndpoint, endPosCartographicScratch);\r\n        // If normal crosses the IDL, go the other way and flip the result.\r\n        // In practice this almost never happens because the cartographic start\r\n        // and end points of each segment are \"nudged\" to be on the same side\r\n        // of the IDL and slightly away from the IDL.\r\n        if (Math.abs(cartographic.longitude - normalEndpointCartographic.longitude) > CesiumMath.PI_OVER_TWO) {\r\n            flipNormal = true;\r\n            normalEndpoint = Cartesian3.subtract(position, normal, normalEndpointScratch);\r\n            normalEndpointCartographic = ellipsoid.cartesianToCartographic(normalEndpoint, endPosCartographicScratch);\r\n        }\r\n\r\n        normalEndpointCartographic.height = 0.0;\r\n        var normalEndpointProjected = projection.project(normalEndpointCartographic, result);\r\n        result = Cartesian3.subtract(normalEndpointProjected, projectedPosition, result);\r\n        result.z = 0.0;\r\n        result = Cartesian3.normalize(result, result);\r\n        if (flipNormal) {\r\n            Cartesian3.negate(result, result);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    var adjustHeightNormalScratch = new Cartesian3();\r\n    var adjustHeightOffsetScratch = new Cartesian3();\r\n    function adjustHeights(bottom, top, minHeight, maxHeight, adjustHeightBottom, adjustHeightTop) {\r\n        // bottom and top should be at WALL_INITIAL_MIN_HEIGHT and WALL_INITIAL_MAX_HEIGHT, respectively\r\n        var adjustHeightNormal = Cartesian3.subtract(top, bottom, adjustHeightNormalScratch);\r\n        Cartesian3.normalize(adjustHeightNormal, adjustHeightNormal);\r\n\r\n        var distanceForBottom = minHeight - WALL_INITIAL_MIN_HEIGHT;\r\n        var adjustHeightOffset = Cartesian3.multiplyByScalar(adjustHeightNormal, distanceForBottom, adjustHeightOffsetScratch);\r\n        Cartesian3.add(bottom, adjustHeightOffset, adjustHeightBottom);\r\n\r\n        var distanceForTop = maxHeight - WALL_INITIAL_MAX_HEIGHT;\r\n        adjustHeightOffset = Cartesian3.multiplyByScalar(adjustHeightNormal, distanceForTop, adjustHeightOffsetScratch);\r\n        Cartesian3.add(top, adjustHeightOffset, adjustHeightTop);\r\n    }\r\n\r\n    var nudgeDirectionScratch = new Cartesian3();\r\n    function nudgeXZ(start, end) {\r\n        var startToXZdistance = Plane.getPointDistance(XZ_PLANE, start);\r\n        var endToXZdistance = Plane.getPointDistance(XZ_PLANE, end);\r\n        var offset = nudgeDirectionScratch;\r\n        // Larger epsilon than what's used in GeometryPipeline, a centimeter in world space\r\n        if (CesiumMath.equalsEpsilon(startToXZdistance, 0.0, CesiumMath.EPSILON2)) {\r\n            offset = direction(end, start, offset);\r\n            Cartesian3.multiplyByScalar(offset, CesiumMath.EPSILON2, offset);\r\n            Cartesian3.add(start, offset, start);\r\n        } else if (CesiumMath.equalsEpsilon(endToXZdistance, 0.0, CesiumMath.EPSILON2)) {\r\n            offset = direction(start, end, offset);\r\n            Cartesian3.multiplyByScalar(offset, CesiumMath.EPSILON2, offset);\r\n            Cartesian3.add(end, offset, end);\r\n        }\r\n    }\r\n\r\n    // \"Nudge\" cartographic coordinates so start and end are on the same side of the IDL.\r\n    // Nudge amounts are tiny, basically just an IDL flip.\r\n    // Only used for 2D/CV.\r\n    function nudgeCartographic(start, end) {\r\n        var absStartLon = Math.abs(start.longitude);\r\n        var absEndLon = Math.abs(end.longitude);\r\n        if (CesiumMath.equalsEpsilon(absStartLon, CesiumMath.PI, CesiumMath.EPSILON11)) {\r\n            var endSign = CesiumMath.sign(end.longitude);\r\n            start.longitude = endSign * (absStartLon - CesiumMath.EPSILON11);\r\n            return 1;\r\n        } else if (CesiumMath.equalsEpsilon(absEndLon, CesiumMath.PI, CesiumMath.EPSILON11)) {\r\n            var startSign = CesiumMath.sign(start.longitude);\r\n            end.longitude = startSign * (absEndLon - CesiumMath.EPSILON11);\r\n            return 2;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    var startCartographicScratch = new Cartographic();\r\n    var endCartographicScratch = new Cartographic();\r\n\r\n    var segmentStartTopScratch = new Cartesian3();\r\n    var segmentEndTopScratch = new Cartesian3();\r\n    var segmentStartBottomScratch = new Cartesian3();\r\n    var segmentEndBottomScratch = new Cartesian3();\r\n    var segmentStartNormalScratch = new Cartesian3();\r\n    var segmentEndNormalScratch = new Cartesian3();\r\n\r\n    var getHeightCartographics = [startCartographicScratch, endCartographicScratch];\r\n    var getHeightRectangleScratch = new Rectangle();\r\n\r\n    var adjustHeightStartTopScratch = new Cartesian3();\r\n    var adjustHeightEndTopScratch = new Cartesian3();\r\n    var adjustHeightStartBottomScratch = new Cartesian3();\r\n    var adjustHeightEndBottomScratch = new Cartesian3();\r\n\r\n    var segmentStart2DScratch = new Cartesian3();\r\n    var segmentEnd2DScratch = new Cartesian3();\r\n    var segmentStartNormal2DScratch = new Cartesian3();\r\n    var segmentEndNormal2DScratch = new Cartesian3();\r\n\r\n    var offsetScratch = new Cartesian3();\r\n    var startUpScratch = new Cartesian3();\r\n    var endUpScratch = new Cartesian3();\r\n    var rightScratch = new Cartesian3();\r\n    var startPlaneNormalScratch = new Cartesian3();\r\n    var endPlaneNormalScratch = new Cartesian3();\r\n    var encodeScratch = new EncodedCartesian3();\r\n\r\n    var encodeScratch2D = new EncodedCartesian3();\r\n    var forwardOffset2DScratch = new Cartesian3();\r\n    var right2DScratch = new Cartesian3();\r\n\r\n    var normalNudgeScratch = new Cartesian3();\r\n\r\n    var scratchBoundingSpheres = [new BoundingSphere(), new BoundingSphere()];\r\n\r\n    // Winding order is reversed so each segment's volume is inside-out\r\n    var REFERENCE_INDICES = [\r\n        0, 2, 1, 0, 3, 2, // right\r\n        0, 7, 3, 0, 4, 7, // start\r\n        0, 5, 4, 0, 1, 5, // bottom\r\n        5, 7, 4, 5, 6, 7, // left\r\n        5, 2, 6, 5, 1, 2, // end\r\n        3, 6, 2, 3, 7, 6 // top\r\n    ];\r\n    var REFERENCE_INDICES_LENGTH = REFERENCE_INDICES.length;\r\n\r\n    // Decompose the \"wall\" into a series of shadow volumes.\r\n    // Each shadow volume's vertices encode a description of the line it contains,\r\n    // including mitering planes at the end points, a plane along the line itself,\r\n    // and attributes for computing length-wise texture coordinates.\r\n    function generateGeometryAttributes(loop, projection, bottomPositionsArray, topPositionsArray, normalsArray, cartographicsArray, compute2dAttributes) {\r\n        var i;\r\n        var index;\r\n        var ellipsoid = projection._ellipsoid;\r\n\r\n        // Each segment will have 8 vertices\r\n        var segmentCount = (bottomPositionsArray.length / 3) - 1;\r\n        var vertexCount = segmentCount * 8;\r\n        var arraySizeVec4 = vertexCount * 4;\r\n        var indexCount = segmentCount * 36;\r\n\r\n        var indices = vertexCount > 65535 ? new Uint32Array(indexCount) : new Uint16Array(indexCount);\r\n        var positionsArray = new Float64Array(vertexCount * 3);\r\n\r\n        var startHiAndForwardOffsetX = new Float32Array(arraySizeVec4);\r\n        var startLoAndForwardOffsetY = new Float32Array(arraySizeVec4);\r\n        var startNormalAndForwardOffsetZ = new Float32Array(arraySizeVec4);\r\n        var endNormalAndTextureCoordinateNormalizationX = new Float32Array(arraySizeVec4);\r\n        var rightNormalAndTextureCoordinateNormalizationY = new Float32Array(arraySizeVec4);\r\n\r\n        var startHiLo2D;\r\n        var offsetAndRight2D;\r\n        var startEndNormals2D;\r\n        var texcoordNormalization2D;\r\n\r\n        if (compute2dAttributes) {\r\n            startHiLo2D = new Float32Array(arraySizeVec4);\r\n            offsetAndRight2D = new Float32Array(arraySizeVec4);\r\n            startEndNormals2D = new Float32Array(arraySizeVec4);\r\n            texcoordNormalization2D = new Float32Array(vertexCount * 2);\r\n        }\r\n\r\n        /*** Compute total lengths for texture coordinate normalization ***/\r\n        // 2D\r\n        var cartographicsLength = cartographicsArray.length / 2;\r\n        var length2D = 0.0;\r\n\r\n        var startCartographic = startCartographicScratch;\r\n        startCartographic.height = 0.0;\r\n        var endCartographic = endCartographicScratch;\r\n        endCartographic.height = 0.0;\r\n\r\n        var segmentStartCartesian = segmentStartTopScratch;\r\n        var segmentEndCartesian = segmentEndTopScratch;\r\n\r\n        if (compute2dAttributes) {\r\n            index = 0;\r\n            for (i = 1; i < cartographicsLength; i++) {\r\n                // Don't clone anything from previous segment b/c possible IDL touch\r\n                startCartographic.latitude = cartographicsArray[index];\r\n                startCartographic.longitude = cartographicsArray[index + 1];\r\n                endCartographic.latitude = cartographicsArray[index + 2];\r\n                endCartographic.longitude = cartographicsArray[index + 3];\r\n\r\n                segmentStartCartesian = projection.project(startCartographic, segmentStartCartesian);\r\n                segmentEndCartesian = projection.project(endCartographic, segmentEndCartesian);\r\n                length2D += Cartesian3.distance(segmentStartCartesian, segmentEndCartesian);\r\n                index += 2;\r\n            }\r\n        }\r\n\r\n        // 3D\r\n        var positionsLength = topPositionsArray.length / 3;\r\n        segmentEndCartesian = Cartesian3.unpack(topPositionsArray, 0, segmentEndCartesian);\r\n        var length3D = 0.0;\r\n\r\n        index = 3;\r\n        for (i = 1; i < positionsLength; i++) {\r\n            segmentStartCartesian = Cartesian3.clone(segmentEndCartesian, segmentStartCartesian);\r\n            segmentEndCartesian = Cartesian3.unpack(topPositionsArray, index, segmentEndCartesian);\r\n            length3D += Cartesian3.distance(segmentStartCartesian, segmentEndCartesian);\r\n            index += 3;\r\n        }\r\n\r\n        /*** Generate segments ***/\r\n        var j;\r\n        index = 3;\r\n        var cartographicsIndex = 0;\r\n        var vec2sWriteIndex = 0;\r\n        var vec3sWriteIndex = 0;\r\n        var vec4sWriteIndex = 0;\r\n        var miterBroken = false;\r\n\r\n        var endBottom = Cartesian3.unpack(bottomPositionsArray, 0, segmentEndBottomScratch);\r\n        var endTop = Cartesian3.unpack(topPositionsArray, 0, segmentEndTopScratch);\r\n        var endGeometryNormal = Cartesian3.unpack(normalsArray, 0, segmentEndNormalScratch);\r\n\r\n        if (loop) {\r\n            var preEndBottom = Cartesian3.unpack(bottomPositionsArray, bottomPositionsArray.length - 6, segmentStartBottomScratch);\r\n            if (breakMiter(endGeometryNormal, preEndBottom, endBottom, endTop)) {\r\n                // Miter broken as if for the last point in the loop, needs to be inverted for first point (clone of endBottom)\r\n                endGeometryNormal = Cartesian3.negate(endGeometryNormal, endGeometryNormal);\r\n            }\r\n        }\r\n\r\n        var lengthSoFar3D = 0.0;\r\n        var lengthSoFar2D = 0.0;\r\n\r\n        // For translating bounding volume\r\n        var sumHeights = 0.0;\r\n\r\n        for (i = 0; i < segmentCount; i++) {\r\n            var startBottom = Cartesian3.clone(endBottom, segmentStartBottomScratch);\r\n            var startTop = Cartesian3.clone(endTop, segmentStartTopScratch);\r\n            var startGeometryNormal = Cartesian3.clone(endGeometryNormal, segmentStartNormalScratch);\r\n\r\n            if (miterBroken) {\r\n                startGeometryNormal = Cartesian3.negate(startGeometryNormal, startGeometryNormal);\r\n            }\r\n\r\n            endBottom = Cartesian3.unpack(bottomPositionsArray, index, segmentEndBottomScratch);\r\n            endTop = Cartesian3.unpack(topPositionsArray, index, segmentEndTopScratch);\r\n            endGeometryNormal = Cartesian3.unpack(normalsArray, index, segmentEndNormalScratch);\r\n\r\n            miterBroken = breakMiter(endGeometryNormal, startBottom, endBottom, endTop);\r\n\r\n            // 2D - don't clone anything from previous segment b/c possible IDL touch\r\n            startCartographic.latitude = cartographicsArray[cartographicsIndex];\r\n            startCartographic.longitude = cartographicsArray[cartographicsIndex + 1];\r\n            endCartographic.latitude = cartographicsArray[cartographicsIndex + 2];\r\n            endCartographic.longitude = cartographicsArray[cartographicsIndex + 3];\r\n            var start2D;\r\n            var end2D;\r\n            var startGeometryNormal2D;\r\n            var endGeometryNormal2D;\r\n\r\n            if (compute2dAttributes) {\r\n                var nudgeResult = nudgeCartographic(startCartographic, endCartographic);\r\n                start2D = projection.project(startCartographic, segmentStart2DScratch);\r\n                end2D = projection.project(endCartographic, segmentEnd2DScratch);\r\n                var direction2D = direction(end2D, start2D, forwardOffset2DScratch);\r\n                direction2D.y = Math.abs(direction2D.y);\r\n\r\n                startGeometryNormal2D = segmentStartNormal2DScratch;\r\n                endGeometryNormal2D = segmentEndNormal2DScratch;\r\n                if (nudgeResult === 0 || Cartesian3.dot(direction2D, Cartesian3.UNIT_Y) > MITER_BREAK_SMALL) {\r\n                    // No nudge - project the original normal\r\n                    // Or, if the line's angle relative to the IDL is very acute,\r\n                    // in which case snapping will produce oddly shaped volumes.\r\n                    startGeometryNormal2D = projectNormal(projection, startCartographic, startGeometryNormal, start2D, segmentStartNormal2DScratch);\r\n                    endGeometryNormal2D = projectNormal(projection, endCartographic, endGeometryNormal, end2D, segmentEndNormal2DScratch);\r\n                } else if (nudgeResult === 1) {\r\n                    // Start is close to IDL - snap start normal to align with IDL\r\n                    endGeometryNormal2D = projectNormal(projection, endCartographic, endGeometryNormal, end2D, segmentEndNormal2DScratch);\r\n                    startGeometryNormal2D.x = 0.0;\r\n                    // If start longitude is negative and end longitude is less negative, relative right is unit -Y\r\n                    // If start longitude is positive and end longitude is less positive, relative right is unit +Y\r\n                    startGeometryNormal2D.y = CesiumMath.sign(startCartographic.longitude - Math.abs(endCartographic.longitude));\r\n                    startGeometryNormal2D.z = 0.0;\r\n                } else {\r\n                    // End is close to IDL - snap end normal to align with IDL\r\n                    startGeometryNormal2D = projectNormal(projection, startCartographic, startGeometryNormal, start2D, segmentStartNormal2DScratch);\r\n                    endGeometryNormal2D.x = 0.0;\r\n                    // If end longitude is negative and start longitude is less negative, relative right is unit Y\r\n                    // If end longitude is positive and start longitude is less positive, relative right is unit -Y\r\n                    endGeometryNormal2D.y = CesiumMath.sign(startCartographic.longitude - endCartographic.longitude);\r\n                    endGeometryNormal2D.z = 0.0;\r\n                }\r\n            }\r\n\r\n            /****************************************\r\n             * Geometry descriptors of a \"line on terrain,\"\r\n             * as opposed to the \"shadow volume used to draw\r\n             * the line on terrain\":\r\n             * - position of start + offset to end\r\n             * - start, end, and right-facing planes\r\n             * - encoded texture coordinate offsets\r\n             ****************************************/\r\n\r\n             /** 3D **/\r\n            var segmentLength3D = Cartesian3.distance(startTop, endTop);\r\n\r\n            var encodedStart = EncodedCartesian3.fromCartesian(startBottom, encodeScratch);\r\n            var forwardOffset = Cartesian3.subtract(endBottom, startBottom, offsetScratch);\r\n            var forward = Cartesian3.normalize(forwardOffset, rightScratch);\r\n\r\n            var startUp = Cartesian3.subtract(startTop, startBottom, startUpScratch);\r\n            startUp = Cartesian3.normalize(startUp, startUp);\r\n            var rightNormal = Cartesian3.cross(forward, startUp, rightScratch);\r\n            rightNormal = Cartesian3.normalize(rightNormal, rightNormal);\r\n\r\n            var startPlaneNormal = Cartesian3.cross(startUp, startGeometryNormal, startPlaneNormalScratch);\r\n            startPlaneNormal = Cartesian3.normalize(startPlaneNormal, startPlaneNormal);\r\n\r\n            var endUp = Cartesian3.subtract(endTop, endBottom, endUpScratch);\r\n            endUp = Cartesian3.normalize(endUp, endUp);\r\n            var endPlaneNormal = Cartesian3.cross(endGeometryNormal, endUp, endPlaneNormalScratch);\r\n            endPlaneNormal = Cartesian3.normalize(endPlaneNormal, endPlaneNormal);\r\n\r\n            var texcoordNormalization3DX = segmentLength3D / length3D;\r\n            var texcoordNormalization3DY = lengthSoFar3D / length3D;\r\n\r\n            /** 2D **/\r\n            var segmentLength2D = 0.0;\r\n            var encodedStart2D;\r\n            var forwardOffset2D;\r\n            var right2D;\r\n            var texcoordNormalization2DX = 0.0;\r\n            var texcoordNormalization2DY = 0.0;\r\n            if (compute2dAttributes) {\r\n                segmentLength2D = Cartesian3.distance(start2D, end2D);\r\n\r\n                encodedStart2D = EncodedCartesian3.fromCartesian(start2D, encodeScratch2D);\r\n                forwardOffset2D = Cartesian3.subtract(end2D, start2D, forwardOffset2DScratch);\r\n\r\n                // Right direction is just forward direction rotated by -90 degrees around Z\r\n                // Similarly with plane normals\r\n                right2D = Cartesian3.normalize(forwardOffset2D, right2DScratch);\r\n                var swap = right2D.x;\r\n                right2D.x = right2D.y;\r\n                right2D.y = -swap;\r\n\r\n                texcoordNormalization2DX = segmentLength2D / length2D;\r\n                texcoordNormalization2DY = lengthSoFar2D / length2D;\r\n            }\r\n            /** Pack **/\r\n            for (j = 0; j < 8; j++) {\r\n                var vec4Index = vec4sWriteIndex + j * 4;\r\n                var vec2Index = vec2sWriteIndex + j * 2;\r\n                var wIndex = vec4Index + 3;\r\n\r\n                // Encode sidedness of vertex relative to right plane in texture coordinate normalization X,\r\n                // whether vertex is top or bottom of volume in sign/magnitude of normalization Y.\r\n                var rightPlaneSide = j < 4 ? 1.0 : -1.0;\r\n                var topBottomSide = (j === 2 || j === 3 || j === 6 || j === 7) ? 1.0 : -1.0;\r\n\r\n                // 3D\r\n                Cartesian3.pack(encodedStart.high, startHiAndForwardOffsetX, vec4Index);\r\n                startHiAndForwardOffsetX[wIndex] = forwardOffset.x;\r\n\r\n                Cartesian3.pack(encodedStart.low, startLoAndForwardOffsetY, vec4Index);\r\n                startLoAndForwardOffsetY[wIndex] = forwardOffset.y;\r\n\r\n                Cartesian3.pack(startPlaneNormal, startNormalAndForwardOffsetZ, vec4Index);\r\n                startNormalAndForwardOffsetZ[wIndex] = forwardOffset.z;\r\n\r\n                Cartesian3.pack(endPlaneNormal, endNormalAndTextureCoordinateNormalizationX, vec4Index);\r\n                endNormalAndTextureCoordinateNormalizationX[wIndex] = texcoordNormalization3DX * rightPlaneSide;\r\n\r\n                Cartesian3.pack(rightNormal, rightNormalAndTextureCoordinateNormalizationY, vec4Index);\r\n\r\n                var texcoordNormalization = texcoordNormalization3DY * topBottomSide;\r\n                if (texcoordNormalization === 0.0 && topBottomSide < 0.0) {\r\n                    texcoordNormalization = 9.0; // some value greater than 1.0\r\n                }\r\n                rightNormalAndTextureCoordinateNormalizationY[wIndex] = texcoordNormalization;\r\n\r\n                // 2D\r\n                if (compute2dAttributes) {\r\n                    startHiLo2D[vec4Index] = encodedStart2D.high.x;\r\n                    startHiLo2D[vec4Index + 1] = encodedStart2D.high.y;\r\n                    startHiLo2D[vec4Index + 2] = encodedStart2D.low.x;\r\n                    startHiLo2D[vec4Index + 3] = encodedStart2D.low.y;\r\n\r\n                    startEndNormals2D[vec4Index] = -startGeometryNormal2D.y;\r\n                    startEndNormals2D[vec4Index + 1] = startGeometryNormal2D.x;\r\n                    startEndNormals2D[vec4Index + 2] = endGeometryNormal2D.y;\r\n                    startEndNormals2D[vec4Index + 3] = -endGeometryNormal2D.x;\r\n\r\n                    offsetAndRight2D[vec4Index] = forwardOffset2D.x;\r\n                    offsetAndRight2D[vec4Index + 1] = forwardOffset2D.y;\r\n                    offsetAndRight2D[vec4Index + 2] = right2D.x;\r\n                    offsetAndRight2D[vec4Index + 3] = right2D.y;\r\n\r\n                    texcoordNormalization2D[vec2Index] = texcoordNormalization2DX * rightPlaneSide;\r\n\r\n                    texcoordNormalization = texcoordNormalization2DY * topBottomSide;\r\n                    if (texcoordNormalization === 0.0 && topBottomSide < 0.0) {\r\n                        texcoordNormalization = 9.0; // some value greater than 1.0\r\n                    }\r\n                    texcoordNormalization2D[vec2Index + 1] = texcoordNormalization;\r\n                }\r\n            }\r\n\r\n            // Adjust height of volume in 3D\r\n            var adjustHeightStartBottom = adjustHeightStartBottomScratch;\r\n            var adjustHeightEndBottom = adjustHeightEndBottomScratch;\r\n            var adjustHeightStartTop = adjustHeightStartTopScratch;\r\n            var adjustHeightEndTop = adjustHeightEndTopScratch;\r\n\r\n            var getHeightsRectangle = Rectangle.fromCartographicArray(getHeightCartographics, getHeightRectangleScratch);\r\n            var minMaxHeights = ApproximateTerrainHeights.getMinimumMaximumHeights(getHeightsRectangle, ellipsoid);\r\n            var minHeight = minMaxHeights.minimumTerrainHeight;\r\n            var maxHeight = minMaxHeights.maximumTerrainHeight;\r\n\r\n            sumHeights += minHeight;\r\n            sumHeights += maxHeight;\r\n\r\n            adjustHeights(startBottom, startTop, minHeight, maxHeight, adjustHeightStartBottom, adjustHeightStartTop);\r\n            adjustHeights(endBottom, endTop, minHeight, maxHeight, adjustHeightEndBottom, adjustHeightEndTop);\r\n\r\n            // Nudge the positions away from the \"polyline\" a little bit to prevent errors in GeometryPipeline\r\n            var normalNudge = Cartesian3.multiplyByScalar(rightNormal, CesiumMath.EPSILON5, normalNudgeScratch);\r\n            Cartesian3.add(adjustHeightStartBottom, normalNudge, adjustHeightStartBottom);\r\n            Cartesian3.add(adjustHeightEndBottom, normalNudge, adjustHeightEndBottom);\r\n            Cartesian3.add(adjustHeightStartTop, normalNudge, adjustHeightStartTop);\r\n            Cartesian3.add(adjustHeightEndTop, normalNudge, adjustHeightEndTop);\r\n\r\n            // If the segment is very close to the XZ plane, nudge the vertices slightly to avoid touching it.\r\n            nudgeXZ(adjustHeightStartBottom, adjustHeightEndBottom);\r\n            nudgeXZ(adjustHeightStartTop, adjustHeightEndTop);\r\n\r\n            Cartesian3.pack(adjustHeightStartBottom, positionsArray, vec3sWriteIndex);\r\n            Cartesian3.pack(adjustHeightEndBottom, positionsArray, vec3sWriteIndex + 3);\r\n            Cartesian3.pack(adjustHeightEndTop, positionsArray, vec3sWriteIndex + 6);\r\n            Cartesian3.pack(adjustHeightStartTop, positionsArray, vec3sWriteIndex + 9);\r\n\r\n            normalNudge = Cartesian3.multiplyByScalar(rightNormal, -2.0 * CesiumMath.EPSILON5, normalNudgeScratch);\r\n            Cartesian3.add(adjustHeightStartBottom, normalNudge, adjustHeightStartBottom);\r\n            Cartesian3.add(adjustHeightEndBottom, normalNudge, adjustHeightEndBottom);\r\n            Cartesian3.add(adjustHeightStartTop, normalNudge, adjustHeightStartTop);\r\n            Cartesian3.add(adjustHeightEndTop, normalNudge, adjustHeightEndTop);\r\n\r\n            nudgeXZ(adjustHeightStartBottom, adjustHeightEndBottom);\r\n            nudgeXZ(adjustHeightStartTop, adjustHeightEndTop);\r\n\r\n            Cartesian3.pack(adjustHeightStartBottom, positionsArray, vec3sWriteIndex + 12);\r\n            Cartesian3.pack(adjustHeightEndBottom, positionsArray, vec3sWriteIndex + 15);\r\n            Cartesian3.pack(adjustHeightEndTop, positionsArray, vec3sWriteIndex + 18);\r\n            Cartesian3.pack(adjustHeightStartTop, positionsArray, vec3sWriteIndex + 21);\r\n\r\n            cartographicsIndex += 2;\r\n            index += 3;\r\n\r\n            vec2sWriteIndex += 16;\r\n            vec3sWriteIndex += 24;\r\n            vec4sWriteIndex += 32;\r\n\r\n            lengthSoFar3D += segmentLength3D;\r\n            lengthSoFar2D += segmentLength2D;\r\n        }\r\n\r\n        index = 0;\r\n        var indexOffset = 0;\r\n        for (i = 0; i < segmentCount; i++) {\r\n            for (j = 0; j < REFERENCE_INDICES_LENGTH; j++) {\r\n                indices[index + j] = REFERENCE_INDICES[j] + indexOffset;\r\n            }\r\n            indexOffset += 8;\r\n            index += REFERENCE_INDICES_LENGTH;\r\n        }\r\n\r\n        var boundingSpheres = scratchBoundingSpheres;\r\n        BoundingSphere.fromVertices(bottomPositionsArray, Cartesian3.ZERO, 3, boundingSpheres[0]);\r\n        BoundingSphere.fromVertices(topPositionsArray, Cartesian3.ZERO, 3, boundingSpheres[1]);\r\n        var boundingSphere = BoundingSphere.fromBoundingSpheres(boundingSpheres);\r\n\r\n        // Adjust bounding sphere height and radius to cover more of the volume\r\n        boundingSphere.radius += sumHeights / (segmentCount * 2.0);\r\n\r\n        var attributes = {\r\n            position : new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.DOUBLE,\r\n                componentsPerAttribute : 3,\r\n                normalize : false,\r\n                values : positionsArray\r\n            }),\r\n            startHiAndForwardOffsetX : getVec4GeometryAttribute(startHiAndForwardOffsetX),\r\n            startLoAndForwardOffsetY : getVec4GeometryAttribute(startLoAndForwardOffsetY),\r\n            startNormalAndForwardOffsetZ : getVec4GeometryAttribute(startNormalAndForwardOffsetZ),\r\n            endNormalAndTextureCoordinateNormalizationX : getVec4GeometryAttribute(endNormalAndTextureCoordinateNormalizationX),\r\n            rightNormalAndTextureCoordinateNormalizationY : getVec4GeometryAttribute(rightNormalAndTextureCoordinateNormalizationY)\r\n        };\r\n\r\n        if (compute2dAttributes) {\r\n            attributes.startHiLo2D = getVec4GeometryAttribute(startHiLo2D);\r\n            attributes.offsetAndRight2D = getVec4GeometryAttribute(offsetAndRight2D);\r\n            attributes.startEndNormals2D = getVec4GeometryAttribute(startEndNormals2D);\r\n            attributes.texcoordNormalization2D = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.FLOAT,\r\n                componentsPerAttribute : 2,\r\n                normalize : false,\r\n                values : texcoordNormalization2D\r\n            });\r\n        }\r\n\r\n        return new Geometry({\r\n            attributes : attributes,\r\n            indices : indices,\r\n            boundingSphere : boundingSphere\r\n        });\r\n    }\r\n\r\n    function getVec4GeometryAttribute(typedArray) {\r\n        return new GeometryAttribute({\r\n            componentDatatype : ComponentDatatype.FLOAT,\r\n            componentsPerAttribute : 4,\r\n            normalize : false,\r\n            values : typedArray\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Approximates an ellipsoid-tangent vector in 2D by projecting the end point into 2D.\r\n     * Exposed for testing.\r\n     *\r\n     * @param {MapProjection} projection Map Projection for projecting coordinates to 2D.\r\n     * @param {Cartographic} cartographic The cartographic origin point of the normal.\r\n     *   Used to check if the normal crosses the IDL during projection.\r\n     * @param {Cartesian3} normal The normal in 3D.\r\n     * @param {Cartesian3} projectedPosition The projected origin point of the normal in 2D.\r\n     * @param {Cartesian3} result Result parameter on which to store the projected normal.\r\n     * @private\r\n     */\r\n    GroundPolylineGeometry._projectNormal = projectNormal;\r\nexport default GroundPolylineGeometry;\r\n","import ApproximateTerrainHeights from '../Core/ApproximateTerrainHeights.js';\r\nimport defined from '../Core/defined.js';\r\nimport GroundPolylineGeometry from '../Core/GroundPolylineGeometry.js';\r\n\r\n    function createGroundPolylineGeometry(groundPolylineGeometry, offset) {\r\n        return ApproximateTerrainHeights.initialize()\r\n            .then(function() {\r\n                if (defined(offset)) {\r\n                    groundPolylineGeometry = GroundPolylineGeometry.unpack(groundPolylineGeometry, offset);\r\n                }\r\n                return GroundPolylineGeometry.createGeometry(groundPolylineGeometry);\r\n            });\r\n    }\r\nexport default createGroundPolylineGeometry;\r\n"],"names":["GeographicTilingScheme","options","defaultValue","EMPTY_OBJECT","this","_ellipsoid","ellipsoid","Ellipsoid","WGS84","_rectangle","rectangle","Rectangle","MAX_VALUE","_projection","GeographicProjection","_numberOfLevelZeroTilesX","numberOfLevelZeroTilesX","_numberOfLevelZeroTilesY","numberOfLevelZeroTilesY","Object","defineProperties","prototype","get","projection","getNumberOfXTilesAtLevel","level","getNumberOfYTilesAtLevel","rectangleToNativeRectangle","result","Check","defined","west","CesiumMath","toDegrees","south","east","north","tileXYToNativeRectangle","x","y","rectangleRadians","tileXYToRectangle","xTiles","yTiles","xTileWidth","width","yTileHeight","height","positionToTileXY","position","contains","longitude","TWO_PI","xTileCoordinate","yTileCoordinate","latitude","Cartesian2","scratchDiagonalCartesianNE","Cartesian3","scratchDiagonalCartesianSW","scratchDiagonalCartographic","Cartographic","scratchCenterCartesian","scratchSurfaceCartesian","scratchBoundingSphere","BoundingSphere","tilingScheme","scratchCorners","scratchTileXY","ApproximateTerrainHeights","getTileXYLevel","fromRadians","i","lastLevelX","lastLevelY","currentX","currentY","maxLevel","_terrainHeightsMaxLevel","failed","j","corner","initialize","initPromise","_initPromise","Resource","fetchJson","buildModuleUrl","then","json","_terrainHeights","getMinimumMaximumHeights","DeveloperError","xyLevel","minTerrainHeight","_defaultMinTerrainHeight","maxTerrainHeight","_defaultMaxTerrainHeight","key","heights","cartographicToCartesian","northeast","southwest","midpoint","surfacePosition","scaleToGeodeticSurface","distance","Math","min","minimumTerrainHeight","max","maximumTerrainHeight","getBoundingSphere","fromRectangle3D","union","undefined","initialized","PROJECTIONS","WebMercatorProjection","PROJECTION_COUNT","length","MITER_BREAK_SMALL","cos","toRadians","MITER_BREAK_LARGE","GroundPolylineGeometry","positions","arcType","ArcType","GEODESIC","RHUMB","_positions","granularity","loop","_projectionIndex","_workerName","_scene3DOnly","packedLength","setProjectionAndEllipsoid","groundPolylineGeometry","mapProjection","projectionIndex","cart3Scratch1","cart3Scratch2","cart3Scratch3","computeRightNormal","start","end","maxHeight","startBottom","getPosition","startTop","endBottom","up","direction","forward","cross","normalize","interpolatedCartographicScratch","interpolatedBottomScratch","interpolatedTopScratch","interpolatedNormalScratch","interpolateSegment","minHeight","normalsArray","bottomPositionsArray","topPositionsArray","cartographicsArray","ellipsoidLine","EllipsoidGeodesic","EllipsoidRhumbLine","surfaceDistance","interpolatedNormal","segments","ceil","interpointDistance","distanceFromStart","pointsToAdd","packIndex","interpolatedCartographic","interpolateUsingSurfaceDistance","interpolatedBottom","interpolatedTop","pack","push","heightlessCartographicScratch","cartographic","clone","toCartesian","target","origin","subtract","tangentDirection","value","array","startingIndex","typeOf","object","index","positionsLength","cartesian","unpack","Array","scene3DOnly","toPreviousScratch","toNextScratch","forwardScratch","vertexUpScratch","computeVertexMiterNormal","previousBottom","vertexBottom","vertexTop","nextBottom","toPrevious","toNext","equalsEpsilon","dot","EPSILON5","add","negate","XZ_PLANE","Plane","fromPointNormal","ZERO","UNIT_Y","previousBottomScratch","vertexBottomScratch","vertexTopScratch","nextBottomScratch","vertexNormalScratch","intersectionScratch","cartographicScratch0","cartographicScratch1","cartographicIntersectionScratch","createGeometry","p0","p1","c0","c1","compute2dAttributes","intersection","intersectionCartographic","intersectionLongitude","rhumbLine","splitPositions","IntersectionTests","lineSegmentPlane","EPSILON7","cartesianToCartographic","setEndPoints","findIntersectionWithLongitude","cartographicsLength","cartographics","fromCartesian","arrayRemoveDuplicates","vertexNormal","startCartographic","nextCartographic","vertexCartographic","endCartographic","preEndCartographic","postEndCartographic","startHiLo2D","offsetAndRight2D","startEndNormals2D","texcoordNormalization2D","segmentCount","vertexCount","arraySizeVec4","indexCount","indices","Uint32Array","Uint16Array","positionsArray","Float64Array","startHiAndForwardOffsetX","Float32Array","startLoAndForwardOffsetY","startNormalAndForwardOffsetZ","endNormalAndTextureCoordinateNormalizationX","rightNormalAndTextureCoordinateNormalizationY","length2D","startCartographicScratch","endCartographicScratch","segmentStartCartesian","segmentStartTopScratch","segmentEndCartesian","segmentEndTopScratch","project","length3D","cartographicsIndex","vec2sWriteIndex","vec3sWriteIndex","vec4sWriteIndex","miterBroken","segmentEndBottomScratch","endTop","endGeometryNormal","segmentEndNormalScratch","preEndBottom","segmentStartBottomScratch","breakMiter","lengthSoFar3D","lengthSoFar2D","sumHeights","start2D","end2D","startGeometryNormal2D","endGeometryNormal2D","startGeometryNormal","segmentStartNormalScratch","nudgeResult","nudgeCartographic","segmentStart2DScratch","direction2D","segmentEnd2DScratch","forwardOffset2DScratch","abs","segmentStartNormal2DScratch","segmentEndNormal2DScratch","projectNormal","sign","z","segmentLength3D","encodedStart","EncodedCartesian3","encodeScratch","forwardOffset","offsetScratch","rightScratch","startUp","startUpScratch","rightNormal","startPlaneNormal","startPlaneNormalScratch","endUp","endUpScratch","endPlaneNormal","endPlaneNormalScratch","encodedStart2D","forwardOffset2D","right2D","texcoordNormalization3DX","texcoordNormalization3DY","segmentLength2D","texcoordNormalization2DX","texcoordNormalization2DY","encodeScratch2D","swap","right2DScratch","vec4Index","vec2Index","wIndex","rightPlaneSide","topBottomSide","high","low","texcoordNormalization","adjustHeightStartBottom","adjustHeightStartBottomScratch","adjustHeightEndBottom","adjustHeightEndBottomScratch","adjustHeightStartTop","adjustHeightStartTopScratch","adjustHeightEndTop","adjustHeightEndTopScratch","getHeightsRectangle","fromCartographicArray","getHeightCartographics","getHeightRectangleScratch","minMaxHeights","adjustHeights","normalNudge","multiplyByScalar","normalNudgeScratch","nudgeXZ","indexOffset","REFERENCE_INDICES_LENGTH","REFERENCE_INDICES","boundingSpheres","scratchBoundingSpheres","fromVertices","boundingSphere","fromBoundingSpheres","radius","attributes","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","getVec4GeometryAttribute","FLOAT","Geometry","generateGeometryAttributes","lineDirectionScratch","matrix3Scratch","Matrix3","quaternionScratch","Quaternion","lineDirection","vertexUp","angle","PI_OVER_TWO","quaternion","fromAxisAngle","rotationMatrix","fromQuaternion","multiplyByVector","endPosCartographicScratch","normalStartpointScratch","normalEndpointScratch","normal","projectedPosition","normalEndpoint","flipNormal","normalEndpointCartographic","normalEndpointProjected","adjustHeightNormalScratch","adjustHeightOffsetScratch","bottom","top","adjustHeightBottom","adjustHeightTop","adjustHeightNormal","distanceForBottom","adjustHeightOffset","distanceForTop","nudgeDirectionScratch","startToXZdistance","getPointDistance","endToXZdistance","offset","EPSILON2","absStartLon","absEndLon","PI","EPSILON11","endSign","startSign","typedArray","_projectNormal"],"mappings":"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"}