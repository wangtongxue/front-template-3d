{"version":3,"file":"IntersectionTests-c6e3245b.js","sources":["../../../../Source/Core/QuadraticRealPolynomial.js","../../../../Source/Core/CubicRealPolynomial.js","../../../../Source/Core/QuarticRealPolynomial.js","../../../../Source/Core/Ray.js","../../../../Source/Core/IntersectionTests.js"],"sourcesContent":["import DeveloperError from './DeveloperError.js';\r\nimport CesiumMath from './Math.js';\r\n\r\n    /**\r\n     * Defines functions for 2nd order polynomial functions of one variable with only real coefficients.\r\n     *\r\n     * @exports QuadraticRealPolynomial\r\n     */\r\n    var QuadraticRealPolynomial = {};\r\n\r\n    /**\r\n     * Provides the discriminant of the quadratic equation from the supplied coefficients.\r\n     *\r\n     * @param {Number} a The coefficient of the 2nd order monomial.\r\n     * @param {Number} b The coefficient of the 1st order monomial.\r\n     * @param {Number} c The coefficient of the 0th order monomial.\r\n     * @returns {Number} The value of the discriminant.\r\n     */\r\n    QuadraticRealPolynomial.computeDiscriminant = function(a, b, c) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (typeof a !== 'number') {\r\n            throw new DeveloperError('a is a required number.');\r\n        }\r\n        if (typeof b !== 'number') {\r\n            throw new DeveloperError('b is a required number.');\r\n        }\r\n        if (typeof c !== 'number') {\r\n            throw new DeveloperError('c is a required number.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var discriminant = b * b - 4.0 * a * c;\r\n        return discriminant;\r\n    };\r\n\r\n    function addWithCancellationCheck(left, right, tolerance) {\r\n        var difference = left + right;\r\n        if ((CesiumMath.sign(left) !== CesiumMath.sign(right)) &&\r\n                Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance) {\r\n            return 0.0;\r\n        }\r\n\r\n        return difference;\r\n    }\r\n\r\n    /**\r\n     * Provides the real valued roots of the quadratic polynomial with the provided coefficients.\r\n     *\r\n     * @param {Number} a The coefficient of the 2nd order monomial.\r\n     * @param {Number} b The coefficient of the 1st order monomial.\r\n     * @param {Number} c The coefficient of the 0th order monomial.\r\n     * @returns {Number[]} The real valued roots.\r\n     */\r\n    QuadraticRealPolynomial.computeRealRoots = function(a, b, c) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (typeof a !== 'number') {\r\n            throw new DeveloperError('a is a required number.');\r\n        }\r\n        if (typeof b !== 'number') {\r\n            throw new DeveloperError('b is a required number.');\r\n        }\r\n        if (typeof c !== 'number') {\r\n            throw new DeveloperError('c is a required number.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var ratio;\r\n        if (a === 0.0) {\r\n            if (b === 0.0) {\r\n                // Constant function: c = 0.\r\n                return [];\r\n            }\r\n\r\n            // Linear function: b * x + c = 0.\r\n            return [-c / b];\r\n        } else if (b === 0.0) {\r\n            if (c === 0.0) {\r\n                // 2nd order monomial: a * x^2 = 0.\r\n                return [0.0, 0.0];\r\n            }\r\n\r\n            var cMagnitude = Math.abs(c);\r\n            var aMagnitude = Math.abs(a);\r\n\r\n            if ((cMagnitude < aMagnitude) && (cMagnitude / aMagnitude < CesiumMath.EPSILON14)) { // c ~= 0.0.\r\n                // 2nd order monomial: a * x^2 = 0.\r\n                return [0.0, 0.0];\r\n            } else if ((cMagnitude > aMagnitude) && (aMagnitude / cMagnitude < CesiumMath.EPSILON14)) { // a ~= 0.0.\r\n                // Constant function: c = 0.\r\n                return [];\r\n            }\r\n\r\n            // a * x^2 + c = 0\r\n            ratio = -c / a;\r\n\r\n            if (ratio < 0.0) {\r\n                // Both roots are complex.\r\n                return [];\r\n            }\r\n\r\n            // Both roots are real.\r\n            var root = Math.sqrt(ratio);\r\n            return [-root, root];\r\n        } else if (c === 0.0) {\r\n            // a * x^2 + b * x = 0\r\n            ratio = -b / a;\r\n            if (ratio < 0.0) {\r\n                return [ratio, 0.0];\r\n            }\r\n\r\n            return [0.0, ratio];\r\n        }\r\n\r\n        // a * x^2 + b * x + c = 0\r\n        var b2 = b * b;\r\n        var four_ac = 4.0 * a * c;\r\n        var radicand = addWithCancellationCheck(b2, -four_ac, CesiumMath.EPSILON14);\r\n\r\n        if (radicand < 0.0) {\r\n            // Both roots are complex.\r\n            return [];\r\n        }\r\n\r\n        var q = -0.5 * addWithCancellationCheck(b, CesiumMath.sign(b) * Math.sqrt(radicand), CesiumMath.EPSILON14);\r\n        if (b > 0.0) {\r\n            return [q / a, c / q];\r\n        }\r\n\r\n        return [c / q, q / a];\r\n    };\r\nexport default QuadraticRealPolynomial;\r\n","import DeveloperError from './DeveloperError.js';\r\nimport QuadraticRealPolynomial from './QuadraticRealPolynomial.js';\r\n\r\n    /**\r\n     * Defines functions for 3rd order polynomial functions of one variable with only real coefficients.\r\n     *\r\n     * @exports CubicRealPolynomial\r\n     */\r\n    var CubicRealPolynomial = {};\r\n\r\n    /**\r\n     * Provides the discriminant of the cubic equation from the supplied coefficients.\r\n     *\r\n     * @param {Number} a The coefficient of the 3rd order monomial.\r\n     * @param {Number} b The coefficient of the 2nd order monomial.\r\n     * @param {Number} c The coefficient of the 1st order monomial.\r\n     * @param {Number} d The coefficient of the 0th order monomial.\r\n     * @returns {Number} The value of the discriminant.\r\n     */\r\n    CubicRealPolynomial.computeDiscriminant = function(a, b, c, d) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (typeof a !== 'number') {\r\n            throw new DeveloperError('a is a required number.');\r\n        }\r\n        if (typeof b !== 'number') {\r\n            throw new DeveloperError('b is a required number.');\r\n        }\r\n        if (typeof c !== 'number') {\r\n            throw new DeveloperError('c is a required number.');\r\n        }\r\n        if (typeof d !== 'number') {\r\n            throw new DeveloperError('d is a required number.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var a2 = a * a;\r\n        var b2 = b * b;\r\n        var c2 = c * c;\r\n        var d2 = d * d;\r\n\r\n        var discriminant = 18.0 * a * b * c * d + b2 * c2 - 27.0 * a2 * d2 - 4.0 * (a * c2 * c + b2 * b * d);\r\n        return discriminant;\r\n    };\r\n\r\n    function computeRealRoots(a, b, c, d) {\r\n        var A = a;\r\n        var B = b / 3.0;\r\n        var C = c / 3.0;\r\n        var D = d;\r\n\r\n        var AC = A * C;\r\n        var BD = B * D;\r\n        var B2 = B * B;\r\n        var C2 = C * C;\r\n        var delta1 = A * C - B2;\r\n        var delta2 = A * D - B * C;\r\n        var delta3 = B * D - C2;\r\n\r\n        var discriminant = 4.0 * delta1 * delta3 - delta2 * delta2;\r\n        var temp;\r\n        var temp1;\r\n\r\n        if (discriminant < 0.0) {\r\n            var ABar;\r\n            var CBar;\r\n            var DBar;\r\n\r\n            if (B2 * BD >= AC * C2) {\r\n                ABar = A;\r\n                CBar = delta1;\r\n                DBar = -2.0 * B * delta1 + A * delta2;\r\n            } else {\r\n                ABar = D;\r\n                CBar = delta3;\r\n                DBar = -D * delta2 + 2.0 * C * delta3;\r\n            }\r\n\r\n            var s = (DBar < 0.0) ? -1.0 : 1.0; // This is not Math.Sign()!\r\n            var temp0 = -s * Math.abs(ABar) * Math.sqrt(-discriminant);\r\n            temp1 = -DBar + temp0;\r\n\r\n            var x = temp1 / 2.0;\r\n            var p = x < 0.0 ? -Math.pow(-x, 1.0 / 3.0) : Math.pow(x, 1.0 / 3.0);\r\n            var q = (temp1 === temp0) ? -p : -CBar / p;\r\n\r\n            temp = (CBar <= 0.0) ? p + q : -DBar / (p * p + q * q + CBar);\r\n\r\n            if (B2 * BD >= AC * C2) {\r\n                return [(temp - B) / A];\r\n            }\r\n\r\n            return [-D / (temp + C)];\r\n        }\r\n\r\n        var CBarA = delta1;\r\n        var DBarA = -2.0 * B * delta1 + A * delta2;\r\n\r\n        var CBarD = delta3;\r\n        var DBarD = -D * delta2 + 2.0 * C * delta3;\r\n\r\n        var squareRootOfDiscriminant = Math.sqrt(discriminant);\r\n        var halfSquareRootOf3 = Math.sqrt(3.0) / 2.0;\r\n\r\n        var theta = Math.abs(Math.atan2(A * squareRootOfDiscriminant, -DBarA) / 3.0);\r\n        temp = 2.0 * Math.sqrt(-CBarA);\r\n        var cosine = Math.cos(theta);\r\n        temp1 = temp * cosine;\r\n        var temp3 = temp * (-cosine / 2.0 - halfSquareRootOf3 * Math.sin(theta));\r\n\r\n        var numeratorLarge = (temp1 + temp3 > 2.0 * B) ? temp1 - B : temp3 - B;\r\n        var denominatorLarge = A;\r\n\r\n        var root1 = numeratorLarge / denominatorLarge;\r\n\r\n        theta = Math.abs(Math.atan2(D * squareRootOfDiscriminant, -DBarD) / 3.0);\r\n        temp = 2.0 * Math.sqrt(-CBarD);\r\n        cosine = Math.cos(theta);\r\n        temp1 = temp * cosine;\r\n        temp3 = temp * (-cosine / 2.0 - halfSquareRootOf3 * Math.sin(theta));\r\n\r\n        var numeratorSmall = -D;\r\n        var denominatorSmall = (temp1 + temp3 < 2.0 * C) ? temp1 + C : temp3 + C;\r\n\r\n        var root3 = numeratorSmall / denominatorSmall;\r\n\r\n        var E = denominatorLarge * denominatorSmall;\r\n        var F = -numeratorLarge * denominatorSmall - denominatorLarge * numeratorSmall;\r\n        var G = numeratorLarge * numeratorSmall;\r\n\r\n        var root2 = (C * F - B * G) / (-B * F + C * E);\r\n\r\n        if (root1 <= root2) {\r\n            if (root1 <= root3) {\r\n                if (root2 <= root3) {\r\n                    return [root1, root2, root3];\r\n                }\r\n                return [root1, root3, root2];\r\n            }\r\n            return [root3, root1, root2];\r\n        }\r\n        if (root1 <= root3) {\r\n            return [root2, root1, root3];\r\n        }\r\n        if (root2 <= root3) {\r\n            return [root2, root3, root1];\r\n        }\r\n        return [root3, root2, root1];\r\n    }\r\n\r\n    /**\r\n     * Provides the real valued roots of the cubic polynomial with the provided coefficients.\r\n     *\r\n     * @param {Number} a The coefficient of the 3rd order monomial.\r\n     * @param {Number} b The coefficient of the 2nd order monomial.\r\n     * @param {Number} c The coefficient of the 1st order monomial.\r\n     * @param {Number} d The coefficient of the 0th order monomial.\r\n     * @returns {Number[]} The real valued roots.\r\n     */\r\n    CubicRealPolynomial.computeRealRoots = function(a, b, c, d) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (typeof a !== 'number') {\r\n            throw new DeveloperError('a is a required number.');\r\n        }\r\n        if (typeof b !== 'number') {\r\n            throw new DeveloperError('b is a required number.');\r\n        }\r\n        if (typeof c !== 'number') {\r\n            throw new DeveloperError('c is a required number.');\r\n        }\r\n        if (typeof d !== 'number') {\r\n            throw new DeveloperError('d is a required number.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var roots;\r\n        var ratio;\r\n        if (a === 0.0) {\r\n            // Quadratic function: b * x^2 + c * x + d = 0.\r\n            return QuadraticRealPolynomial.computeRealRoots(b, c, d);\r\n        } else if (b === 0.0) {\r\n            if (c === 0.0) {\r\n                if (d === 0.0) {\r\n                    // 3rd order monomial: a * x^3 = 0.\r\n                    return [0.0, 0.0, 0.0];\r\n                }\r\n\r\n                // a * x^3 + d = 0\r\n                ratio = -d / a;\r\n                var root = (ratio < 0.0) ? -Math.pow(-ratio, 1.0 / 3.0) : Math.pow(ratio, 1.0 / 3.0);\r\n                return [root, root, root];\r\n            } else if (d === 0.0) {\r\n                // x * (a * x^2 + c) = 0.\r\n                roots = QuadraticRealPolynomial.computeRealRoots(a, 0, c);\r\n\r\n                // Return the roots in ascending order.\r\n                if (roots.Length === 0) {\r\n                    return [0.0];\r\n                }\r\n                return [roots[0], 0.0, roots[1]];\r\n            }\r\n\r\n            // Deflated cubic polynomial: a * x^3 + c * x + d= 0.\r\n            return computeRealRoots(a, 0, c, d);\r\n        } else if (c === 0.0) {\r\n            if (d === 0.0) {\r\n                // x^2 * (a * x + b) = 0.\r\n                ratio = -b / a;\r\n                if (ratio < 0.0) {\r\n                    return [ratio, 0.0, 0.0];\r\n                }\r\n                return [0.0, 0.0, ratio];\r\n            }\r\n            // a * x^3 + b * x^2 + d = 0.\r\n            return computeRealRoots(a, b, 0, d);\r\n        } else if (d === 0.0) {\r\n            // x * (a * x^2 + b * x + c) = 0\r\n            roots = QuadraticRealPolynomial.computeRealRoots(a, b, c);\r\n\r\n            // Return the roots in ascending order.\r\n            if (roots.length === 0) {\r\n                return [0.0];\r\n            } else if (roots[1] <= 0.0) {\r\n                return [roots[0], roots[1], 0.0];\r\n            } else if (roots[0] >= 0.0) {\r\n                return [0.0, roots[0], roots[1]];\r\n            }\r\n            return [roots[0], 0.0, roots[1]];\r\n        }\r\n\r\n        return computeRealRoots(a, b, c, d);\r\n    };\r\nexport default CubicRealPolynomial;\r\n","import CubicRealPolynomial from './CubicRealPolynomial.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport CesiumMath from './Math.js';\r\nimport QuadraticRealPolynomial from './QuadraticRealPolynomial.js';\r\n\r\n    /**\r\n     * Defines functions for 4th order polynomial functions of one variable with only real coefficients.\r\n     *\r\n     * @exports QuarticRealPolynomial\r\n     */\r\n    var QuarticRealPolynomial = {};\r\n\r\n    /**\r\n     * Provides the discriminant of the quartic equation from the supplied coefficients.\r\n     *\r\n     * @param {Number} a The coefficient of the 4th order monomial.\r\n     * @param {Number} b The coefficient of the 3rd order monomial.\r\n     * @param {Number} c The coefficient of the 2nd order monomial.\r\n     * @param {Number} d The coefficient of the 1st order monomial.\r\n     * @param {Number} e The coefficient of the 0th order monomial.\r\n     * @returns {Number} The value of the discriminant.\r\n     */\r\n    QuarticRealPolynomial.computeDiscriminant = function(a, b, c, d, e) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (typeof a !== 'number') {\r\n            throw new DeveloperError('a is a required number.');\r\n        }\r\n        if (typeof b !== 'number') {\r\n            throw new DeveloperError('b is a required number.');\r\n        }\r\n        if (typeof c !== 'number') {\r\n            throw new DeveloperError('c is a required number.');\r\n        }\r\n        if (typeof d !== 'number') {\r\n            throw new DeveloperError('d is a required number.');\r\n        }\r\n        if (typeof e !== 'number') {\r\n            throw new DeveloperError('e is a required number.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var a2 = a * a;\r\n        var a3 = a2 * a;\r\n        var b2 = b * b;\r\n        var b3 = b2 * b;\r\n        var c2 = c * c;\r\n        var c3 = c2 * c;\r\n        var d2 = d * d;\r\n        var d3 = d2 * d;\r\n        var e2 = e * e;\r\n        var e3 = e2 * e;\r\n\r\n        var discriminant = (b2 * c2 * d2 - 4.0 * b3 * d3 - 4.0 * a * c3 * d2 + 18 * a * b * c * d3 - 27.0 * a2 * d2 * d2 + 256.0 * a3 * e3) +\r\n            e * (18.0 * b3 * c * d - 4.0 * b2 * c3 + 16.0 * a * c2 * c2 - 80.0 * a * b * c2 * d - 6.0 * a * b2 * d2 + 144.0 * a2 * c * d2) +\r\n            e2 * (144.0 * a * b2 * c - 27.0 * b2 * b2 - 128.0 * a2 * c2 - 192.0 * a2 * b * d);\r\n        return discriminant;\r\n    };\r\n\r\n    function original(a3, a2, a1, a0) {\r\n        var a3Squared = a3 * a3;\r\n\r\n        var p = a2 - 3.0 * a3Squared / 8.0;\r\n        var q = a1 - a2 * a3 / 2.0 + a3Squared * a3 / 8.0;\r\n        var r = a0 - a1 * a3 / 4.0 + a2 * a3Squared / 16.0 - 3.0 * a3Squared * a3Squared / 256.0;\r\n\r\n        // Find the roots of the cubic equations:  h^6 + 2 p h^4 + (p^2 - 4 r) h^2 - q^2 = 0.\r\n        var cubicRoots = CubicRealPolynomial.computeRealRoots(1.0, 2.0 * p, p * p - 4.0 * r, -q * q);\r\n\r\n        if (cubicRoots.length > 0) {\r\n            var temp = -a3 / 4.0;\r\n\r\n            // Use the largest positive root.\r\n            var hSquared = cubicRoots[cubicRoots.length - 1];\r\n\r\n            if (Math.abs(hSquared) < CesiumMath.EPSILON14) {\r\n                // y^4 + p y^2 + r = 0.\r\n                var roots = QuadraticRealPolynomial.computeRealRoots(1.0, p, r);\r\n\r\n                if (roots.length === 2) {\r\n                    var root0 = roots[0];\r\n                    var root1 = roots[1];\r\n\r\n                    var y;\r\n                    if (root0 >= 0.0 && root1 >= 0.0) {\r\n                        var y0 = Math.sqrt(root0);\r\n                        var y1 = Math.sqrt(root1);\r\n\r\n                        return [temp - y1, temp - y0, temp + y0, temp + y1];\r\n                    } else if (root0 >= 0.0 && root1 < 0.0) {\r\n                        y = Math.sqrt(root0);\r\n                        return [temp - y, temp + y];\r\n                    } else if (root0 < 0.0 && root1 >= 0.0) {\r\n                        y = Math.sqrt(root1);\r\n                        return [temp - y, temp + y];\r\n                    }\r\n                }\r\n                return [];\r\n            } else if (hSquared > 0.0) {\r\n                var h = Math.sqrt(hSquared);\r\n\r\n                var m = (p + hSquared - q / h) / 2.0;\r\n                var n = (p + hSquared + q / h) / 2.0;\r\n\r\n                // Now solve the two quadratic factors:  (y^2 + h y + m)(y^2 - h y + n);\r\n                var roots1 = QuadraticRealPolynomial.computeRealRoots(1.0, h, m);\r\n                var roots2 = QuadraticRealPolynomial.computeRealRoots(1.0, -h, n);\r\n\r\n                if (roots1.length !== 0) {\r\n                    roots1[0] += temp;\r\n                    roots1[1] += temp;\r\n\r\n                    if (roots2.length !== 0) {\r\n                        roots2[0] += temp;\r\n                        roots2[1] += temp;\r\n\r\n                        if (roots1[1] <= roots2[0]) {\r\n                            return [roots1[0], roots1[1], roots2[0], roots2[1]];\r\n                        } else if (roots2[1] <= roots1[0]) {\r\n                            return [roots2[0], roots2[1], roots1[0], roots1[1]];\r\n                        } else if (roots1[0] >= roots2[0] && roots1[1] <= roots2[1]) {\r\n                            return [roots2[0], roots1[0], roots1[1], roots2[1]];\r\n                        } else if (roots2[0] >= roots1[0] && roots2[1] <= roots1[1]) {\r\n                            return [roots1[0], roots2[0], roots2[1], roots1[1]];\r\n                        } else if (roots1[0] > roots2[0] && roots1[0] < roots2[1]) {\r\n                            return [roots2[0], roots1[0], roots2[1], roots1[1]];\r\n                        }\r\n                        return [roots1[0], roots2[0], roots1[1], roots2[1]];\r\n                    }\r\n                    return roots1;\r\n                }\r\n\r\n                if (roots2.length !== 0) {\r\n                    roots2[0] += temp;\r\n                    roots2[1] += temp;\r\n\r\n                    return roots2;\r\n                }\r\n                return [];\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n\r\n    function neumark(a3, a2, a1, a0) {\r\n        var a1Squared = a1 * a1;\r\n        var a2Squared = a2 * a2;\r\n        var a3Squared = a3 * a3;\r\n\r\n        var p = -2.0 * a2;\r\n        var q = a1 * a3 + a2Squared - 4.0 * a0;\r\n        var r = a3Squared * a0 - a1 * a2 * a3 + a1Squared;\r\n\r\n        var cubicRoots = CubicRealPolynomial.computeRealRoots(1.0, p, q, r);\r\n\r\n        if (cubicRoots.length > 0) {\r\n            // Use the most positive root\r\n            var y = cubicRoots[0];\r\n\r\n            var temp = (a2 - y);\r\n            var tempSquared = temp * temp;\r\n\r\n            var g1 = a3 / 2.0;\r\n            var h1 = temp / 2.0;\r\n\r\n            var m = tempSquared - 4.0 * a0;\r\n            var mError = tempSquared + 4.0 * Math.abs(a0);\r\n\r\n            var n = a3Squared - 4.0 * y;\r\n            var nError = a3Squared + 4.0 * Math.abs(y);\r\n\r\n            var g2;\r\n            var h2;\r\n\r\n            if (y < 0.0 || (m * nError < n * mError)) {\r\n                var squareRootOfN = Math.sqrt(n);\r\n                g2 = squareRootOfN / 2.0;\r\n                h2 = squareRootOfN === 0.0 ? 0.0 : (a3 * h1 - a1) / squareRootOfN;\r\n            } else {\r\n                var squareRootOfM = Math.sqrt(m);\r\n                g2 = squareRootOfM === 0.0 ? 0.0 : (a3 * h1 - a1) / squareRootOfM;\r\n                h2 = squareRootOfM / 2.0;\r\n            }\r\n\r\n            var G;\r\n            var g;\r\n            if (g1 === 0.0 && g2 === 0.0) {\r\n                G = 0.0;\r\n                g = 0.0;\r\n            } else if (CesiumMath.sign(g1) === CesiumMath.sign(g2)) {\r\n                G = g1 + g2;\r\n                g = y / G;\r\n            } else {\r\n                g = g1 - g2;\r\n                G = y / g;\r\n            }\r\n\r\n            var H;\r\n            var h;\r\n            if (h1 === 0.0 && h2 === 0.0) {\r\n                H = 0.0;\r\n                h = 0.0;\r\n            } else if (CesiumMath.sign(h1) === CesiumMath.sign(h2)) {\r\n                H = h1 + h2;\r\n                h = a0 / H;\r\n            } else {\r\n                h = h1 - h2;\r\n                H = a0 / h;\r\n            }\r\n\r\n            // Now solve the two quadratic factors:  (y^2 + G y + H)(y^2 + g y + h);\r\n            var roots1 = QuadraticRealPolynomial.computeRealRoots(1.0, G, H);\r\n            var roots2 = QuadraticRealPolynomial.computeRealRoots(1.0, g, h);\r\n\r\n            if (roots1.length !== 0) {\r\n                if (roots2.length !== 0) {\r\n                    if (roots1[1] <= roots2[0]) {\r\n                        return [roots1[0], roots1[1], roots2[0], roots2[1]];\r\n                    } else if (roots2[1] <= roots1[0]) {\r\n                        return [roots2[0], roots2[1], roots1[0], roots1[1]];\r\n                    } else if (roots1[0] >= roots2[0] && roots1[1] <= roots2[1]) {\r\n                        return [roots2[0], roots1[0], roots1[1], roots2[1]];\r\n                    } else if (roots2[0] >= roots1[0] && roots2[1] <= roots1[1]) {\r\n                        return [roots1[0], roots2[0], roots2[1], roots1[1]];\r\n                    } else if (roots1[0] > roots2[0] && roots1[0] < roots2[1]) {\r\n                        return [roots2[0], roots1[0], roots2[1], roots1[1]];\r\n                    }\r\n                    return [roots1[0], roots2[0], roots1[1], roots2[1]];\r\n                }\r\n                return roots1;\r\n            }\r\n            if (roots2.length !== 0) {\r\n                return roots2;\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Provides the real valued roots of the quartic polynomial with the provided coefficients.\r\n     *\r\n     * @param {Number} a The coefficient of the 4th order monomial.\r\n     * @param {Number} b The coefficient of the 3rd order monomial.\r\n     * @param {Number} c The coefficient of the 2nd order monomial.\r\n     * @param {Number} d The coefficient of the 1st order monomial.\r\n     * @param {Number} e The coefficient of the 0th order monomial.\r\n     * @returns {Number[]} The real valued roots.\r\n     */\r\n    QuarticRealPolynomial.computeRealRoots = function(a, b, c, d, e) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (typeof a !== 'number') {\r\n            throw new DeveloperError('a is a required number.');\r\n        }\r\n        if (typeof b !== 'number') {\r\n            throw new DeveloperError('b is a required number.');\r\n        }\r\n        if (typeof c !== 'number') {\r\n            throw new DeveloperError('c is a required number.');\r\n        }\r\n        if (typeof d !== 'number') {\r\n            throw new DeveloperError('d is a required number.');\r\n        }\r\n        if (typeof e !== 'number') {\r\n            throw new DeveloperError('e is a required number.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        if (Math.abs(a) < CesiumMath.EPSILON15) {\r\n            return CubicRealPolynomial.computeRealRoots(b, c, d, e);\r\n        }\r\n        var a3 = b / a;\r\n        var a2 = c / a;\r\n        var a1 = d / a;\r\n        var a0 = e / a;\r\n\r\n        var k = (a3 < 0.0) ? 1 : 0;\r\n        k += (a2 < 0.0) ? k + 1 : k;\r\n        k += (a1 < 0.0) ? k + 1 : k;\r\n        k += (a0 < 0.0) ? k + 1 : k;\r\n\r\n        switch (k) {\r\n        case 0:\r\n            return original(a3, a2, a1, a0);\r\n        case 1:\r\n            return neumark(a3, a2, a1, a0);\r\n        case 2:\r\n            return neumark(a3, a2, a1, a0);\r\n        case 3:\r\n            return original(a3, a2, a1, a0);\r\n        case 4:\r\n            return original(a3, a2, a1, a0);\r\n        case 5:\r\n            return neumark(a3, a2, a1, a0);\r\n        case 6:\r\n            return original(a3, a2, a1, a0);\r\n        case 7:\r\n            return original(a3, a2, a1, a0);\r\n        case 8:\r\n            return neumark(a3, a2, a1, a0);\r\n        case 9:\r\n            return original(a3, a2, a1, a0);\r\n        case 10:\r\n            return original(a3, a2, a1, a0);\r\n        case 11:\r\n            return neumark(a3, a2, a1, a0);\r\n        case 12:\r\n            return original(a3, a2, a1, a0);\r\n        case 13:\r\n            return original(a3, a2, a1, a0);\r\n        case 14:\r\n            return original(a3, a2, a1, a0);\r\n        case 15:\r\n            return original(a3, a2, a1, a0);\r\n        default:\r\n            return undefined;\r\n        }\r\n    };\r\nexport default QuarticRealPolynomial;\r\n","import Cartesian3 from './Cartesian3.js';\r\nimport Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\n\r\n    /**\r\n     * Represents a ray that extends infinitely from the provided origin in the provided direction.\r\n     * @alias Ray\r\n     * @constructor\r\n     *\r\n     * @param {Cartesian3} [origin=Cartesian3.ZERO] The origin of the ray.\r\n     * @param {Cartesian3} [direction=Cartesian3.ZERO] The direction of the ray.\r\n     */\r\n    function Ray(origin, direction) {\r\n        direction = Cartesian3.clone(defaultValue(direction, Cartesian3.ZERO));\r\n        if (!Cartesian3.equals(direction, Cartesian3.ZERO)) {\r\n            Cartesian3.normalize(direction, direction);\r\n        }\r\n\r\n        /**\r\n         * The origin of the ray.\r\n         * @type {Cartesian3}\r\n         * @default {@link Cartesian3.ZERO}\r\n         */\r\n        this.origin = Cartesian3.clone(defaultValue(origin, Cartesian3.ZERO));\r\n\r\n        /**\r\n         * The direction of the ray.\r\n         * @type {Cartesian3}\r\n         */\r\n        this.direction = direction;\r\n    }\r\n\r\n    /**\r\n     * Duplicates a Ray instance.\r\n     *\r\n     * @param {Ray} ray The ray to duplicate.\r\n     * @param {Ray} [result] The object onto which to store the result.\r\n     * @returns {Ray} The modified result parameter or a new Ray instance if one was not provided. (Returns undefined if ray is undefined)\r\n     */\r\n    Ray.clone = function(ray, result) {\r\n        if (!defined(ray)) {\r\n            return undefined;\r\n        }\r\n        if (!defined(result)) {\r\n            return new Ray(ray.origin, ray.direction);\r\n        }\r\n        result.origin = Cartesian3.clone(ray.origin);\r\n        result.direction = Cartesian3.clone(ray.direction);\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the point along the ray given by r(t) = o + t*d,\r\n     * where o is the origin of the ray and d is the direction.\r\n     *\r\n     * @param {Ray} ray The ray.\r\n     * @param {Number} t A scalar value.\r\n     * @param {Cartesian3} [result] The object in which the result will be stored.\r\n     * @returns {Cartesian3} The modified result parameter, or a new instance if none was provided.\r\n     *\r\n     * @example\r\n     * //Get the first intersection point of a ray and an ellipsoid.\r\n     * var intersection = Cesium.IntersectionTests.rayEllipsoid(ray, ellipsoid);\r\n     * var point = Cesium.Ray.getPoint(ray, intersection.start);\r\n     */\r\n    Ray.getPoint = function(ray, t, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('ray', ray);\r\n        Check.typeOf.number('t', t);\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n\r\n        result = Cartesian3.multiplyByScalar(ray.direction, t, result);\r\n        return Cartesian3.add(ray.origin, result, result);\r\n    };\r\nexport default Ray;\r\n","import Cartesian3 from './Cartesian3.js';\r\nimport Cartographic from './Cartographic.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport Interval from './Interval.js';\r\nimport CesiumMath from './Math.js';\r\nimport Matrix3 from './Matrix3.js';\r\nimport QuadraticRealPolynomial from './QuadraticRealPolynomial.js';\r\nimport QuarticRealPolynomial from './QuarticRealPolynomial.js';\r\nimport Ray from './Ray.js';\r\n\r\n    /**\r\n     * Functions for computing the intersection between geometries such as rays, planes, triangles, and ellipsoids.\r\n     *\r\n     * @exports IntersectionTests\r\n     * @namespace\r\n     */\r\n    var IntersectionTests = {};\r\n\r\n    /**\r\n     * Computes the intersection of a ray and a plane.\r\n     *\r\n     * @param {Ray} ray The ray.\r\n     * @param {Plane} plane The plane.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\r\n     */\r\n    IntersectionTests.rayPlane = function(ray, plane, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(ray)) {\r\n            throw new DeveloperError('ray is required.');\r\n        }\r\n        if (!defined(plane)) {\r\n            throw new DeveloperError('plane is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n\r\n        var origin = ray.origin;\r\n        var direction = ray.direction;\r\n        var normal = plane.normal;\r\n        var denominator = Cartesian3.dot(normal, direction);\r\n\r\n        if (Math.abs(denominator) < CesiumMath.EPSILON15) {\r\n            // Ray is parallel to plane.  The ray may be in the polygon's plane.\r\n            return undefined;\r\n        }\r\n\r\n        var t = (-plane.distance - Cartesian3.dot(normal, origin)) / denominator;\r\n\r\n        if (t < 0) {\r\n            return undefined;\r\n        }\r\n\r\n        result = Cartesian3.multiplyByScalar(direction, t, result);\r\n        return Cartesian3.add(origin, result, result);\r\n    };\r\n\r\n    var scratchEdge0 = new Cartesian3();\r\n    var scratchEdge1 = new Cartesian3();\r\n    var scratchPVec = new Cartesian3();\r\n    var scratchTVec = new Cartesian3();\r\n    var scratchQVec = new Cartesian3();\r\n\r\n    /**\r\n     * Computes the intersection of a ray and a triangle as a parametric distance along the input ray. The result is negative when the triangle is behind the ray.\r\n     *\r\n     * Implements {@link https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf|\r\n     * Fast Minimum Storage Ray/Triangle Intersection} by Tomas Moller and Ben Trumbore.\r\n     *\r\n     * @memberof IntersectionTests\r\n     *\r\n     * @param {Ray} ray The ray.\r\n     * @param {Cartesian3} p0 The first vertex of the triangle.\r\n     * @param {Cartesian3} p1 The second vertex of the triangle.\r\n     * @param {Cartesian3} p2 The third vertex of the triangle.\r\n     * @param {Boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\r\n     *                  and return undefined for intersections with the back face.\r\n     * @returns {Number} The intersection as a parametric distance along the ray, or undefined if there is no intersection.\r\n     */\r\n    IntersectionTests.rayTriangleParametric  = function(ray, p0, p1, p2, cullBackFaces) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(ray)) {\r\n            throw new DeveloperError('ray is required.');\r\n        }\r\n        if (!defined(p0)) {\r\n            throw new DeveloperError('p0 is required.');\r\n        }\r\n        if (!defined(p1)) {\r\n            throw new DeveloperError('p1 is required.');\r\n        }\r\n        if (!defined(p2)) {\r\n            throw new DeveloperError('p2 is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        cullBackFaces = defaultValue(cullBackFaces, false);\r\n\r\n        var origin = ray.origin;\r\n        var direction = ray.direction;\r\n\r\n        var edge0 = Cartesian3.subtract(p1, p0, scratchEdge0);\r\n        var edge1 = Cartesian3.subtract(p2, p0, scratchEdge1);\r\n\r\n        var p = Cartesian3.cross(direction, edge1, scratchPVec);\r\n        var det = Cartesian3.dot(edge0, p);\r\n\r\n        var tvec;\r\n        var q;\r\n\r\n        var u;\r\n        var v;\r\n        var t;\r\n\r\n        if (cullBackFaces) {\r\n            if (det < CesiumMath.EPSILON6) {\r\n                return undefined;\r\n            }\r\n\r\n            tvec = Cartesian3.subtract(origin, p0, scratchTVec);\r\n            u = Cartesian3.dot(tvec, p);\r\n            if (u < 0.0 || u > det) {\r\n                return undefined;\r\n            }\r\n\r\n            q = Cartesian3.cross(tvec, edge0, scratchQVec);\r\n\r\n            v = Cartesian3.dot(direction, q);\r\n            if (v < 0.0 || u + v > det) {\r\n                return undefined;\r\n            }\r\n\r\n            t = Cartesian3.dot(edge1, q) / det;\r\n        } else {\r\n            if (Math.abs(det) < CesiumMath.EPSILON6) {\r\n                return undefined;\r\n            }\r\n            var invDet = 1.0 / det;\r\n\r\n            tvec = Cartesian3.subtract(origin, p0, scratchTVec);\r\n            u = Cartesian3.dot(tvec, p) * invDet;\r\n            if (u < 0.0 || u > 1.0) {\r\n                return undefined;\r\n            }\r\n\r\n            q = Cartesian3.cross(tvec, edge0, scratchQVec);\r\n\r\n            v = Cartesian3.dot(direction, q) * invDet;\r\n            if (v < 0.0 || u + v > 1.0) {\r\n                return undefined;\r\n            }\r\n\r\n            t = Cartesian3.dot(edge1, q) * invDet;\r\n        }\r\n\r\n        return t;\r\n    };\r\n\r\n    /**\r\n     * Computes the intersection of a ray and a triangle as a Cartesian3 coordinate.\r\n     *\r\n     * Implements {@link https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf|\r\n     * Fast Minimum Storage Ray/Triangle Intersection} by Tomas Moller and Ben Trumbore.\r\n     *\r\n     * @memberof IntersectionTests\r\n     *\r\n     * @param {Ray} ray The ray.\r\n     * @param {Cartesian3} p0 The first vertex of the triangle.\r\n     * @param {Cartesian3} p1 The second vertex of the triangle.\r\n     * @param {Cartesian3} p2 The third vertex of the triangle.\r\n     * @param {Boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\r\n     *                  and return undefined for intersections with the back face.\r\n     * @param {Cartesian3} [result] The <code>Cartesian3</code> onto which to store the result.\r\n     * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\r\n     */\r\n    IntersectionTests.rayTriangle = function(ray, p0, p1, p2, cullBackFaces, result) {\r\n        var t = IntersectionTests.rayTriangleParametric(ray, p0, p1, p2, cullBackFaces);\r\n        if (!defined(t) || t < 0.0) {\r\n            return undefined;\r\n        }\r\n\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n\r\n        Cartesian3.multiplyByScalar(ray.direction, t, result);\r\n        return Cartesian3.add(ray.origin, result, result);\r\n    };\r\n\r\n    var scratchLineSegmentTriangleRay = new Ray();\r\n\r\n    /**\r\n     * Computes the intersection of a line segment and a triangle.\r\n     * @memberof IntersectionTests\r\n     *\r\n     * @param {Cartesian3} v0 The an end point of the line segment.\r\n     * @param {Cartesian3} v1 The other end point of the line segment.\r\n     * @param {Cartesian3} p0 The first vertex of the triangle.\r\n     * @param {Cartesian3} p1 The second vertex of the triangle.\r\n     * @param {Cartesian3} p2 The third vertex of the triangle.\r\n     * @param {Boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\r\n     *                  and return undefined for intersections with the back face.\r\n     * @param {Cartesian3} [result] The <code>Cartesian3</code> onto which to store the result.\r\n     * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\r\n     */\r\n    IntersectionTests.lineSegmentTriangle = function(v0, v1, p0, p1, p2, cullBackFaces, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(v0)) {\r\n            throw new DeveloperError('v0 is required.');\r\n        }\r\n        if (!defined(v1)) {\r\n            throw new DeveloperError('v1 is required.');\r\n        }\r\n        if (!defined(p0)) {\r\n            throw new DeveloperError('p0 is required.');\r\n        }\r\n        if (!defined(p1)) {\r\n            throw new DeveloperError('p1 is required.');\r\n        }\r\n        if (!defined(p2)) {\r\n            throw new DeveloperError('p2 is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var ray = scratchLineSegmentTriangleRay;\r\n        Cartesian3.clone(v0, ray.origin);\r\n        Cartesian3.subtract(v1, v0, ray.direction);\r\n        Cartesian3.normalize(ray.direction, ray.direction);\r\n\r\n        var t = IntersectionTests.rayTriangleParametric(ray, p0, p1, p2, cullBackFaces);\r\n        if (!defined(t) || t < 0.0 || t > Cartesian3.distance(v0, v1)) {\r\n            return undefined;\r\n        }\r\n\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n\r\n        Cartesian3.multiplyByScalar(ray.direction, t, result);\r\n        return Cartesian3.add(ray.origin, result, result);\r\n    };\r\n\r\n    function solveQuadratic(a, b, c, result) {\r\n        var det = b * b - 4.0 * a * c;\r\n        if (det < 0.0) {\r\n            return undefined;\r\n        } else if (det > 0.0) {\r\n            var denom = 1.0 / (2.0 * a);\r\n            var disc = Math.sqrt(det);\r\n            var root0 = (-b + disc) * denom;\r\n            var root1 = (-b - disc) * denom;\r\n\r\n            if (root0 < root1) {\r\n                result.root0 = root0;\r\n                result.root1 = root1;\r\n            } else {\r\n                result.root0 = root1;\r\n                result.root1 = root0;\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        var root = -b / (2.0 * a);\r\n        if (root === 0.0) {\r\n            return undefined;\r\n        }\r\n\r\n        result.root0 = result.root1 = root;\r\n        return result;\r\n    }\r\n\r\n    var raySphereRoots = {\r\n        root0 : 0.0,\r\n        root1 : 0.0\r\n    };\r\n\r\n    function raySphere(ray, sphere, result) {\r\n        if (!defined(result)) {\r\n            result = new Interval();\r\n        }\r\n\r\n        var origin = ray.origin;\r\n        var direction = ray.direction;\r\n\r\n        var center = sphere.center;\r\n        var radiusSquared = sphere.radius * sphere.radius;\r\n\r\n        var diff = Cartesian3.subtract(origin, center, scratchPVec);\r\n\r\n        var a = Cartesian3.dot(direction, direction);\r\n        var b = 2.0 * Cartesian3.dot(direction, diff);\r\n        var c = Cartesian3.magnitudeSquared(diff) - radiusSquared;\r\n\r\n        var roots = solveQuadratic(a, b, c, raySphereRoots);\r\n        if (!defined(roots)) {\r\n            return undefined;\r\n        }\r\n\r\n        result.start = roots.root0;\r\n        result.stop = roots.root1;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Computes the intersection points of a ray with a sphere.\r\n     * @memberof IntersectionTests\r\n     *\r\n     * @param {Ray} ray The ray.\r\n     * @param {BoundingSphere} sphere The sphere.\r\n     * @param {Interval} [result] The result onto which to store the result.\r\n     * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.\r\n     */\r\n    IntersectionTests.raySphere = function(ray, sphere, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(ray)) {\r\n            throw new DeveloperError('ray is required.');\r\n        }\r\n        if (!defined(sphere)) {\r\n            throw new DeveloperError('sphere is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        result = raySphere(ray, sphere, result);\r\n        if (!defined(result) || result.stop < 0.0) {\r\n            return undefined;\r\n        }\r\n\r\n        result.start = Math.max(result.start, 0.0);\r\n        return result;\r\n    };\r\n\r\n    var scratchLineSegmentRay = new Ray();\r\n\r\n    /**\r\n     * Computes the intersection points of a line segment with a sphere.\r\n     * @memberof IntersectionTests\r\n     *\r\n     * @param {Cartesian3} p0 An end point of the line segment.\r\n     * @param {Cartesian3} p1 The other end point of the line segment.\r\n     * @param {BoundingSphere} sphere The sphere.\r\n     * @param {Interval} [result] The result onto which to store the result.\r\n     * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.\r\n     */\r\n    IntersectionTests.lineSegmentSphere = function(p0, p1, sphere, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(p0)) {\r\n            throw new DeveloperError('p0 is required.');\r\n        }\r\n        if (!defined(p1)) {\r\n            throw new DeveloperError('p1 is required.');\r\n        }\r\n        if (!defined(sphere)) {\r\n            throw new DeveloperError('sphere is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var ray = scratchLineSegmentRay;\r\n        Cartesian3.clone(p0, ray.origin);\r\n        var direction = Cartesian3.subtract(p1, p0, ray.direction);\r\n\r\n        var maxT = Cartesian3.magnitude(direction);\r\n        Cartesian3.normalize(direction, direction);\r\n\r\n        result = raySphere(ray, sphere, result);\r\n        if (!defined(result) || result.stop < 0.0 || result.start > maxT) {\r\n            return undefined;\r\n        }\r\n\r\n        result.start = Math.max(result.start, 0.0);\r\n        result.stop = Math.min(result.stop, maxT);\r\n        return result;\r\n    };\r\n\r\n    var scratchQ = new Cartesian3();\r\n    var scratchW = new Cartesian3();\r\n\r\n    /**\r\n     * Computes the intersection points of a ray with an ellipsoid.\r\n     *\r\n     * @param {Ray} ray The ray.\r\n     * @param {Ellipsoid} ellipsoid The ellipsoid.\r\n     * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.\r\n     */\r\n    IntersectionTests.rayEllipsoid = function(ray, ellipsoid) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(ray)) {\r\n            throw new DeveloperError('ray is required.');\r\n        }\r\n        if (!defined(ellipsoid)) {\r\n            throw new DeveloperError('ellipsoid is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var inverseRadii = ellipsoid.oneOverRadii;\r\n        var q = Cartesian3.multiplyComponents(inverseRadii, ray.origin, scratchQ);\r\n        var w = Cartesian3.multiplyComponents(inverseRadii, ray.direction, scratchW);\r\n\r\n        var q2 = Cartesian3.magnitudeSquared(q);\r\n        var qw = Cartesian3.dot(q, w);\r\n\r\n        var difference, w2, product, discriminant, temp;\r\n\r\n        if (q2 > 1.0) {\r\n            // Outside ellipsoid.\r\n            if (qw >= 0.0) {\r\n                // Looking outward or tangent (0 intersections).\r\n                return undefined;\r\n            }\r\n\r\n            // qw < 0.0.\r\n            var qw2 = qw * qw;\r\n            difference = q2 - 1.0; // Positively valued.\r\n            w2 = Cartesian3.magnitudeSquared(w);\r\n            product = w2 * difference;\r\n\r\n            if (qw2 < product) {\r\n                // Imaginary roots (0 intersections).\r\n                return undefined;\r\n            } else if (qw2 > product) {\r\n                // Distinct roots (2 intersections).\r\n                discriminant = qw * qw - product;\r\n                temp = -qw + Math.sqrt(discriminant); // Avoid cancellation.\r\n                var root0 = temp / w2;\r\n                var root1 = difference / temp;\r\n                if (root0 < root1) {\r\n                    return new Interval(root0, root1);\r\n                }\r\n\r\n                return {\r\n                    start : root1,\r\n                    stop : root0\r\n                };\r\n            }\r\n            // qw2 == product.  Repeated roots (2 intersections).\r\n            var root = Math.sqrt(difference / w2);\r\n            return new Interval(root, root);\r\n        } else if (q2 < 1.0) {\r\n            // Inside ellipsoid (2 intersections).\r\n            difference = q2 - 1.0; // Negatively valued.\r\n            w2 = Cartesian3.magnitudeSquared(w);\r\n            product = w2 * difference; // Negatively valued.\r\n\r\n            discriminant = qw * qw - product;\r\n            temp = -qw + Math.sqrt(discriminant); // Positively valued.\r\n            return new Interval(0.0, temp / w2);\r\n        }\r\n        // q2 == 1.0. On ellipsoid.\r\n        if (qw < 0.0) {\r\n            // Looking inward.\r\n            w2 = Cartesian3.magnitudeSquared(w);\r\n            return new Interval(0.0, -qw / w2);\r\n        }\r\n\r\n        // qw >= 0.0.  Looking outward or tangent.\r\n        return undefined;\r\n    };\r\n\r\n    function addWithCancellationCheck(left, right, tolerance) {\r\n        var difference = left + right;\r\n        if ((CesiumMath.sign(left) !== CesiumMath.sign(right)) &&\r\n                Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance) {\r\n            return 0.0;\r\n        }\r\n\r\n        return difference;\r\n    }\r\n\r\n    function quadraticVectorExpression(A, b, c, x, w) {\r\n        var xSquared = x * x;\r\n        var wSquared = w * w;\r\n\r\n        var l2 = (A[Matrix3.COLUMN1ROW1] - A[Matrix3.COLUMN2ROW2]) * wSquared;\r\n        var l1 = w * (x * addWithCancellationCheck(A[Matrix3.COLUMN1ROW0], A[Matrix3.COLUMN0ROW1], CesiumMath.EPSILON15) + b.y);\r\n        var l0 = (A[Matrix3.COLUMN0ROW0] * xSquared + A[Matrix3.COLUMN2ROW2] * wSquared) + x * b.x + c;\r\n\r\n        var r1 = wSquared * addWithCancellationCheck(A[Matrix3.COLUMN2ROW1], A[Matrix3.COLUMN1ROW2], CesiumMath.EPSILON15);\r\n        var r0 = w * (x * addWithCancellationCheck(A[Matrix3.COLUMN2ROW0], A[Matrix3.COLUMN0ROW2]) + b.z);\r\n\r\n        var cosines;\r\n        var solutions = [];\r\n        if (r0 === 0.0 && r1 === 0.0) {\r\n            cosines = QuadraticRealPolynomial.computeRealRoots(l2, l1, l0);\r\n            if (cosines.length === 0) {\r\n                return solutions;\r\n            }\r\n\r\n            var cosine0 = cosines[0];\r\n            var sine0 = Math.sqrt(Math.max(1.0 - cosine0 * cosine0, 0.0));\r\n            solutions.push(new Cartesian3(x, w * cosine0, w * -sine0));\r\n            solutions.push(new Cartesian3(x, w * cosine0, w * sine0));\r\n\r\n            if (cosines.length === 2) {\r\n                var cosine1 = cosines[1];\r\n                var sine1 = Math.sqrt(Math.max(1.0 - cosine1 * cosine1, 0.0));\r\n                solutions.push(new Cartesian3(x, w * cosine1, w * -sine1));\r\n                solutions.push(new Cartesian3(x, w * cosine1, w * sine1));\r\n            }\r\n\r\n            return solutions;\r\n        }\r\n\r\n        var r0Squared = r0 * r0;\r\n        var r1Squared = r1 * r1;\r\n        var l2Squared = l2 * l2;\r\n        var r0r1 = r0 * r1;\r\n\r\n        var c4 = l2Squared + r1Squared;\r\n        var c3 = 2.0 * (l1 * l2 + r0r1);\r\n        var c2 = 2.0 * l0 * l2 + l1 * l1 - r1Squared + r0Squared;\r\n        var c1 = 2.0 * (l0 * l1 - r0r1);\r\n        var c0 = l0 * l0 - r0Squared;\r\n\r\n        if (c4 === 0.0 && c3 === 0.0 && c2 === 0.0 && c1 === 0.0) {\r\n            return solutions;\r\n        }\r\n\r\n        cosines = QuarticRealPolynomial.computeRealRoots(c4, c3, c2, c1, c0);\r\n        var length = cosines.length;\r\n        if (length === 0) {\r\n            return solutions;\r\n        }\r\n\r\n        for ( var i = 0; i < length; ++i) {\r\n            var cosine = cosines[i];\r\n            var cosineSquared = cosine * cosine;\r\n            var sineSquared = Math.max(1.0 - cosineSquared, 0.0);\r\n            var sine = Math.sqrt(sineSquared);\r\n\r\n            //var left = l2 * cosineSquared + l1 * cosine + l0;\r\n            var left;\r\n            if (CesiumMath.sign(l2) === CesiumMath.sign(l0)) {\r\n                left = addWithCancellationCheck(l2 * cosineSquared + l0, l1 * cosine, CesiumMath.EPSILON12);\r\n            } else if (CesiumMath.sign(l0) === CesiumMath.sign(l1 * cosine)) {\r\n                left = addWithCancellationCheck(l2 * cosineSquared, l1 * cosine + l0, CesiumMath.EPSILON12);\r\n            } else {\r\n                left = addWithCancellationCheck(l2 * cosineSquared + l1 * cosine, l0, CesiumMath.EPSILON12);\r\n            }\r\n\r\n            var right = addWithCancellationCheck(r1 * cosine, r0, CesiumMath.EPSILON15);\r\n            var product = left * right;\r\n\r\n            if (product < 0.0) {\r\n                solutions.push(new Cartesian3(x, w * cosine, w * sine));\r\n            } else if (product > 0.0) {\r\n                solutions.push(new Cartesian3(x, w * cosine, w * -sine));\r\n            } else if (sine !== 0.0) {\r\n                solutions.push(new Cartesian3(x, w * cosine, w * -sine));\r\n                solutions.push(new Cartesian3(x, w * cosine, w * sine));\r\n                ++i;\r\n            } else {\r\n                solutions.push(new Cartesian3(x, w * cosine, w * sine));\r\n            }\r\n        }\r\n\r\n        return solutions;\r\n    }\r\n\r\n    var firstAxisScratch = new Cartesian3();\r\n    var secondAxisScratch = new Cartesian3();\r\n    var thirdAxisScratch = new Cartesian3();\r\n    var referenceScratch = new Cartesian3();\r\n    var bCart = new Cartesian3();\r\n    var bScratch = new Matrix3();\r\n    var btScratch = new Matrix3();\r\n    var diScratch = new Matrix3();\r\n    var dScratch = new Matrix3();\r\n    var cScratch = new Matrix3();\r\n    var tempMatrix = new Matrix3();\r\n    var aScratch = new Matrix3();\r\n    var sScratch = new Cartesian3();\r\n    var closestScratch = new Cartesian3();\r\n    var surfPointScratch = new Cartographic();\r\n\r\n    /**\r\n     * Provides the point along the ray which is nearest to the ellipsoid.\r\n     *\r\n     * @param {Ray} ray The ray.\r\n     * @param {Ellipsoid} ellipsoid The ellipsoid.\r\n     * @returns {Cartesian3} The nearest planetodetic point on the ray.\r\n     */\r\n    IntersectionTests.grazingAltitudeLocation = function(ray, ellipsoid) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(ray)) {\r\n            throw new DeveloperError('ray is required.');\r\n        }\r\n        if (!defined(ellipsoid)) {\r\n            throw new DeveloperError('ellipsoid is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var position = ray.origin;\r\n        var direction = ray.direction;\r\n\r\n        if (!Cartesian3.equals(position, Cartesian3.ZERO)) {\r\n            var normal = ellipsoid.geodeticSurfaceNormal(position, firstAxisScratch);\r\n            if (Cartesian3.dot(direction, normal) >= 0.0) { // The location provided is the closest point in altitude\r\n                return position;\r\n            }\r\n        }\r\n\r\n        var intersects = defined(this.rayEllipsoid(ray, ellipsoid));\r\n\r\n        // Compute the scaled direction vector.\r\n        var f = ellipsoid.transformPositionToScaledSpace(direction, firstAxisScratch);\r\n\r\n        // Constructs a basis from the unit scaled direction vector. Construct its rotation and transpose.\r\n        var firstAxis = Cartesian3.normalize(f, f);\r\n        var reference = Cartesian3.mostOrthogonalAxis(f, referenceScratch);\r\n        var secondAxis = Cartesian3.normalize(Cartesian3.cross(reference, firstAxis, secondAxisScratch), secondAxisScratch);\r\n        var thirdAxis  = Cartesian3.normalize(Cartesian3.cross(firstAxis, secondAxis, thirdAxisScratch), thirdAxisScratch);\r\n        var B = bScratch;\r\n        B[0] = firstAxis.x;\r\n        B[1] = firstAxis.y;\r\n        B[2] = firstAxis.z;\r\n        B[3] = secondAxis.x;\r\n        B[4] = secondAxis.y;\r\n        B[5] = secondAxis.z;\r\n        B[6] = thirdAxis.x;\r\n        B[7] = thirdAxis.y;\r\n        B[8] = thirdAxis.z;\r\n\r\n        var B_T = Matrix3.transpose(B, btScratch);\r\n\r\n        // Get the scaling matrix and its inverse.\r\n        var D_I = Matrix3.fromScale(ellipsoid.radii, diScratch);\r\n        var D = Matrix3.fromScale(ellipsoid.oneOverRadii, dScratch);\r\n\r\n        var C = cScratch;\r\n        C[0] = 0.0;\r\n        C[1] = -direction.z;\r\n        C[2] = direction.y;\r\n        C[3] = direction.z;\r\n        C[4] = 0.0;\r\n        C[5] = -direction.x;\r\n        C[6] = -direction.y;\r\n        C[7] = direction.x;\r\n        C[8] = 0.0;\r\n\r\n        var temp = Matrix3.multiply(Matrix3.multiply(B_T, D, tempMatrix), C, tempMatrix);\r\n        var A = Matrix3.multiply(Matrix3.multiply(temp, D_I, aScratch), B, aScratch);\r\n        var b = Matrix3.multiplyByVector(temp, position, bCart);\r\n\r\n        // Solve for the solutions to the expression in standard form:\r\n        var solutions = quadraticVectorExpression(A, Cartesian3.negate(b, firstAxisScratch), 0.0, 0.0, 1.0);\r\n\r\n        var s;\r\n        var altitude;\r\n        var length = solutions.length;\r\n        if (length > 0) {\r\n            var closest = Cartesian3.clone(Cartesian3.ZERO, closestScratch);\r\n            var maximumValue = Number.NEGATIVE_INFINITY;\r\n\r\n            for ( var i = 0; i < length; ++i) {\r\n                s = Matrix3.multiplyByVector(D_I, Matrix3.multiplyByVector(B, solutions[i], sScratch), sScratch);\r\n                var v = Cartesian3.normalize(Cartesian3.subtract(s, position, referenceScratch), referenceScratch);\r\n                var dotProduct = Cartesian3.dot(v, direction);\r\n\r\n                if (dotProduct > maximumValue) {\r\n                    maximumValue = dotProduct;\r\n                    closest = Cartesian3.clone(s, closest);\r\n                }\r\n            }\r\n\r\n            var surfacePoint = ellipsoid.cartesianToCartographic(closest, surfPointScratch);\r\n            maximumValue = CesiumMath.clamp(maximumValue, 0.0, 1.0);\r\n            altitude = Cartesian3.magnitude(Cartesian3.subtract(closest, position, referenceScratch)) * Math.sqrt(1.0 - maximumValue * maximumValue);\r\n            altitude = intersects ? -altitude : altitude;\r\n            surfacePoint.height = altitude;\r\n            return ellipsoid.cartographicToCartesian(surfacePoint, new Cartesian3());\r\n        }\r\n\r\n        return undefined;\r\n    };\r\n\r\n    var lineSegmentPlaneDifference = new Cartesian3();\r\n\r\n    /**\r\n     * Computes the intersection of a line segment and a plane.\r\n     *\r\n     * @param {Cartesian3} endPoint0 An end point of the line segment.\r\n     * @param {Cartesian3} endPoint1 The other end point of the line segment.\r\n     * @param {Plane} plane The plane.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The intersection point or undefined if there is no intersection.\r\n     *\r\n     * @example\r\n     * var origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\r\n     * var normal = ellipsoid.geodeticSurfaceNormal(origin);\r\n     * var plane = Cesium.Plane.fromPointNormal(origin, normal);\r\n     *\r\n     * var p0 = new Cesium.Cartesian3(...);\r\n     * var p1 = new Cesium.Cartesian3(...);\r\n     *\r\n     * // find the intersection of the line segment from p0 to p1 and the tangent plane at origin.\r\n     * var intersection = Cesium.IntersectionTests.lineSegmentPlane(p0, p1, plane);\r\n     */\r\n    IntersectionTests.lineSegmentPlane = function(endPoint0, endPoint1, plane, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(endPoint0)) {\r\n            throw new DeveloperError('endPoint0 is required.');\r\n        }\r\n        if (!defined(endPoint1)) {\r\n            throw new DeveloperError('endPoint1 is required.');\r\n        }\r\n        if (!defined(plane)) {\r\n            throw new DeveloperError('plane is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n\r\n        var difference = Cartesian3.subtract(endPoint1, endPoint0, lineSegmentPlaneDifference);\r\n        var normal = plane.normal;\r\n        var nDotDiff = Cartesian3.dot(normal, difference);\r\n\r\n        // check if the segment and plane are parallel\r\n        if (Math.abs(nDotDiff) < CesiumMath.EPSILON6) {\r\n            return undefined;\r\n        }\r\n\r\n        var nDotP0 = Cartesian3.dot(normal, endPoint0);\r\n        var t = -(plane.distance + nDotP0) / nDotDiff;\r\n\r\n        // intersection only if t is in [0, 1]\r\n        if (t < 0.0 || t > 1.0) {\r\n            return undefined;\r\n        }\r\n\r\n        // intersection is endPoint0 + t * (endPoint1 - endPoint0)\r\n        Cartesian3.multiplyByScalar(difference, t, result);\r\n        Cartesian3.add(endPoint0, result, result);\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the intersection of a triangle and a plane\r\n     *\r\n     * @param {Cartesian3} p0 First point of the triangle\r\n     * @param {Cartesian3} p1 Second point of the triangle\r\n     * @param {Cartesian3} p2 Third point of the triangle\r\n     * @param {Plane} plane Intersection plane\r\n     * @returns {Object} An object with properties <code>positions</code> and <code>indices</code>, which are arrays that represent three triangles that do not cross the plane. (Undefined if no intersection exists)\r\n     *\r\n     * @example\r\n     * var origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\r\n     * var normal = ellipsoid.geodeticSurfaceNormal(origin);\r\n     * var plane = Cesium.Plane.fromPointNormal(origin, normal);\r\n     *\r\n     * var p0 = new Cesium.Cartesian3(...);\r\n     * var p1 = new Cesium.Cartesian3(...);\r\n     * var p2 = new Cesium.Cartesian3(...);\r\n     *\r\n     * // convert the triangle composed of points (p0, p1, p2) to three triangles that don't cross the plane\r\n     * var triangles = Cesium.IntersectionTests.trianglePlaneIntersection(p0, p1, p2, plane);\r\n     */\r\n    IntersectionTests.trianglePlaneIntersection = function(p0, p1, p2, plane) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if ((!defined(p0)) ||\r\n            (!defined(p1)) ||\r\n            (!defined(p2)) ||\r\n            (!defined(plane))) {\r\n            throw new DeveloperError('p0, p1, p2, and plane are required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var planeNormal = plane.normal;\r\n        var planeD = plane.distance;\r\n        var p0Behind = (Cartesian3.dot(planeNormal, p0) + planeD) < 0.0;\r\n        var p1Behind = (Cartesian3.dot(planeNormal, p1) + planeD) < 0.0;\r\n        var p2Behind = (Cartesian3.dot(planeNormal, p2) + planeD) < 0.0;\r\n        // Given these dots products, the calls to lineSegmentPlaneIntersection\r\n        // always have defined results.\r\n\r\n        var numBehind = 0;\r\n        numBehind += p0Behind ? 1 : 0;\r\n        numBehind += p1Behind ? 1 : 0;\r\n        numBehind += p2Behind ? 1 : 0;\r\n\r\n        var u1, u2;\r\n        if (numBehind === 1 || numBehind === 2) {\r\n            u1 = new Cartesian3();\r\n            u2 = new Cartesian3();\r\n        }\r\n\r\n        if (numBehind === 1) {\r\n            if (p0Behind) {\r\n                IntersectionTests.lineSegmentPlane(p0, p1, plane, u1);\r\n                IntersectionTests.lineSegmentPlane(p0, p2, plane, u2);\r\n\r\n                return {\r\n                    positions : [p0, p1, p2, u1, u2 ],\r\n                    indices : [\r\n                        // Behind\r\n                        0, 3, 4,\r\n\r\n                        // In front\r\n                        1, 2, 4,\r\n                        1, 4, 3\r\n                    ]\r\n                };\r\n            } else if (p1Behind) {\r\n                IntersectionTests.lineSegmentPlane(p1, p2, plane, u1);\r\n                IntersectionTests.lineSegmentPlane(p1, p0, plane, u2);\r\n\r\n                return {\r\n                    positions : [p0, p1, p2, u1, u2 ],\r\n                    indices : [\r\n                        // Behind\r\n                        1, 3, 4,\r\n\r\n                        // In front\r\n                        2, 0, 4,\r\n                        2, 4, 3\r\n                    ]\r\n                };\r\n            } else if (p2Behind) {\r\n                IntersectionTests.lineSegmentPlane(p2, p0, plane, u1);\r\n                IntersectionTests.lineSegmentPlane(p2, p1, plane, u2);\r\n\r\n                return {\r\n                    positions : [p0, p1, p2, u1, u2 ],\r\n                    indices : [\r\n                        // Behind\r\n                        2, 3, 4,\r\n\r\n                        // In front\r\n                        0, 1, 4,\r\n                        0, 4, 3\r\n                    ]\r\n                };\r\n            }\r\n        } else if (numBehind === 2) {\r\n            if (!p0Behind) {\r\n                IntersectionTests.lineSegmentPlane(p1, p0, plane, u1);\r\n                IntersectionTests.lineSegmentPlane(p2, p0, plane, u2);\r\n\r\n                return {\r\n                    positions : [p0, p1, p2, u1, u2 ],\r\n                    indices : [\r\n                        // Behind\r\n                        1, 2, 4,\r\n                        1, 4, 3,\r\n\r\n                        // In front\r\n                        0, 3, 4\r\n                    ]\r\n                };\r\n            } else if (!p1Behind) {\r\n                IntersectionTests.lineSegmentPlane(p2, p1, plane, u1);\r\n                IntersectionTests.lineSegmentPlane(p0, p1, plane, u2);\r\n\r\n                return {\r\n                    positions : [p0, p1, p2, u1, u2 ],\r\n                    indices : [\r\n                        // Behind\r\n                        2, 0, 4,\r\n                        2, 4, 3,\r\n\r\n                        // In front\r\n                        1, 3, 4\r\n                    ]\r\n                };\r\n            } else if (!p2Behind) {\r\n                IntersectionTests.lineSegmentPlane(p0, p2, plane, u1);\r\n                IntersectionTests.lineSegmentPlane(p1, p2, plane, u2);\r\n\r\n                return {\r\n                    positions : [p0, p1, p2, u1, u2 ],\r\n                    indices : [\r\n                        // Behind\r\n                        0, 1, 4,\r\n                        0, 4, 3,\r\n\r\n                        // In front\r\n                        2, 3, 4\r\n                    ]\r\n                };\r\n            }\r\n        }\r\n\r\n        // if numBehind is 3, the triangle is completely behind the plane;\r\n        // otherwise, it is completely in front (numBehind is 0).\r\n        return undefined;\r\n    };\r\nexport default IntersectionTests;\r\n"],"names":["QuadraticRealPolynomial","addWithCancellationCheck","left","right","tolerance","difference","CesiumMath","sign","Math","abs","max","computeDiscriminant","a","b","c","DeveloperError","computeRealRoots","ratio","cMagnitude","aMagnitude","EPSILON14","root","sqrt","radicand","q","CubicRealPolynomial","d","temp","temp1","A","B","C","D","AC","BD","B2","C2","delta1","delta2","delta3","discriminant","ABar","CBar","DBar","temp0","x","p","pow","CBarA","DBarA","CBarD","DBarD","squareRootOfDiscriminant","halfSquareRootOf3","theta","atan2","cosine","cos","temp3","sin","numeratorLarge","denominatorLarge","root1","numeratorSmall","denominatorSmall","root3","F","root2","b2","c2","roots","Length","length","QuarticRealPolynomial","original","a3","a2","a1","a0","a3Squared","r","cubicRoots","hSquared","y","root0","y0","y1","h","m","n","roots1","roots2","neumark","g2","h2","G","g","H","tempSquared","g1","h1","mError","nError","squareRootOfN","squareRootOfM","Ray","origin","direction","Cartesian3","clone","defaultValue","ZERO","equals","normalize","this","e","b3","c3","d2","d3","e2","EPSILON15","k","ray","result","defined","getPoint","t","Check","typeOf","object","number","multiplyByScalar","add","IntersectionTests","rayPlane","plane","normal","denominator","dot","distance","scratchEdge0","scratchEdge1","scratchPVec","scratchTVec","scratchQVec","rayTriangleParametric","p0","p1","p2","cullBackFaces","tvec","u","v","edge0","subtract","edge1","cross","det","EPSILON6","invDet","rayTriangle","scratchLineSegmentTriangleRay","lineSegmentTriangle","v0","v1","raySphereRoots","raySphere","sphere","Interval","center","radiusSquared","radius","diff","denom","disc","solveQuadratic","magnitudeSquared","start","stop","scratchLineSegmentRay","lineSegmentSphere","maxT","magnitude","min","scratchQ","scratchW","rayEllipsoid","ellipsoid","w2","product","inverseRadii","oneOverRadii","multiplyComponents","w","q2","qw","qw2","firstAxisScratch","secondAxisScratch","thirdAxisScratch","referenceScratch","bCart","bScratch","Matrix3","btScratch","diScratch","dScratch","cScratch","tempMatrix","aScratch","sScratch","closestScratch","surfPointScratch","Cartographic","grazingAltitudeLocation","position","geodeticSurfaceNormal","intersects","f","transformPositionToScaledSpace","firstAxis","reference","mostOrthogonalAxis","secondAxis","thirdAxis","z","B_T","transpose","D_I","fromScale","radii","s","altitude","multiply","multiplyByVector","solutions","cosines","xSquared","wSquared","l2","COLUMN1ROW1","COLUMN2ROW2","l1","COLUMN1ROW0","COLUMN0ROW1","l0","COLUMN0ROW0","r1","COLUMN2ROW1","COLUMN1ROW2","r0","COLUMN2ROW0","COLUMN0ROW2","cosine0","sine0","push","cosine1","sine1","r0Squared","r1Squared","r0r1","c4","c1","c0","i","cosineSquared","sineSquared","sine","EPSILON12","quadraticVectorExpression","negate","closest","maximumValue","Number","NEGATIVE_INFINITY","dotProduct","surfacePoint","cartesianToCartographic","clamp","height","cartographicToCartesian","lineSegmentPlaneDifference","lineSegmentPlane","endPoint0","endPoint1","nDotDiff","nDotP0","trianglePlaneIntersection","u1","u2","planeNormal","planeD","p0Behind","p1Behind","p2Behind","numBehind","positions","indices"],"mappings":"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"}