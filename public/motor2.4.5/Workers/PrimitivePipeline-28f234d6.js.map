{"version":3,"file":"PrimitivePipeline-28f234d6.js","sources":["../../../../Source/Core/OffsetGeometryInstanceAttribute.js","../../../../Source/Scene/PrimitivePipeline.js"],"sourcesContent":["import Check from './Check.js';\r\nimport ComponentDatatype from './ComponentDatatype.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\n\r\n    /**\r\n     * Value and type information for per-instance geometry attribute that determines the geometry instance offset\r\n     *\r\n     * @alias OffsetGeometryInstanceAttribute\r\n     * @constructor\r\n     *\r\n     * @param {Number} [x=0] The x translation\r\n     * @param {Number} [y=0] The y translation\r\n     * @param {Number} [z=0] The z translation\r\n     *\r\n     * @private\r\n     *\r\n     * @see GeometryInstance\r\n     * @see GeometryInstanceAttribute\r\n     */\r\n    function OffsetGeometryInstanceAttribute(x, y, z) {\r\n        x = defaultValue(x, 0);\r\n        y = defaultValue(y, 0);\r\n        z = defaultValue(z, 0);\r\n\r\n        /**\r\n         * The values for the attributes stored in a typed array.\r\n         *\r\n         * @type Float32Array\r\n         */\r\n        this.value = new Float32Array([x, y, z]);\r\n    }\r\n\r\n    Object.defineProperties(OffsetGeometryInstanceAttribute.prototype, {\r\n        /**\r\n         * The datatype of each component in the attribute, e.g., individual elements in\r\n         * {@link OffsetGeometryInstanceAttribute#value}.\r\n         *\r\n         * @memberof OffsetGeometryInstanceAttribute.prototype\r\n         *\r\n         * @type {ComponentDatatype}\r\n         * @readonly\r\n         *\r\n         * @default {@link ComponentDatatype.FLOAT}\r\n         */\r\n        componentDatatype : {\r\n            get : function() {\r\n                return ComponentDatatype.FLOAT;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * The number of components in the attributes, i.e., {@link OffsetGeometryInstanceAttribute#value}.\r\n         *\r\n         * @memberof OffsetGeometryInstanceAttribute.prototype\r\n         *\r\n         * @type {Number}\r\n         * @readonly\r\n         *\r\n         * @default 3\r\n         */\r\n        componentsPerAttribute : {\r\n            get : function() {\r\n                return 3;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * When <code>true</code> and <code>componentDatatype</code> is an integer format,\r\n         * indicate that the components should be mapped to the range [0, 1] (unsigned)\r\n         * or [-1, 1] (signed) when they are accessed as floating-point for rendering.\r\n         *\r\n         * @memberof OffsetGeometryInstanceAttribute.prototype\r\n         *\r\n         * @type {Boolean}\r\n         * @readonly\r\n         *\r\n         * @default false\r\n         */\r\n        normalize : {\r\n            get : function() {\r\n                return false;\r\n            }\r\n        }\r\n    });\r\n\r\n    /**\r\n     * Creates a new {@link OffsetGeometryInstanceAttribute} instance given the provided an enabled flag and {@link DistanceDisplayCondition}.\r\n     *\r\n     * @param {Cartesian3} offset The cartesian offset\r\n     * @returns {OffsetGeometryInstanceAttribute} The new {@link OffsetGeometryInstanceAttribute} instance.\r\n     */\r\n    OffsetGeometryInstanceAttribute.fromCartesian3 = function(offset) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('offset', offset);\r\n        //>>includeEnd('debug');\r\n\r\n        return new OffsetGeometryInstanceAttribute(offset.x, offset.y, offset.z);\r\n    };\r\n\r\n    /**\r\n     * Converts a distance display condition to a typed array that can be used to assign a distance display condition attribute.\r\n     *\r\n     * @param {Cartesian3} offset The cartesian offset\r\n     * @param {Float32Array} [result] The array to store the result in, if undefined a new instance will be created.\r\n     * @returns {Float32Array} The modified result parameter or a new instance if result was undefined.\r\n     *\r\n     * @example\r\n     * var attributes = primitive.getGeometryInstanceAttributes('an id');\r\n     * attributes.modelMatrix = Cesium.OffsetGeometryInstanceAttribute.toValue(modelMatrix, attributes.modelMatrix);\r\n     */\r\n    OffsetGeometryInstanceAttribute.toValue = function(offset, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('offset', offset);\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            result = new Float32Array([offset.x, offset.y, offset.z]);\r\n        }\r\n\r\n        result[0] = offset.x;\r\n        result[1] = offset.y;\r\n        result[2] = offset.z;\r\n        return result;\r\n    };\r\nexport default OffsetGeometryInstanceAttribute;\r\n","import BoundingSphere from '../Core/BoundingSphere.js';\r\nimport ComponentDatatype from '../Core/ComponentDatatype.js';\r\nimport defaultValue from '../Core/defaultValue.js';\r\nimport defined from '../Core/defined.js';\r\nimport DeveloperError from '../Core/DeveloperError.js';\r\nimport Ellipsoid from '../Core/Ellipsoid.js';\r\nimport GeographicProjection from '../Core/GeographicProjection.js';\r\nimport Geometry from '../Core/Geometry.js';\r\nimport GeometryAttribute from '../Core/GeometryAttribute.js';\r\nimport GeometryAttributes from '../Core/GeometryAttributes.js';\r\nimport GeometryPipeline from '../Core/GeometryPipeline.js';\r\nimport IndexDatatype from '../Core/IndexDatatype.js';\r\nimport Matrix4 from '../Core/Matrix4.js';\r\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\r\nimport WebMercatorProjection from '../Core/WebMercatorProjection.js';\r\n\r\n    function transformToWorldCoordinates(instances, primitiveModelMatrix, scene3DOnly) {\r\n        var toWorld = !scene3DOnly;\r\n        var length = instances.length;\r\n        var i;\r\n\r\n        if (!toWorld && (length > 1)) {\r\n            var modelMatrix = instances[0].modelMatrix;\r\n\r\n            for (i = 1; i < length; ++i) {\r\n                if (!Matrix4.equals(modelMatrix, instances[i].modelMatrix)) {\r\n                    toWorld = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (toWorld) {\r\n            for (i = 0; i < length; ++i) {\r\n                if (defined(instances[i].geometry)) {\r\n                    GeometryPipeline.transformToWorldCoordinates(instances[i]);\r\n                }\r\n            }\r\n        } else {\r\n            // Leave geometry in local coordinate system; auto update model-matrix.\r\n            Matrix4.multiplyTransformation(primitiveModelMatrix, instances[0].modelMatrix, primitiveModelMatrix);\r\n        }\r\n    }\r\n\r\n    function addGeometryBatchId(geometry, batchId) {\r\n        var attributes = geometry.attributes;\r\n        var positionAttr = attributes.position;\r\n        var numberOfComponents = positionAttr.values.length / positionAttr.componentsPerAttribute;\r\n\r\n        attributes.batchId = new GeometryAttribute({\r\n            componentDatatype : ComponentDatatype.FLOAT,\r\n            componentsPerAttribute : 1,\r\n            values : new Float32Array(numberOfComponents)\r\n        });\r\n\r\n        var values = attributes.batchId.values;\r\n        for (var j = 0; j < numberOfComponents; ++j) {\r\n            values[j] = batchId;\r\n        }\r\n    }\r\n\r\n    function addBatchIds(instances) {\r\n        var length = instances.length;\r\n\r\n        for (var i = 0; i < length; ++i) {\r\n            var instance = instances[i];\r\n            if (defined(instance.geometry)) {\r\n                addGeometryBatchId(instance.geometry, i);\r\n            } else if (defined(instance.westHemisphereGeometry) && defined(instance.eastHemisphereGeometry)) {\r\n                addGeometryBatchId(instance.westHemisphereGeometry, i);\r\n                addGeometryBatchId(instance.eastHemisphereGeometry, i);\r\n            }\r\n        }\r\n    }\r\n\r\n    function geometryPipeline(parameters) {\r\n        var instances = parameters.instances;\r\n        var projection = parameters.projection;\r\n        var uintIndexSupport = parameters.elementIndexUintSupported;\r\n        var scene3DOnly = parameters.scene3DOnly;\r\n        var vertexCacheOptimize = parameters.vertexCacheOptimize;\r\n        var compressVertices = parameters.compressVertices;\r\n        var modelMatrix = parameters.modelMatrix;\r\n\r\n        var i;\r\n        var geometry;\r\n        var primitiveType;\r\n        var length = instances.length;\r\n\r\n        for (i = 0; i < length; ++i) {\r\n            if (defined(instances[i].geometry)) {\r\n                primitiveType = instances[i].geometry.primitiveType;\r\n                break;\r\n            }\r\n        }\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        for (i = 1; i < length; ++i) {\r\n            if (defined(instances[i].geometry) && instances[i].geometry.primitiveType !== primitiveType) {\r\n                throw new DeveloperError('All instance geometries must have the same primitiveType.');\r\n            }\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        // Unify to world coordinates before combining.\r\n        transformToWorldCoordinates(instances, modelMatrix, scene3DOnly);\r\n\r\n        // Clip to IDL\r\n        if (!scene3DOnly) {\r\n            for (i = 0; i < length; ++i) {\r\n                if (defined(instances[i].geometry)) {\r\n                    GeometryPipeline.splitLongitude(instances[i]);\r\n                }\r\n            }\r\n        }\r\n\r\n        addBatchIds(instances);\r\n\r\n        // Optimize for vertex shader caches\r\n        if (vertexCacheOptimize) {\r\n            for (i = 0; i < length; ++i) {\r\n                var instance = instances[i];\r\n                if (defined(instance.geometry)) {\r\n                    GeometryPipeline.reorderForPostVertexCache(instance.geometry);\r\n                    GeometryPipeline.reorderForPreVertexCache(instance.geometry);\r\n                } else if (defined(instance.westHemisphereGeometry) && defined(instance.eastHemisphereGeometry)) {\r\n                    GeometryPipeline.reorderForPostVertexCache(instance.westHemisphereGeometry);\r\n                    GeometryPipeline.reorderForPreVertexCache(instance.westHemisphereGeometry);\r\n\r\n                    GeometryPipeline.reorderForPostVertexCache(instance.eastHemisphereGeometry);\r\n                    GeometryPipeline.reorderForPreVertexCache(instance.eastHemisphereGeometry);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Combine into single geometry for better rendering performance.\r\n        var geometries = GeometryPipeline.combineInstances(instances);\r\n\r\n        length = geometries.length;\r\n        for (i = 0; i < length; ++i) {\r\n            geometry = geometries[i];\r\n\r\n            // Split positions for GPU RTE\r\n            var attributes = geometry.attributes;\r\n            var name;\r\n            if (!scene3DOnly) {\r\n                for (name in attributes) {\r\n                    if (attributes.hasOwnProperty(name) && attributes[name].componentDatatype === ComponentDatatype.DOUBLE) {\r\n                        var name3D = name + '3D';\r\n                        var name2D = name + '2D';\r\n\r\n                        // Compute 2D positions\r\n                        GeometryPipeline.projectTo2D(geometry, name, name3D, name2D, projection);\r\n                        if (defined(geometry.boundingSphere) && name === 'position') {\r\n                            geometry.boundingSphereCV = BoundingSphere.fromVertices(geometry.attributes.position2D.values);\r\n                        }\r\n\r\n                        GeometryPipeline.encodeAttribute(geometry, name3D, name3D + 'High', name3D + 'Low');\r\n                        GeometryPipeline.encodeAttribute(geometry, name2D, name2D + 'High', name2D + 'Low');\r\n                    }\r\n                }\r\n            } else {\r\n                for (name in attributes) {\r\n                    if (attributes.hasOwnProperty(name) && attributes[name].componentDatatype === ComponentDatatype.DOUBLE) {\r\n                        GeometryPipeline.encodeAttribute(geometry, name, name + '3DHigh', name + '3DLow');\r\n                    }\r\n                }\r\n            }\r\n\r\n            // oct encode and pack normals, compress texture coordinates\r\n            if (compressVertices) {\r\n                GeometryPipeline.compressVertices(geometry);\r\n            }\r\n        }\r\n\r\n        if (!uintIndexSupport) {\r\n            // Break into multiple geometries to fit within unsigned short indices if needed\r\n            var splitGeometries = [];\r\n            length = geometries.length;\r\n            for (i = 0; i < length; ++i) {\r\n                geometry = geometries[i];\r\n                splitGeometries = splitGeometries.concat(GeometryPipeline.fitToUnsignedShortIndices(geometry));\r\n            }\r\n\r\n            geometries = splitGeometries;\r\n        }\r\n\r\n        return geometries;\r\n    }\r\n\r\n    function createPickOffsets(instances, geometryName, geometries, pickOffsets) {\r\n        var offset;\r\n        var indexCount;\r\n        var geometryIndex;\r\n\r\n        var offsetIndex = pickOffsets.length - 1;\r\n        if (offsetIndex >= 0) {\r\n            var pickOffset = pickOffsets[offsetIndex];\r\n            offset = pickOffset.offset + pickOffset.count;\r\n            geometryIndex = pickOffset.index;\r\n            indexCount = geometries[geometryIndex].indices.length;\r\n        } else {\r\n            offset = 0;\r\n            geometryIndex = 0;\r\n            indexCount = geometries[geometryIndex].indices.length;\r\n        }\r\n\r\n        var length = instances.length;\r\n        for (var i = 0; i < length; ++i) {\r\n            var instance = instances[i];\r\n            var geometry = instance[geometryName];\r\n            if (!defined(geometry)) {\r\n                continue;\r\n            }\r\n\r\n            var count = geometry.indices.length;\r\n\r\n            if (offset + count > indexCount) {\r\n                offset = 0;\r\n                indexCount = geometries[++geometryIndex].indices.length;\r\n            }\r\n\r\n            pickOffsets.push({\r\n                index : geometryIndex,\r\n                offset : offset,\r\n                count : count\r\n            });\r\n            offset += count;\r\n        }\r\n    }\r\n\r\n    function createInstancePickOffsets(instances, geometries) {\r\n        var pickOffsets = [];\r\n        createPickOffsets(instances, 'geometry', geometries, pickOffsets);\r\n        createPickOffsets(instances, 'westHemisphereGeometry', geometries, pickOffsets);\r\n        createPickOffsets(instances, 'eastHemisphereGeometry', geometries, pickOffsets);\r\n        return pickOffsets;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    var PrimitivePipeline = {};\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    PrimitivePipeline.combineGeometry = function(parameters) {\r\n        var geometries;\r\n        var attributeLocations;\r\n        var instances = parameters.instances;\r\n        var length = instances.length;\r\n        var pickOffsets;\r\n\r\n        var offsetInstanceExtend;\r\n        var hasOffset = false;\r\n        if (length > 0) {\r\n            geometries = geometryPipeline(parameters);\r\n            if (geometries.length > 0) {\r\n                attributeLocations = GeometryPipeline.createAttributeLocations(geometries[0]);\r\n                if (parameters.createPickOffsets) {\r\n                    pickOffsets = createInstancePickOffsets(instances, geometries);\r\n                }\r\n            }\r\n            if (defined(instances[0].attributes) && defined(instances[0].attributes.offset)) {\r\n                offsetInstanceExtend = new Array(length);\r\n                hasOffset = true;\r\n            }\r\n        }\r\n\r\n        var boundingSpheres = new Array(length);\r\n        var boundingSpheresCV = new Array(length);\r\n        for (var i = 0; i < length; ++i) {\r\n            var instance = instances[i];\r\n            var geometry = instance.geometry;\r\n            if (defined(geometry)) {\r\n                boundingSpheres[i] = geometry.boundingSphere;\r\n                boundingSpheresCV[i] = geometry.boundingSphereCV;\r\n                if (hasOffset) {\r\n                    offsetInstanceExtend[i] = instance.geometry.offsetAttribute;\r\n                }\r\n            }\r\n\r\n            var eastHemisphereGeometry = instance.eastHemisphereGeometry;\r\n            var westHemisphereGeometry = instance.westHemisphereGeometry;\r\n            if (defined(eastHemisphereGeometry) && defined(westHemisphereGeometry)) {\r\n                if (defined(eastHemisphereGeometry.boundingSphere) && defined(westHemisphereGeometry.boundingSphere)) {\r\n                    boundingSpheres[i] = BoundingSphere.union(eastHemisphereGeometry.boundingSphere, westHemisphereGeometry.boundingSphere);\r\n                }\r\n                if (defined(eastHemisphereGeometry.boundingSphereCV) && defined(westHemisphereGeometry.boundingSphereCV)) {\r\n                    boundingSpheresCV[i] = BoundingSphere.union(eastHemisphereGeometry.boundingSphereCV, westHemisphereGeometry.boundingSphereCV);\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            geometries : geometries,\r\n            modelMatrix : parameters.modelMatrix,\r\n            attributeLocations : attributeLocations,\r\n            pickOffsets : pickOffsets,\r\n            offsetInstanceExtend : offsetInstanceExtend,\r\n            boundingSpheres : boundingSpheres,\r\n            boundingSpheresCV : boundingSpheresCV\r\n        };\r\n    };\r\n\r\n    function transferGeometry(geometry, transferableObjects) {\r\n        var attributes = geometry.attributes;\r\n        for (var name in attributes) {\r\n            if (attributes.hasOwnProperty(name)) {\r\n                var attribute = attributes[name];\r\n\r\n                if (defined(attribute) && defined(attribute.values)) {\r\n                    transferableObjects.push(attribute.values.buffer);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (defined(geometry.indices)) {\r\n            transferableObjects.push(geometry.indices.buffer);\r\n        }\r\n    }\r\n\r\n    function transferGeometries(geometries, transferableObjects) {\r\n        var length = geometries.length;\r\n        for (var i = 0; i < length; ++i) {\r\n            transferGeometry(geometries[i], transferableObjects);\r\n        }\r\n    }\r\n\r\n    // This function was created by simplifying packCreateGeometryResults into a count-only operation.\r\n    function countCreateGeometryResults(items) {\r\n        var count = 1;\r\n        var length = items.length;\r\n        for (var i = 0; i < length; i++) {\r\n            var geometry = items[i];\r\n            ++count;\r\n\r\n            if (!defined(geometry)) {\r\n                continue;\r\n            }\r\n\r\n            var attributes = geometry.attributes;\r\n\r\n            count += 7 + 2 * BoundingSphere.packedLength + (defined(geometry.indices) ? geometry.indices.length : 0);\r\n\r\n            for (var property in attributes) {\r\n                if (attributes.hasOwnProperty(property) && defined(attributes[property])) {\r\n                    var attribute = attributes[property];\r\n                    count += 5 + attribute.values.length;\r\n                }\r\n            }\r\n        }\r\n\r\n        return count;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    PrimitivePipeline.packCreateGeometryResults = function(items, transferableObjects) {\r\n        var packedData = new Float64Array(countCreateGeometryResults(items));\r\n        var stringTable = [];\r\n        var stringHash = {};\r\n\r\n        var length = items.length;\r\n        var count = 0;\r\n        packedData[count++] = length;\r\n        for (var i = 0; i < length; i++) {\r\n            var geometry = items[i];\r\n\r\n            var validGeometry = defined(geometry);\r\n            packedData[count++] = validGeometry ? 1.0 : 0.0;\r\n\r\n            if (!validGeometry) {\r\n                continue;\r\n            }\r\n\r\n            packedData[count++] = geometry.primitiveType;\r\n            packedData[count++] = geometry.geometryType;\r\n            packedData[count++] = defaultValue(geometry.offsetAttribute, -1);\r\n\r\n            var validBoundingSphere = defined(geometry.boundingSphere) ? 1.0 : 0.0;\r\n            packedData[count++] = validBoundingSphere;\r\n            if (validBoundingSphere) {\r\n                BoundingSphere.pack(geometry.boundingSphere, packedData, count);\r\n            }\r\n\r\n            count += BoundingSphere.packedLength;\r\n\r\n            var validBoundingSphereCV = defined(geometry.boundingSphereCV) ? 1.0 : 0.0;\r\n            packedData[count++] = validBoundingSphereCV;\r\n            if (validBoundingSphereCV) {\r\n                BoundingSphere.pack(geometry.boundingSphereCV, packedData, count);\r\n            }\r\n\r\n            count += BoundingSphere.packedLength;\r\n\r\n            var attributes = geometry.attributes;\r\n            var attributesToWrite = [];\r\n            for (var property in attributes) {\r\n                if (attributes.hasOwnProperty(property) && defined(attributes[property])) {\r\n                    attributesToWrite.push(property);\r\n                    if (!defined(stringHash[property])) {\r\n                        stringHash[property] = stringTable.length;\r\n                        stringTable.push(property);\r\n                    }\r\n                }\r\n            }\r\n\r\n            packedData[count++] = attributesToWrite.length;\r\n            for (var q = 0; q < attributesToWrite.length; q++) {\r\n                var name = attributesToWrite[q];\r\n                var attribute = attributes[name];\r\n                packedData[count++] = stringHash[name];\r\n                packedData[count++] = attribute.componentDatatype;\r\n                packedData[count++] = attribute.componentsPerAttribute;\r\n                packedData[count++] = attribute.normalize ? 1 : 0;\r\n                packedData[count++] = attribute.values.length;\r\n                packedData.set(attribute.values, count);\r\n                count += attribute.values.length;\r\n            }\r\n\r\n            var indicesLength = defined(geometry.indices) ? geometry.indices.length : 0;\r\n            packedData[count++] = indicesLength;\r\n\r\n            if (indicesLength > 0) {\r\n                packedData.set(geometry.indices, count);\r\n                count += indicesLength;\r\n            }\r\n        }\r\n\r\n        transferableObjects.push(packedData.buffer);\r\n\r\n        return {\r\n            stringTable : stringTable,\r\n            packedData : packedData\r\n        };\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    PrimitivePipeline.unpackCreateGeometryResults = function(createGeometryResult) {\r\n        var stringTable = createGeometryResult.stringTable;\r\n        var packedGeometry = createGeometryResult.packedData;\r\n\r\n        var i;\r\n        var result = new Array(packedGeometry[0]);\r\n        var resultIndex = 0;\r\n\r\n        var packedGeometryIndex = 1;\r\n        while (packedGeometryIndex < packedGeometry.length) {\r\n            var valid = packedGeometry[packedGeometryIndex++] === 1.0;\r\n            if (!valid) {\r\n                result[resultIndex++] = undefined;\r\n                continue;\r\n            }\r\n\r\n            var primitiveType = packedGeometry[packedGeometryIndex++];\r\n            var geometryType = packedGeometry[packedGeometryIndex++];\r\n            var offsetAttribute = packedGeometry[packedGeometryIndex++];\r\n            if (offsetAttribute === -1) {\r\n                offsetAttribute = undefined;\r\n            }\r\n\r\n            var boundingSphere;\r\n            var boundingSphereCV;\r\n\r\n            var validBoundingSphere = packedGeometry[packedGeometryIndex++] === 1.0;\r\n            if (validBoundingSphere) {\r\n                boundingSphere = BoundingSphere.unpack(packedGeometry, packedGeometryIndex);\r\n            }\r\n\r\n            packedGeometryIndex += BoundingSphere.packedLength;\r\n\r\n            var validBoundingSphereCV = packedGeometry[packedGeometryIndex++] === 1.0;\r\n            if (validBoundingSphereCV) {\r\n                boundingSphereCV = BoundingSphere.unpack(packedGeometry, packedGeometryIndex);\r\n            }\r\n\r\n            packedGeometryIndex += BoundingSphere.packedLength;\r\n\r\n            var length;\r\n            var values;\r\n            var componentsPerAttribute;\r\n            var attributes = new GeometryAttributes();\r\n            var numAttributes = packedGeometry[packedGeometryIndex++];\r\n            for (i = 0; i < numAttributes; i++) {\r\n                var name = stringTable[packedGeometry[packedGeometryIndex++]];\r\n                var componentDatatype = packedGeometry[packedGeometryIndex++];\r\n                componentsPerAttribute = packedGeometry[packedGeometryIndex++];\r\n                var normalize = packedGeometry[packedGeometryIndex++] !== 0;\r\n\r\n                length = packedGeometry[packedGeometryIndex++];\r\n                values = ComponentDatatype.createTypedArray(componentDatatype, length);\r\n                for (var valuesIndex = 0; valuesIndex < length; valuesIndex++) {\r\n                    values[valuesIndex] = packedGeometry[packedGeometryIndex++];\r\n                }\r\n\r\n                attributes[name] = new GeometryAttribute({\r\n                    componentDatatype : componentDatatype,\r\n                    componentsPerAttribute : componentsPerAttribute,\r\n                    normalize : normalize,\r\n                    values : values\r\n                });\r\n            }\r\n\r\n            var indices;\r\n            length = packedGeometry[packedGeometryIndex++];\r\n\r\n            if (length > 0) {\r\n                var numberOfVertices = values.length / componentsPerAttribute;\r\n                indices = IndexDatatype.createTypedArray(numberOfVertices, length);\r\n                for (i = 0; i < length; i++) {\r\n                    indices[i] = packedGeometry[packedGeometryIndex++];\r\n                }\r\n            }\r\n\r\n            result[resultIndex++] = new Geometry({\r\n                primitiveType : primitiveType,\r\n                geometryType : geometryType,\r\n                boundingSphere : boundingSphere,\r\n                boundingSphereCV : boundingSphereCV,\r\n                indices : indices,\r\n                attributes : attributes,\r\n                offsetAttribute: offsetAttribute\r\n            });\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    function packInstancesForCombine(instances, transferableObjects) {\r\n        var length = instances.length;\r\n        var packedData = new Float64Array(1 + (length * 19));\r\n        var count = 0;\r\n        packedData[count++] = length;\r\n        for (var i = 0; i < length; i++) {\r\n            var instance = instances[i];\r\n            Matrix4.pack(instance.modelMatrix, packedData, count);\r\n            count += Matrix4.packedLength;\r\n            if (defined(instance.attributes) && defined(instance.attributes.offset)) {\r\n                var values = instance.attributes.offset.value;\r\n                packedData[count] = values[0];\r\n                packedData[count + 1] = values[1];\r\n                packedData[count + 2] = values[2];\r\n            }\r\n            count += 3;\r\n        }\r\n        transferableObjects.push(packedData.buffer);\r\n\r\n        return packedData;\r\n    }\r\n\r\n    function unpackInstancesForCombine(data) {\r\n        var packedInstances = data;\r\n        var result = new Array(packedInstances[0]);\r\n        var count = 0;\r\n\r\n        var i = 1;\r\n        while (i < packedInstances.length) {\r\n            var modelMatrix = Matrix4.unpack(packedInstances, i);\r\n            var attributes;\r\n            i += Matrix4.packedLength;\r\n            if (defined(packedInstances[i])) {\r\n                attributes = {\r\n                    offset : new OffsetGeometryInstanceAttribute(packedInstances[i], packedInstances[i + 1], packedInstances[i + 2])\r\n                };\r\n            }\r\n            i += 3;\r\n\r\n            result[count++] = {\r\n                modelMatrix : modelMatrix,\r\n                attributes : attributes\r\n            };\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    PrimitivePipeline.packCombineGeometryParameters = function(parameters, transferableObjects) {\r\n        var createGeometryResults = parameters.createGeometryResults;\r\n        var length = createGeometryResults.length;\r\n\r\n        for (var i = 0; i < length; i++) {\r\n            transferableObjects.push(createGeometryResults[i].packedData.buffer);\r\n        }\r\n\r\n        return {\r\n            createGeometryResults : parameters.createGeometryResults,\r\n            packedInstances : packInstancesForCombine(parameters.instances, transferableObjects),\r\n            ellipsoid : parameters.ellipsoid,\r\n            isGeographic : parameters.projection instanceof GeographicProjection,\r\n            elementIndexUintSupported : parameters.elementIndexUintSupported,\r\n            scene3DOnly : parameters.scene3DOnly,\r\n            vertexCacheOptimize : parameters.vertexCacheOptimize,\r\n            compressVertices : parameters.compressVertices,\r\n            modelMatrix : parameters.modelMatrix,\r\n            createPickOffsets : parameters.createPickOffsets\r\n        };\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    PrimitivePipeline.unpackCombineGeometryParameters = function(packedParameters) {\r\n        var instances = unpackInstancesForCombine(packedParameters.packedInstances);\r\n        var createGeometryResults = packedParameters.createGeometryResults;\r\n        var length = createGeometryResults.length;\r\n        var instanceIndex = 0;\r\n\r\n        for (var resultIndex = 0; resultIndex < length; resultIndex++) {\r\n            var geometries = PrimitivePipeline.unpackCreateGeometryResults(createGeometryResults[resultIndex]);\r\n            var geometriesLength = geometries.length;\r\n            for (var geometryIndex = 0; geometryIndex < geometriesLength; geometryIndex++) {\r\n                var geometry = geometries[geometryIndex];\r\n                var instance = instances[instanceIndex];\r\n                instance.geometry = geometry;\r\n                ++instanceIndex;\r\n            }\r\n        }\r\n\r\n        var ellipsoid = Ellipsoid.clone(packedParameters.ellipsoid);\r\n        var projection = packedParameters.isGeographic ? new GeographicProjection(ellipsoid) : new WebMercatorProjection(ellipsoid);\r\n\r\n        return {\r\n            instances : instances,\r\n            ellipsoid : ellipsoid,\r\n            projection : projection,\r\n            elementIndexUintSupported : packedParameters.elementIndexUintSupported,\r\n            scene3DOnly : packedParameters.scene3DOnly,\r\n            vertexCacheOptimize : packedParameters.vertexCacheOptimize,\r\n            compressVertices : packedParameters.compressVertices,\r\n            modelMatrix : Matrix4.clone(packedParameters.modelMatrix),\r\n            createPickOffsets : packedParameters.createPickOffsets\r\n        };\r\n    };\r\n\r\n    function packBoundingSpheres(boundingSpheres) {\r\n        var length = boundingSpheres.length;\r\n        var bufferLength = 1 + (BoundingSphere.packedLength + 1) * length;\r\n        var buffer = new Float32Array(bufferLength);\r\n\r\n        var bufferIndex = 0;\r\n        buffer[bufferIndex++] = length;\r\n\r\n        for (var i = 0; i < length; ++i) {\r\n            var bs = boundingSpheres[i];\r\n            if (!defined(bs)) {\r\n                buffer[bufferIndex++] = 0.0;\r\n            } else {\r\n                buffer[bufferIndex++] = 1.0;\r\n                BoundingSphere.pack(boundingSpheres[i], buffer, bufferIndex);\r\n            }\r\n            bufferIndex += BoundingSphere.packedLength;\r\n        }\r\n\r\n        return buffer;\r\n    }\r\n\r\n    function unpackBoundingSpheres(buffer) {\r\n        var result = new Array(buffer[0]);\r\n        var count = 0;\r\n\r\n        var i = 1;\r\n        while (i < buffer.length) {\r\n            if (buffer[i++] === 1.0) {\r\n                result[count] = BoundingSphere.unpack(buffer, i);\r\n            }\r\n            ++count;\r\n            i += BoundingSphere.packedLength;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    PrimitivePipeline.packCombineGeometryResults = function(results, transferableObjects) {\r\n        if (defined(results.geometries)) {\r\n            transferGeometries(results.geometries, transferableObjects);\r\n        }\r\n\r\n        var packedBoundingSpheres = packBoundingSpheres(results.boundingSpheres);\r\n        var packedBoundingSpheresCV = packBoundingSpheres(results.boundingSpheresCV);\r\n        transferableObjects.push(packedBoundingSpheres.buffer, packedBoundingSpheresCV.buffer);\r\n\r\n        return {\r\n            geometries : results.geometries,\r\n            attributeLocations : results.attributeLocations,\r\n            modelMatrix : results.modelMatrix,\r\n            pickOffsets : results.pickOffsets,\r\n            offsetInstanceExtend: results.offsetInstanceExtend,\r\n            boundingSpheres : packedBoundingSpheres,\r\n            boundingSpheresCV : packedBoundingSpheresCV\r\n        };\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    PrimitivePipeline.unpackCombineGeometryResults = function(packedResult) {\r\n        return {\r\n            geometries : packedResult.geometries,\r\n            attributeLocations : packedResult.attributeLocations,\r\n            modelMatrix : packedResult.modelMatrix,\r\n            pickOffsets : packedResult.pickOffsets,\r\n            offsetInstanceExtend: packedResult.offsetInstanceExtend,\r\n            boundingSpheres : unpackBoundingSpheres(packedResult.boundingSpheres),\r\n            boundingSpheresCV : unpackBoundingSpheres(packedResult.boundingSpheresCV)\r\n        };\r\n    };\r\nexport default PrimitivePipeline;\r\n"],"names":["OffsetGeometryInstanceAttribute","x","y","z","defaultValue","this","value","Float32Array","addGeometryBatchId","geometry","batchId","attributes","positionAttr","position","numberOfComponents","values","length","componentsPerAttribute","GeometryAttribute","componentDatatype","ComponentDatatype","FLOAT","j","geometryPipeline","parameters","i","primitiveType","instances","projection","uintIndexSupport","elementIndexUintSupported","scene3DOnly","vertexCacheOptimize","compressVertices","modelMatrix","defined","DeveloperError","primitiveModelMatrix","toWorld","Matrix4","equals","GeometryPipeline","transformToWorldCoordinates","multiplyTransformation","splitLongitude","instance","westHemisphereGeometry","eastHemisphereGeometry","addBatchIds","reorderForPostVertexCache","reorderForPreVertexCache","geometries","combineInstances","name","hasOwnProperty","DOUBLE","encodeAttribute","name3D","name2D","projectTo2D","boundingSphere","boundingSphereCV","BoundingSphere","fromVertices","position2D","splitGeometries","concat","fitToUnsignedShortIndices","createPickOffsets","geometryName","pickOffsets","offset","indexCount","geometryIndex","offsetIndex","pickOffset","count","index","indices","push","Object","defineProperties","prototype","get","normalize","fromCartesian3","Check","toValue","result","PrimitivePipeline","transferGeometry","transferableObjects","attribute","buffer","packInstancesForCombine","packedData","Float64Array","pack","packedLength","packBoundingSpheres","boundingSpheres","bufferLength","bufferIndex","bs","unpackBoundingSpheres","Array","unpack","combineGeometry","attributeLocations","offsetInstanceExtend","hasOffset","createAttributeLocations","createInstancePickOffsets","boundingSpheresCV","offsetAttribute","union","packCreateGeometryResults","items","property","countCreateGeometryResults","stringTable","stringHash","validGeometry","geometryType","validBoundingSphere","validBoundingSphereCV","attributesToWrite","q","set","indicesLength","unpackCreateGeometryResults","createGeometryResult","packedGeometry","resultIndex","packedGeometryIndex","undefined","GeometryAttributes","numAttributes","createTypedArray","valuesIndex","numberOfVertices","IndexDatatype","Geometry","packCombineGeometryParameters","createGeometryResults","packedInstances","ellipsoid","isGeographic","GeographicProjection","unpackCombineGeometryParameters","packedParameters","data","unpackInstancesForCombine","instanceIndex","geometriesLength","Ellipsoid","clone","WebMercatorProjection","packCombineGeometryResults","results","transferGeometries","packedBoundingSpheres","packedBoundingSpheresCV","unpackCombineGeometryResults","packedResult"],"mappings":"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"}