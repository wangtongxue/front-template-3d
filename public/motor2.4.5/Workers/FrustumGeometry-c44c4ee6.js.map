{"version":3,"file":"FrustumGeometry-c44c4ee6.js","sources":["../../../../Source/Core/CullingVolume.js","../../../../Source/Core/OrthographicOffCenterFrustum.js","../../../../Source/Core/OrthographicFrustum.js","../../../../Source/Core/PerspectiveOffCenterFrustum.js","../../../../Source/Core/PerspectiveFrustum.js","../../../../Source/Core/FrustumGeometry.js"],"sourcesContent":["import Cartesian3 from './Cartesian3.js';\r\nimport Cartesian4 from './Cartesian4.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport Intersect from './Intersect.js';\r\nimport Plane from './Plane.js';\r\n\r\n    /**\r\n     * The culling volume defined by planes.\r\n     *\r\n     * @alias CullingVolume\r\n     * @constructor\r\n     *\r\n     * @param {Cartesian4[]} [planes] An array of clipping planes.\r\n     */\r\n    function CullingVolume(planes) {\r\n        /**\r\n         * Each plane is represented by a Cartesian4 object, where the x, y, and z components\r\n         * define the unit vector normal to the plane, and the w component is the distance of the\r\n         * plane from the origin.\r\n         * @type {Cartesian4[]}\r\n         * @default []\r\n         */\r\n        this.planes = defaultValue(planes, []);\r\n    }\r\n\r\n    var faces = [new Cartesian3(), new Cartesian3(), new Cartesian3()];\r\n    Cartesian3.clone(Cartesian3.UNIT_X, faces[0]);\r\n    Cartesian3.clone(Cartesian3.UNIT_Y, faces[1]);\r\n    Cartesian3.clone(Cartesian3.UNIT_Z, faces[2]);\r\n\r\n    var scratchPlaneCenter = new Cartesian3();\r\n    var scratchPlaneNormal = new Cartesian3();\r\n    var scratchPlane = new Plane(new Cartesian3(1.0, 0.0, 0.0), 0.0);\r\n\r\n    /**\r\n     * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.\r\n     * The planes are aligned to the x, y, and z axes in world coordinates.\r\n     *\r\n     * @param {BoundingSphere} boundingSphere The bounding sphere used to create the culling volume.\r\n     * @param {CullingVolume} [result] The object onto which to store the result.\r\n     * @returns {CullingVolume} The culling volume created from the bounding sphere.\r\n     */\r\n    CullingVolume.fromBoundingSphere = function(boundingSphere, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(boundingSphere)) {\r\n            throw new DeveloperError('boundingSphere is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            result = new CullingVolume();\r\n        }\r\n\r\n        var length = faces.length;\r\n        var planes = result.planes;\r\n        planes.length = 2 * length;\r\n\r\n        var center = boundingSphere.center;\r\n        var radius = boundingSphere.radius;\r\n\r\n        var planeIndex = 0;\r\n\r\n        for (var i = 0; i < length; ++i) {\r\n            var faceNormal = faces[i];\r\n\r\n            var plane0 = planes[planeIndex];\r\n            var plane1 = planes[planeIndex + 1];\r\n\r\n            if (!defined(plane0)) {\r\n                plane0 = planes[planeIndex] = new Cartesian4();\r\n            }\r\n            if (!defined(plane1)) {\r\n                plane1 = planes[planeIndex + 1] = new Cartesian4();\r\n            }\r\n\r\n            Cartesian3.multiplyByScalar(faceNormal, -radius, scratchPlaneCenter);\r\n            Cartesian3.add(center, scratchPlaneCenter, scratchPlaneCenter);\r\n\r\n            plane0.x = faceNormal.x;\r\n            plane0.y = faceNormal.y;\r\n            plane0.z = faceNormal.z;\r\n            plane0.w = -Cartesian3.dot(faceNormal, scratchPlaneCenter);\r\n\r\n            Cartesian3.multiplyByScalar(faceNormal, radius, scratchPlaneCenter);\r\n            Cartesian3.add(center, scratchPlaneCenter, scratchPlaneCenter);\r\n\r\n            plane1.x = -faceNormal.x;\r\n            plane1.y = -faceNormal.y;\r\n            plane1.z = -faceNormal.z;\r\n            plane1.w = -Cartesian3.dot(Cartesian3.negate(faceNormal, scratchPlaneNormal), scratchPlaneCenter);\r\n\r\n            planeIndex += 2;\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Determines whether a bounding volume intersects the culling volume.\r\n     *\r\n     * @param {Object} boundingVolume The bounding volume whose intersection with the culling volume is to be tested.\r\n     * @returns {Intersect}  Intersect.OUTSIDE, Intersect.INTERSECTING, or Intersect.INSIDE.\r\n     */\r\n    CullingVolume.prototype.computeVisibility = function(boundingVolume) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(boundingVolume)) {\r\n            throw new DeveloperError('boundingVolume is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var planes = this.planes;\r\n        var intersecting = false;\r\n        for (var k = 0, len = planes.length; k < len; ++k) {\r\n            var result = boundingVolume.intersectPlane(Plane.fromCartesian4(planes[k], scratchPlane));\r\n            if (result === Intersect.OUTSIDE) {\r\n                return Intersect.OUTSIDE;\r\n            } else if (result === Intersect.INTERSECTING) {\r\n                intersecting = true;\r\n            }\r\n        }\r\n\r\n        return intersecting ? Intersect.INTERSECTING : Intersect.INSIDE;\r\n    };\r\n\r\n    /**\r\n     * Determines whether a bounding volume intersects the culling volume.\r\n     *\r\n     * @param {Object} boundingVolume The bounding volume whose intersection with the culling volume is to be tested.\r\n     * @param {Number} parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling\r\n     *                                 volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then\r\n     *                                 the parent (and therefore this) volume is completely inside plane[planeIndex]\r\n     *                                 and that plane check can be skipped.\r\n     * @returns {Number} A plane mask as described above (which can be applied to this boundingVolume's children).\r\n     *\r\n     * @private\r\n     */\r\n    CullingVolume.prototype.computeVisibilityWithPlaneMask = function(boundingVolume, parentPlaneMask) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(boundingVolume)) {\r\n            throw new DeveloperError('boundingVolume is required.');\r\n        }\r\n        if (!defined(parentPlaneMask)) {\r\n            throw new DeveloperError('parentPlaneMask is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        if (parentPlaneMask === CullingVolume.MASK_OUTSIDE || parentPlaneMask === CullingVolume.MASK_INSIDE) {\r\n            // parent is completely outside or completely inside, so this child is as well.\r\n            return parentPlaneMask;\r\n        }\r\n\r\n        // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.\r\n        // (Because if there are fewer than 31 planes, the upper bits wont be changed.)\r\n        var mask = CullingVolume.MASK_INSIDE;\r\n\r\n        var planes = this.planes;\r\n        for (var k = 0, len = planes.length; k < len; ++k) {\r\n            // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.\r\n            var flag = (k < 31) ? (1 << k) : 0;\r\n            if (k < 31 && (parentPlaneMask & flag) === 0) {\r\n                // boundingVolume is known to be INSIDE this plane.\r\n                continue;\r\n            }\r\n\r\n            var result = boundingVolume.intersectPlane(Plane.fromCartesian4(planes[k], scratchPlane));\r\n            if (result === Intersect.OUTSIDE) {\r\n                return CullingVolume.MASK_OUTSIDE;\r\n            } else if (result === Intersect.INTERSECTING) {\r\n                mask |= flag;\r\n            }\r\n        }\r\n\r\n        return mask;\r\n    };\r\n\r\n    /**\r\n     * For plane masks (as used in {@link CullingVolume#computeVisibilityWithPlaneMask}), this special value\r\n     * represents the case where the object bounding volume is entirely outside the culling volume.\r\n     *\r\n     * @type {Number}\r\n     * @private\r\n     */\r\n    CullingVolume.MASK_OUTSIDE = 0xffffffff;\r\n\r\n    /**\r\n     * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\r\n     * represents the case where the object bounding volume is entirely inside the culling volume.\r\n     *\r\n     * @type {Number}\r\n     * @private\r\n     */\r\n    CullingVolume.MASK_INSIDE = 0x00000000;\r\n\r\n    /**\r\n     * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\r\n     * represents the case where the object bounding volume (may) intersect all planes of the culling volume.\r\n     *\r\n     * @type {Number}\r\n     * @private\r\n     */\r\n    CullingVolume.MASK_INDETERMINATE = 0x7fffffff;\r\nexport default CullingVolume;\r\n","import Cartesian3 from './Cartesian3.js';\r\nimport Cartesian4 from './Cartesian4.js';\r\nimport CullingVolume from './CullingVolume.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport CesiumMath from './Math.js';\r\nimport Matrix4 from './Matrix4.js';\r\n\r\n    /**\r\n     * The viewing frustum is defined by 6 planes.\r\n     * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\r\n     * define the unit vector normal to the plane, and the w component is the distance of the\r\n     * plane from the origin/camera position.\r\n     *\r\n     * @alias OrthographicOffCenterFrustum\r\n     * @constructor\r\n     *\r\n     * @param {Object} [options] An object with the following properties:\r\n     * @param {Number} [options.left] The left clipping plane distance.\r\n     * @param {Number} [options.right] The right clipping plane distance.\r\n     * @param {Number} [options.top] The top clipping plane distance.\r\n     * @param {Number} [options.bottom] The bottom clipping plane distance.\r\n     * @param {Number} [options.near=1.0] The near clipping plane distance.\r\n     * @param {Number} [options.far=500000000.0] The far clipping plane distance.\r\n     *\r\n     * @example\r\n     * var maxRadii = ellipsoid.maximumRadius;\r\n     *\r\n     * var frustum = new Cesium.OrthographicOffCenterFrustum();\r\n     * frustum.right = maxRadii * Cesium.Math.PI;\r\n     * frustum.left = -c.frustum.right;\r\n     * frustum.top = c.frustum.right * (canvas.clientHeight / canvas.clientWidth);\r\n     * frustum.bottom = -c.frustum.top;\r\n     * frustum.near = 0.01 * maxRadii;\r\n     * frustum.far = 50.0 * maxRadii;\r\n     */\r\n    function OrthographicOffCenterFrustum(options) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n        /**\r\n         * The left clipping plane.\r\n         * @type {Number}\r\n         * @default undefined\r\n         */\r\n        this.left = options.left;\r\n        this._left = undefined;\r\n\r\n        /**\r\n         * The right clipping plane.\r\n         * @type {Number}\r\n         * @default undefined\r\n         */\r\n        this.right = options.right;\r\n        this._right = undefined;\r\n\r\n        /**\r\n         * The top clipping plane.\r\n         * @type {Number}\r\n         * @default undefined\r\n         */\r\n        this.top = options.top;\r\n        this._top = undefined;\r\n\r\n        /**\r\n         * The bottom clipping plane.\r\n         * @type {Number}\r\n         * @default undefined\r\n         */\r\n        this.bottom = options.bottom;\r\n        this._bottom = undefined;\r\n\r\n        /**\r\n         * The distance of the near plane.\r\n         * @type {Number}\r\n         * @default 1.0\r\n         */\r\n        this.near = defaultValue(options.near, 1.0);\r\n        this._near = this.near;\r\n\r\n        /**\r\n         * The distance of the far plane.\r\n         * @type {Number}\r\n         * @default 500000000.0;\r\n         */\r\n        this.far = defaultValue(options.far, 500000000.0);\r\n        this._far = this.far;\r\n\r\n        this._cullingVolume = new CullingVolume();\r\n        this._orthographicMatrix = new Matrix4();\r\n    }\r\n\r\n    function update(frustum) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(frustum.right) || !defined(frustum.left) ||\r\n            !defined(frustum.top) || !defined(frustum.bottom) ||\r\n            !defined(frustum.near) || !defined(frustum.far)) {\r\n            throw new DeveloperError('right, left, top, bottom, near, or far parameters are not set.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        if (frustum.top !== frustum._top || frustum.bottom !== frustum._bottom ||\r\n            frustum.left !== frustum._left || frustum.right !== frustum._right ||\r\n            frustum.near !== frustum._near || frustum.far !== frustum._far) {\r\n\r\n            //>>includeStart('debug', pragmas.debug);\r\n            if (frustum.left > frustum.right) {\r\n                throw new DeveloperError('right must be greater than left.');\r\n            }\r\n            if (frustum.bottom > frustum.top) {\r\n                throw new DeveloperError('top must be greater than bottom.');\r\n            }\r\n            if (frustum.near <= 0 || frustum.near > frustum.far) {\r\n                throw new DeveloperError('near must be greater than zero and less than far.');\r\n            }\r\n            //>>includeEnd('debug');\r\n\r\n            frustum._left = frustum.left;\r\n            frustum._right = frustum.right;\r\n            frustum._top = frustum.top;\r\n            frustum._bottom = frustum.bottom;\r\n            frustum._near = frustum.near;\r\n            frustum._far = frustum.far;\r\n            frustum._orthographicMatrix = Matrix4.computeOrthographicOffCenter(frustum.left, frustum.right, frustum.bottom, frustum.top, frustum.near, frustum.far, frustum._orthographicMatrix);\r\n        }\r\n    }\r\n\r\n    Object.defineProperties(OrthographicOffCenterFrustum.prototype, {\r\n        /**\r\n         * Gets the orthographic projection matrix computed from the view frustum.\r\n         * @memberof OrthographicOffCenterFrustum.prototype\r\n         * @type {Matrix4}\r\n         * @readonly\r\n         */\r\n        projectionMatrix : {\r\n            get : function() {\r\n                update(this);\r\n                return this._orthographicMatrix;\r\n            }\r\n        }\r\n    });\r\n\r\n    var getPlanesRight = new Cartesian3();\r\n    var getPlanesNearCenter = new Cartesian3();\r\n    var getPlanesPoint = new Cartesian3();\r\n    var negateScratch = new Cartesian3();\r\n\r\n    /**\r\n     * Creates a culling volume for this frustum.\r\n     *\r\n     * @param {Cartesian3} position The eye position.\r\n     * @param {Cartesian3} direction The view direction.\r\n     * @param {Cartesian3} up The up direction.\r\n     * @returns {CullingVolume} A culling volume at the given position and orientation.\r\n     *\r\n     * @example\r\n     * // Check if a bounding volume intersects the frustum.\r\n     * var cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\r\n     * var intersect = cullingVolume.computeVisibility(boundingVolume);\r\n     */\r\n    OrthographicOffCenterFrustum.prototype.computeCullingVolume = function(position, direction, up) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(position)) {\r\n            throw new DeveloperError('position is required.');\r\n        }\r\n        if (!defined(direction)) {\r\n            throw new DeveloperError('direction is required.');\r\n        }\r\n        if (!defined(up)) {\r\n            throw new DeveloperError('up is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var planes = this._cullingVolume.planes;\r\n        var t = this.top;\r\n        var b = this.bottom;\r\n        var r = this.right;\r\n        var l = this.left;\r\n        var n = this.near;\r\n        var f = this.far;\r\n\r\n        var right = Cartesian3.cross(direction, up, getPlanesRight);\r\n        Cartesian3.normalize(right, right);\r\n        var nearCenter = getPlanesNearCenter;\r\n        Cartesian3.multiplyByScalar(direction, n, nearCenter);\r\n        Cartesian3.add(position, nearCenter, nearCenter);\r\n\r\n        var point = getPlanesPoint;\r\n\r\n        // Left plane\r\n        Cartesian3.multiplyByScalar(right, l, point);\r\n        Cartesian3.add(nearCenter, point, point);\r\n\r\n        var plane = planes[0];\r\n        if (!defined(plane)) {\r\n            plane = planes[0] = new Cartesian4();\r\n        }\r\n        plane.x = right.x;\r\n        plane.y = right.y;\r\n        plane.z = right.z;\r\n        plane.w = -Cartesian3.dot(right, point);\r\n\r\n        // Right plane\r\n        Cartesian3.multiplyByScalar(right, r, point);\r\n        Cartesian3.add(nearCenter, point, point);\r\n\r\n        plane = planes[1];\r\n        if (!defined(plane)) {\r\n            plane = planes[1] = new Cartesian4();\r\n        }\r\n        plane.x = -right.x;\r\n        plane.y = -right.y;\r\n        plane.z = -right.z;\r\n        plane.w = -Cartesian3.dot(Cartesian3.negate(right, negateScratch), point);\r\n\r\n        // Bottom plane\r\n        Cartesian3.multiplyByScalar(up, b, point);\r\n        Cartesian3.add(nearCenter, point, point);\r\n\r\n        plane = planes[2];\r\n        if (!defined(plane)) {\r\n            plane = planes[2] = new Cartesian4();\r\n        }\r\n        plane.x = up.x;\r\n        plane.y = up.y;\r\n        plane.z = up.z;\r\n        plane.w = -Cartesian3.dot(up, point);\r\n\r\n        // Top plane\r\n        Cartesian3.multiplyByScalar(up, t, point);\r\n        Cartesian3.add(nearCenter, point, point);\r\n\r\n        plane = planes[3];\r\n        if (!defined(plane)) {\r\n            plane = planes[3] = new Cartesian4();\r\n        }\r\n        plane.x = -up.x;\r\n        plane.y = -up.y;\r\n        plane.z = -up.z;\r\n        plane.w = -Cartesian3.dot(Cartesian3.negate(up, negateScratch), point);\r\n\r\n        // Near plane\r\n        plane = planes[4];\r\n        if (!defined(plane)) {\r\n            plane = planes[4] = new Cartesian4();\r\n        }\r\n        plane.x = direction.x;\r\n        plane.y = direction.y;\r\n        plane.z = direction.z;\r\n        plane.w = -Cartesian3.dot(direction, nearCenter);\r\n\r\n        // Far plane\r\n        Cartesian3.multiplyByScalar(direction, f, point);\r\n        Cartesian3.add(position, point, point);\r\n\r\n        plane = planes[5];\r\n        if (!defined(plane)) {\r\n            plane = planes[5] = new Cartesian4();\r\n        }\r\n        plane.x = -direction.x;\r\n        plane.y = -direction.y;\r\n        plane.z = -direction.z;\r\n        plane.w = -Cartesian3.dot(Cartesian3.negate(direction, negateScratch), point);\r\n\r\n        return this._cullingVolume;\r\n    };\r\n\r\n    /**\r\n     * Returns the pixel's width and height in meters.\r\n     *\r\n     * @param {Number} drawingBufferWidth The width of the drawing buffer.\r\n     * @param {Number} drawingBufferHeight The height of the drawing buffer.\r\n     * @param {Number} distance The distance to the near plane in meters.\r\n     * @param {Number} pixelRatio The scaling factor from pixel space to coordinate space.\r\n     * @param {Cartesian2} result The object onto which to store the result.\r\n     * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\r\n     *\r\n     * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\r\n     * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\r\n     * @exception {DeveloperError} pixelRatio must be greater than zero.\r\n     *\r\n     * @example\r\n     * // Example 1\r\n     * // Get the width and height of a pixel.\r\n     * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 0.0, scene.pixelRatio, new Cesium.Cartesian2());\r\n     */\r\n    OrthographicOffCenterFrustum.prototype.getPixelDimensions = function(drawingBufferWidth, drawingBufferHeight, distance, pixelRatio, result) {\r\n        update(this);\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(drawingBufferWidth) || !defined(drawingBufferHeight)) {\r\n            throw new DeveloperError('Both drawingBufferWidth and drawingBufferHeight are required.');\r\n        }\r\n        if (drawingBufferWidth <= 0) {\r\n            throw new DeveloperError('drawingBufferWidth must be greater than zero.');\r\n        }\r\n        if (drawingBufferHeight <= 0) {\r\n            throw new DeveloperError('drawingBufferHeight must be greater than zero.');\r\n        }\r\n        if (!defined(distance)) {\r\n            throw new DeveloperError('distance is required.');\r\n        }\r\n        if (!defined(pixelRatio)) {\r\n            throw new DeveloperError('pixelRatio is required.');\r\n        }\r\n        if (pixelRatio <= 0) {\r\n            throw new DeveloperError('pixelRatio must be greater than zero.');\r\n        }\r\n        if (!defined(result)) {\r\n            throw new DeveloperError('A result object is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var frustumWidth = this.right - this.left;\r\n        var frustumHeight = this.top - this.bottom;\r\n        var pixelWidth = pixelRatio * frustumWidth / drawingBufferWidth;\r\n        var pixelHeight = pixelRatio * frustumHeight / drawingBufferHeight;\r\n\r\n        result.x = pixelWidth;\r\n        result.y = pixelHeight;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Returns a duplicate of a OrthographicOffCenterFrustum instance.\r\n     *\r\n     * @param {OrthographicOffCenterFrustum} [result] The object onto which to store the result.\r\n     * @returns {OrthographicOffCenterFrustum} The modified result parameter or a new OrthographicOffCenterFrustum instance if one was not provided.\r\n     */\r\n    OrthographicOffCenterFrustum.prototype.clone = function(result) {\r\n        if (!defined(result)) {\r\n            result = new OrthographicOffCenterFrustum();\r\n        }\r\n\r\n        result.left = this.left;\r\n        result.right = this.right;\r\n        result.top = this.top;\r\n        result.bottom = this.bottom;\r\n        result.near = this.near;\r\n        result.far = this.far;\r\n\r\n        // force update of clone to compute matrices\r\n        result._left = undefined;\r\n        result._right = undefined;\r\n        result._top = undefined;\r\n        result._bottom = undefined;\r\n        result._near = undefined;\r\n        result._far = undefined;\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Compares the provided OrthographicOffCenterFrustum componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {OrthographicOffCenterFrustum} [other] The right hand side OrthographicOffCenterFrustum.\r\n     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     */\r\n    OrthographicOffCenterFrustum.prototype.equals = function(other) {\r\n        return (defined(other) && other instanceof OrthographicOffCenterFrustum &&\r\n                this.right === other.right &&\r\n                this.left === other.left &&\r\n                this.top === other.top &&\r\n                this.bottom === other.bottom &&\r\n                this.near === other.near &&\r\n                this.far === other.far);\r\n    };\r\n\r\n    /**\r\n     * Compares the provided OrthographicOffCenterFrustum componentwise and returns\r\n     * <code>true</code> if they pass an absolute or relative tolerance test,\r\n     * <code>false</code> otherwise.\r\n     *\r\n     * @param {OrthographicOffCenterFrustum} other The right hand side OrthographicOffCenterFrustum.\r\n     * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\r\n     * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\r\n     * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\r\n     */\r\n    OrthographicOffCenterFrustum.prototype.equalsEpsilon = function(other, relativeEpsilon, absoluteEpsilon) {\r\n        return (other === this) ||\r\n               (defined(other) &&\r\n                other instanceof OrthographicOffCenterFrustum &&\r\n                CesiumMath.equalsEpsilon(this.right, other.right, relativeEpsilon, absoluteEpsilon) &&\r\n                CesiumMath.equalsEpsilon(this.left, other.left, relativeEpsilon, absoluteEpsilon) &&\r\n                CesiumMath.equalsEpsilon(this.top, other.top, relativeEpsilon, absoluteEpsilon) &&\r\n                CesiumMath.equalsEpsilon(this.bottom, other.bottom, relativeEpsilon, absoluteEpsilon) &&\r\n                CesiumMath.equalsEpsilon(this.near, other.near, relativeEpsilon, absoluteEpsilon) &&\r\n                CesiumMath.equalsEpsilon(this.far, other.far, relativeEpsilon, absoluteEpsilon));\r\n    };\r\nexport default OrthographicOffCenterFrustum;\r\n","import Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport CesiumMath from './Math.js';\r\nimport OrthographicOffCenterFrustum from './OrthographicOffCenterFrustum.js';\r\n\r\n    /**\r\n     * The viewing frustum is defined by 6 planes.\r\n     * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\r\n     * define the unit vector normal to the plane, and the w component is the distance of the\r\n     * plane from the origin/camera position.\r\n     *\r\n     * @alias OrthographicFrustum\r\n     * @constructor\r\n     *\r\n     * @param {Object} [options] An object with the following properties:\r\n     * @param {Number} [options.width] The width of the frustum in meters.\r\n     * @param {Number} [options.aspectRatio] The aspect ratio of the frustum's width to it's height.\r\n     * @param {Number} [options.near=1.0] The distance of the near plane.\r\n     * @param {Number} [options.far=500000000.0] The distance of the far plane.\r\n     *\r\n     * @example\r\n     * var maxRadii = ellipsoid.maximumRadius;\r\n     *\r\n     * var frustum = new Cesium.OrthographicFrustum();\r\n     * frustum.near = 0.01 * maxRadii;\r\n     * frustum.far = 50.0 * maxRadii;\r\n     */\r\n    function OrthographicFrustum(options) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n        this._offCenterFrustum = new OrthographicOffCenterFrustum();\r\n\r\n        /**\r\n         * The horizontal width of the frustum in meters.\r\n         * @type {Number}\r\n         * @default undefined\r\n         */\r\n        this.width = options.width;\r\n        this._width = undefined;\r\n\r\n        /**\r\n         * The aspect ratio of the frustum's width to it's height.\r\n         * @type {Number}\r\n         * @default undefined\r\n         */\r\n        this.aspectRatio = options.aspectRatio;\r\n        this._aspectRatio = undefined;\r\n\r\n        /**\r\n         * The distance of the near plane.\r\n         * @type {Number}\r\n         * @default 1.0\r\n         */\r\n        this.near = defaultValue(options.near, 1.0);\r\n        this._near = this.near;\r\n\r\n        /**\r\n         * The distance of the far plane.\r\n         * @type {Number}\r\n         * @default 500000000.0;\r\n         */\r\n        this.far = defaultValue(options.far, 500000000.0);\r\n        this._far = this.far;\r\n    }\r\n\r\n    /**\r\n     * The number of elements used to pack the object into an array.\r\n     * @type {Number}\r\n     */\r\n    OrthographicFrustum.packedLength = 4;\r\n\r\n    /**\r\n     * Stores the provided instance into the provided array.\r\n     *\r\n     * @param {OrthographicFrustum} value The value to pack.\r\n     * @param {Number[]} array The array to pack into.\r\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n     *\r\n     * @returns {Number[]} The array that was packed into\r\n     */\r\n    OrthographicFrustum.pack = function(value, array, startingIndex) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('value', value);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        array[startingIndex++] = value.width;\r\n        array[startingIndex++] = value.aspectRatio;\r\n        array[startingIndex++] = value.near;\r\n        array[startingIndex] = value.far;\r\n\r\n        return array;\r\n    };\r\n\r\n    /**\r\n     * Retrieves an instance from a packed array.\r\n     *\r\n     * @param {Number[]} array The packed array.\r\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n     * @param {OrthographicFrustum} [result] The object into which to store the result.\r\n     * @returns {OrthographicFrustum} The modified result parameter or a new OrthographicFrustum instance if one was not provided.\r\n     */\r\n    OrthographicFrustum.unpack = function(array, startingIndex, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        if (!defined(result)) {\r\n            result = new OrthographicFrustum();\r\n        }\r\n\r\n        result.width = array[startingIndex++];\r\n        result.aspectRatio = array[startingIndex++];\r\n        result.near = array[startingIndex++];\r\n        result.far = array[startingIndex];\r\n\r\n        return result;\r\n    };\r\n\r\n    function update(frustum) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(frustum.width) || !defined(frustum.aspectRatio) || !defined(frustum.near) || !defined(frustum.far)) {\r\n            throw new DeveloperError('width, aspectRatio, near, or far parameters are not set.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var f = frustum._offCenterFrustum;\r\n\r\n        if (frustum.width !== frustum._width || frustum.aspectRatio !== frustum._aspectRatio ||\r\n            frustum.near !== frustum._near || frustum.far !== frustum._far) {\r\n            //>>includeStart('debug', pragmas.debug);\r\n            if (frustum.aspectRatio < 0) {\r\n                throw new DeveloperError('aspectRatio must be positive.');\r\n            }\r\n            if (frustum.near < 0 || frustum.near > frustum.far) {\r\n                throw new DeveloperError('near must be greater than zero and less than far.');\r\n            }\r\n            //>>includeEnd('debug');\r\n\r\n            frustum._aspectRatio = frustum.aspectRatio;\r\n            frustum._width = frustum.width;\r\n            frustum._near = frustum.near;\r\n            frustum._far = frustum.far;\r\n\r\n            var ratio = 1.0 / frustum.aspectRatio;\r\n            f.right = frustum.width * 0.5;\r\n            f.left = -f.right;\r\n            f.top = ratio * f.right;\r\n            f.bottom = -f.top;\r\n            f.near = frustum.near;\r\n            f.far = frustum.far;\r\n\r\n        }\r\n    }\r\n\r\n    Object.defineProperties(OrthographicFrustum.prototype, {\r\n        /**\r\n         * Gets the orthographic projection matrix computed from the view frustum.\r\n         * @memberof OrthographicFrustum.prototype\r\n         * @type {Matrix4}\r\n         * @readonly\r\n         */\r\n        projectionMatrix : {\r\n            get : function() {\r\n                update(this);\r\n                return this._offCenterFrustum.projectionMatrix;\r\n            }\r\n        }\r\n\r\n    });\r\n\r\n    /**\r\n     * Creates a culling volume for this frustum.\r\n     *\r\n     * @param {Cartesian3} position The eye position.\r\n     * @param {Cartesian3} direction The view direction.\r\n     * @param {Cartesian3} up The up direction.\r\n     * @returns {CullingVolume} A culling volume at the given position and orientation.\r\n     *\r\n     * @example\r\n     * // Check if a bounding volume intersects the frustum.\r\n     * var cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\r\n     * var intersect = cullingVolume.computeVisibility(boundingVolume);\r\n     */\r\n    OrthographicFrustum.prototype.computeCullingVolume = function(position, direction, up) {\r\n        update(this);\r\n        return this._offCenterFrustum.computeCullingVolume(position, direction, up);\r\n    };\r\n\r\n    /**\r\n     * Returns the pixel's width and height in meters.\r\n     *\r\n     * @param {Number} drawingBufferWidth The width of the drawing buffer.\r\n     * @param {Number} drawingBufferHeight The height of the drawing buffer.\r\n     * @param {Number} distance The distance to the near plane in meters.\r\n     * @param {Number} pixelRatio The scaling factor from pixel space to coordinate space.\r\n     * @param {Cartesian2} result The object onto which to store the result.\r\n     * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\r\n     *\r\n     * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\r\n     * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\r\n     * @exception {DeveloperError} pixelRatio must be greater than zero.\r\n     *\r\n     * @example\r\n     * // Example 1\r\n     * // Get the width and height of a pixel.\r\n     * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 0.0, scene.pixelRatio, new Cesium.Cartesian2());\r\n     */\r\n    OrthographicFrustum.prototype.getPixelDimensions = function(drawingBufferWidth, drawingBufferHeight, distance, pixelRatio, result) {\r\n        update(this);\r\n        return this._offCenterFrustum.getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, pixelRatio, result);\r\n    };\r\n\r\n    /**\r\n     * Returns a duplicate of a OrthographicFrustum instance.\r\n     *\r\n     * @param {OrthographicFrustum} [result] The object onto which to store the result.\r\n     * @returns {OrthographicFrustum} The modified result parameter or a new OrthographicFrustum instance if one was not provided.\r\n     */\r\n    OrthographicFrustum.prototype.clone = function(result) {\r\n        if (!defined(result)) {\r\n            result = new OrthographicFrustum();\r\n        }\r\n\r\n        result.aspectRatio = this.aspectRatio;\r\n        result.width = this.width;\r\n        result.near = this.near;\r\n        result.far = this.far;\r\n\r\n        // force update of clone to compute matrices\r\n        result._aspectRatio = undefined;\r\n        result._width = undefined;\r\n        result._near = undefined;\r\n        result._far = undefined;\r\n\r\n        this._offCenterFrustum.clone(result._offCenterFrustum);\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Compares the provided OrthographicFrustum componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {OrthographicFrustum} [other] The right hand side OrthographicFrustum.\r\n     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     */\r\n    OrthographicFrustum.prototype.equals = function(other) {\r\n        if (!defined(other) || !(other instanceof OrthographicFrustum)) {\r\n            return false;\r\n        }\r\n\r\n        update(this);\r\n        update(other);\r\n\r\n        return (this.width === other.width &&\r\n                this.aspectRatio === other.aspectRatio &&\r\n                this._offCenterFrustum.equals(other._offCenterFrustum));\r\n    };\r\n\r\n    /**\r\n     * Compares the provided OrthographicFrustum componentwise and returns\r\n     * <code>true</code> if they pass an absolute or relative tolerance test,\r\n     * <code>false</code> otherwise.\r\n     *\r\n     * @param {OrthographicFrustum} other The right hand side OrthographicFrustum.\r\n     * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\r\n     * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\r\n     * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\r\n     */\r\n    OrthographicFrustum.prototype.equalsEpsilon = function(other, relativeEpsilon, absoluteEpsilon) {\r\n        if (!defined(other) || !(other instanceof OrthographicFrustum)) {\r\n            return false;\r\n        }\r\n\r\n        update(this);\r\n        update(other);\r\n\r\n        return (CesiumMath.equalsEpsilon(this.width, other.width, relativeEpsilon, absoluteEpsilon) &&\r\n                CesiumMath.equalsEpsilon(this.aspectRatio, other.aspectRatio, relativeEpsilon, absoluteEpsilon) &&\r\n                this._offCenterFrustum.equalsEpsilon(other._offCenterFrustum, relativeEpsilon, absoluteEpsilon));\r\n    };\r\nexport default OrthographicFrustum;\r\n","import Cartesian3 from './Cartesian3.js';\r\nimport Cartesian4 from './Cartesian4.js';\r\nimport CullingVolume from './CullingVolume.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport CesiumMath from './Math.js';\r\nimport Matrix4 from './Matrix4.js';\r\n\r\n    /**\r\n     * The viewing frustum is defined by 6 planes.\r\n     * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\r\n     * define the unit vector normal to the plane, and the w component is the distance of the\r\n     * plane from the origin/camera position.\r\n     *\r\n     * @alias PerspectiveOffCenterFrustum\r\n     * @constructor\r\n     *\r\n     * @param {Object} [options] An object with the following properties:\r\n     * @param {Number} [options.left] The left clipping plane distance.\r\n     * @param {Number} [options.right] The right clipping plane distance.\r\n     * @param {Number} [options.top] The top clipping plane distance.\r\n     * @param {Number} [options.bottom] The bottom clipping plane distance.\r\n     * @param {Number} [options.near=1.0] The near clipping plane distance.\r\n     * @param {Number} [options.far=500000000.0] The far clipping plane distance.\r\n     *\r\n     * @example\r\n     * var frustum = new Cesium.PerspectiveOffCenterFrustum({\r\n     *     left : -1.0,\r\n     *     right : 1.0,\r\n     *     top : 1.0,\r\n     *     bottom : -1.0,\r\n     *     near : 1.0,\r\n     *     far : 100.0\r\n     * });\r\n     *\r\n     * @see PerspectiveFrustum\r\n     */\r\n    function PerspectiveOffCenterFrustum(options) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n        /**\r\n         * Defines the left clipping plane.\r\n         * @type {Number}\r\n         * @default undefined\r\n         */\r\n        this.left = options.left;\r\n        this._left = undefined;\r\n\r\n        /**\r\n         * Defines the right clipping plane.\r\n         * @type {Number}\r\n         * @default undefined\r\n         */\r\n        this.right = options.right;\r\n        this._right = undefined;\r\n\r\n        /**\r\n         * Defines the top clipping plane.\r\n         * @type {Number}\r\n         * @default undefined\r\n         */\r\n        this.top = options.top;\r\n        this._top = undefined;\r\n\r\n        /**\r\n         * Defines the bottom clipping plane.\r\n         * @type {Number}\r\n         * @default undefined\r\n         */\r\n        this.bottom = options.bottom;\r\n        this._bottom = undefined;\r\n\r\n        /**\r\n         * The distance of the near plane.\r\n         * @type {Number}\r\n         * @default 1.0\r\n         */\r\n        this.near = defaultValue(options.near, 1.0);\r\n        this._near = this.near;\r\n\r\n        /**\r\n         * The distance of the far plane.\r\n         * @type {Number}\r\n         * @default 500000000.0\r\n         */\r\n        this.far = defaultValue(options.far, 500000000.0);\r\n        this._far = this.far;\r\n\r\n        this._cullingVolume = new CullingVolume();\r\n        this._perspectiveMatrix = new Matrix4();\r\n        this._infinitePerspective = new Matrix4();\r\n    }\r\n\r\n    function update(frustum) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(frustum.right) || !defined(frustum.left) ||\r\n            !defined(frustum.top) || !defined(frustum.bottom) ||\r\n            !defined(frustum.near) || !defined(frustum.far)) {\r\n            throw new DeveloperError('right, left, top, bottom, near, or far parameters are not set.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var t = frustum.top;\r\n        var b = frustum.bottom;\r\n        var r = frustum.right;\r\n        var l = frustum.left;\r\n        var n = frustum.near;\r\n        var f = frustum.far;\r\n\r\n        if (t !== frustum._top || b !== frustum._bottom ||\r\n            l !== frustum._left || r !== frustum._right ||\r\n            n !== frustum._near || f !== frustum._far) {\r\n\r\n            //>>includeStart('debug', pragmas.debug);\r\n            if (frustum.near <= 0 || frustum.near > frustum.far) {\r\n                throw new DeveloperError('near must be greater than zero and less than far.');\r\n            }\r\n            //>>includeEnd('debug');\r\n\r\n            frustum._left = l;\r\n            frustum._right = r;\r\n            frustum._top = t;\r\n            frustum._bottom = b;\r\n            frustum._near = n;\r\n            frustum._far = f;\r\n            frustum._perspectiveMatrix = Matrix4.computePerspectiveOffCenter(l, r, b, t, n, f, frustum._perspectiveMatrix);\r\n            frustum._infinitePerspective = Matrix4.computeInfinitePerspectiveOffCenter(l, r, b, t, n, frustum._infinitePerspective);\r\n        }\r\n    }\r\n\r\n    Object.defineProperties(PerspectiveOffCenterFrustum.prototype, {\r\n        /**\r\n         * Gets the perspective projection matrix computed from the view frustum.\r\n         * @memberof PerspectiveOffCenterFrustum.prototype\r\n         * @type {Matrix4}\r\n         * @readonly\r\n         *\r\n         * @see PerspectiveOffCenterFrustum#infiniteProjectionMatrix\r\n         */\r\n        projectionMatrix : {\r\n            get : function() {\r\n                update(this);\r\n                return this._perspectiveMatrix;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Gets the perspective projection matrix computed from the view frustum with an infinite far plane.\r\n         * @memberof PerspectiveOffCenterFrustum.prototype\r\n         * @type {Matrix4}\r\n         * @readonly\r\n         *\r\n         * @see PerspectiveOffCenterFrustum#projectionMatrix\r\n         */\r\n        infiniteProjectionMatrix : {\r\n            get : function() {\r\n                update(this);\r\n                return this._infinitePerspective;\r\n            }\r\n        }\r\n    });\r\n\r\n    var getPlanesRight = new Cartesian3();\r\n    var getPlanesNearCenter = new Cartesian3();\r\n    var getPlanesFarCenter = new Cartesian3();\r\n    var getPlanesNormal = new Cartesian3();\r\n    /**\r\n     * Creates a culling volume for this frustum.\r\n     *\r\n     * @param {Cartesian3} position The eye position.\r\n     * @param {Cartesian3} direction The view direction.\r\n     * @param {Cartesian3} up The up direction.\r\n     * @returns {CullingVolume} A culling volume at the given position and orientation.\r\n     *\r\n     * @example\r\n     * // Check if a bounding volume intersects the frustum.\r\n     * var cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\r\n     * var intersect = cullingVolume.computeVisibility(boundingVolume);\r\n     */\r\n    PerspectiveOffCenterFrustum.prototype.computeCullingVolume = function(position, direction, up) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(position)) {\r\n            throw new DeveloperError('position is required.');\r\n        }\r\n\r\n        if (!defined(direction)) {\r\n            throw new DeveloperError('direction is required.');\r\n        }\r\n\r\n        if (!defined(up)) {\r\n            throw new DeveloperError('up is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var planes = this._cullingVolume.planes;\r\n\r\n        var t = this.top;\r\n        var b = this.bottom;\r\n        var r = this.right;\r\n        var l = this.left;\r\n        var n = this.near;\r\n        var f = this.far;\r\n\r\n        var right = Cartesian3.cross(direction, up, getPlanesRight);\r\n\r\n        var nearCenter = getPlanesNearCenter;\r\n        Cartesian3.multiplyByScalar(direction, n, nearCenter);\r\n        Cartesian3.add(position, nearCenter, nearCenter);\r\n\r\n        var farCenter = getPlanesFarCenter;\r\n        Cartesian3.multiplyByScalar(direction, f, farCenter);\r\n        Cartesian3.add(position, farCenter, farCenter);\r\n\r\n        var normal = getPlanesNormal;\r\n\r\n        //Left plane computation\r\n        Cartesian3.multiplyByScalar(right, l, normal);\r\n        Cartesian3.add(nearCenter, normal, normal);\r\n        Cartesian3.subtract(normal, position, normal);\r\n        Cartesian3.normalize(normal, normal);\r\n        Cartesian3.cross(normal, up, normal);\r\n        Cartesian3.normalize(normal, normal);\r\n\r\n        var plane = planes[0];\r\n        if (!defined(plane)) {\r\n            plane = planes[0] = new Cartesian4();\r\n        }\r\n        plane.x = normal.x;\r\n        plane.y = normal.y;\r\n        plane.z = normal.z;\r\n        plane.w = -Cartesian3.dot(normal, position);\r\n\r\n        //Right plane computation\r\n        Cartesian3.multiplyByScalar(right, r, normal);\r\n        Cartesian3.add(nearCenter, normal, normal);\r\n        Cartesian3.subtract(normal, position, normal);\r\n        Cartesian3.cross(up, normal, normal);\r\n        Cartesian3.normalize(normal, normal);\r\n\r\n        plane = planes[1];\r\n        if (!defined(plane)) {\r\n            plane = planes[1] = new Cartesian4();\r\n        }\r\n        plane.x = normal.x;\r\n        plane.y = normal.y;\r\n        plane.z = normal.z;\r\n        plane.w = -Cartesian3.dot(normal, position);\r\n\r\n        //Bottom plane computation\r\n        Cartesian3.multiplyByScalar(up, b, normal);\r\n        Cartesian3.add(nearCenter, normal, normal);\r\n        Cartesian3.subtract(normal, position, normal);\r\n        Cartesian3.cross(right, normal, normal);\r\n        Cartesian3.normalize(normal, normal);\r\n\r\n        plane = planes[2];\r\n        if (!defined(plane)) {\r\n            plane = planes[2] = new Cartesian4();\r\n        }\r\n        plane.x = normal.x;\r\n        plane.y = normal.y;\r\n        plane.z = normal.z;\r\n        plane.w = -Cartesian3.dot(normal, position);\r\n\r\n        //Top plane computation\r\n        Cartesian3.multiplyByScalar(up, t, normal);\r\n        Cartesian3.add(nearCenter, normal, normal);\r\n        Cartesian3.subtract(normal, position, normal);\r\n        Cartesian3.cross(normal, right, normal);\r\n        Cartesian3.normalize(normal, normal);\r\n\r\n        plane = planes[3];\r\n        if (!defined(plane)) {\r\n            plane = planes[3] = new Cartesian4();\r\n        }\r\n        plane.x = normal.x;\r\n        plane.y = normal.y;\r\n        plane.z = normal.z;\r\n        plane.w = -Cartesian3.dot(normal, position);\r\n\r\n        //Near plane computation\r\n        plane = planes[4];\r\n        if (!defined(plane)) {\r\n            plane = planes[4] = new Cartesian4();\r\n        }\r\n        plane.x = direction.x;\r\n        plane.y = direction.y;\r\n        plane.z = direction.z;\r\n        plane.w = -Cartesian3.dot(direction, nearCenter);\r\n\r\n        //Far plane computation\r\n        Cartesian3.negate(direction, normal);\r\n\r\n        plane = planes[5];\r\n        if (!defined(plane)) {\r\n            plane = planes[5] = new Cartesian4();\r\n        }\r\n        plane.x = normal.x;\r\n        plane.y = normal.y;\r\n        plane.z = normal.z;\r\n        plane.w = -Cartesian3.dot(normal, farCenter);\r\n\r\n        return this._cullingVolume;\r\n    };\r\n\r\n    /**\r\n     * Returns the pixel's width and height in meters.\r\n     *\r\n     * @param {Number} drawingBufferWidth The width of the drawing buffer.\r\n     * @param {Number} drawingBufferHeight The height of the drawing buffer.\r\n     * @param {Number} distance The distance to the near plane in meters.\r\n     * @param {Number} pixelRatio The scaling factor from pixel space to coordinate space.\r\n     * @param {Cartesian2} result The object onto which to store the result.\r\n     * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\r\n     *\r\n     * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\r\n     * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\r\n     * @exception {DeveloperError} pixelRatio must be greater than zero.\r\n     *\r\n     * @example\r\n     * // Example 1\r\n     * // Get the width and height of a pixel.\r\n     * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, scene.pixelRatio, new Cesium.Cartesian2());\r\n     *\r\n     * @example\r\n     * // Example 2\r\n     * // Get the width and height of a pixel if the near plane was set to 'distance'.\r\n     * // For example, get the size of a pixel of an image on a billboard.\r\n     * var position = camera.position;\r\n     * var direction = camera.direction;\r\n     * var toCenter = Cesium.Cartesian3.subtract(primitive.boundingVolume.center, position, new Cesium.Cartesian3());      // vector from camera to a primitive\r\n     * var toCenterProj = Cesium.Cartesian3.multiplyByScalar(direction, Cesium.Cartesian3.dot(direction, toCenter), new Cesium.Cartesian3()); // project vector onto camera direction vector\r\n     * var distance = Cesium.Cartesian3.magnitude(toCenterProj);\r\n     * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, scene.pixelRatio, new Cesium.Cartesian2());\r\n     */\r\n    PerspectiveOffCenterFrustum.prototype.getPixelDimensions = function(drawingBufferWidth, drawingBufferHeight, distance, pixelRatio, result) {\r\n        update(this);\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(drawingBufferWidth) || !defined(drawingBufferHeight)) {\r\n            throw new DeveloperError('Both drawingBufferWidth and drawingBufferHeight are required.');\r\n        }\r\n        if (drawingBufferWidth <= 0) {\r\n            throw new DeveloperError('drawingBufferWidth must be greater than zero.');\r\n        }\r\n        if (drawingBufferHeight <= 0) {\r\n            throw new DeveloperError('drawingBufferHeight must be greater than zero.');\r\n        }\r\n        if (!defined(distance)) {\r\n            throw new DeveloperError('distance is required.');\r\n        }\r\n        if (!defined(pixelRatio)) {\r\n            throw new DeveloperError('pixelRatio is required');\r\n        }\r\n        if (pixelRatio <= 0) {\r\n            throw new DeveloperError('pixelRatio must be greater than zero.');\r\n        }\r\n        if (!defined(result)) {\r\n            throw new DeveloperError('A result object is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var inverseNear = 1.0 / this.near;\r\n        var tanTheta = this.top * inverseNear;\r\n        var pixelHeight = 2.0 * pixelRatio * distance * tanTheta / drawingBufferHeight;\r\n        tanTheta = this.right * inverseNear;\r\n        var pixelWidth = 2.0 * pixelRatio * distance * tanTheta / drawingBufferWidth;\r\n\r\n        result.x = pixelWidth;\r\n        result.y = pixelHeight;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Returns a duplicate of a PerspectiveOffCenterFrustum instance.\r\n     *\r\n     * @param {PerspectiveOffCenterFrustum} [result] The object onto which to store the result.\r\n     * @returns {PerspectiveOffCenterFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.\r\n     */\r\n    PerspectiveOffCenterFrustum.prototype.clone = function(result) {\r\n        if (!defined(result)) {\r\n            result = new PerspectiveOffCenterFrustum();\r\n        }\r\n\r\n        result.right = this.right;\r\n        result.left = this.left;\r\n        result.top = this.top;\r\n        result.bottom = this.bottom;\r\n        result.near = this.near;\r\n        result.far = this.far;\r\n\r\n        // force update of clone to compute matrices\r\n        result._left = undefined;\r\n        result._right = undefined;\r\n        result._top = undefined;\r\n        result._bottom = undefined;\r\n        result._near = undefined;\r\n        result._far = undefined;\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Compares the provided PerspectiveOffCenterFrustum componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {PerspectiveOffCenterFrustum} [other] The right hand side PerspectiveOffCenterFrustum.\r\n     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     */\r\n    PerspectiveOffCenterFrustum.prototype.equals = function(other) {\r\n        return (defined(other) && other instanceof PerspectiveOffCenterFrustum &&\r\n                this.right === other.right &&\r\n                this.left === other.left &&\r\n                this.top === other.top &&\r\n                this.bottom === other.bottom &&\r\n                this.near === other.near &&\r\n                this.far === other.far);\r\n    };\r\n\r\n    /**\r\n     * Compares the provided PerspectiveOffCenterFrustum componentwise and returns\r\n     * <code>true</code> if they pass an absolute or relative tolerance test,\r\n     * <code>false</code> otherwise.\r\n     *\r\n     * @param {PerspectiveOffCenterFrustum} other The right hand side PerspectiveOffCenterFrustum.\r\n     * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\r\n     * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\r\n     * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\r\n     */\r\n    PerspectiveOffCenterFrustum.prototype.equalsEpsilon = function(other, relativeEpsilon, absoluteEpsilon) {\r\n        return (other === this) ||\r\n               (defined(other) &&\r\n                other instanceof PerspectiveOffCenterFrustum &&\r\n                CesiumMath.equalsEpsilon(this.right, other.right, relativeEpsilon, absoluteEpsilon) &&\r\n                CesiumMath.equalsEpsilon(this.left, other.left, relativeEpsilon, absoluteEpsilon) &&\r\n                CesiumMath.equalsEpsilon(this.top, other.top, relativeEpsilon, absoluteEpsilon) &&\r\n                CesiumMath.equalsEpsilon(this.bottom, other.bottom, relativeEpsilon, absoluteEpsilon) &&\r\n                CesiumMath.equalsEpsilon(this.near, other.near, relativeEpsilon, absoluteEpsilon) &&\r\n                CesiumMath.equalsEpsilon(this.far, other.far, relativeEpsilon, absoluteEpsilon));\r\n    };\r\nexport default PerspectiveOffCenterFrustum;\r\n","import Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport CesiumMath from './Math.js';\r\nimport PerspectiveOffCenterFrustum from './PerspectiveOffCenterFrustum.js';\r\n\r\n    /**\r\n     * The viewing frustum is defined by 6 planes.\r\n     * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\r\n     * define the unit vector normal to the plane, and the w component is the distance of the\r\n     * plane from the origin/camera position.\r\n     *\r\n     * @alias PerspectiveFrustum\r\n     * @constructor\r\n     *\r\n     * @param {Object} [options] An object with the following properties:\r\n     * @param {Number} [options.fov] The angle of the field of view (FOV), in radians.\r\n     * @param {Number} [options.aspectRatio] The aspect ratio of the frustum's width to it's height.\r\n     * @param {Number} [options.near=1.0] The distance of the near plane.\r\n     * @param {Number} [options.far=500000000.0] The distance of the far plane.\r\n     * @param {Number} [options.xOffset=0.0] The offset in the x direction.\r\n     * @param {Number} [options.yOffset=0.0] The offset in the y direction.\r\n     *\r\n     * @example\r\n     * var frustum = new Cesium.PerspectiveFrustum({\r\n     *     fov : Cesium.Math.PI_OVER_THREE,\r\n     *     aspectRatio : canvas.clientWidth / canvas.clientHeight\r\n     *     near : 1.0,\r\n     *     far : 1000.0\r\n     * });\r\n     *\r\n     * @see PerspectiveOffCenterFrustum\r\n     */\r\n    function PerspectiveFrustum(options) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n        this._offCenterFrustum = new PerspectiveOffCenterFrustum();\r\n\r\n        /**\r\n         * The angle of the field of view (FOV), in radians.  This angle will be used\r\n         * as the vertical FOV if the width is greater than the height, otherwise\r\n         * it will be the horizontal FOV.\r\n         * @type {Number}\r\n         * @default undefined\r\n         */\r\n        this.fov = options.fov;\r\n        this._fov = undefined;\r\n        this._fovy = undefined;\r\n\r\n        this._sseDenominator = undefined;\r\n\r\n        /**\r\n         * The aspect ratio of the frustum's width to it's height.\r\n         * @type {Number}\r\n         * @default undefined\r\n         */\r\n        this.aspectRatio = options.aspectRatio;\r\n        this._aspectRatio = undefined;\r\n\r\n        /**\r\n         * The distance of the near plane.\r\n         * @type {Number}\r\n         * @default 1.0\r\n         */\r\n        this.near = defaultValue(options.near, 1.0);\r\n        this._near = this.near;\r\n\r\n        /**\r\n         * The distance of the far plane.\r\n         * @type {Number}\r\n         * @default 500000000.0\r\n         */\r\n        this.far = defaultValue(options.far, 500000000.0);\r\n        this._far = this.far;\r\n\r\n        /**\r\n         * Offsets the frustum in the x direction.\r\n         * @type {Number}\r\n         * @default 0.0\r\n         */\r\n        this.xOffset = defaultValue(options.xOffset, 0.0);\r\n        this._xOffset = this.xOffset;\r\n\r\n        /**\r\n         * Offsets the frustum in the y direction.\r\n         * @type {Number}\r\n         * @default 0.0\r\n         */\r\n        this.yOffset = defaultValue(options.yOffset, 0.0);\r\n        this._yOffset = this.yOffset;\r\n    }\r\n\r\n    /**\r\n     * The number of elements used to pack the object into an array.\r\n     * @type {Number}\r\n     */\r\n    PerspectiveFrustum.packedLength = 6;\r\n\r\n    /**\r\n     * Stores the provided instance into the provided array.\r\n     *\r\n     * @param {PerspectiveFrustum} value The value to pack.\r\n     * @param {Number[]} array The array to pack into.\r\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n     *\r\n     * @returns {Number[]} The array that was packed into\r\n     */\r\n    PerspectiveFrustum.pack = function(value, array, startingIndex) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('value', value);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        array[startingIndex++] = value.fov;\r\n        array[startingIndex++] = value.aspectRatio;\r\n        array[startingIndex++] = value.near;\r\n        array[startingIndex++] = value.far;\r\n        array[startingIndex++] = value.xOffset;\r\n        array[startingIndex] = value.yOffset;\r\n\r\n        return array;\r\n    };\r\n\r\n    /**\r\n     * Retrieves an instance from a packed array.\r\n     *\r\n     * @param {Number[]} array The packed array.\r\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n     * @param {PerspectiveFrustum} [result] The object into which to store the result.\r\n     * @returns {PerspectiveFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.\r\n     */\r\n    PerspectiveFrustum.unpack = function(array, startingIndex, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        if (!defined(result)) {\r\n            result = new PerspectiveFrustum();\r\n        }\r\n\r\n        result.fov = array[startingIndex++];\r\n        result.aspectRatio = array[startingIndex++];\r\n        result.near = array[startingIndex++];\r\n        result.far = array[startingIndex++];\r\n        result.xOffset = array[startingIndex++];\r\n        result.yOffset = array[startingIndex];\r\n\r\n        return result;\r\n    };\r\n\r\n    function update(frustum) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(frustum.fov) || !defined(frustum.aspectRatio) || !defined(frustum.near) || !defined(frustum.far)) {\r\n            throw new DeveloperError('fov, aspectRatio, near, or far parameters are not set.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var f = frustum._offCenterFrustum;\r\n\r\n        if (frustum.fov !== frustum._fov || frustum.aspectRatio !== frustum._aspectRatio ||\r\n            frustum.near !== frustum._near || frustum.far !== frustum._far ||\r\n            frustum.xOffset !== frustum._xOffset || frustum.yOffset !== frustum._yOffset) {\r\n            //>>includeStart('debug', pragmas.debug);\r\n            if (frustum.fov < 0 || frustum.fov >= Math.PI) {\r\n                throw new DeveloperError('fov must be in the range [0, PI).');\r\n            }\r\n\r\n            if (frustum.aspectRatio < 0) {\r\n                throw new DeveloperError('aspectRatio must be positive.');\r\n            }\r\n\r\n            if (frustum.near < 0 || frustum.near > frustum.far) {\r\n                throw new DeveloperError('near must be greater than zero and less than far.');\r\n            }\r\n            //>>includeEnd('debug');\r\n\r\n            frustum._aspectRatio = frustum.aspectRatio;\r\n            frustum._fov = frustum.fov;\r\n            frustum._fovy = (frustum.aspectRatio > 1) ? frustum.fov : Math.atan(Math.tan(frustum.fov * 0.5) / frustum.aspectRatio) * 2.0;\r\n            frustum._near = frustum.near;\r\n            frustum._far = frustum.far;\r\n            frustum._sseDenominator = 2.0 * Math.tan(0.5 * frustum._fovy);\r\n            frustum._xOffset = frustum.xOffset;\r\n            frustum._yOffset = frustum.yOffset;\r\n\r\n            f.top = frustum.near * Math.tan(0.5 * frustum._fovy);\r\n            f.bottom = -f.top;\r\n            f.right = frustum.aspectRatio * f.top;\r\n            f.left = -f.right;\r\n            f.near = frustum.near;\r\n            f.far = frustum.far;\r\n\r\n            f.right += frustum.xOffset;\r\n            f.left += frustum.xOffset;\r\n            f.top += frustum.yOffset;\r\n            f.bottom += frustum.yOffset;\r\n        }\r\n    }\r\n\r\n    Object.defineProperties(PerspectiveFrustum.prototype, {\r\n        /**\r\n         * Gets the perspective projection matrix computed from the view frustum.\r\n         * @memberof PerspectiveFrustum.prototype\r\n         * @type {Matrix4}\r\n         * @readonly\r\n         *\r\n         * @see PerspectiveFrustum#infiniteProjectionMatrix\r\n         */\r\n        projectionMatrix : {\r\n            get : function() {\r\n                update(this);\r\n                return this._offCenterFrustum.projectionMatrix;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * The perspective projection matrix computed from the view frustum with an infinite far plane.\r\n         * @memberof PerspectiveFrustum.prototype\r\n         * @type {Matrix4}\r\n         * @readonly\r\n         *\r\n         * @see PerspectiveFrustum#projectionMatrix\r\n         */\r\n        infiniteProjectionMatrix : {\r\n            get : function() {\r\n                update(this);\r\n                return this._offCenterFrustum.infiniteProjectionMatrix;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Gets the angle of the vertical field of view, in radians.\r\n         * @memberof PerspectiveFrustum.prototype\r\n         * @type {Number}\r\n         * @readonly\r\n         * @default undefined\r\n         */\r\n        fovy : {\r\n            get : function() {\r\n                update(this);\r\n                return this._fovy;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * @readonly\r\n         * @private\r\n         */\r\n        sseDenominator : {\r\n            get : function () {\r\n                update(this);\r\n                return this._sseDenominator;\r\n            }\r\n        }\r\n    });\r\n\r\n    /**\r\n     * Creates a culling volume for this frustum.\r\n     *\r\n     * @param {Cartesian3} position The eye position.\r\n     * @param {Cartesian3} direction The view direction.\r\n     * @param {Cartesian3} up The up direction.\r\n     * @returns {CullingVolume} A culling volume at the given position and orientation.\r\n     *\r\n     * @example\r\n     * // Check if a bounding volume intersects the frustum.\r\n     * var cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\r\n     * var intersect = cullingVolume.computeVisibility(boundingVolume);\r\n     */\r\n    PerspectiveFrustum.prototype.computeCullingVolume = function(position, direction, up) {\r\n        update(this);\r\n        return this._offCenterFrustum.computeCullingVolume(position, direction, up);\r\n    };\r\n\r\n    /**\r\n     * Returns the pixel's width and height in meters.\r\n     *\r\n     * @param {Number} drawingBufferWidth The width of the drawing buffer.\r\n     * @param {Number} drawingBufferHeight The height of the drawing buffer.\r\n     * @param {Number} distance The distance to the near plane in meters.\r\n     * @param {Number} pixelRatio The scaling factor from pixel space to coordinate space.\r\n     * @param {Cartesian2} result The object onto which to store the result.\r\n     * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\r\n     *\r\n     * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\r\n     * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\r\n     * @exception {DeveloperError} pixelRatio must be greater than zero.\r\n     *\r\n     * @example\r\n     * // Example 1\r\n     * // Get the width and height of a pixel.\r\n     * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, scene.pixelRatio, new Cesium.Cartesian2());\r\n     *\r\n     * @example\r\n     * // Example 2\r\n     * // Get the width and height of a pixel if the near plane was set to 'distance'.\r\n     * // For example, get the size of a pixel of an image on a billboard.\r\n     * var position = camera.position;\r\n     * var direction = camera.direction;\r\n     * var toCenter = Cesium.Cartesian3.subtract(primitive.boundingVolume.center, position, new Cesium.Cartesian3());      // vector from camera to a primitive\r\n     * var toCenterProj = Cesium.Cartesian3.multiplyByScalar(direction, Cesium.Cartesian3.dot(direction, toCenter), new Cesium.Cartesian3()); // project vector onto camera direction vector\r\n     * var distance = Cesium.Cartesian3.magnitude(toCenterProj);\r\n     * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, scene.pixelRatio, new Cesium.Cartesian2());\r\n     */\r\n    PerspectiveFrustum.prototype.getPixelDimensions = function(drawingBufferWidth, drawingBufferHeight, distance, pixelRatio, result) {\r\n        update(this);\r\n        return this._offCenterFrustum.getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, pixelRatio, result);\r\n    };\r\n\r\n    /**\r\n     * Returns a duplicate of a PerspectiveFrustum instance.\r\n     *\r\n     * @param {PerspectiveFrustum} [result] The object onto which to store the result.\r\n     * @returns {PerspectiveFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.\r\n     */\r\n    PerspectiveFrustum.prototype.clone = function(result) {\r\n        if (!defined(result)) {\r\n            result = new PerspectiveFrustum();\r\n        }\r\n\r\n        result.aspectRatio = this.aspectRatio;\r\n        result.fov = this.fov;\r\n        result.near = this.near;\r\n        result.far = this.far;\r\n\r\n        // force update of clone to compute matrices\r\n        result._aspectRatio = undefined;\r\n        result._fov = undefined;\r\n        result._near = undefined;\r\n        result._far = undefined;\r\n\r\n        this._offCenterFrustum.clone(result._offCenterFrustum);\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Compares the provided PerspectiveFrustum componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {PerspectiveFrustum} [other] The right hand side PerspectiveFrustum.\r\n     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     */\r\n    PerspectiveFrustum.prototype.equals = function(other) {\r\n        if (!defined(other) || !(other instanceof PerspectiveFrustum)) {\r\n            return false;\r\n        }\r\n\r\n        update(this);\r\n        update(other);\r\n\r\n        return (this.fov === other.fov &&\r\n                this.aspectRatio === other.aspectRatio &&\r\n                this._offCenterFrustum.equals(other._offCenterFrustum));\r\n    };\r\n\r\n    /**\r\n     * Compares the provided PerspectiveFrustum componentwise and returns\r\n     * <code>true</code> if they pass an absolute or relative tolerance test,\r\n     * <code>false</code> otherwise.\r\n     *\r\n     * @param {PerspectiveFrustum} other The right hand side PerspectiveFrustum.\r\n     * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\r\n     * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\r\n     * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\r\n     */\r\n    PerspectiveFrustum.prototype.equalsEpsilon = function(other, relativeEpsilon, absoluteEpsilon) {\r\n        if (!defined(other) || !(other instanceof PerspectiveFrustum)) {\r\n            return false;\r\n        }\r\n\r\n        update(this);\r\n        update(other);\r\n\r\n        return (CesiumMath.equalsEpsilon(this.fov, other.fov, relativeEpsilon, absoluteEpsilon) &&\r\n                CesiumMath.equalsEpsilon(this.aspectRatio, other.aspectRatio, relativeEpsilon, absoluteEpsilon) &&\r\n                this._offCenterFrustum.equalsEpsilon(other._offCenterFrustum, relativeEpsilon, absoluteEpsilon));\r\n    };\r\nexport default PerspectiveFrustum;\r\n","import BoundingSphere from './BoundingSphere.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport Cartesian4 from './Cartesian4.js';\r\nimport Check from './Check.js';\r\nimport ComponentDatatype from './ComponentDatatype.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport Geometry from './Geometry.js';\r\nimport GeometryAttribute from './GeometryAttribute.js';\r\nimport GeometryAttributes from './GeometryAttributes.js';\r\nimport Matrix3 from './Matrix3.js';\r\nimport Matrix4 from './Matrix4.js';\r\nimport OrthographicFrustum from './OrthographicFrustum.js';\r\nimport PerspectiveFrustum from './PerspectiveFrustum.js';\r\nimport PrimitiveType from './PrimitiveType.js';\r\nimport Quaternion from './Quaternion.js';\r\nimport VertexFormat from './VertexFormat.js';\r\n\r\n    var PERSPECTIVE = 0;\r\n    var ORTHOGRAPHIC = 1;\r\n\r\n    /**\r\n     * Describes a frustum at the given the origin and orientation.\r\n     *\r\n     * @alias FrustumGeometry\r\n     * @constructor\r\n     *\r\n     * @param {Object} options Object with the following properties:\r\n     * @param {PerspectiveFrustum|OrthographicFrustum} options.frustum The frustum.\r\n     * @param {Cartesian3} options.origin The origin of the frustum.\r\n     * @param {Quaternion} options.orientation The orientation of the frustum.\r\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\r\n     */\r\n    function FrustumGeometry(options) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('options', options);\r\n        Check.typeOf.object('options.frustum', options.frustum);\r\n        Check.typeOf.object('options.origin', options.origin);\r\n        Check.typeOf.object('options.orientation', options.orientation);\r\n        //>>includeEnd('debug');\r\n\r\n        var frustum = options.frustum;\r\n        var orientation = options.orientation;\r\n        var origin = options.origin;\r\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\r\n\r\n        // This is private because it is used by DebugCameraPrimitive to draw a multi-frustum by\r\n        // creating multiple FrustumGeometrys. This way the near plane of one frustum doesn't overlap\r\n        // the far plane of another.\r\n        var drawNearPlane = defaultValue(options._drawNearPlane, true);\r\n\r\n        var frustumType;\r\n        var frustumPackedLength;\r\n        if (frustum instanceof PerspectiveFrustum) {\r\n            frustumType = PERSPECTIVE;\r\n            frustumPackedLength = PerspectiveFrustum.packedLength;\r\n        } else if (frustum instanceof OrthographicFrustum) {\r\n            frustumType = ORTHOGRAPHIC;\r\n            frustumPackedLength = OrthographicFrustum.packedLength;\r\n        }\r\n\r\n        this._frustumType = frustumType;\r\n        this._frustum = frustum.clone();\r\n        this._origin = Cartesian3.clone(origin);\r\n        this._orientation = Quaternion.clone(orientation);\r\n        this._drawNearPlane = drawNearPlane;\r\n        this._vertexFormat = vertexFormat;\r\n        this._workerName = 'createFrustumGeometry';\r\n\r\n        /**\r\n         * The number of elements used to pack the object into an array.\r\n         * @type {Number}\r\n         */\r\n        this.packedLength = 2 + frustumPackedLength + Cartesian3.packedLength + Quaternion.packedLength + VertexFormat.packedLength;\r\n    }\r\n\r\n    /**\r\n     * Stores the provided instance into the provided array.\r\n     *\r\n     * @param {FrustumGeometry} value The value to pack.\r\n     * @param {Number[]} array The array to pack into.\r\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n     *\r\n     * @returns {Number[]} The array that was packed into\r\n     */\r\n    FrustumGeometry.pack = function(value, array, startingIndex) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('value', value);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        var frustumType = value._frustumType;\r\n        var frustum = value._frustum;\r\n\r\n        array[startingIndex++] = frustumType;\r\n\r\n        if (frustumType === PERSPECTIVE) {\r\n            PerspectiveFrustum.pack(frustum, array, startingIndex);\r\n            startingIndex += PerspectiveFrustum.packedLength;\r\n        } else {\r\n            OrthographicFrustum.pack(frustum, array, startingIndex);\r\n            startingIndex += OrthographicFrustum.packedLength;\r\n        }\r\n\r\n        Cartesian3.pack(value._origin, array, startingIndex);\r\n        startingIndex += Cartesian3.packedLength;\r\n        Quaternion.pack(value._orientation, array, startingIndex);\r\n        startingIndex += Quaternion.packedLength;\r\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\r\n        startingIndex += VertexFormat.packedLength;\r\n        array[startingIndex] = value._drawNearPlane ? 1.0 : 0.0;\r\n\r\n        return array;\r\n    };\r\n\r\n    var scratchPackPerspective = new PerspectiveFrustum();\r\n    var scratchPackOrthographic = new OrthographicFrustum();\r\n    var scratchPackQuaternion = new Quaternion();\r\n    var scratchPackorigin = new Cartesian3();\r\n    var scratchVertexFormat = new VertexFormat();\r\n\r\n    /**\r\n     * Retrieves an instance from a packed array.\r\n     *\r\n     * @param {Number[]} array The packed array.\r\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n     * @param {FrustumGeometry} [result] The object into which to store the result.\r\n     */\r\n    FrustumGeometry.unpack = function(array, startingIndex, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        var frustumType = array[startingIndex++];\r\n\r\n        var frustum;\r\n        if (frustumType === PERSPECTIVE) {\r\n            frustum = PerspectiveFrustum.unpack(array, startingIndex, scratchPackPerspective);\r\n            startingIndex += PerspectiveFrustum.packedLength;\r\n        } else {\r\n            frustum = OrthographicFrustum.unpack(array, startingIndex, scratchPackOrthographic);\r\n            startingIndex += OrthographicFrustum.packedLength;\r\n        }\r\n\r\n        var origin = Cartesian3.unpack(array, startingIndex, scratchPackorigin);\r\n        startingIndex += Cartesian3.packedLength;\r\n        var orientation = Quaternion.unpack(array, startingIndex, scratchPackQuaternion);\r\n        startingIndex += Quaternion.packedLength;\r\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\r\n        startingIndex += VertexFormat.packedLength;\r\n        var drawNearPlane = array[startingIndex] === 1.0;\r\n\r\n        if (!defined(result)) {\r\n            return new FrustumGeometry({\r\n                frustum : frustum,\r\n                origin : origin,\r\n                orientation : orientation,\r\n                vertexFormat : vertexFormat,\r\n                _drawNearPlane : drawNearPlane\r\n            });\r\n        }\r\n\r\n        var frustumResult = frustumType === result._frustumType ? result._frustum : undefined;\r\n        result._frustum = frustum.clone(frustumResult);\r\n\r\n        result._frustumType = frustumType;\r\n        result._origin = Cartesian3.clone(origin, result._origin);\r\n        result._orientation = Quaternion.clone(orientation, result._orientation);\r\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\r\n        result._drawNearPlane = drawNearPlane;\r\n\r\n        return result;\r\n    };\r\n\r\n    function getAttributes(offset, normals, tangents, bitangents, st, normal, tangent, bitangent) {\r\n        var stOffset = offset / 3 * 2;\r\n\r\n        for (var i = 0; i < 4; ++i) {\r\n            if (defined(normals)) {\r\n                normals[offset] = normal.x;\r\n                normals[offset + 1] = normal.y;\r\n                normals[offset + 2] = normal.z;\r\n            }\r\n            if (defined(tangents)) {\r\n                tangents[offset] = tangent.x;\r\n                tangents[offset + 1] = tangent.y;\r\n                tangents[offset + 2] = tangent.z;\r\n            }\r\n            if (defined(bitangents)) {\r\n                bitangents[offset] = bitangent.x;\r\n                bitangents[offset + 1] = bitangent.y;\r\n                bitangents[offset + 2] = bitangent.z;\r\n            }\r\n            offset += 3;\r\n        }\r\n\r\n        st[stOffset] = 0.0;\r\n        st[stOffset + 1] = 0.0;\r\n        st[stOffset + 2] = 1.0;\r\n        st[stOffset + 3] = 0.0;\r\n        st[stOffset + 4] = 1.0;\r\n        st[stOffset + 5] = 1.0;\r\n        st[stOffset + 6] = 0.0;\r\n        st[stOffset + 7] = 1.0;\r\n    }\r\n\r\n    var scratchRotationMatrix = new Matrix3();\r\n    var scratchViewMatrix = new Matrix4();\r\n    var scratchInverseMatrix = new Matrix4();\r\n\r\n    var scratchXDirection = new Cartesian3();\r\n    var scratchYDirection = new Cartesian3();\r\n    var scratchZDirection = new Cartesian3();\r\n    var scratchNegativeX = new Cartesian3();\r\n    var scratchNegativeY = new Cartesian3();\r\n    var scratchNegativeZ = new Cartesian3();\r\n\r\n    var frustumSplits = new Array(3);\r\n\r\n    var frustumCornersNDC = new Array(4);\r\n    frustumCornersNDC[0] = new Cartesian4(-1.0, -1.0, 1.0, 1.0);\r\n    frustumCornersNDC[1] = new Cartesian4(1.0, -1.0, 1.0, 1.0);\r\n    frustumCornersNDC[2] = new Cartesian4(1.0, 1.0, 1.0, 1.0);\r\n    frustumCornersNDC[3] = new Cartesian4(-1.0, 1.0, 1.0, 1.0);\r\n\r\n    var scratchFrustumCorners = new Array(4);\r\n    for (var i = 0; i < 4; ++i) {\r\n        scratchFrustumCorners[i] = new Cartesian4();\r\n    }\r\n\r\n    FrustumGeometry._computeNearFarPlanes = function(origin, orientation, frustumType, frustum, positions, xDirection, yDirection, zDirection) {\r\n        var rotationMatrix = Matrix3.fromQuaternion(orientation, scratchRotationMatrix);\r\n        var x = defaultValue(xDirection, scratchXDirection);\r\n        var y = defaultValue(yDirection, scratchYDirection);\r\n        var z = defaultValue(zDirection, scratchZDirection);\r\n\r\n        x = Matrix3.getColumn(rotationMatrix, 0, x);\r\n        y = Matrix3.getColumn(rotationMatrix, 1, y);\r\n        z = Matrix3.getColumn(rotationMatrix, 2, z);\r\n\r\n        Cartesian3.normalize(x, x);\r\n        Cartesian3.normalize(y, y);\r\n        Cartesian3.normalize(z, z);\r\n\r\n        Cartesian3.negate(x, x);\r\n\r\n        var view = Matrix4.computeView(origin, z, y, x, scratchViewMatrix);\r\n\r\n        var inverseView;\r\n        var inverseViewProjection;\r\n        if (frustumType === PERSPECTIVE) {\r\n            var projection = frustum.projectionMatrix;\r\n            var viewProjection = Matrix4.multiply(projection, view, scratchInverseMatrix);\r\n            inverseViewProjection = Matrix4.inverse(viewProjection, scratchInverseMatrix);\r\n        } else {\r\n            inverseView = Matrix4.inverseTransformation(view, scratchInverseMatrix);\r\n        }\r\n\r\n        if (defined(inverseViewProjection)) {\r\n            frustumSplits[0] = frustum.near;\r\n            frustumSplits[1] = frustum.far;\r\n        } else {\r\n            frustumSplits[0] = 0.0;\r\n            frustumSplits[1] = frustum.near;\r\n            frustumSplits[2] = frustum.far;\r\n        }\r\n\r\n        for (var i = 0; i < 2; ++i) {\r\n            for (var j = 0; j < 4; ++j) {\r\n                var corner = Cartesian4.clone(frustumCornersNDC[j], scratchFrustumCorners[j]);\r\n\r\n                if (!defined(inverseViewProjection)) {\r\n                    if (defined(frustum._offCenterFrustum)) {\r\n                        frustum = frustum._offCenterFrustum;\r\n                    }\r\n\r\n                    var near = frustumSplits[i];\r\n                    var far = frustumSplits[i + 1];\r\n\r\n                    corner.x = (corner.x * (frustum.right - frustum.left) + frustum.left + frustum.right) * 0.5;\r\n                    corner.y = (corner.y * (frustum.top - frustum.bottom) + frustum.bottom + frustum.top) * 0.5;\r\n                    corner.z = (corner.z * (near - far) - near - far) * 0.5;\r\n                    corner.w = 1.0;\r\n\r\n                    Matrix4.multiplyByVector(inverseView, corner, corner);\r\n                } else {\r\n                    corner = Matrix4.multiplyByVector(inverseViewProjection, corner, corner);\r\n\r\n                    // Reverse perspective divide\r\n                    var w = 1.0 / corner.w;\r\n                    Cartesian3.multiplyByScalar(corner, w, corner);\r\n\r\n                    Cartesian3.subtract(corner, origin, corner);\r\n                    Cartesian3.normalize(corner, corner);\r\n\r\n                    var fac = Cartesian3.dot(z, corner);\r\n                    Cartesian3.multiplyByScalar(corner, frustumSplits[i] / fac, corner);\r\n                    Cartesian3.add(corner, origin, corner);\r\n                }\r\n\r\n                positions[12 * i + j * 3] = corner.x;\r\n                positions[12 * i + j * 3 + 1] = corner.y;\r\n                positions[12 * i + j * 3 + 2] = corner.z;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Computes the geometric representation of a frustum, including its vertices, indices, and a bounding sphere.\r\n     *\r\n     * @param {FrustumGeometry} frustumGeometry A description of the frustum.\r\n     * @returns {Geometry|undefined} The computed vertices and indices.\r\n     */\r\n    FrustumGeometry.createGeometry = function(frustumGeometry) {\r\n        var frustumType = frustumGeometry._frustumType;\r\n        var frustum = frustumGeometry._frustum;\r\n        var origin = frustumGeometry._origin;\r\n        var orientation = frustumGeometry._orientation;\r\n        var drawNearPlane = frustumGeometry._drawNearPlane;\r\n        var vertexFormat = frustumGeometry._vertexFormat;\r\n\r\n        var numberOfPlanes = drawNearPlane ? 6 : 5;\r\n        var positions = new Float64Array(3 * 4 * 6);\r\n        FrustumGeometry._computeNearFarPlanes(origin, orientation, frustumType, frustum, positions);\r\n\r\n        // -x plane\r\n        var offset = 3 * 4 * 2;\r\n        positions[offset]      = positions[3 * 4];\r\n        positions[offset + 1]  = positions[3 * 4 + 1];\r\n        positions[offset + 2]  = positions[3 * 4 + 2];\r\n        positions[offset + 3]  = positions[0];\r\n        positions[offset + 4]  = positions[1];\r\n        positions[offset + 5]  = positions[2];\r\n        positions[offset + 6]  = positions[3 * 3];\r\n        positions[offset + 7]  = positions[3 * 3 + 1];\r\n        positions[offset + 8]  = positions[3 * 3 + 2];\r\n        positions[offset + 9]  = positions[3 * 7];\r\n        positions[offset + 10] = positions[3 * 7 + 1];\r\n        positions[offset + 11] = positions[3 * 7 + 2];\r\n\r\n        // -y plane\r\n        offset += 3 * 4;\r\n        positions[offset]      = positions[3 * 5];\r\n        positions[offset + 1]  = positions[3 * 5 + 1];\r\n        positions[offset + 2]  = positions[3 * 5 + 2];\r\n        positions[offset + 3]  = positions[3];\r\n        positions[offset + 4]  = positions[3 + 1];\r\n        positions[offset + 5]  = positions[3 + 2];\r\n        positions[offset + 6]  = positions[0];\r\n        positions[offset + 7]  = positions[1];\r\n        positions[offset + 8]  = positions[2];\r\n        positions[offset + 9]  = positions[3 * 4];\r\n        positions[offset + 10] = positions[3 * 4 + 1];\r\n        positions[offset + 11] = positions[3 * 4 + 2];\r\n\r\n        // +x plane\r\n        offset += 3 * 4;\r\n        positions[offset]      = positions[3];\r\n        positions[offset + 1]  = positions[3 + 1];\r\n        positions[offset + 2]  = positions[3 + 2];\r\n        positions[offset + 3]  = positions[3 * 5];\r\n        positions[offset + 4]  = positions[3 * 5 + 1];\r\n        positions[offset + 5]  = positions[3 * 5 + 2];\r\n        positions[offset + 6]  = positions[3 * 6];\r\n        positions[offset + 7]  = positions[3 * 6 + 1];\r\n        positions[offset + 8]  = positions[3 * 6 + 2];\r\n        positions[offset + 9]  = positions[3 * 2];\r\n        positions[offset + 10] = positions[3 * 2 + 1];\r\n        positions[offset + 11] = positions[3 * 2 + 2];\r\n\r\n        // +y plane\r\n        offset += 3 * 4;\r\n        positions[offset]      = positions[3 * 2];\r\n        positions[offset + 1]  = positions[3 * 2 + 1];\r\n        positions[offset + 2]  = positions[3 * 2 + 2];\r\n        positions[offset + 3]  = positions[3 * 6];\r\n        positions[offset + 4]  = positions[3 * 6 + 1];\r\n        positions[offset + 5]  = positions[3 * 6 + 2];\r\n        positions[offset + 6]  = positions[3 * 7];\r\n        positions[offset + 7]  = positions[3 * 7 + 1];\r\n        positions[offset + 8]  = positions[3 * 7 + 2];\r\n        positions[offset + 9]  = positions[3 * 3];\r\n        positions[offset + 10] = positions[3 * 3 + 1];\r\n        positions[offset + 11] = positions[3 * 3 + 2];\r\n\r\n        if (!drawNearPlane) {\r\n            positions = positions.subarray(3 * 4);\r\n        }\r\n\r\n        var attributes = new GeometryAttributes({\r\n            position : new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.DOUBLE,\r\n                componentsPerAttribute : 3,\r\n                values : positions\r\n            })\r\n        });\r\n\r\n        if (defined(vertexFormat.normal) || defined(vertexFormat.tangent) || defined(vertexFormat.bitangent) || defined(vertexFormat.st)) {\r\n            var normals = defined(vertexFormat.normal) ? new Float32Array(3 * 4 * numberOfPlanes) : undefined;\r\n            var tangents = defined(vertexFormat.tangent) ? new Float32Array(3 * 4 * numberOfPlanes) : undefined;\r\n            var bitangents = defined(vertexFormat.bitangent) ? new Float32Array(3 * 4 * numberOfPlanes) : undefined;\r\n            var st = defined(vertexFormat.st) ? new Float32Array(2 * 4 * numberOfPlanes) : undefined;\r\n\r\n            var x = scratchXDirection;\r\n            var y = scratchYDirection;\r\n            var z = scratchZDirection;\r\n\r\n            var negativeX = Cartesian3.negate(x, scratchNegativeX);\r\n            var negativeY = Cartesian3.negate(y, scratchNegativeY);\r\n            var negativeZ = Cartesian3.negate(z, scratchNegativeZ);\r\n\r\n            offset = 0;\r\n            if (drawNearPlane) {\r\n                getAttributes(offset, normals, tangents, bitangents, st, negativeZ, x, y); // near\r\n                offset += 3 * 4;\r\n            }\r\n            getAttributes(offset, normals, tangents, bitangents, st, z, negativeX, y); // far\r\n            offset += 3 * 4;\r\n            getAttributes(offset, normals, tangents, bitangents, st, negativeX, negativeZ, y); // -x\r\n            offset += 3 * 4;\r\n            getAttributes(offset, normals, tangents, bitangents, st, negativeY, negativeZ, negativeX); // -y\r\n            offset += 3 * 4;\r\n            getAttributes(offset, normals, tangents, bitangents, st, x, z, y); // +x\r\n            offset += 3 * 4;\r\n            getAttributes(offset, normals, tangents, bitangents, st, y, z, negativeX); // +y\r\n\r\n            if (defined(normals)) {\r\n                attributes.normal = new GeometryAttribute({\r\n                    componentDatatype : ComponentDatatype.FLOAT,\r\n                    componentsPerAttribute : 3,\r\n                    values : normals\r\n                });\r\n            }\r\n            if (defined(tangents)) {\r\n                attributes.tangent = new GeometryAttribute({\r\n                    componentDatatype : ComponentDatatype.FLOAT,\r\n                    componentsPerAttribute : 3,\r\n                    values : tangents\r\n                });\r\n            }\r\n            if (defined(bitangents)) {\r\n                attributes.bitangent = new GeometryAttribute({\r\n                    componentDatatype : ComponentDatatype.FLOAT,\r\n                    componentsPerAttribute : 3,\r\n                    values : bitangents\r\n                });\r\n            }\r\n            if (defined(st)) {\r\n                attributes.st = new GeometryAttribute({\r\n                    componentDatatype : ComponentDatatype.FLOAT,\r\n                    componentsPerAttribute : 2,\r\n                    values : st\r\n                });\r\n            }\r\n        }\r\n\r\n        var indices = new Uint16Array(6 * numberOfPlanes);\r\n        for (var i = 0; i < numberOfPlanes; ++i) {\r\n            var indexOffset = i * 6;\r\n            var index = i * 4;\r\n\r\n            indices[indexOffset] = index;\r\n            indices[indexOffset + 1] = index + 1;\r\n            indices[indexOffset + 2] = index + 2;\r\n            indices[indexOffset + 3] = index;\r\n            indices[indexOffset + 4] = index + 2;\r\n            indices[indexOffset + 5] = index + 3;\r\n        }\r\n\r\n        return new Geometry({\r\n            attributes : attributes,\r\n            indices : indices,\r\n            primitiveType : PrimitiveType.TRIANGLES,\r\n            boundingSphere : BoundingSphere.fromVertices(positions)\r\n        });\r\n    };\r\nexport default FrustumGeometry;\r\n"],"names":["CullingVolume","planes","this","defaultValue","faces","Cartesian3","clone","UNIT_X","UNIT_Y","UNIT_Z","scratchPlaneCenter","scratchPlaneNormal","scratchPlane","Plane","OrthographicOffCenterFrustum","options","EMPTY_OBJECT","left","_left","undefined","right","_right","top","_top","bottom","_bottom","near","_near","far","_far","_cullingVolume","_orthographicMatrix","Matrix4","update","frustum","defined","DeveloperError","computeOrthographicOffCenter","fromBoundingSphere","boundingSphere","result","length","center","radius","planeIndex","i","faceNormal","plane0","plane1","Cartesian4","multiplyByScalar","add","x","y","z","w","dot","negate","prototype","computeVisibility","boundingVolume","intersecting","k","len","intersectPlane","fromCartesian4","Intersect","OUTSIDE","INTERSECTING","INSIDE","computeVisibilityWithPlaneMask","parentPlaneMask","MASK_OUTSIDE","MASK_INSIDE","mask","flag","MASK_INDETERMINATE","Object","defineProperties","projectionMatrix","get","getPlanesRight","getPlanesNearCenter","getPlanesPoint","negateScratch","OrthographicFrustum","_offCenterFrustum","width","_width","aspectRatio","_aspectRatio","f","ratio","PerspectiveOffCenterFrustum","_perspectiveMatrix","_infinitePerspective","t","b","r","l","n","computePerspectiveOffCenter","computeInfinitePerspectiveOffCenter","computeCullingVolume","position","direction","up","cross","normalize","nearCenter","point","plane","getPixelDimensions","drawingBufferWidth","drawingBufferHeight","distance","pixelRatio","pixelWidth","pixelHeight","equals","other","equalsEpsilon","relativeEpsilon","absoluteEpsilon","CesiumMath","packedLength","pack","value","array","startingIndex","Check","typeOf","object","unpack","infiniteProjectionMatrix","getPlanesFarCenter","getPlanesNormal","PerspectiveFrustum","fov","_fov","_fovy","_sseDenominator","xOffset","_xOffset","yOffset","_yOffset","Math","PI","atan","tan","farCenter","normal","subtract","inverseNear","tanTheta","fovy","sseDenominator","FrustumGeometry","origin","orientation","frustumType","frustumPackedLength","vertexFormat","VertexFormat","DEFAULT","drawNearPlane","_drawNearPlane","_frustumType","_frustum","_origin","_orientation","Quaternion","_vertexFormat","_workerName","scratchPackPerspective","scratchPackOrthographic","scratchPackQuaternion","scratchPackorigin","scratchVertexFormat","getAttributes","offset","normals","tangents","bitangents","st","tangent","bitangent","stOffset","frustumResult","scratchRotationMatrix","Matrix3","scratchViewMatrix","scratchInverseMatrix","scratchXDirection","scratchYDirection","scratchZDirection","scratchNegativeX","scratchNegativeY","scratchNegativeZ","frustumSplits","Array","frustumCornersNDC","scratchFrustumCorners","_computeNearFarPlanes","positions","xDirection","yDirection","zDirection","rotationMatrix","fromQuaternion","getColumn","inverseView","inverseViewProjection","view","computeView","projection","viewProjection","multiply","inverse","inverseTransformation","j","corner","multiplyByVector","fac","createGeometry","frustumGeometry","numberOfPlanes","Float64Array","subarray","attributes","GeometryAttributes","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","Float32Array","negativeX","negativeY","negativeZ","FLOAT","indices","Uint16Array","indexOffset","index","Geometry","primitiveType","PrimitiveType","TRIANGLES","BoundingSphere","fromVertices"],"mappings":"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"}