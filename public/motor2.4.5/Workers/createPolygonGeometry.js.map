{"version":3,"file":"createPolygonGeometry.js","sources":["../../../../Source/Core/PolygonGeometry.js","../../../../Source/WorkersES6/createPolygonGeometry.js"],"sourcesContent":["import ArcType from './ArcType.js';\r\nimport arrayFill from './arrayFill.js';\r\nimport BoundingRectangle from './BoundingRectangle.js';\r\nimport BoundingSphere from './BoundingSphere.js';\r\nimport Cartesian2 from './Cartesian2.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport Cartographic from './Cartographic.js';\r\nimport Check from './Check.js';\r\nimport ComponentDatatype from './ComponentDatatype.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport EllipsoidGeodesic from './EllipsoidGeodesic.js';\r\nimport EllipsoidTangentPlane from './EllipsoidTangentPlane.js';\r\nimport Geometry from './Geometry.js';\r\nimport GeometryAttribute from './GeometryAttribute.js';\r\nimport GeometryInstance from './GeometryInstance.js';\r\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\r\nimport GeometryPipeline from './GeometryPipeline.js';\r\nimport IndexDatatype from './IndexDatatype.js';\r\nimport CesiumMath from './Math.js';\r\nimport Matrix3 from './Matrix3.js';\r\nimport PolygonGeometryLibrary from './PolygonGeometryLibrary.js';\r\nimport PolygonPipeline from './PolygonPipeline.js';\r\nimport Quaternion from './Quaternion.js';\r\nimport Rectangle from './Rectangle.js';\r\nimport VertexFormat from './VertexFormat.js';\r\nimport WindingOrder from './WindingOrder.js';\r\n\r\n    var scratchCarto1 = new Cartographic();\r\n    var scratchCarto2 = new Cartographic();\r\n    function adjustPosHeightsForNormal(position, p1, p2, ellipsoid) {\r\n        var carto1 = ellipsoid.cartesianToCartographic(position, scratchCarto1);\r\n        var height = carto1.height;\r\n        var p1Carto = ellipsoid.cartesianToCartographic(p1, scratchCarto2);\r\n        p1Carto.height = height;\r\n        ellipsoid.cartographicToCartesian(p1Carto, p1);\r\n\r\n        var p2Carto = ellipsoid.cartesianToCartographic(p2, scratchCarto2);\r\n        p2Carto.height = height - 100;\r\n        ellipsoid.cartographicToCartesian(p2Carto, p2);\r\n    }\r\n\r\n    var scratchBoundingRectangle = new BoundingRectangle();\r\n    var scratchPosition = new Cartesian3();\r\n    var scratchNormal = new Cartesian3();\r\n    var scratchTangent = new Cartesian3();\r\n    var scratchBitangent = new Cartesian3();\r\n    var p1Scratch = new Cartesian3();\r\n    var p2Scratch = new Cartesian3();\r\n    var scratchPerPosNormal = new Cartesian3();\r\n    var scratchPerPosTangent = new Cartesian3();\r\n    var scratchPerPosBitangent = new Cartesian3();\r\n\r\n    var appendTextureCoordinatesOrigin = new Cartesian2();\r\n    var appendTextureCoordinatesCartesian2 = new Cartesian2();\r\n    var appendTextureCoordinatesCartesian3 = new Cartesian3();\r\n    var appendTextureCoordinatesQuaternion = new Quaternion();\r\n    var appendTextureCoordinatesMatrix3 = new Matrix3();\r\n    var tangentMatrixScratch = new Matrix3();\r\n\r\n    function computeAttributes(options) {\r\n        var vertexFormat = options.vertexFormat;\r\n        var geometry = options.geometry;\r\n        var shadowVolume = options.shadowVolume;\r\n        var flatPositions = geometry.attributes.position.values;\r\n        var length = flatPositions.length;\r\n        var wall = options.wall;\r\n        var top = options.top || wall;\r\n        var bottom = options.bottom || wall;\r\n        if (vertexFormat.st || vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent || shadowVolume) {\r\n            // PERFORMANCE_IDEA: Compute before subdivision, then just interpolate during subdivision.\r\n            // PERFORMANCE_IDEA: Compute with createGeometryFromPositions() for fast path when there's no holes.\r\n            var boundingRectangle = options.boundingRectangle;\r\n            var tangentPlane = options.tangentPlane;\r\n            var ellipsoid = options.ellipsoid;\r\n            var stRotation = options.stRotation;\r\n            var perPositionHeight = options.perPositionHeight;\r\n\r\n            var origin = appendTextureCoordinatesOrigin;\r\n            origin.x = boundingRectangle.x;\r\n            origin.y = boundingRectangle.y;\r\n\r\n            var textureCoordinates = vertexFormat.st ? new Float32Array(2 * (length / 3)) : undefined;\r\n            var normals;\r\n            if (vertexFormat.normal) {\r\n                if (perPositionHeight && top && !wall) {\r\n                    normals = geometry.attributes.normal.values;\r\n                } else {\r\n                    normals = new Float32Array(length);\r\n                }\r\n            }\r\n            var tangents = vertexFormat.tangent ? new Float32Array(length) : undefined;\r\n            var bitangents = vertexFormat.bitangent ? new Float32Array(length) : undefined;\r\n            var extrudeNormals = shadowVolume ? new Float32Array(length) : undefined;\r\n\r\n            var textureCoordIndex = 0;\r\n            var attrIndex = 0;\r\n\r\n            var normal = scratchNormal;\r\n            var tangent = scratchTangent;\r\n            var bitangent = scratchBitangent;\r\n            var recomputeNormal = true;\r\n\r\n            var textureMatrix = appendTextureCoordinatesMatrix3;\r\n            var tangentRotationMatrix = tangentMatrixScratch;\r\n            if (stRotation !== 0.0) {\r\n                var rotation = Quaternion.fromAxisAngle(tangentPlane._plane.normal, stRotation, appendTextureCoordinatesQuaternion);\r\n                textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\r\n\r\n                rotation = Quaternion.fromAxisAngle(tangentPlane._plane.normal, -stRotation, appendTextureCoordinatesQuaternion);\r\n                tangentRotationMatrix = Matrix3.fromQuaternion(rotation, tangentRotationMatrix);\r\n            } else {\r\n                textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\r\n                tangentRotationMatrix = Matrix3.clone(Matrix3.IDENTITY, tangentRotationMatrix);\r\n            }\r\n\r\n            var bottomOffset = 0;\r\n            var bottomOffset2 = 0;\r\n\r\n            if (top && bottom) {\r\n                bottomOffset = length / 2;\r\n                bottomOffset2 = length / 3;\r\n\r\n                length /= 2;\r\n            }\r\n\r\n            for ( var i = 0; i < length; i += 3) {\r\n                var position = Cartesian3.fromArray(flatPositions, i, appendTextureCoordinatesCartesian3);\r\n\r\n                if (vertexFormat.st) {\r\n                    var p = Matrix3.multiplyByVector(textureMatrix, position, scratchPosition);\r\n                    p = ellipsoid.scaleToGeodeticSurface(p,p);\r\n                    var st = tangentPlane.projectPointOntoPlane(p, appendTextureCoordinatesCartesian2);\r\n                    Cartesian2.subtract(st, origin, st);\r\n\r\n                    var stx = CesiumMath.clamp(st.x / boundingRectangle.width, 0, 1);\r\n                    var sty = CesiumMath.clamp(st.y / boundingRectangle.height, 0, 1);\r\n                    if (bottom) {\r\n                        textureCoordinates[textureCoordIndex + bottomOffset2] = stx;\r\n                        textureCoordinates[textureCoordIndex + 1 + bottomOffset2] = sty;\r\n                    }\r\n                    if (top) {\r\n                        textureCoordinates[textureCoordIndex] = stx;\r\n                        textureCoordinates[textureCoordIndex + 1] = sty;\r\n                    }\r\n\r\n                    textureCoordIndex += 2;\r\n                }\r\n\r\n                if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent || shadowVolume) {\r\n                    var attrIndex1 = attrIndex + 1;\r\n                    var attrIndex2 = attrIndex + 2;\r\n\r\n                    if (wall) {\r\n                        if (i + 3 < length) {\r\n                            var p1 = Cartesian3.fromArray(flatPositions, i + 3, p1Scratch);\r\n\r\n                            if (recomputeNormal) {\r\n                                var p2 = Cartesian3.fromArray(flatPositions, i + length, p2Scratch);\r\n                                if (perPositionHeight) {\r\n                                    adjustPosHeightsForNormal(position, p1, p2, ellipsoid);\r\n                                }\r\n                                Cartesian3.subtract(p1, position, p1);\r\n                                Cartesian3.subtract(p2, position, p2);\r\n                                normal = Cartesian3.normalize(Cartesian3.cross(p2, p1, normal), normal);\r\n                                recomputeNormal = false;\r\n                            }\r\n\r\n                            if (Cartesian3.equalsEpsilon(p1, position, CesiumMath.EPSILON10)) { // if we've reached a corner\r\n                                recomputeNormal = true;\r\n                            }\r\n                        }\r\n\r\n                        if (vertexFormat.tangent || vertexFormat.bitangent) {\r\n                            bitangent = ellipsoid.geodeticSurfaceNormal(position, bitangent);\r\n                            if (vertexFormat.tangent) {\r\n                                tangent = Cartesian3.normalize(Cartesian3.cross(bitangent, normal, tangent), tangent);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        normal = ellipsoid.geodeticSurfaceNormal(position, normal);\r\n                        if (vertexFormat.tangent || vertexFormat.bitangent) {\r\n                            if (perPositionHeight) {\r\n                                scratchPerPosNormal = Cartesian3.fromArray(normals, attrIndex, scratchPerPosNormal);\r\n                                scratchPerPosTangent = Cartesian3.cross(Cartesian3.UNIT_Z, scratchPerPosNormal, scratchPerPosTangent);\r\n                                scratchPerPosTangent = Cartesian3.normalize(Matrix3.multiplyByVector(tangentRotationMatrix, scratchPerPosTangent, scratchPerPosTangent), scratchPerPosTangent);\r\n                                if (vertexFormat.bitangent) {\r\n                                    scratchPerPosBitangent = Cartesian3.normalize(Cartesian3.cross(scratchPerPosNormal, scratchPerPosTangent, scratchPerPosBitangent), scratchPerPosBitangent);\r\n                                }\r\n                            }\r\n\r\n                            tangent = Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);\r\n                            tangent = Cartesian3.normalize(Matrix3.multiplyByVector(tangentRotationMatrix, tangent, tangent), tangent);\r\n                            if (vertexFormat.bitangent) {\r\n                                bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (vertexFormat.normal) {\r\n                        if (options.wall) {\r\n                            normals[attrIndex + bottomOffset] = normal.x;\r\n                            normals[attrIndex1 + bottomOffset] = normal.y;\r\n                            normals[attrIndex2 + bottomOffset] = normal.z;\r\n                        } else if (bottom){\r\n                            normals[attrIndex + bottomOffset] = -normal.x;\r\n                            normals[attrIndex1 + bottomOffset] = -normal.y;\r\n                            normals[attrIndex2 + bottomOffset] = -normal.z;\r\n                        }\r\n\r\n                        if ((top && !perPositionHeight) || wall) {\r\n                            normals[attrIndex] = normal.x;\r\n                            normals[attrIndex1] = normal.y;\r\n                            normals[attrIndex2] = normal.z;\r\n                        }\r\n                    }\r\n\r\n                    if (shadowVolume) {\r\n                        if (wall) {\r\n                            normal = ellipsoid.geodeticSurfaceNormal(position, normal);\r\n                        }\r\n                        extrudeNormals[attrIndex + bottomOffset] = -normal.x;\r\n                        extrudeNormals[attrIndex1 + bottomOffset] = -normal.y;\r\n                        extrudeNormals[attrIndex2 + bottomOffset] = -normal.z;\r\n                    }\r\n\r\n                    if (vertexFormat.tangent) {\r\n                        if (options.wall) {\r\n                            tangents[attrIndex + bottomOffset] = tangent.x;\r\n                            tangents[attrIndex1 + bottomOffset] = tangent.y;\r\n                            tangents[attrIndex2 + bottomOffset] = tangent.z;\r\n                        } else if (bottom) {\r\n                            tangents[attrIndex + bottomOffset] = -tangent.x;\r\n                            tangents[attrIndex1 + bottomOffset] = -tangent.y;\r\n                            tangents[attrIndex2 + bottomOffset] = -tangent.z;\r\n                        }\r\n\r\n                        if(top) {\r\n                            if (perPositionHeight) {\r\n                                tangents[attrIndex] = scratchPerPosTangent.x;\r\n                                tangents[attrIndex1] = scratchPerPosTangent.y;\r\n                                tangents[attrIndex2] = scratchPerPosTangent.z;\r\n                            } else {\r\n                                tangents[attrIndex] = tangent.x;\r\n                                tangents[attrIndex1] = tangent.y;\r\n                                tangents[attrIndex2] = tangent.z;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (vertexFormat.bitangent) {\r\n                        if (bottom) {\r\n                            bitangents[attrIndex + bottomOffset] = bitangent.x;\r\n                            bitangents[attrIndex1 + bottomOffset] = bitangent.y;\r\n                            bitangents[attrIndex2 + bottomOffset] = bitangent.z;\r\n                        }\r\n                        if (top) {\r\n                            if (perPositionHeight) {\r\n                                bitangents[attrIndex] = scratchPerPosBitangent.x;\r\n                                bitangents[attrIndex1] = scratchPerPosBitangent.y;\r\n                                bitangents[attrIndex2] = scratchPerPosBitangent.z;\r\n                            } else {\r\n                                bitangents[attrIndex] = bitangent.x;\r\n                                bitangents[attrIndex1] = bitangent.y;\r\n                                bitangents[attrIndex2] = bitangent.z;\r\n                            }\r\n                        }\r\n                    }\r\n                    attrIndex += 3;\r\n                }\r\n            }\r\n\r\n            if (vertexFormat.st) {\r\n                geometry.attributes.st = new GeometryAttribute({\r\n                    componentDatatype : ComponentDatatype.FLOAT,\r\n                    componentsPerAttribute : 2,\r\n                    values : textureCoordinates\r\n                });\r\n            }\r\n\r\n            if (vertexFormat.normal) {\r\n                geometry.attributes.normal = new GeometryAttribute({\r\n                    componentDatatype : ComponentDatatype.FLOAT,\r\n                    componentsPerAttribute : 3,\r\n                    values : normals\r\n                });\r\n            }\r\n\r\n            if (vertexFormat.tangent) {\r\n                geometry.attributes.tangent = new GeometryAttribute({\r\n                    componentDatatype : ComponentDatatype.FLOAT,\r\n                    componentsPerAttribute : 3,\r\n                    values : tangents\r\n                });\r\n            }\r\n\r\n            if (vertexFormat.bitangent) {\r\n                geometry.attributes.bitangent = new GeometryAttribute({\r\n                    componentDatatype : ComponentDatatype.FLOAT,\r\n                    componentsPerAttribute : 3,\r\n                    values : bitangents\r\n                });\r\n            }\r\n\r\n            if (shadowVolume) {\r\n                geometry.attributes.extrudeDirection = new GeometryAttribute({\r\n                    componentDatatype : ComponentDatatype.FLOAT,\r\n                    componentsPerAttribute : 3,\r\n                    values : extrudeNormals\r\n                });\r\n            }\r\n        }\r\n\r\n        if (options.extrude && defined(options.offsetAttribute)) {\r\n            var size = flatPositions.length / 3;\r\n            var offsetAttribute = new Uint8Array(size);\r\n\r\n            if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\r\n                if ((top && bottom) || wall) {\r\n                    offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\r\n                } else if (top) {\r\n                    offsetAttribute = arrayFill(offsetAttribute, 1);\r\n                }\r\n            } else {\r\n                var offsetValue = options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\r\n                offsetAttribute = arrayFill(offsetAttribute, offsetValue);\r\n            }\r\n\r\n            geometry.attributes.applyOffset = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\r\n                componentsPerAttribute : 1,\r\n                values : offsetAttribute\r\n            });\r\n        }\r\n\r\n        return geometry;\r\n    }\r\n\r\n    var startCartographicScratch = new Cartographic();\r\n    var endCartographicScratch = new Cartographic();\r\n    var idlCross = {\r\n        westOverIDL : 0.0,\r\n        eastOverIDL : 0.0\r\n    };\r\n    var ellipsoidGeodesic = new EllipsoidGeodesic();\r\n    function computeRectangle(positions, ellipsoid, arcType, granularity, result) {\r\n        result = defaultValue(result, new Rectangle());\r\n        if (!defined(positions) || positions.length < 3) {\r\n            result.west = 0.0;\r\n            result.north = 0.0;\r\n            result.south = 0.0;\r\n            result.east = 0.0;\r\n            return result;\r\n        }\r\n\r\n        if (arcType === ArcType.RHUMB) {\r\n            return Rectangle.fromCartesianArray(positions, ellipsoid, result);\r\n        }\r\n\r\n        if (!ellipsoidGeodesic.ellipsoid.equals(ellipsoid)) {\r\n            ellipsoidGeodesic = new EllipsoidGeodesic(undefined, undefined, ellipsoid);\r\n        }\r\n\r\n        result.west = Number.POSITIVE_INFINITY;\r\n        result.east = Number.NEGATIVE_INFINITY;\r\n        result.south = Number.POSITIVE_INFINITY;\r\n        result.north = Number.NEGATIVE_INFINITY;\r\n\r\n        idlCross.westOverIDL = Number.POSITIVE_INFINITY;\r\n        idlCross.eastOverIDL = Number.NEGATIVE_INFINITY;\r\n\r\n        var inverseChordLength = 1.0 / CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\r\n        var positionsLength = positions.length;\r\n        var endCartographic = ellipsoid.cartesianToCartographic(positions[0], endCartographicScratch);\r\n        var startCartographic = startCartographicScratch;\r\n        var swap;\r\n\r\n        for (var i = 1; i < positionsLength; i++) {\r\n            swap = startCartographic;\r\n            startCartographic = endCartographic;\r\n            endCartographic = ellipsoid.cartesianToCartographic(positions[i], swap);\r\n            ellipsoidGeodesic.setEndPoints(startCartographic, endCartographic);\r\n            interpolateAndGrowRectangle(ellipsoidGeodesic, inverseChordLength, result, idlCross);\r\n        }\r\n\r\n        swap = startCartographic;\r\n        startCartographic = endCartographic;\r\n        endCartographic = ellipsoid.cartesianToCartographic(positions[0], swap);\r\n        ellipsoidGeodesic.setEndPoints(startCartographic, endCartographic);\r\n        interpolateAndGrowRectangle(ellipsoidGeodesic, inverseChordLength, result, idlCross);\r\n\r\n        if (result.east - result.west > idlCross.eastOverIDL - idlCross.westOverIDL) {\r\n            result.west = idlCross.westOverIDL;\r\n            result.east = idlCross.eastOverIDL;\r\n\r\n            if (result.east > CesiumMath.PI) {\r\n                result.east = result.east - CesiumMath.TWO_PI;\r\n            }\r\n            if (result.west > CesiumMath.PI) {\r\n                result.west = result.west - CesiumMath.TWO_PI;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    var interpolatedCartographicScratch = new Cartographic();\r\n    function interpolateAndGrowRectangle(ellipsoidGeodesic, inverseChordLength, result, idlCross) {\r\n        var segmentLength = ellipsoidGeodesic.surfaceDistance;\r\n\r\n        var numPoints = Math.ceil(segmentLength * inverseChordLength);\r\n        var subsegmentDistance = numPoints > 0 ? segmentLength / (numPoints - 1) : Number.POSITIVE_INFINITY;\r\n        var interpolationDistance = 0.0;\r\n\r\n        for (var i = 0; i < numPoints; i++) {\r\n            var interpolatedCartographic = ellipsoidGeodesic.interpolateUsingSurfaceDistance(interpolationDistance, interpolatedCartographicScratch);\r\n            interpolationDistance += subsegmentDistance;\r\n            var longitude = interpolatedCartographic.longitude;\r\n            var latitude = interpolatedCartographic.latitude;\r\n\r\n            result.west = Math.min(result.west, longitude);\r\n            result.east = Math.max(result.east, longitude);\r\n            result.south = Math.min(result.south, latitude);\r\n            result.north = Math.max(result.north, latitude);\r\n\r\n            var lonAdjusted = longitude >= 0 ?  longitude : longitude +  CesiumMath.TWO_PI;\r\n            idlCross.westOverIDL = Math.min(idlCross.westOverIDL, lonAdjusted);\r\n            idlCross.eastOverIDL = Math.max(idlCross.eastOverIDL, lonAdjusted);\r\n        }\r\n    }\r\n\r\n    var createGeometryFromPositionsExtrudedPositions = [];\r\n\r\n    function createGeometryFromPositionsExtruded(ellipsoid, polygon, granularity, hierarchy, perPositionHeight, closeTop, closeBottom, vertexFormat, arcType) {\r\n        var geos = {\r\n            walls : []\r\n        };\r\n        var i;\r\n\r\n        if (closeTop || closeBottom) {\r\n            var topGeo = PolygonGeometryLibrary.createGeometryFromPositions(ellipsoid, polygon, granularity, perPositionHeight, vertexFormat, arcType);\r\n\r\n            var edgePoints = topGeo.attributes.position.values;\r\n            var indices = topGeo.indices;\r\n            var numPositions;\r\n            var newIndices;\r\n\r\n            if (closeTop && closeBottom) {\r\n                var topBottomPositions = edgePoints.concat(edgePoints);\r\n\r\n                numPositions = topBottomPositions.length / 3;\r\n\r\n                newIndices = IndexDatatype.createTypedArray(numPositions, indices.length * 2);\r\n                newIndices.set(indices);\r\n                var ilength = indices.length;\r\n\r\n                var length = numPositions / 2;\r\n\r\n                for (i = 0; i < ilength; i += 3) {\r\n                    var i0 = newIndices[i] + length;\r\n                    var i1 = newIndices[i + 1] + length;\r\n                    var i2 = newIndices[i + 2] + length;\r\n\r\n                    newIndices[i + ilength] = i2;\r\n                    newIndices[i + 1 + ilength] = i1;\r\n                    newIndices[i + 2 + ilength] = i0;\r\n                }\r\n\r\n                topGeo.attributes.position.values = topBottomPositions;\r\n                if (perPositionHeight && vertexFormat.normal) {\r\n                    var normals = topGeo.attributes.normal.values;\r\n                    topGeo.attributes.normal.values = new Float32Array(topBottomPositions.length);\r\n                    topGeo.attributes.normal.values.set(normals);\r\n                }\r\n                topGeo.indices = newIndices;\r\n            } else if (closeBottom) {\r\n                numPositions = edgePoints.length / 3;\r\n                newIndices = IndexDatatype.createTypedArray(numPositions, indices.length);\r\n\r\n                for (i = 0; i < indices.length; i += 3) {\r\n                    newIndices[i] = indices[i + 2];\r\n                    newIndices[i + 1] = indices[i + 1];\r\n                    newIndices[i + 2] = indices[i];\r\n                }\r\n\r\n                topGeo.indices = newIndices;\r\n            }\r\n\r\n            geos.topAndBottom = new GeometryInstance({\r\n                geometry : topGeo\r\n            });\r\n        }\r\n\r\n        var outerRing = hierarchy.outerRing;\r\n        var tangentPlane = EllipsoidTangentPlane.fromPoints(outerRing, ellipsoid);\r\n        var positions2D = tangentPlane.projectPointsOntoPlane(outerRing, createGeometryFromPositionsExtrudedPositions);\r\n\r\n        var windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\r\n        if (windingOrder === WindingOrder.CLOCKWISE) {\r\n            outerRing = outerRing.slice().reverse();\r\n        }\r\n\r\n        var wallGeo = PolygonGeometryLibrary.computeWallGeometry(outerRing, ellipsoid, granularity, perPositionHeight, arcType);\r\n        geos.walls.push(new GeometryInstance({\r\n            geometry : wallGeo\r\n        }));\r\n\r\n        var holes = hierarchy.holes;\r\n        for (i = 0; i < holes.length; i++) {\r\n            var hole = holes[i];\r\n\r\n            tangentPlane = EllipsoidTangentPlane.fromPoints(hole, ellipsoid);\r\n            positions2D = tangentPlane.projectPointsOntoPlane(hole, createGeometryFromPositionsExtrudedPositions);\r\n\r\n            windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\r\n            if (windingOrder === WindingOrder.COUNTER_CLOCKWISE) {\r\n                hole = hole.slice().reverse();\r\n            }\r\n\r\n            wallGeo = PolygonGeometryLibrary.computeWallGeometry(hole, ellipsoid, granularity, perPositionHeight, arcType);\r\n            geos.walls.push(new GeometryInstance({\r\n                geometry : wallGeo\r\n            }));\r\n        }\r\n\r\n        return geos;\r\n    }\r\n\r\n    /**\r\n     * A description of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\r\n     *\r\n     * @alias PolygonGeometry\r\n     * @constructor\r\n     *\r\n     * @param {Object} options Object with the following properties:\r\n     * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\r\n     * @param {Number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.\r\n     * @param {Number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.\r\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\r\n     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\r\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\r\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n     * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\r\n     * @param {Boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.\r\n     * @param {Boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.\r\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\r\n     *\r\n     * @see PolygonGeometry#createGeometry\r\n     * @see PolygonGeometry#fromPositions\r\n     *\r\n     * @demo {@link https://sandcastle.cesium.com/index.html?src=Polygon.html|Cesium Sandcastle Polygon Demo}\r\n     *\r\n     * @example\r\n     * // 1. create a polygon from points\r\n     * var polygon = new Cesium.PolygonGeometry({\r\n     *   polygonHierarchy : new Cesium.PolygonHierarchy(\r\n     *     Cesium.Cartesian3.fromDegreesArray([\r\n     *       -72.0, 40.0,\r\n     *       -70.0, 35.0,\r\n     *       -75.0, 30.0,\r\n     *       -70.0, 30.0,\r\n     *       -68.0, 40.0\r\n     *     ])\r\n     *   )\r\n     * });\r\n     * var geometry = Cesium.PolygonGeometry.createGeometry(polygon);\r\n     *\r\n     * // 2. create a nested polygon with holes\r\n     * var polygonWithHole = new Cesium.PolygonGeometry({\r\n     *   polygonHierarchy : new Cesium.PolygonHierarchy(\r\n     *     Cesium.Cartesian3.fromDegreesArray([\r\n     *       -109.0, 30.0,\r\n     *       -95.0, 30.0,\r\n     *       -95.0, 40.0,\r\n     *       -109.0, 40.0\r\n     *     ]),\r\n     *     [new Cesium.PolygonHierarchy(\r\n     *       Cesium.Cartesian3.fromDegreesArray([\r\n     *         -107.0, 31.0,\r\n     *         -107.0, 39.0,\r\n     *         -97.0, 39.0,\r\n     *         -97.0, 31.0\r\n     *       ]),\r\n     *       [new Cesium.PolygonHierarchy(\r\n     *         Cesium.Cartesian3.fromDegreesArray([\r\n     *           -105.0, 33.0,\r\n     *           -99.0, 33.0,\r\n     *           -99.0, 37.0,\r\n     *           -105.0, 37.0\r\n     *         ]),\r\n     *         [new Cesium.PolygonHierarchy(\r\n     *           Cesium.Cartesian3.fromDegreesArray([\r\n     *             -103.0, 34.0,\r\n     *             -101.0, 34.0,\r\n     *             -101.0, 36.0,\r\n     *             -103.0, 36.0\r\n     *           ])\r\n     *         )]\r\n     *       )]\r\n     *     )]\r\n     *   )\r\n     * });\r\n     * var geometry = Cesium.PolygonGeometry.createGeometry(polygonWithHole);\r\n     *\r\n     * // 3. create extruded polygon\r\n     * var extrudedPolygon = new Cesium.PolygonGeometry({\r\n     *   polygonHierarchy : new Cesium.PolygonHierarchy(\r\n     *     Cesium.Cartesian3.fromDegreesArray([\r\n     *       -72.0, 40.0,\r\n     *       -70.0, 35.0,\r\n     *       -75.0, 30.0,\r\n     *       -70.0, 30.0,\r\n     *       -68.0, 40.0\r\n     *     ])\r\n     *   ),\r\n     *   extrudedHeight: 300000\r\n     * });\r\n     * var geometry = Cesium.PolygonGeometry.createGeometry(extrudedPolygon);\r\n     */\r\n    function PolygonGeometry(options) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('options', options);\r\n        Check.typeOf.object('options.polygonHierarchy', options.polygonHierarchy);\r\n        if (defined(options.perPositionHeight) && options.perPositionHeight && defined(options.height)) {\r\n            throw new DeveloperError('Cannot use both options.perPositionHeight and options.height');\r\n        }\r\n        if (defined(options.arcType) && options.arcType !== ArcType.GEODESIC && options.arcType !== ArcType.RHUMB) {\r\n            throw new DeveloperError('Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var polygonHierarchy = options.polygonHierarchy;\r\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\r\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\r\n        var stRotation = defaultValue(options.stRotation, 0.0);\r\n        var perPositionHeight = defaultValue(options.perPositionHeight, false);\r\n        var perPositionHeightExtrude = perPositionHeight && defined(options.extrudedHeight);\r\n        var height = defaultValue(options.height, 0.0);\r\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\r\n\r\n        if (!perPositionHeightExtrude) {\r\n            var h = Math.max(height, extrudedHeight);\r\n            extrudedHeight = Math.min(height, extrudedHeight);\r\n            height = h;\r\n        }\r\n\r\n        this._vertexFormat = VertexFormat.clone(vertexFormat);\r\n        this._ellipsoid = Ellipsoid.clone(ellipsoid);\r\n        this._granularity = granularity;\r\n        this._stRotation = stRotation;\r\n        this._height = height;\r\n        this._extrudedHeight = extrudedHeight;\r\n        this._closeTop = defaultValue(options.closeTop, true);\r\n        this._closeBottom = defaultValue(options.closeBottom, true);\r\n        this._polygonHierarchy = polygonHierarchy;\r\n        this._perPositionHeight = perPositionHeight;\r\n        this._perPositionHeightExtrude = perPositionHeightExtrude;\r\n        this._shadowVolume = defaultValue(options.shadowVolume, false);\r\n        this._workerName = 'createPolygonGeometry';\r\n        this._offsetAttribute = options.offsetAttribute;\r\n        this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);\r\n\r\n        this._rectangle = undefined;\r\n        this._textureCoordinateRotationPoints = undefined;\r\n\r\n        /**\r\n         * The number of elements used to pack the object into an array.\r\n         * @type {Number}\r\n         */\r\n        this.packedLength = PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) + Ellipsoid.packedLength + VertexFormat.packedLength + 12;\r\n    }\r\n\r\n    /**\r\n     * A description of a polygon from an array of positions. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\r\n     *\r\n     * @param {Object} options Object with the following properties:\r\n     * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\r\n     * @param {Number} [options.height=0.0] The height of the polygon.\r\n     * @param {Number} [options.extrudedHeight] The height of the polygon extrusion.\r\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\r\n     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\r\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\r\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n     * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\r\n     * @param {Boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.\r\n     * @param {Boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.\r\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\r\n     * @returns {PolygonGeometry}\r\n     *\r\n     *\r\n     * @example\r\n     * // create a polygon from points\r\n     * var polygon = Cesium.PolygonGeometry.fromPositions({\r\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\r\n     *     -72.0, 40.0,\r\n     *     -70.0, 35.0,\r\n     *     -75.0, 30.0,\r\n     *     -70.0, 30.0,\r\n     *     -68.0, 40.0\r\n     *   ])\r\n     * });\r\n     * var geometry = Cesium.PolygonGeometry.createGeometry(polygon);\r\n     *\r\n     * @see PolygonGeometry#createGeometry\r\n     */\r\n    PolygonGeometry.fromPositions = function(options) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('options.positions', options.positions);\r\n        //>>includeEnd('debug');\r\n\r\n        var newOptions = {\r\n            polygonHierarchy : {\r\n                positions : options.positions\r\n            },\r\n            height : options.height,\r\n            extrudedHeight : options.extrudedHeight,\r\n            vertexFormat : options.vertexFormat,\r\n            stRotation : options.stRotation,\r\n            ellipsoid : options.ellipsoid,\r\n            granularity : options.granularity,\r\n            perPositionHeight : options.perPositionHeight,\r\n            closeTop : options.closeTop,\r\n            closeBottom : options.closeBottom,\r\n            offsetAttribute : options.offsetAttribute,\r\n            arcType : options.arcType\r\n        };\r\n        return new PolygonGeometry(newOptions);\r\n    };\r\n\r\n    /**\r\n     * Stores the provided instance into the provided array.\r\n     *\r\n     * @param {PolygonGeometry} value The value to pack.\r\n     * @param {Number[]} array The array to pack into.\r\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n     *\r\n     * @returns {Number[]} The array that was packed into\r\n     */\r\n    PolygonGeometry.pack = function(value, array, startingIndex) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('value', value);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._polygonHierarchy, array, startingIndex);\r\n\r\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\r\n        startingIndex += Ellipsoid.packedLength;\r\n\r\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\r\n        startingIndex += VertexFormat.packedLength;\r\n\r\n        array[startingIndex++] = value._height;\r\n        array[startingIndex++] = value._extrudedHeight;\r\n        array[startingIndex++] = value._granularity;\r\n        array[startingIndex++] = value._stRotation;\r\n        array[startingIndex++] = value._perPositionHeightExtrude ? 1.0 : 0.0;\r\n        array[startingIndex++] = value._perPositionHeight ? 1.0 : 0.0;\r\n        array[startingIndex++] = value._closeTop ? 1.0 : 0.0;\r\n        array[startingIndex++] = value._closeBottom ? 1.0 : 0.0;\r\n        array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\r\n        array[startingIndex++] = defaultValue(value._offsetAttribute, -1);\r\n        array[startingIndex++] = value._arcType;\r\n        array[startingIndex] = value.packedLength;\r\n\r\n        return array;\r\n    };\r\n\r\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\r\n    var scratchVertexFormat = new VertexFormat();\r\n\r\n    //Only used to avoid inability to default construct.\r\n    var dummyOptions = {\r\n        polygonHierarchy : {}\r\n    };\r\n\r\n    /**\r\n     * Retrieves an instance from a packed array.\r\n     *\r\n     * @param {Number[]} array The packed array.\r\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n     * @param {PolygonGeometry} [result] The object into which to store the result.\r\n     */\r\n    PolygonGeometry.unpack = function(array, startingIndex, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex);\r\n        startingIndex = polygonHierarchy.startingIndex;\r\n        delete polygonHierarchy.startingIndex;\r\n\r\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\r\n        startingIndex += Ellipsoid.packedLength;\r\n\r\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\r\n        startingIndex += VertexFormat.packedLength;\r\n\r\n        var height = array[startingIndex++];\r\n        var extrudedHeight = array[startingIndex++];\r\n        var granularity = array[startingIndex++];\r\n        var stRotation = array[startingIndex++];\r\n        var perPositionHeightExtrude = array[startingIndex++] === 1.0;\r\n        var perPositionHeight = array[startingIndex++] === 1.0;\r\n        var closeTop = array[startingIndex++] === 1.0;\r\n        var closeBottom = array[startingIndex++] === 1.0;\r\n        var shadowVolume = array[startingIndex++] === 1.0;\r\n        var offsetAttribute = array[startingIndex++];\r\n        var arcType = array[startingIndex++];\r\n        var packedLength = array[startingIndex];\r\n\r\n        if (!defined(result)) {\r\n            result = new PolygonGeometry(dummyOptions);\r\n        }\r\n\r\n        result._polygonHierarchy = polygonHierarchy;\r\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\r\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\r\n        result._height = height;\r\n        result._extrudedHeight = extrudedHeight;\r\n        result._granularity = granularity;\r\n        result._stRotation = stRotation;\r\n        result._perPositionHeightExtrude = perPositionHeightExtrude;\r\n        result._perPositionHeight = perPositionHeight;\r\n        result._closeTop = closeTop;\r\n        result._closeBottom = closeBottom;\r\n        result._shadowVolume = shadowVolume;\r\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\r\n        result._arcType = arcType;\r\n        result.packedLength = packedLength;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Returns the bounding rectangle given the provided options\r\n     *\r\n     * @param {Object} options Object with the following properties:\r\n     * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\r\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions sampled.\r\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\r\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\r\n     * @param {Rectangle} [result] An object in which to store the result.\r\n     *\r\n     * @returns {Rectangle} The result rectangle\r\n     */\r\n    PolygonGeometry.computeRectangle = function(options, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('options', options);\r\n        Check.typeOf.object('options.polygonHierarchy', options.polygonHierarchy);\r\n        //>>includeEnd('debug');\r\n\r\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\r\n        var arcType = defaultValue(options.arcType, ArcType.GEODESIC);\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (arcType !== ArcType.GEODESIC && arcType !== ArcType.RHUMB) {\r\n            throw new DeveloperError('Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var polygonHierarchy = options.polygonHierarchy;\r\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n\r\n        return computeRectangle(polygonHierarchy.positions, ellipsoid, arcType, granularity, result);\r\n    };\r\n\r\n    /**\r\n     * Computes the geometric representation of a polygon, including its vertices, indices, and a bounding sphere.\r\n     *\r\n     * @param {PolygonGeometry} polygonGeometry A description of the polygon.\r\n     * @returns {Geometry|undefined} The computed vertices and indices.\r\n     */\r\n    PolygonGeometry.createGeometry = function(polygonGeometry) {\r\n        var vertexFormat = polygonGeometry._vertexFormat;\r\n        var ellipsoid = polygonGeometry._ellipsoid;\r\n        var granularity = polygonGeometry._granularity;\r\n        var stRotation = polygonGeometry._stRotation;\r\n        var polygonHierarchy = polygonGeometry._polygonHierarchy;\r\n        var perPositionHeight = polygonGeometry._perPositionHeight;\r\n        var closeTop = polygonGeometry._closeTop;\r\n        var closeBottom = polygonGeometry._closeBottom;\r\n        var arcType = polygonGeometry._arcType;\r\n\r\n        var outerPositions = polygonHierarchy.positions;\r\n        if (outerPositions.length < 3) {\r\n            return;\r\n        }\r\n\r\n        var tangentPlane = EllipsoidTangentPlane.fromPoints(outerPositions, ellipsoid);\r\n\r\n        var results = PolygonGeometryLibrary.polygonsFromHierarchy(polygonHierarchy, tangentPlane.projectPointsOntoPlane.bind(tangentPlane), !perPositionHeight, ellipsoid);\r\n\r\n        var hierarchy = results.hierarchy;\r\n        var polygons = results.polygons;\r\n\r\n        if (hierarchy.length === 0) {\r\n            return;\r\n        }\r\n\r\n        outerPositions = hierarchy[0].outerRing;\r\n        var boundingRectangle = PolygonGeometryLibrary.computeBoundingRectangle(tangentPlane.plane.normal, tangentPlane.projectPointOntoPlane.bind(tangentPlane), outerPositions, stRotation, scratchBoundingRectangle);\r\n\r\n        var geometries = [];\r\n\r\n        var height = polygonGeometry._height;\r\n        var extrudedHeight = polygonGeometry._extrudedHeight;\r\n        var extrude = polygonGeometry._perPositionHeightExtrude || !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\r\n\r\n        var options = {\r\n            perPositionHeight: perPositionHeight,\r\n            vertexFormat: vertexFormat,\r\n            geometry: undefined,\r\n            tangentPlane: tangentPlane,\r\n            boundingRectangle: boundingRectangle,\r\n            ellipsoid: ellipsoid,\r\n            stRotation: stRotation,\r\n            bottom: false,\r\n            top: true,\r\n            wall: false,\r\n            extrude: false,\r\n            arcType: arcType\r\n        };\r\n\r\n        var i;\r\n\r\n        if (extrude) {\r\n            options.extrude = true;\r\n            options.top = closeTop;\r\n            options.bottom = closeBottom;\r\n            options.shadowVolume = polygonGeometry._shadowVolume;\r\n            options.offsetAttribute = polygonGeometry._offsetAttribute;\r\n            for (i = 0; i < polygons.length; i++) {\r\n                var splitGeometry = createGeometryFromPositionsExtruded(ellipsoid, polygons[i], granularity, hierarchy[i], perPositionHeight, closeTop, closeBottom, vertexFormat, arcType);\r\n\r\n                var topAndBottom;\r\n                if (closeTop && closeBottom) {\r\n                    topAndBottom = splitGeometry.topAndBottom;\r\n                    options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(topAndBottom.geometry, height, extrudedHeight, ellipsoid, perPositionHeight);\r\n                } else if (closeTop) {\r\n                    topAndBottom = splitGeometry.topAndBottom;\r\n                    topAndBottom.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(topAndBottom.geometry.attributes.position.values, height, ellipsoid, !perPositionHeight);\r\n                    options.geometry = topAndBottom.geometry;\r\n                } else if (closeBottom) {\r\n                    topAndBottom = splitGeometry.topAndBottom;\r\n                    topAndBottom.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(topAndBottom.geometry.attributes.position.values, extrudedHeight, ellipsoid, true);\r\n                    options.geometry = topAndBottom.geometry;\r\n                }\r\n                if (closeTop || closeBottom) {\r\n                    options.wall = false;\r\n                    topAndBottom.geometry = computeAttributes(options);\r\n                    geometries.push(topAndBottom);\r\n                }\r\n\r\n                var walls = splitGeometry.walls;\r\n                options.wall = true;\r\n                for ( var k = 0; k < walls.length; k++) {\r\n                    var wall = walls[k];\r\n                    options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(wall.geometry, height, extrudedHeight, ellipsoid, perPositionHeight);\r\n                    wall.geometry = computeAttributes(options);\r\n                    geometries.push(wall);\r\n                }\r\n            }\r\n        } else {\r\n            for (i = 0; i < polygons.length; i++) {\r\n                var geometryInstance = new GeometryInstance({\r\n                    geometry : PolygonGeometryLibrary.createGeometryFromPositions(ellipsoid, polygons[i], granularity, perPositionHeight, vertexFormat, arcType)\r\n                });\r\n                geometryInstance.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(geometryInstance.geometry.attributes.position.values, height, ellipsoid, !perPositionHeight);\r\n                options.geometry = geometryInstance.geometry;\r\n                geometryInstance.geometry = computeAttributes(options);\r\n\r\n                if (defined(polygonGeometry._offsetAttribute)) {\r\n                    var length = geometryInstance.geometry.attributes.position.values.length;\r\n                    var applyOffset = new Uint8Array(length / 3);\r\n                    var offsetValue = polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\r\n                    arrayFill(applyOffset, offsetValue);\r\n                    geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute({\r\n                        componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\r\n                        componentsPerAttribute : 1,\r\n                        values: applyOffset\r\n                    });\r\n                }\r\n\r\n                geometries.push(geometryInstance);\r\n            }\r\n        }\r\n\r\n        var geometry = GeometryPipeline.combineInstances(geometries)[0];\r\n        geometry.attributes.position.values = new Float64Array(geometry.attributes.position.values);\r\n        geometry.indices = IndexDatatype.createTypedArray(geometry.attributes.position.values.length / 3, geometry.indices);\r\n\r\n        var attributes = geometry.attributes;\r\n        var boundingSphere = BoundingSphere.fromVertices(attributes.position.values);\r\n\r\n        if (!vertexFormat.position) {\r\n            delete attributes.position;\r\n        }\r\n\r\n        return new Geometry({\r\n            attributes : attributes,\r\n            indices : geometry.indices,\r\n            primitiveType : geometry.primitiveType,\r\n            boundingSphere : boundingSphere,\r\n            offsetAttribute : polygonGeometry._offsetAttribute\r\n        });\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    PolygonGeometry.createShadowVolume = function(polygonGeometry, minHeightFunc, maxHeightFunc) {\r\n        var granularity = polygonGeometry._granularity;\r\n        var ellipsoid = polygonGeometry._ellipsoid;\r\n\r\n        var minHeight = minHeightFunc(granularity, ellipsoid);\r\n        var maxHeight = maxHeightFunc(granularity, ellipsoid);\r\n\r\n        return new PolygonGeometry({\r\n            polygonHierarchy : polygonGeometry._polygonHierarchy,\r\n            ellipsoid : ellipsoid,\r\n            stRotation : polygonGeometry._stRotation,\r\n            granularity : granularity,\r\n            perPositionHeight : false,\r\n            extrudedHeight : minHeight,\r\n            height : maxHeight,\r\n            vertexFormat : VertexFormat.POSITION_ONLY,\r\n            shadowVolume: true,\r\n            arcType : polygonGeometry._arcType\r\n        });\r\n    };\r\n\r\n    function textureCoordinateRotationPoints(polygonGeometry) {\r\n        var stRotation = -polygonGeometry._stRotation;\r\n        if (stRotation === 0.0) {\r\n            return [0, 0, 0, 1, 1, 0];\r\n        }\r\n        var ellipsoid = polygonGeometry._ellipsoid;\r\n        var positions = polygonGeometry._polygonHierarchy.positions;\r\n        var boundingRectangle = polygonGeometry.rectangle;\r\n        return Geometry._textureCoordinateRotationPoints(positions, stRotation, ellipsoid, boundingRectangle);\r\n    }\r\n\r\n    Object.defineProperties(PolygonGeometry.prototype, {\r\n        /**\r\n         * @private\r\n         */\r\n        rectangle : {\r\n            get : function() {\r\n                if (!defined(this._rectangle)) {\r\n                    var positions = this._polygonHierarchy.positions;\r\n                    this._rectangle = computeRectangle(positions, this._ellipsoid, this._arcType, this._granularity);\r\n                }\r\n\r\n                return this._rectangle;\r\n            }\r\n        },\r\n        /**\r\n         * For remapping texture coordinates when rendering PolygonGeometries as GroundPrimitives.\r\n         * @private\r\n         */\r\n        textureCoordinateRotationPoints : {\r\n            get : function() {\r\n                if (!defined(this._textureCoordinateRotationPoints)) {\r\n                    this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(this);\r\n                }\r\n                return this._textureCoordinateRotationPoints;\r\n            }\r\n        }\r\n    });\r\nexport default PolygonGeometry;\r\n","import defined from '../Core/defined.js';\r\nimport Ellipsoid from '../Core/Ellipsoid.js';\r\nimport PolygonGeometry from '../Core/PolygonGeometry.js';\r\n\r\n    function createPolygonGeometry(polygonGeometry, offset) {\r\n        if (defined(offset)) {\r\n            polygonGeometry = PolygonGeometry.unpack(polygonGeometry, offset);\r\n        }\r\n        polygonGeometry._ellipsoid = Ellipsoid.clone(polygonGeometry._ellipsoid);\r\n        return PolygonGeometry.createGeometry(polygonGeometry);\r\n    }\r\nexport default createPolygonGeometry;\r\n"],"names":["scratchCarto1","Cartographic","scratchCarto2","adjustPosHeightsForNormal","position","p1","p2","ellipsoid","height","cartesianToCartographic","p1Carto","cartographicToCartesian","p2Carto","scratchBoundingRectangle","BoundingRectangle","scratchPosition","Cartesian3","scratchNormal","scratchTangent","scratchBitangent","p1Scratch","p2Scratch","scratchPerPosNormal","scratchPerPosTangent","scratchPerPosBitangent","appendTextureCoordinatesOrigin","Cartesian2","appendTextureCoordinatesCartesian2","appendTextureCoordinatesCartesian3","appendTextureCoordinatesQuaternion","Quaternion","appendTextureCoordinatesMatrix3","Matrix3","tangentMatrixScratch","computeAttributes","options","vertexFormat","geometry","shadowVolume","flatPositions","attributes","values","length","wall","top","bottom","st","normal","tangent","bitangent","boundingRectangle","tangentPlane","stRotation","perPositionHeight","origin","x","y","normals","textureCoordinates","Float32Array","undefined","tangents","bitangents","extrudeNormals","textureCoordIndex","attrIndex","recomputeNormal","textureMatrix","tangentRotationMatrix","rotation","fromAxisAngle","_plane","fromQuaternion","clone","IDENTITY","bottomOffset","bottomOffset2","i","fromArray","p","multiplyByVector","scaleToGeodeticSurface","projectPointOntoPlane","subtract","stx","CesiumMath","clamp","width","sty","attrIndex1","attrIndex2","normalize","cross","equalsEpsilon","EPSILON10","geodeticSurfaceNormal","UNIT_Z","z","GeometryAttribute","componentDatatype","ComponentDatatype","FLOAT","componentsPerAttribute","extrudeDirection","extrude","defined","offsetAttribute","size","Uint8Array","GeometryOffsetAttribute","TOP","arrayFill","offsetValue","NONE","applyOffset","UNSIGNED_BYTE","startCartographicScratch","endCartographicScratch","idlCross","westOverIDL","eastOverIDL","ellipsoidGeodesic","EllipsoidGeodesic","computeRectangle","positions","arcType","granularity","result","defaultValue","Rectangle","west","north","south","east","ArcType","RHUMB","fromCartesianArray","equals","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","swap","inverseChordLength","chordLength","maximumRadius","positionsLength","endCartographic","startCartographic","setEndPoints","interpolateAndGrowRectangle","PI","TWO_PI","interpolatedCartographicScratch","segmentLength","surfaceDistance","numPoints","Math","ceil","subsegmentDistance","interpolationDistance","interpolatedCartographic","interpolateUsingSurfaceDistance","longitude","latitude","min","max","lonAdjusted","createGeometryFromPositionsExtrudedPositions","createGeometryFromPositionsExtruded","polygon","hierarchy","closeTop","closeBottom","geos","walls","numPositions","newIndices","topGeo","PolygonGeometryLibrary","createGeometryFromPositions","edgePoints","indices","topBottomPositions","concat","IndexDatatype","createTypedArray","set","ilength","i0","i1","i2","topAndBottom","GeometryInstance","outerRing","EllipsoidTangentPlane","fromPoints","positions2D","projectPointsOntoPlane","windingOrder","PolygonPipeline","computeWindingOrder2D","WindingOrder","CLOCKWISE","slice","reverse","wallGeo","computeWallGeometry","push","holes","hole","COUNTER_CLOCKWISE","PolygonGeometry","Check","typeOf","object","polygonHierarchy","DeveloperError","GEODESIC","VertexFormat","DEFAULT","Ellipsoid","WGS84","RADIANS_PER_DEGREE","perPositionHeightExtrude","extrudedHeight","h","this","_vertexFormat","_ellipsoid","_granularity","_stRotation","_height","_extrudedHeight","_closeTop","_closeBottom","_polygonHierarchy","_perPositionHeight","_perPositionHeightExtrude","_shadowVolume","_workerName","_offsetAttribute","_arcType","_rectangle","_textureCoordinateRotationPoints","packedLength","computeHierarchyPackedLength","fromPositions","EMPTY_OBJECT","pack","value","array","startingIndex","packPolygonHierarchy","scratchEllipsoid","UNIT_SPHERE","scratchVertexFormat","dummyOptions","unpack","unpackPolygonHierarchy","createGeometry","polygonGeometry","outerPositions","results","polygonsFromHierarchy","bind","polygons","computeBoundingRectangle","plane","geometries","EPSILON2","splitGeometry","scaleToGeodeticHeightExtruded","scaleToGeodeticHeight","k","geometryInstance","GeometryPipeline","combineInstances","Float64Array","boundingSphere","BoundingSphere","fromVertices","Geometry","primitiveType","createShadowVolume","minHeightFunc","maxHeightFunc","minHeight","maxHeight","POSITION_ONLY","Object","defineProperties","prototype","rectangle","get","textureCoordinateRotationPoints","offset"],"mappings":"82BA8BI,IAAIA,EAAgB,IAAIC,eACpBC,EAAgB,IAAID,eACxB,SAASE,EAA0BC,EAAUC,EAAIC,EAAIC,GACjD,IACIC,EADSD,EAAUE,wBAAwBL,EAAUJ,GACrCQ,OAChBE,EAAUH,EAAUE,wBAAwBJ,EAAIH,GACpDQ,EAAQF,OAASA,EACjBD,EAAUI,wBAAwBD,EAASL,GAE3C,IAAIO,EAAUL,EAAUE,wBAAwBH,EAAIJ,GACpDU,EAAQJ,OAASA,EAAS,IAC1BD,EAAUI,wBAAwBC,EAASN,GAG/C,IAAIO,EAA2B,IAAIC,oBAC/BC,EAAkB,IAAIC,aACtBC,EAAgB,IAAID,aACpBE,EAAiB,IAAIF,aACrBG,EAAmB,IAAIH,aACvBI,EAAY,IAAIJ,aAChBK,EAAY,IAAIL,aAChBM,EAAsB,IAAIN,aAC1BO,EAAuB,IAAIP,aAC3BQ,EAAyB,IAAIR,aAE7BS,EAAiC,IAAIC,aACrCC,EAAqC,IAAID,aACzCE,EAAqC,IAAIZ,aACzCa,EAAqC,IAAIC,aACzCC,EAAkC,IAAIC,UACtCC,EAAuB,IAAID,UAE/B,SAASE,EAAkBC,GACvB,IAAIC,EAAeD,EAAQC,aACvBC,EAAWF,EAAQE,SACnBC,EAAeH,EAAQG,aACvBC,EAAgBF,EAASG,WAAWpC,SAASqC,OAC7CC,EAASH,EAAcG,OACvBC,EAAOR,EAAQQ,KACfC,EAAMT,EAAQS,KAAOD,EACrBE,EAASV,EAAQU,QAAUF,EAC/B,GAAIP,EAAaU,IAAMV,EAAaW,QAAUX,EAAaY,SAAWZ,EAAaa,WAAaX,EAAc,CAG1G,IAAIY,EAAoBf,EAAQe,kBAC5BC,EAAehB,EAAQgB,aACvB5C,EAAY4B,EAAQ5B,UACpB6C,EAAajB,EAAQiB,WACrBC,EAAoBlB,EAAQkB,kBAE5BC,EAAS7B,EACb6B,EAAOC,EAAIL,EAAkBK,EAC7BD,EAAOE,EAAIN,EAAkBM,EAE7B,IACIC,EADAC,EAAqBtB,EAAaU,GAAK,IAAIa,aAAkBjB,EAAS,EAAd,QAAoBkB,EAE5ExB,EAAaW,SAETU,EADAJ,GAAqBT,IAAQD,EACnBN,EAASG,WAAWO,OAAON,OAE3B,IAAIkB,aAAajB,IAGnC,IAAImB,EAAWzB,EAAaY,QAAU,IAAIW,aAAajB,QAAUkB,EAC7DE,EAAa1B,EAAaa,UAAY,IAAIU,aAAajB,QAAUkB,EACjEG,EAAiBzB,EAAe,IAAIqB,aAAajB,QAAUkB,EAE3DI,EAAoB,EACpBC,EAAY,EAEZlB,EAAS9B,EACT+B,EAAU9B,EACV+B,EAAY9B,EACZ+C,GAAkB,EAElBC,EAAgBpC,EAChBqC,EAAwBnC,EAC5B,GAAmB,IAAfmB,EAAoB,CACpB,IAAIiB,EAAWvC,aAAWwC,cAAcnB,EAAaoB,OAAOxB,OAAQK,EAAYvB,GAChFsC,EAAgBnC,UAAQwC,eAAeH,EAAUF,GAEjDE,EAAWvC,aAAWwC,cAAcnB,EAAaoB,OAAOxB,QAASK,EAAYvB,GAC7EuC,EAAwBpC,UAAQwC,eAAeH,EAAUD,QAEzDD,EAAgBnC,UAAQyC,MAAMzC,UAAQ0C,SAAUP,GAChDC,EAAwBpC,UAAQyC,MAAMzC,UAAQ0C,SAAUN,GAG5D,IAAIO,EAAe,EACfC,GAAgB,EAEhBhC,GAAOC,IACP8B,EAAejC,EAAS,EACxBkC,GAAgBlC,EAAS,EAEzBA,GAAU,GAGd,IAAM,IAAImC,GAAI,EAAGA,GAAInC,EAAQmC,IAAK,EAAG,CACjC,IAAIzE,GAAWY,aAAW8D,UAAUvC,EAAesC,GAAGjD,GAEtD,GAAIQ,EAAaU,GAAI,CACjB,IAAIiC,GAAI/C,UAAQgD,iBAAiBb,EAAe/D,GAAUW,GAC1DgE,GAAIxE,EAAU0E,uBAAuBF,GAAEA,IACvC,IAAIjC,GAAKK,EAAa+B,sBAAsBH,GAAGpD,GAC/CD,aAAWyD,SAASrC,GAAIQ,EAAQR,IAEhC,IAAIsC,GAAMC,aAAWC,MAAMxC,GAAGS,EAAIL,EAAkBqC,MAAO,EAAG,GAC1DC,GAAMH,aAAWC,MAAMxC,GAAGU,EAAIN,EAAkB1C,OAAQ,EAAG,GAC3DqC,IACAa,EAAmBM,EAAoBY,IAAiBQ,GACxD1B,EAAmBM,EAAoB,EAAIY,IAAiBY,IAE5D5C,IACAc,EAAmBM,GAAqBoB,GACxC1B,EAAmBM,EAAoB,GAAKwB,IAGhDxB,GAAqB,EAGzB,GAAI5B,EAAaW,QAAUX,EAAaY,SAAWZ,EAAaa,WAAaX,EAAc,CACvF,IAAImD,GAAaxB,EAAY,EACzByB,GAAazB,EAAY,EAE7B,GAAItB,EAAM,CACN,GAAIkC,GAAI,EAAInC,EAAQ,CAChB,IAAIrC,GAAKW,aAAW8D,UAAUvC,EAAesC,GAAI,EAAGzD,GAEpD,GAAI8C,EAAiB,CACjB,IAAI5D,GAAKU,aAAW8D,UAAUvC,EAAesC,GAAInC,EAAQrB,GACrDgC,GACAlD,EAA0BC,GAAUC,GAAIC,GAAIC,GAEhDS,aAAWmE,SAAS9E,GAAID,GAAUC,IAClCW,aAAWmE,SAAS7E,GAAIF,GAAUE,IAClCyC,EAAS/B,aAAW2E,UAAU3E,aAAW4E,MAAMtF,GAAID,GAAI0C,GAASA,GAChEmB,GAAkB,EAGlBlD,aAAW6E,cAAcxF,GAAID,GAAUiF,aAAWS,aAClD5B,GAAkB,IAItB9B,EAAaY,SAAWZ,EAAaa,aACrCA,EAAY1C,EAAUwF,sBAAsB3F,GAAU6C,GAClDb,EAAaY,UACbA,EAAUhC,aAAW2E,UAAU3E,aAAW4E,MAAM3C,EAAWF,EAAQC,GAAUA,UAIrFD,EAASxC,EAAUwF,sBAAsB3F,GAAU2C,IAC/CX,EAAaY,SAAWZ,EAAaa,aACjCI,IACA/B,EAAsBN,aAAW8D,UAAUrB,EAASQ,EAAW3C,GAC/DC,EAAuBP,aAAW4E,MAAM5E,aAAWgF,OAAQ1E,EAAqBC,GAChFA,EAAuBP,aAAW2E,UAAU3D,UAAQgD,iBAAiBZ,EAAuB7C,EAAsBA,GAAuBA,GACrIa,EAAaa,YACbzB,EAAyBR,aAAW2E,UAAU3E,aAAW4E,MAAMtE,EAAqBC,EAAsBC,GAAyBA,KAI3IwB,EAAUhC,aAAW4E,MAAM5E,aAAWgF,OAAQjD,EAAQC,GACtDA,EAAUhC,aAAW2E,UAAU3D,UAAQgD,iBAAiBZ,EAAuBpB,EAASA,GAAUA,GAC9FZ,EAAaa,YACbA,EAAYjC,aAAW2E,UAAU3E,aAAW4E,MAAM7C,EAAQC,EAASC,GAAYA,KAKvFb,EAAaW,SACTZ,EAAQQ,MACRc,EAAQQ,EAAYU,GAAgB5B,EAAOQ,EAC3CE,EAAQgC,GAAad,GAAgB5B,EAAOS,EAC5CC,EAAQiC,GAAaf,GAAgB5B,EAAOkD,GACrCpD,IACPY,EAAQQ,EAAYU,IAAiB5B,EAAOQ,EAC5CE,EAAQgC,GAAad,IAAiB5B,EAAOS,EAC7CC,EAAQiC,GAAaf,IAAiB5B,EAAOkD,IAG5CrD,IAAQS,GAAsBV,KAC/Bc,EAAQQ,GAAalB,EAAOQ,EAC5BE,EAAQgC,IAAc1C,EAAOS,EAC7BC,EAAQiC,IAAc3C,EAAOkD,IAIjC3D,IACIK,IACAI,EAASxC,EAAUwF,sBAAsB3F,GAAU2C,IAEvDgB,EAAeE,EAAYU,IAAiB5B,EAAOQ,EACnDQ,EAAe0B,GAAad,IAAiB5B,EAAOS,EACpDO,EAAe2B,GAAaf,IAAiB5B,EAAOkD,GAGpD7D,EAAaY,UACTb,EAAQQ,MACRkB,EAASI,EAAYU,GAAgB3B,EAAQO,EAC7CM,EAAS4B,GAAad,GAAgB3B,EAAQQ,EAC9CK,EAAS6B,GAAaf,GAAgB3B,EAAQiD,GACvCpD,IACPgB,EAASI,EAAYU,IAAiB3B,EAAQO,EAC9CM,EAAS4B,GAAad,IAAiB3B,EAAQQ,EAC/CK,EAAS6B,GAAaf,IAAiB3B,EAAQiD,GAGhDrD,IACKS,GACAQ,EAASI,GAAa1C,EAAqBgC,EAC3CM,EAAS4B,IAAclE,EAAqBiC,EAC5CK,EAAS6B,IAAcnE,EAAqB0E,IAE5CpC,EAASI,GAAajB,EAAQO,EAC9BM,EAAS4B,IAAczC,EAAQQ,EAC/BK,EAAS6B,IAAc1C,EAAQiD,KAKvC7D,EAAaa,YACTJ,IACAiB,EAAWG,EAAYU,GAAgB1B,EAAUM,EACjDO,EAAW2B,GAAad,GAAgB1B,EAAUO,EAClDM,EAAW4B,GAAaf,GAAgB1B,EAAUgD,GAElDrD,IACIS,GACAS,EAAWG,GAAazC,EAAuB+B,EAC/CO,EAAW2B,IAAcjE,EAAuBgC,EAChDM,EAAW4B,IAAclE,EAAuByE,IAEhDnC,EAAWG,GAAahB,EAAUM,EAClCO,EAAW2B,IAAcxC,EAAUO,EACnCM,EAAW4B,IAAczC,EAAUgD,KAI/ChC,GAAa,GAIjB7B,EAAaU,KACbT,EAASG,WAAWM,GAAK,IAAIoD,oBAAkB,CAC3CC,kBAAoBC,oBAAkBC,MACtCC,uBAAyB,EACzB7D,OAASiB,KAIbtB,EAAaW,SACbV,EAASG,WAAWO,OAAS,IAAImD,oBAAkB,CAC/CC,kBAAoBC,oBAAkBC,MACtCC,uBAAyB,EACzB7D,OAASgB,KAIbrB,EAAaY,UACbX,EAASG,WAAWQ,QAAU,IAAIkD,oBAAkB,CAChDC,kBAAoBC,oBAAkBC,MACtCC,uBAAyB,EACzB7D,OAASoB,KAIbzB,EAAaa,YACbZ,EAASG,WAAWS,UAAY,IAAIiD,oBAAkB,CAClDC,kBAAoBC,oBAAkBC,MACtCC,uBAAyB,EACzB7D,OAASqB,KAIbxB,IACAD,EAASG,WAAW+D,iBAAmB,IAAIL,oBAAkB,CACzDC,kBAAoBC,oBAAkBC,MACtCC,uBAAyB,EACzB7D,OAASsB,KAKrB,GAAI5B,EAAQqE,SAAWC,UAAQtE,EAAQuE,iBAAkB,CACrD,IAAIC,GAAOpE,EAAcG,OAAS,EAC9BgE,GAAkB,IAAIE,WAAWD,IAErC,GAAIxE,EAAQuE,kBAAoBG,0BAAwBC,IAC/ClE,GAAOC,GAAWF,EACnB+D,GAAkBK,YAAUL,GAAiB,EAAG,EAAGC,GAAO,GACnD/D,IACP8D,GAAkBK,YAAUL,GAAiB,QAE9C,CACH,IAAIM,GAAc7E,EAAQuE,kBAAoBG,0BAAwBI,KAAO,EAAI,EACjFP,GAAkBK,YAAUL,GAAiBM,IAGjD3E,EAASG,WAAW0E,YAAc,IAAIhB,oBAAkB,CACpDC,kBAAoBC,oBAAkBe,cACtCb,uBAAyB,EACzB7D,OAASiE,KAIjB,OAAOrE,EAGX,IAAI+E,EAA2B,IAAInH,eAC/BoH,EAAyB,IAAIpH,eAC7BqH,EAAW,CACXC,YAAc,EACdC,YAAc,GAEdC,EAAoB,IAAIC,oBAC5B,SAASC,EAAiBC,EAAWrH,EAAWsH,EAASC,EAAaC,GAElE,GADAA,EAASC,eAAaD,EAAQ,IAAIE,cAC7BxB,UAAQmB,IAAcA,EAAUlF,OAAS,EAK1C,OAJAqF,EAAOG,KAAO,EACdH,EAAOI,MAAQ,EACfJ,EAAOK,MAAQ,EACfL,EAAOM,KAAO,EACPN,EAGX,GAAIF,IAAYS,UAAQC,MACpB,OAAON,YAAUO,mBAAmBZ,EAAWrH,EAAWwH,GAGzDN,EAAkBlH,UAAUkI,OAAOlI,KACpCkH,EAAoB,IAAIC,yBAAkB9D,OAAWA,EAAWrD,IAGpEwH,EAAOG,KAAOQ,OAAOC,kBACrBZ,EAAOM,KAAOK,OAAOE,kBACrBb,EAAOK,MAAQM,OAAOC,kBACtBZ,EAAOI,MAAQO,OAAOE,kBAEtBtB,EAASC,YAAcmB,OAAOC,kBAC9BrB,EAASE,YAAckB,OAAOE,kBAQ9B,IANA,IAIIC,EAJAC,EAAqB,EAAMzD,aAAW0D,YAAYjB,EAAavH,EAAUyI,eACzEC,EAAkBrB,EAAUlF,OAC5BwG,EAAkB3I,EAAUE,wBAAwBmH,EAAU,GAAIP,GAClE8B,EAAoB/B,EAGfvC,EAAI,EAAGA,EAAIoE,EAAiBpE,IACjCgE,EAAOM,EACPA,EAAoBD,EACpBA,EAAkB3I,EAAUE,wBAAwBmH,EAAU/C,GAAIgE,GAClEpB,EAAkB2B,aAAaD,EAAmBD,GAClDG,GAA4B5B,EAAmBqB,EAAoBf,EAAQT,GAqB/E,OAlBAuB,EAAOM,EACPA,EAAoBD,EACpBA,EAAkB3I,EAAUE,wBAAwBmH,EAAU,GAAIiB,GAClEpB,EAAkB2B,aAAaD,EAAmBD,GAClDG,GAA4B5B,EAAmBqB,EAAoBf,EAAQT,GAEvES,EAAOM,KAAON,EAAOG,KAAOZ,EAASE,YAAcF,EAASC,cAC5DQ,EAAOG,KAAOZ,EAASC,YACvBQ,EAAOM,KAAOf,EAASE,YAEnBO,EAAOM,KAAOhD,aAAWiE,KACzBvB,EAAOM,KAAON,EAAOM,KAAOhD,aAAWkE,QAEvCxB,EAAOG,KAAO7C,aAAWiE,KACzBvB,EAAOG,KAAOH,EAAOG,KAAO7C,aAAWkE,SAIxCxB,EAGX,IAAIyB,EAAkC,IAAIvJ,eAC1C,SAASoJ,GAA4B5B,EAAmBqB,EAAoBf,EAAQT,GAOhF,IANA,IAAImC,EAAgBhC,EAAkBiC,gBAElCC,EAAYC,KAAKC,KAAKJ,EAAgBX,GACtCgB,EAAqBH,EAAY,EAAIF,GAAiBE,EAAY,GAAKjB,OAAOC,kBAC9EoB,EAAwB,EAEnBlF,EAAI,EAAGA,EAAI8E,EAAW9E,IAAK,CAChC,IAAImF,EAA2BvC,EAAkBwC,gCAAgCF,EAAuBP,GACxGO,GAAyBD,EACzB,IAAII,EAAYF,EAAyBE,UACrCC,EAAWH,EAAyBG,SAExCpC,EAAOG,KAAO0B,KAAKQ,IAAIrC,EAAOG,KAAMgC,GACpCnC,EAAOM,KAAOuB,KAAKS,IAAItC,EAAOM,KAAM6B,GACpCnC,EAAOK,MAAQwB,KAAKQ,IAAIrC,EAAOK,MAAO+B,GACtCpC,EAAOI,MAAQyB,KAAKS,IAAItC,EAAOI,MAAOgC,GAEtC,IAAIG,EAAcJ,GAAa,EAAKA,EAAYA,EAAa7E,aAAWkE,OACxEjC,EAASC,YAAcqC,KAAKQ,IAAI9C,EAASC,YAAa+C,GACtDhD,EAASE,YAAcoC,KAAKS,IAAI/C,EAASE,YAAa8C,IAI9D,IAAIC,GAA+C,GAEnD,SAASC,GAAoCjK,EAAWkK,EAAS3C,EAAa4C,EAAWrH,EAAmBsH,EAAUC,EAAaxI,EAAcyF,GAC7I,IAGIhD,EAHAgG,EAAO,CACPC,MAAQ,IAIZ,GAAIH,GAAYC,EAAa,CACzB,IAIIG,EACAC,EALAC,EAASC,yBAAuBC,4BAA4B5K,EAAWkK,EAAS3C,EAAazE,EAAmBjB,EAAcyF,GAE9HuD,EAAaH,EAAOzI,WAAWpC,SAASqC,OACxC4I,EAAUJ,EAAOI,QAIrB,GAAIV,GAAYC,EAAa,CACzB,IAAIU,EAAqBF,EAAWG,OAAOH,GAE3CL,EAAeO,EAAmB5I,OAAS,GAE3CsI,EAAaQ,gBAAcC,iBAAiBV,EAA+B,EAAjBM,EAAQ3I,SACvDgJ,IAAIL,GACf,IAAIM,EAAUN,EAAQ3I,OAElBA,EAASqI,EAAe,EAE5B,IAAKlG,EAAI,EAAGA,EAAI8G,EAAS9G,GAAK,EAAG,CAC7B,IAAI+G,EAAKZ,EAAWnG,GAAKnC,EACrBmJ,EAAKb,EAAWnG,EAAI,GAAKnC,EACzBoJ,EAAKd,EAAWnG,EAAI,GAAKnC,EAE7BsI,EAAWnG,EAAI8G,GAAWG,EAC1Bd,EAAWnG,EAAI,EAAI8G,GAAWE,EAC9Bb,EAAWnG,EAAI,EAAI8G,GAAWC,EAIlC,GADAX,EAAOzI,WAAWpC,SAASqC,OAAS6I,EAChCjI,GAAqBjB,EAAaW,OAAQ,CAC1C,IAAIU,EAAUwH,EAAOzI,WAAWO,OAAON,OACvCwI,EAAOzI,WAAWO,OAAON,OAAS,IAAIkB,aAAa2H,EAAmB5I,QACtEuI,EAAOzI,WAAWO,OAAON,OAAOiJ,IAAIjI,GAExCwH,EAAOI,QAAUL,OACd,GAAIJ,EAAa,CAIpB,IAHAG,EAAeK,EAAW1I,OAAS,EACnCsI,EAAaQ,gBAAcC,iBAAiBV,EAAcM,EAAQ3I,QAE7DmC,EAAI,EAAGA,EAAIwG,EAAQ3I,OAAQmC,GAAK,EACjCmG,EAAWnG,GAAKwG,EAAQxG,EAAI,GAC5BmG,EAAWnG,EAAI,GAAKwG,EAAQxG,EAAI,GAChCmG,EAAWnG,EAAI,GAAKwG,EAAQxG,GAGhCoG,EAAOI,QAAUL,EAGrBH,EAAKkB,aAAe,IAAIC,mBAAiB,CACrC3J,SAAW4I,IAInB,IAAIgB,EAAYvB,EAAUuB,UACtB9I,EAAe+I,wBAAsBC,WAAWF,EAAW1L,GAC3D6L,EAAcjJ,EAAakJ,uBAAuBJ,EAAW1B,IAE7D+B,EAAeC,kBAAgBC,sBAAsBJ,GACrDE,IAAiBG,eAAaC,YAC9BT,EAAYA,EAAUU,QAAQC,WAGlC,IAAIC,EAAU3B,yBAAuB4B,oBAAoBb,EAAW1L,EAAWuH,EAAazE,EAAmBwE,GAC/GgD,EAAKC,MAAMiC,KAAK,IAAIf,mBAAiB,CACjC3J,SAAWwK,KAGf,IAAIG,EAAQtC,EAAUsC,MACtB,IAAKnI,EAAI,EAAGA,EAAImI,EAAMtK,OAAQmC,IAAK,CAC/B,IAAIoI,EAAOD,EAAMnI,GAGjBuH,GADAjJ,EAAe+I,wBAAsBC,WAAWc,EAAM1M,IAC3B8L,uBAAuBY,EAAM1C,KAExD+B,EAAeC,kBAAgBC,sBAAsBJ,MAChCK,eAAaS,oBAC9BD,EAAOA,EAAKN,QAAQC,WAGxBC,EAAU3B,yBAAuB4B,oBAAoBG,EAAM1M,EAAWuH,EAAazE,EAAmBwE,GACtGgD,EAAKC,MAAMiC,KAAK,IAAIf,mBAAiB,CACjC3J,SAAWwK,KAInB,OAAOhC,EA8FX,SAASsC,GAAgBhL,GAIrB,GAFAiL,QAAMC,OAAOC,OAAO,UAAWnL,GAC/BiL,QAAMC,OAAOC,OAAO,2BAA4BnL,EAAQoL,kBACpD9G,UAAQtE,EAAQkB,oBAAsBlB,EAAQkB,mBAAqBoD,UAAQtE,EAAQ3B,QACnF,MAAM,IAAIgN,iBAAe,gEAE7B,GAAI/G,UAAQtE,EAAQ0F,UAAY1F,EAAQ0F,UAAYS,UAAQmF,UAAYtL,EAAQ0F,UAAYS,UAAQC,MAChG,MAAM,IAAIiF,iBAAe,0EAI7B,IAAID,EAAmBpL,EAAQoL,iBAC3BnL,EAAe4F,eAAa7F,EAAQC,aAAcsL,eAAaC,SAC/DpN,EAAYyH,eAAa7F,EAAQ5B,UAAWqN,YAAUC,OACtD/F,EAAcE,eAAa7F,EAAQ2F,YAAazC,aAAWyI,oBAC3D1K,EAAa4E,eAAa7F,EAAQiB,WAAY,GAC9CC,EAAoB2E,eAAa7F,EAAQkB,mBAAmB,GAC5D0K,EAA2B1K,GAAqBoD,UAAQtE,EAAQ6L,gBAChExN,EAASwH,eAAa7F,EAAQ3B,OAAQ,GACtCwN,EAAiBhG,eAAa7F,EAAQ6L,eAAgBxN,GAE1D,IAAKuN,EAA0B,CAC3B,IAAIE,EAAIrE,KAAKS,IAAI7J,EAAQwN,GACzBA,EAAiBpE,KAAKQ,IAAI5J,EAAQwN,GAClCxN,EAASyN,EAGbC,KAAKC,cAAgBT,eAAajJ,MAAMrC,GACxC8L,KAAKE,WAAaR,YAAUnJ,MAAMlE,GAClC2N,KAAKG,aAAevG,EACpBoG,KAAKI,YAAclL,EACnB8K,KAAKK,QAAU/N,EACf0N,KAAKM,gBAAkBR,EACvBE,KAAKO,UAAYzG,eAAa7F,EAAQwI,UAAU,GAChDuD,KAAKQ,aAAe1G,eAAa7F,EAAQyI,aAAa,GACtDsD,KAAKS,kBAAoBpB,EACzBW,KAAKU,mBAAqBvL,EAC1B6K,KAAKW,0BAA4Bd,EACjCG,KAAKY,cAAgB9G,eAAa7F,EAAQG,cAAc,GACxD4L,KAAKa,YAAc,wBACnBb,KAAKc,iBAAmB7M,EAAQuE,gBAChCwH,KAAKe,SAAWjH,eAAa7F,EAAQ0F,QAASS,UAAQmF,UAEtDS,KAAKgB,gBAAatL,EAClBsK,KAAKiB,sCAAmCvL,EAMxCsK,KAAKkB,aAAelE,yBAAuBmE,6BAA6B9B,GAAoBK,YAAUwB,aAAe1B,eAAa0B,aAAe,GAoCrJjC,GAAgBmC,cAAgB,SAASnN,GAuBrC,OAtBAA,EAAU6F,eAAa7F,EAAS6F,eAAauH,cAG7CnC,QAAM3G,QAAQ,oBAAqBtE,EAAQyF,WAmBpC,IAAIuF,GAhBM,CACbI,iBAAmB,CACf3F,UAAYzF,EAAQyF,WAExBpH,OAAS2B,EAAQ3B,OACjBwN,eAAiB7L,EAAQ6L,eACzB5L,aAAeD,EAAQC,aACvBgB,WAAajB,EAAQiB,WACrB7C,UAAY4B,EAAQ5B,UACpBuH,YAAc3F,EAAQ2F,YACtBzE,kBAAoBlB,EAAQkB,kBAC5BsH,SAAWxI,EAAQwI,SACnBC,YAAczI,EAAQyI,YACtBlE,gBAAkBvE,EAAQuE,gBAC1BmB,QAAU1F,EAAQ0F,WAc1BsF,GAAgBqC,KAAO,SAASC,EAAOC,EAAOC,GA6B1C,OA3BAvC,QAAMC,OAAOC,OAAO,QAASmC,GAC7BrC,QAAM3G,QAAQ,QAASiJ,GAGvBC,EAAgB3H,eAAa2H,EAAe,GAE5CA,EAAgBzE,yBAAuB0E,qBAAqBH,EAAMd,kBAAmBe,EAAOC,GAE5F/B,YAAU4B,KAAKC,EAAMrB,WAAYsB,EAAOC,GACxCA,GAAiB/B,YAAUwB,aAE3B1B,eAAa8B,KAAKC,EAAMtB,cAAeuB,EAAOC,GAC9CA,GAAiBjC,eAAa0B,aAE9BM,EAAMC,KAAmBF,EAAMlB,QAC/BmB,EAAMC,KAAmBF,EAAMjB,gBAC/BkB,EAAMC,KAAmBF,EAAMpB,aAC/BqB,EAAMC,KAAmBF,EAAMnB,YAC/BoB,EAAMC,KAAmBF,EAAMZ,0BAA4B,EAAM,EACjEa,EAAMC,KAAmBF,EAAMb,mBAAqB,EAAM,EAC1Dc,EAAMC,KAAmBF,EAAMhB,UAAY,EAAM,EACjDiB,EAAMC,KAAmBF,EAAMf,aAAe,EAAM,EACpDgB,EAAMC,KAAmBF,EAAMX,cAAgB,EAAM,EACrDY,EAAMC,KAAmB3H,eAAayH,EAAMT,kBAAmB,GAC/DU,EAAMC,KAAmBF,EAAMR,SAC/BS,EAAMC,GAAiBF,EAAML,aAEtBM,GAGX,IAAIG,GAAmBjC,YAAUnJ,MAAMmJ,YAAUkC,aAC7CC,GAAsB,IAAIrC,eAG1BsC,GAAe,CACfzC,iBAAmB,WAUvBJ,GAAgB8C,OAAS,SAASP,EAAOC,EAAe5H,GAEpDqF,QAAM3G,QAAQ,QAASiJ,GAGvBC,EAAgB3H,eAAa2H,EAAe,GAE5C,IAAIpC,EAAmBrC,yBAAuBgF,uBAAuBR,EAAOC,GAC5EA,EAAgBpC,EAAiBoC,qBAC1BpC,EAAiBoC,cAExB,IAAIpP,EAAYqN,YAAUqC,OAAOP,EAAOC,EAAeE,IACvDF,GAAiB/B,YAAUwB,aAE3B,IAAIhN,EAAesL,eAAauC,OAAOP,EAAOC,EAAeI,IAC7DJ,GAAiBjC,eAAa0B,aAE9B,IAAI5O,EAASkP,EAAMC,KACf3B,EAAiB0B,EAAMC,KACvB7H,EAAc4H,EAAMC,KACpBvM,EAAasM,EAAMC,KACnB5B,EAAsD,IAA3B2B,EAAMC,KACjCtM,EAA+C,IAA3BqM,EAAMC,KAC1BhF,EAAsC,IAA3B+E,EAAMC,KACjB/E,EAAyC,IAA3B8E,EAAMC,KACpBrN,EAA0C,IAA3BoN,EAAMC,KACrBjJ,EAAkBgJ,EAAMC,KACxB9H,EAAU6H,EAAMC,KAChBP,EAAeM,EAAMC,GAqBzB,OAnBKlJ,UAAQsB,KACTA,EAAS,IAAIoF,GAAgB6C,KAGjCjI,EAAO4G,kBAAoBpB,EAC3BxF,EAAOqG,WAAaR,YAAUnJ,MAAMlE,EAAWwH,EAAOqG,YACtDrG,EAAOoG,cAAgBT,eAAajJ,MAAMrC,EAAc2F,EAAOoG,eAC/DpG,EAAOwG,QAAU/N,EACjBuH,EAAOyG,gBAAkBR,EACzBjG,EAAOsG,aAAevG,EACtBC,EAAOuG,YAAclL,EACrB2E,EAAO8G,0BAA4Bd,EACnChG,EAAO6G,mBAAqBvL,EAC5B0E,EAAO0G,UAAY9D,EACnB5C,EAAO2G,aAAe9D,EACtB7C,EAAO+G,cAAgBxM,EACvByF,EAAOiH,kBAAwC,IAArBtI,OAAyB9C,EAAY8C,EAC/DqB,EAAOkH,SAAWpH,EAClBE,EAAOqH,aAAeA,EACfrH,GAeXoF,GAAgBxF,iBAAmB,SAASxF,EAAS4F,GAEjDqF,QAAMC,OAAOC,OAAO,UAAWnL,GAC/BiL,QAAMC,OAAOC,OAAO,2BAA4BnL,EAAQoL,kBAGxD,IAAIzF,EAAcE,eAAa7F,EAAQ2F,YAAazC,aAAWyI,oBAC3DjG,EAAUG,eAAa7F,EAAQ0F,QAASS,UAAQmF,UAEpD,GAAI5F,IAAYS,UAAQmF,UAAY5F,IAAYS,UAAQC,MACpD,MAAM,IAAIiF,iBAAe,0EAI7B,IAAID,EAAmBpL,EAAQoL,iBAC3BhN,EAAYyH,eAAa7F,EAAQ5B,UAAWqN,YAAUC,OAE1D,OAAOlG,EAAiB4F,EAAiB3F,UAAWrH,EAAWsH,EAASC,EAAaC,IASzFoF,GAAgBgD,eAAiB,SAASC,GACtC,IAAIhO,EAAegO,EAAgBjC,cAC/B5N,EAAY6P,EAAgBhC,WAC5BtG,EAAcsI,EAAgB/B,aAC9BjL,EAAagN,EAAgB9B,YAC7Bf,EAAmB6C,EAAgBzB,kBACnCtL,EAAoB+M,EAAgBxB,mBACpCjE,EAAWyF,EAAgB3B,UAC3B7D,EAAcwF,EAAgB1B,aAC9B7G,EAAUuI,EAAgBnB,SAE1BoB,EAAiB9C,EAAiB3F,UACtC,KAAIyI,EAAe3N,OAAS,GAA5B,CAIA,IAAIS,EAAe+I,wBAAsBC,WAAWkE,EAAgB9P,GAEhE+P,EAAUpF,yBAAuBqF,sBAAsBhD,EAAkBpK,EAAakJ,uBAAuBmE,KAAKrN,IAAgBE,EAAmB9C,GAErJmK,EAAY4F,EAAQ5F,UACpB+F,EAAWH,EAAQG,SAEvB,GAAyB,IAArB/F,EAAUhI,OAAd,CAIA2N,EAAiB3F,EAAU,GAAGuB,UAC9B,IAuBIpH,EAvBA3B,EAAoBgI,yBAAuBwF,yBAAyBvN,EAAawN,MAAM5N,OAAQI,EAAa+B,sBAAsBsL,KAAKrN,GAAekN,EAAgBjN,EAAYvC,GAElL+P,EAAa,GAEbpQ,EAAS4P,EAAgB7B,QACzBP,EAAiBoC,EAAgB5B,gBAGjCrM,EAAU,CACVkB,kBAAmBA,EACnBjB,aAAcA,EACdC,cAAUuB,EACVT,aAAcA,EACdD,kBAAmBA,EACnB3C,UAAWA,EACX6C,WAAYA,EACZP,QAAQ,EACRD,KAAK,EACLD,MAAM,EACN6D,SAAS,EACTqB,QAASA,GAKb,GAnBcuI,EAAgBvB,4BAA8BxJ,aAAWQ,cAAcrF,EAAQwN,EAAgB,EAAG3I,aAAWwL,UAyBvH,IALA1O,EAAQqE,SAAU,EAClBrE,EAAQS,IAAM+H,EACdxI,EAAQU,OAAS+H,EACjBzI,EAAQG,aAAe8N,EAAgBtB,cACvC3M,EAAQuE,gBAAkB0J,EAAgBpB,iBACrCnK,EAAI,EAAGA,EAAI4L,EAAS/N,OAAQmC,IAAK,CAClC,IAEIkH,EAFA+E,EAAgBtG,GAAoCjK,EAAWkQ,EAAS5L,GAAIiD,EAAa4C,EAAU7F,GAAIxB,EAAmBsH,EAAUC,EAAaxI,EAAcyF,GAG/J8C,GAAYC,GACZmB,EAAe+E,EAAc/E,aAC7B5J,EAAQE,SAAW6I,yBAAuB6F,8BAA8BhF,EAAa1J,SAAU7B,EAAQwN,EAAgBzN,EAAW8C,IAC3HsH,IACPoB,EAAe+E,EAAc/E,cAChB1J,SAASG,WAAWpC,SAASqC,OAAS8J,kBAAgByE,sBAAsBjF,EAAa1J,SAASG,WAAWpC,SAASqC,OAAQjC,EAAQD,GAAY8C,GAC/JlB,EAAQE,SAAW0J,EAAa1J,UACzBuI,KACPmB,EAAe+E,EAAc/E,cAChB1J,SAASG,WAAWpC,SAASqC,OAAS8J,kBAAgByE,sBAAsBjF,EAAa1J,SAASG,WAAWpC,SAASqC,OAAQuL,EAAgBzN,GAAW,GACtK4B,EAAQE,SAAW0J,EAAa1J,WAEhCsI,GAAYC,KACZzI,EAAQQ,MAAO,EACfoJ,EAAa1J,SAAWH,EAAkBC,GAC1CyO,EAAW7D,KAAKhB,IAGpB,IAAIjB,EAAQgG,EAAchG,MAC1B3I,EAAQQ,MAAO,EACf,IAAM,IAAIsO,EAAI,EAAGA,EAAInG,EAAMpI,OAAQuO,IAAK,CACpC,IAAItO,EAAOmI,EAAMmG,GACjB9O,EAAQE,SAAW6I,yBAAuB6F,8BAA8BpO,EAAKN,SAAU7B,EAAQwN,EAAgBzN,EAAW8C,GAC1HV,EAAKN,SAAWH,EAAkBC,GAClCyO,EAAW7D,KAAKpK,SAIxB,IAAKkC,EAAI,EAAGA,EAAI4L,EAAS/N,OAAQmC,IAAK,CAClC,IAAIqM,EAAmB,IAAIlF,mBAAiB,CACxC3J,SAAW6I,yBAAuBC,4BAA4B5K,EAAWkQ,EAAS5L,GAAIiD,EAAazE,EAAmBjB,EAAcyF,KAMxI,GAJAqJ,EAAiB7O,SAASG,WAAWpC,SAASqC,OAAS8J,kBAAgByE,sBAAsBE,EAAiB7O,SAASG,WAAWpC,SAASqC,OAAQjC,EAAQD,GAAY8C,GACvKlB,EAAQE,SAAW6O,EAAiB7O,SACpC6O,EAAiB7O,SAAWH,EAAkBC,GAE1CsE,UAAQ2J,EAAgBpB,kBAAmB,CAC3C,IAAItM,EAASwO,EAAiB7O,SAASG,WAAWpC,SAASqC,OAAOC,OAC9DwE,EAAc,IAAIN,WAAWlE,EAAS,GACtCsE,EAAcoJ,EAAgBpB,mBAAqBnI,0BAAwBI,KAAO,EAAI,EAC1FF,YAAUG,EAAaF,GACvBkK,EAAiB7O,SAASG,WAAW0E,YAAc,IAAIhB,oBAAkB,CACrEC,kBAAoBC,oBAAkBe,cACtCb,uBAAyB,EACzB7D,OAAQyE,IAIhB0J,EAAW7D,KAAKmE,GAIxB,IAAI7O,EAAW8O,mBAAiBC,iBAAiBR,GAAY,GAC7DvO,EAASG,WAAWpC,SAASqC,OAAS,IAAI4O,aAAahP,EAASG,WAAWpC,SAASqC,QACpFJ,EAASgJ,QAAUG,gBAAcC,iBAAiBpJ,EAASG,WAAWpC,SAASqC,OAAOC,OAAS,EAAGL,EAASgJ,SAE3G,IAAI7I,EAAaH,EAASG,WACtB8O,EAAiBC,iBAAeC,aAAahP,EAAWpC,SAASqC,QAMrE,OAJKL,EAAahC,iBACPoC,EAAWpC,SAGf,IAAIqR,WAAS,CAChBjP,WAAaA,EACb6I,QAAUhJ,EAASgJ,QACnBqG,cAAgBrP,EAASqP,cACzBJ,eAAiBA,EACjB5K,gBAAkB0J,EAAgBpB,sBAO1C7B,GAAgBwE,mBAAqB,SAASvB,EAAiBwB,EAAeC,GAC1E,IAAI/J,EAAcsI,EAAgB/B,aAC9B9N,EAAY6P,EAAgBhC,WAE5B0D,EAAYF,EAAc9J,EAAavH,GACvCwR,EAAYF,EAAc/J,EAAavH,GAE3C,OAAO,IAAI4M,GAAgB,CACvBI,iBAAmB6C,EAAgBzB,kBACnCpO,UAAYA,EACZ6C,WAAagN,EAAgB9B,YAC7BxG,YAAcA,EACdzE,mBAAoB,EACpB2K,eAAiB8D,EACjBtR,OAASuR,EACT3P,aAAesL,eAAasE,cAC5B1P,cAAc,EACduF,QAAUuI,EAAgBnB,YAelCgD,OAAOC,iBAAiB/E,GAAgBgF,UAAW,CAI/CC,UAAY,CACRC,IAAM,WACF,IAAK5L,UAAQyH,KAAKgB,YAAa,CAC3B,IAAItH,EAAYsG,KAAKS,kBAAkB/G,UACvCsG,KAAKgB,WAAavH,EAAiBC,EAAWsG,KAAKE,WAAYF,KAAKe,SAAUf,KAAKG,cAGvF,OAAOH,KAAKgB,aAOpBoD,gCAAkC,CAC9BD,IAAM,WAIF,OAHK5L,UAAQyH,KAAKiB,oCACdjB,KAAKiB,iCAhCrB,SAAyCiB,GACrC,IAAIhN,GAAcgN,EAAgB9B,YAClC,GAAmB,IAAflL,EACA,MAAO,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GAE3B,IAAI7C,EAAY6P,EAAgBhC,WAC5BxG,EAAYwI,EAAgBzB,kBAAkB/G,UAC9C1E,EAAoBkN,EAAgBgC,UACxC,OAAOX,WAAStC,iCAAiCvH,EAAWxE,EAAY7C,EAAW2C,GAwB/BoP,CAAgCpE,OAErEA,KAAKiB,qCC7iCxB,SAA+BiB,EAAiBmC,GAK5C,OAJI9L,UAAQ8L,KACRnC,EAAkBjD,GAAgB8C,OAAOG,EAAiBmC,IAE9DnC,EAAgBhC,WAAaR,YAAUnJ,MAAM2L,EAAgBhC,YACtDjB,GAAgBgD,eAAeC"}