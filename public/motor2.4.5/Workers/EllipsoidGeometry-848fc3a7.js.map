{"version":3,"file":"EllipsoidGeometry-848fc3a7.js","sources":["../../../../Source/Core/EllipsoidGeometry.js"],"sourcesContent":["import arrayFill from './arrayFill.js';\r\nimport BoundingSphere from './BoundingSphere.js';\r\nimport Cartesian2 from './Cartesian2.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport ComponentDatatype from './ComponentDatatype.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport Geometry from './Geometry.js';\r\nimport GeometryAttribute from './GeometryAttribute.js';\r\nimport GeometryAttributes from './GeometryAttributes.js';\r\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\r\nimport IndexDatatype from './IndexDatatype.js';\r\nimport CesiumMath from './Math.js';\r\nimport PrimitiveType from './PrimitiveType.js';\r\nimport VertexFormat from './VertexFormat.js';\r\n\r\n    var scratchPosition = new Cartesian3();\r\n    var scratchNormal = new Cartesian3();\r\n    var scratchTangent = new Cartesian3();\r\n    var scratchBitangent = new Cartesian3();\r\n    var scratchNormalST = new Cartesian3();\r\n    var defaultRadii = new Cartesian3(1.0, 1.0, 1.0);\r\n\r\n    var cos = Math.cos;\r\n    var sin = Math.sin;\r\n\r\n    /**\r\n     * A description of an ellipsoid centered at the origin.\r\n     *\r\n     * @alias EllipsoidGeometry\r\n     * @constructor\r\n     *\r\n     * @param {Object} [options] Object with the following properties:\r\n     * @param {Cartesian3} [options.radii=Cartesian3(1.0, 1.0, 1.0)] The radii of the ellipsoid in the x, y, and z directions.\r\n     * @param {Cartesian3} [options.innerRadii=options.radii] The inner radii of the ellipsoid in the x, y, and z directions.\r\n     * @param {Number} [options.minimumClock=0.0] The minimum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\r\n     * @param {Number} [options.maximumClock=2*PI] The maximum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\r\n     * @param {Number} [options.minimumCone=0.0] The minimum angle measured from the positive z-axis and toward the negative z-axis.\r\n     * @param {Number} [options.maximumCone=PI] The maximum angle measured from the positive z-axis and toward the negative z-axis.\r\n     * @param {Number} [options.stackPartitions=64] The number of times to partition the ellipsoid into stacks.\r\n     * @param {Number} [options.slicePartitions=64] The number of times to partition the ellipsoid into radial slices.\r\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\r\n     *\r\n     * @exception {DeveloperError} options.slicePartitions cannot be less than three.\r\n     * @exception {DeveloperError} options.stackPartitions cannot be less than three.\r\n     *\r\n     * @see EllipsoidGeometry#createGeometry\r\n     *\r\n     * @example\r\n     * var ellipsoid = new Cesium.EllipsoidGeometry({\r\n     *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\r\n     *   radii : new Cesium.Cartesian3(1000000.0, 500000.0, 500000.0)\r\n     * });\r\n     * var geometry = Cesium.EllipsoidGeometry.createGeometry(ellipsoid);\r\n     */\r\n    function EllipsoidGeometry(options) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n        var radii = defaultValue(options.radii, defaultRadii);\r\n        var innerRadii = defaultValue(options.innerRadii, radii);\r\n        var minimumClock = defaultValue(options.minimumClock, 0.0);\r\n        var maximumClock = defaultValue(options.maximumClock, CesiumMath.TWO_PI);\r\n        var minimumCone = defaultValue(options.minimumCone, 0.0);\r\n        var maximumCone = defaultValue(options.maximumCone, CesiumMath.PI);\r\n        var stackPartitions = Math.round(defaultValue(options.stackPartitions, 64));\r\n        var slicePartitions = Math.round(defaultValue(options.slicePartitions, 64));\r\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (slicePartitions < 3) {\r\n            throw new DeveloperError('options.slicePartitions cannot be less than three.');\r\n        }\r\n        if (stackPartitions < 3) {\r\n            throw new DeveloperError('options.stackPartitions cannot be less than three.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        this._radii = Cartesian3.clone(radii);\r\n        this._innerRadii = Cartesian3.clone(innerRadii);\r\n        this._minimumClock = minimumClock;\r\n        this._maximumClock = maximumClock;\r\n        this._minimumCone = minimumCone;\r\n        this._maximumCone = maximumCone;\r\n        this._stackPartitions = stackPartitions;\r\n        this._slicePartitions = slicePartitions;\r\n        this._vertexFormat = VertexFormat.clone(vertexFormat);\r\n        this._offsetAttribute = options.offsetAttribute;\r\n        this._workerName = 'createEllipsoidGeometry';\r\n    }\r\n\r\n    /**\r\n     * The number of elements used to pack the object into an array.\r\n     * @type {Number}\r\n     */\r\n    EllipsoidGeometry.packedLength = 2 * (Cartesian3.packedLength) + VertexFormat.packedLength + 7;\r\n\r\n    /**\r\n     * Stores the provided instance into the provided array.\r\n     *\r\n     * @param {EllipsoidGeometry} value The value to pack.\r\n     * @param {Number[]} array The array to pack into.\r\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n     *\r\n     * @returns {Number[]} The array that was packed into\r\n     */\r\n    EllipsoidGeometry.pack = function(value, array, startingIndex) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(value)) {\r\n            throw new DeveloperError('value is required');\r\n        }\r\n        if (!defined(array)) {\r\n            throw new DeveloperError('array is required');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        Cartesian3.pack(value._radii, array, startingIndex);\r\n        startingIndex += Cartesian3.packedLength;\r\n\r\n        Cartesian3.pack(value._innerRadii, array, startingIndex);\r\n        startingIndex += Cartesian3.packedLength;\r\n\r\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\r\n        startingIndex += VertexFormat.packedLength;\r\n\r\n        array[startingIndex++] = value._minimumClock;\r\n        array[startingIndex++] = value._maximumClock;\r\n        array[startingIndex++] = value._minimumCone;\r\n        array[startingIndex++] = value._maximumCone;\r\n        array[startingIndex++] = value._stackPartitions;\r\n        array[startingIndex++] = value._slicePartitions;\r\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\r\n\r\n        return array;\r\n    };\r\n\r\n    var scratchRadii = new Cartesian3();\r\n    var scratchInnerRadii = new Cartesian3();\r\n    var scratchVertexFormat = new VertexFormat();\r\n    var scratchOptions = {\r\n        radii : scratchRadii,\r\n        innerRadii : scratchInnerRadii,\r\n        vertexFormat : scratchVertexFormat,\r\n        minimumClock : undefined,\r\n        maximumClock : undefined,\r\n        minimumCone : undefined,\r\n        maximumCone : undefined,\r\n        stackPartitions : undefined,\r\n        slicePartitions : undefined,\r\n        offsetAttribute : undefined\r\n    };\r\n\r\n    /**\r\n     * Retrieves an instance from a packed array.\r\n     *\r\n     * @param {Number[]} array The packed array.\r\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n     * @param {EllipsoidGeometry} [result] The object into which to store the result.\r\n     * @returns {EllipsoidGeometry} The modified result parameter or a new EllipsoidGeometry instance if one was not provided.\r\n     */\r\n    EllipsoidGeometry.unpack = function(array, startingIndex, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(array)) {\r\n            throw new DeveloperError('array is required');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        var radii = Cartesian3.unpack(array, startingIndex, scratchRadii);\r\n        startingIndex += Cartesian3.packedLength;\r\n\r\n        var innerRadii = Cartesian3.unpack(array, startingIndex, scratchInnerRadii);\r\n        startingIndex += Cartesian3.packedLength;\r\n\r\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\r\n        startingIndex += VertexFormat.packedLength;\r\n\r\n        var minimumClock = array[startingIndex++];\r\n        var maximumClock = array[startingIndex++];\r\n        var minimumCone = array[startingIndex++];\r\n        var maximumCone = array[startingIndex++];\r\n        var stackPartitions = array[startingIndex++];\r\n        var slicePartitions = array[startingIndex++];\r\n        var offsetAttribute = array[startingIndex];\r\n\r\n        if (!defined(result)) {\r\n            scratchOptions.minimumClock = minimumClock;\r\n            scratchOptions.maximumClock = maximumClock;\r\n            scratchOptions.minimumCone = minimumCone;\r\n            scratchOptions.maximumCone = maximumCone;\r\n            scratchOptions.stackPartitions = stackPartitions;\r\n            scratchOptions.slicePartitions = slicePartitions;\r\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\r\n            return new EllipsoidGeometry(scratchOptions);\r\n        }\r\n\r\n        result._radii = Cartesian3.clone(radii, result._radii);\r\n        result._innerRadii = Cartesian3.clone(innerRadii, result._innerRadii);\r\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\r\n        result._minimumClock = minimumClock;\r\n        result._maximumClock = maximumClock;\r\n        result._minimumCone = minimumCone;\r\n        result._maximumCone = maximumCone;\r\n        result._stackPartitions = stackPartitions;\r\n        result._slicePartitions = slicePartitions;\r\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the geometric representation of an ellipsoid, including its vertices, indices, and a bounding sphere.\r\n     *\r\n     * @param {EllipsoidGeometry} ellipsoidGeometry A description of the ellipsoid.\r\n     * @returns {Geometry|undefined} The computed vertices and indices.\r\n     */\r\n    EllipsoidGeometry.createGeometry = function(ellipsoidGeometry) {\r\n        var radii = ellipsoidGeometry._radii;\r\n        if ((radii.x <= 0) || (radii.y <= 0) || (radii.z <= 0)) {\r\n            return;\r\n        }\r\n\r\n        var innerRadii = ellipsoidGeometry._innerRadii;\r\n        if ((innerRadii.x <= 0) || (innerRadii.y <= 0) || innerRadii.z <= 0) {\r\n            return;\r\n        }\r\n\r\n        var minimumClock = ellipsoidGeometry._minimumClock;\r\n        var maximumClock = ellipsoidGeometry._maximumClock;\r\n        var minimumCone = ellipsoidGeometry._minimumCone;\r\n        var maximumCone = ellipsoidGeometry._maximumCone;\r\n        var vertexFormat = ellipsoidGeometry._vertexFormat;\r\n\r\n        // Add an extra slice and stack so that the number of partitions is the\r\n        // number of surfaces rather than the number of joints\r\n        var slicePartitions = ellipsoidGeometry._slicePartitions + 1;\r\n        var stackPartitions = ellipsoidGeometry._stackPartitions + 1;\r\n\r\n        slicePartitions = Math.round(slicePartitions * Math.abs(maximumClock - minimumClock) / CesiumMath.TWO_PI);\r\n        stackPartitions = Math.round(stackPartitions * Math.abs(maximumCone - minimumCone) / CesiumMath.PI);\r\n\r\n        if (slicePartitions < 2) {\r\n            slicePartitions = 2;\r\n        }\r\n        if (stackPartitions < 2) {\r\n            stackPartitions = 2;\r\n        }\r\n\r\n        var i;\r\n        var j;\r\n        var index = 0;\r\n\r\n        // Create arrays for theta and phi. Duplicate first and last angle to\r\n        // allow different normals at the intersections.\r\n        var phis = [minimumCone];\r\n        var thetas = [minimumClock];\r\n        for (i = 0; i < stackPartitions; i++) {\r\n            phis.push(minimumCone + i * (maximumCone - minimumCone) / (stackPartitions - 1));\r\n        }\r\n        phis.push(maximumCone);\r\n        for (j = 0; j < slicePartitions; j++) {\r\n            thetas.push(minimumClock + j * (maximumClock - minimumClock) / (slicePartitions - 1));\r\n        }\r\n        thetas.push(maximumClock);\r\n        var numPhis = phis.length;\r\n        var numThetas = thetas.length;\r\n\r\n        // Allow for extra indices if there is an inner surface and if we need\r\n        // to close the sides if the clock range is not a full circle\r\n        var extraIndices = 0;\r\n        var vertexMultiplier = 1.0;\r\n        var hasInnerSurface = ((innerRadii.x !== radii.x) || (innerRadii.y !== radii.y) || innerRadii.z !== radii.z);\r\n        var isTopOpen = false;\r\n        var isBotOpen = false;\r\n        var isClockOpen = false;\r\n        if (hasInnerSurface) {\r\n            vertexMultiplier = 2.0;\r\n            if (minimumCone > 0.0) {\r\n                isTopOpen = true;\r\n                extraIndices += (slicePartitions - 1);\r\n            }\r\n            if (maximumCone < Math.PI) {\r\n                isBotOpen = true;\r\n                extraIndices += (slicePartitions - 1);\r\n            }\r\n            if ((maximumClock - minimumClock) % CesiumMath.TWO_PI) {\r\n                isClockOpen = true;\r\n                extraIndices += ((stackPartitions - 1) * 2) + 1;\r\n            } else {\r\n                extraIndices += 1;\r\n            }\r\n        }\r\n\r\n        var vertexCount = numThetas * numPhis * vertexMultiplier;\r\n        var positions = new Float64Array(vertexCount * 3);\r\n        var isInner = arrayFill(new Array(vertexCount), false);\r\n        var negateNormal = arrayFill(new Array(vertexCount), false);\r\n\r\n        // Multiply by 6 because there are two triangles per sector\r\n        var indexCount = slicePartitions * stackPartitions * vertexMultiplier;\r\n        var numIndices = 6 * (indexCount + extraIndices + 1 - (slicePartitions + stackPartitions) * vertexMultiplier);\r\n        var indices = IndexDatatype.createTypedArray(indexCount, numIndices);\r\n\r\n        var normals = (vertexFormat.normal) ? new Float32Array(vertexCount * 3) : undefined;\r\n        var tangents = (vertexFormat.tangent) ? new Float32Array(vertexCount * 3) : undefined;\r\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(vertexCount * 3) : undefined;\r\n        var st = (vertexFormat.st) ? new Float32Array(vertexCount * 2) : undefined;\r\n\r\n        // Calculate sin/cos phi\r\n        var sinPhi = new Array(numPhis);\r\n        var cosPhi = new Array(numPhis);\r\n        for (i = 0; i < numPhis; i++) {\r\n            sinPhi[i] = sin(phis[i]);\r\n            cosPhi[i] = cos(phis[i]);\r\n        }\r\n\r\n        // Calculate sin/cos theta\r\n        var sinTheta = new Array(numThetas);\r\n        var cosTheta = new Array(numThetas);\r\n        for (j = 0; j < numThetas; j++) {\r\n            cosTheta[j] = cos(thetas[j]);\r\n            sinTheta[j] = sin(thetas[j]);\r\n        }\r\n\r\n        // Create outer surface\r\n        for (i = 0; i < numPhis; i++) {\r\n            for (j = 0; j < numThetas; j++) {\r\n                positions[index++] = radii.x * sinPhi[i] * cosTheta[j];\r\n                positions[index++] = radii.y * sinPhi[i] * sinTheta[j];\r\n                positions[index++] = radii.z * cosPhi[i];\r\n            }\r\n        }\r\n\r\n        // Create inner surface\r\n        var vertexIndex = vertexCount / 2.0;\r\n        if (hasInnerSurface) {\r\n            for (i = 0; i < numPhis; i++) {\r\n                for (j = 0; j < numThetas; j++) {\r\n                    positions[index++] = innerRadii.x * sinPhi[i] * cosTheta[j];\r\n                    positions[index++] = innerRadii.y * sinPhi[i] * sinTheta[j];\r\n                    positions[index++] = innerRadii.z * cosPhi[i];\r\n\r\n                    // Keep track of which vertices are the inner and which ones\r\n                    // need the normal to be negated\r\n                    isInner[vertexIndex] = true;\r\n                    if (i > 0 && i !== (numPhis - 1) && j !== 0 && j !== (numThetas - 1)) {\r\n                        negateNormal[vertexIndex] = true;\r\n                    }\r\n                    vertexIndex++;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Create indices for outer surface\r\n        index = 0;\r\n        var topOffset;\r\n        var bottomOffset;\r\n        for (i = 1; i < (numPhis - 2); i++) {\r\n            topOffset = i * numThetas;\r\n            bottomOffset = (i + 1) * numThetas;\r\n\r\n            for (j = 1; j < numThetas - 2; j++) {\r\n                indices[index++] = bottomOffset + j;\r\n                indices[index++] = bottomOffset + j + 1;\r\n                indices[index++] = topOffset + j + 1;\r\n\r\n                indices[index++] = bottomOffset + j;\r\n                indices[index++] = topOffset + j + 1;\r\n                indices[index++] = topOffset + j;\r\n            }\r\n        }\r\n\r\n        // Create indices for inner surface\r\n        if (hasInnerSurface) {\r\n            var offset = numPhis * numThetas;\r\n            for (i = 1; i < (numPhis - 2); i++) {\r\n                topOffset = offset + i * numThetas;\r\n                bottomOffset = offset + (i + 1) * numThetas;\r\n\r\n                for (j = 1; j < numThetas - 2; j++) {\r\n                    indices[index++] = bottomOffset + j;\r\n                    indices[index++] = topOffset + j;\r\n                    indices[index++] = topOffset + j + 1;\r\n\r\n                    indices[index++] = bottomOffset + j;\r\n                    indices[index++] = topOffset + j + 1;\r\n                    indices[index++] = bottomOffset + j + 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        var outerOffset;\r\n        var innerOffset;\r\n        if (hasInnerSurface) {\r\n            if (isTopOpen) {\r\n                // Connect the top of the inner surface to the top of the outer surface\r\n                innerOffset = numPhis * numThetas;\r\n                for (i = 1; i < numThetas - 2; i++) {\r\n                    indices[index++] = i;\r\n                    indices[index++] = i + 1;\r\n                    indices[index++] = innerOffset + i + 1;\r\n\r\n                    indices[index++] = i;\r\n                    indices[index++] = innerOffset + i + 1;\r\n                    indices[index++] = innerOffset + i;\r\n                }\r\n            }\r\n\r\n            if (isBotOpen) {\r\n                // Connect the bottom of the inner surface to the bottom of the outer surface\r\n                outerOffset = numPhis * numThetas - numThetas;\r\n                innerOffset = numPhis * numThetas * vertexMultiplier - numThetas;\r\n                for (i = 1; i < numThetas - 2; i++) {\r\n                    indices[index++] = outerOffset + i + 1;\r\n                    indices[index++] = outerOffset + i;\r\n                    indices[index++] = innerOffset + i;\r\n\r\n                    indices[index++] = outerOffset + i + 1;\r\n                    indices[index++] = innerOffset + i;\r\n                    indices[index++] = innerOffset + i + 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Connect the edges if clock is not closed\r\n        if (isClockOpen) {\r\n            for (i = 1; i < numPhis - 2; i++) {\r\n                innerOffset = numThetas * numPhis + (numThetas * i);\r\n                outerOffset = numThetas * i;\r\n                indices[index++] = innerOffset;\r\n                indices[index++] = outerOffset + numThetas;\r\n                indices[index++] = outerOffset;\r\n\r\n                indices[index++] = innerOffset;\r\n                indices[index++] = innerOffset + numThetas;\r\n                indices[index++] = outerOffset + numThetas;\r\n            }\r\n\r\n            for (i = 1; i < numPhis - 2; i++) {\r\n                innerOffset = numThetas * numPhis + (numThetas * (i + 1)) - 1;\r\n                outerOffset = numThetas * (i + 1) - 1;\r\n                indices[index++] = outerOffset + numThetas;\r\n                indices[index++] = innerOffset;\r\n                indices[index++] = outerOffset;\r\n\r\n                indices[index++] = outerOffset + numThetas;\r\n                indices[index++] = innerOffset + numThetas;\r\n                indices[index++] = innerOffset;\r\n            }\r\n        }\r\n\r\n        var attributes = new GeometryAttributes();\r\n\r\n        if (vertexFormat.position) {\r\n            attributes.position = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.DOUBLE,\r\n                componentsPerAttribute : 3,\r\n                values : positions\r\n            });\r\n        }\r\n\r\n        var stIndex = 0;\r\n        var normalIndex = 0;\r\n        var tangentIndex = 0;\r\n        var bitangentIndex = 0;\r\n        var vertexCountHalf = vertexCount / 2.0;\r\n\r\n        var ellipsoid;\r\n        var ellipsoidOuter = Ellipsoid.fromCartesian3(radii);\r\n        var ellipsoidInner = Ellipsoid.fromCartesian3(innerRadii);\r\n\r\n        if (vertexFormat.st || vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\r\n            for (i = 0; i < vertexCount; i++) {\r\n                ellipsoid = (isInner[i]) ? ellipsoidInner : ellipsoidOuter;\r\n                var position = Cartesian3.fromArray(positions, i * 3, scratchPosition);\r\n                var normal = ellipsoid.geodeticSurfaceNormal(position, scratchNormal);\r\n                if (negateNormal[i]) {\r\n                    Cartesian3.negate(normal, normal);\r\n                }\r\n\r\n                if (vertexFormat.st) {\r\n                    var normalST = Cartesian2.negate(normal, scratchNormalST);\r\n                    st[stIndex++] = (Math.atan2(normalST.y, normalST.x) / CesiumMath.TWO_PI) + 0.5;\r\n                    st[stIndex++] = (Math.asin(normal.z) / Math.PI) + 0.5;\r\n                }\r\n\r\n                if (vertexFormat.normal) {\r\n                    normals[normalIndex++] = normal.x;\r\n                    normals[normalIndex++] = normal.y;\r\n                    normals[normalIndex++] = normal.z;\r\n                }\r\n\r\n                if (vertexFormat.tangent || vertexFormat.bitangent) {\r\n                    var tangent = scratchTangent;\r\n\r\n                    // Use UNIT_X for the poles\r\n                    var tangetOffset = 0;\r\n                    var unit;\r\n                    if (isInner[i]) {\r\n                        tangetOffset = vertexCountHalf;\r\n                    }\r\n                    if ((!isTopOpen && (i >= tangetOffset && i < (tangetOffset + numThetas * 2)))) {\r\n                        unit = Cartesian3.UNIT_X;\r\n                    } else {\r\n                        unit = Cartesian3.UNIT_Z;\r\n                    }\r\n                    Cartesian3.cross(unit, normal, tangent);\r\n                    Cartesian3.normalize(tangent, tangent);\r\n\r\n                    if (vertexFormat.tangent) {\r\n                        tangents[tangentIndex++] = tangent.x;\r\n                        tangents[tangentIndex++] = tangent.y;\r\n                        tangents[tangentIndex++] = tangent.z;\r\n                    }\r\n\r\n                    if (vertexFormat.bitangent) {\r\n                        var bitangent = Cartesian3.cross(normal, tangent, scratchBitangent);\r\n                        Cartesian3.normalize(bitangent, bitangent);\r\n\r\n                        bitangents[bitangentIndex++] = bitangent.x;\r\n                        bitangents[bitangentIndex++] = bitangent.y;\r\n                        bitangents[bitangentIndex++] = bitangent.z;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (vertexFormat.st) {\r\n                attributes.st = new GeometryAttribute({\r\n                    componentDatatype : ComponentDatatype.FLOAT,\r\n                    componentsPerAttribute : 2,\r\n                    values : st\r\n                });\r\n            }\r\n\r\n            if (vertexFormat.normal) {\r\n                attributes.normal = new GeometryAttribute({\r\n                    componentDatatype : ComponentDatatype.FLOAT,\r\n                    componentsPerAttribute : 3,\r\n                    values : normals\r\n                });\r\n            }\r\n\r\n            if (vertexFormat.tangent) {\r\n                attributes.tangent = new GeometryAttribute({\r\n                    componentDatatype : ComponentDatatype.FLOAT,\r\n                    componentsPerAttribute : 3,\r\n                    values : tangents\r\n                });\r\n            }\r\n\r\n            if (vertexFormat.bitangent) {\r\n                attributes.bitangent = new GeometryAttribute({\r\n                    componentDatatype : ComponentDatatype.FLOAT,\r\n                    componentsPerAttribute : 3,\r\n                    values : bitangents\r\n                });\r\n            }\r\n        }\r\n\r\n        if (defined(ellipsoidGeometry._offsetAttribute)) {\r\n            var length = positions.length;\r\n            var applyOffset = new Uint8Array(length / 3);\r\n            var offsetValue = ellipsoidGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\r\n            arrayFill(applyOffset, offsetValue);\r\n            attributes.applyOffset = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\r\n                componentsPerAttribute : 1,\r\n                values : applyOffset\r\n            });\r\n        }\r\n\r\n        return new Geometry({\r\n            attributes : attributes,\r\n            indices : indices,\r\n            primitiveType : PrimitiveType.TRIANGLES,\r\n            boundingSphere : BoundingSphere.fromEllipsoid(ellipsoidOuter),\r\n            offsetAttribute : ellipsoidGeometry._offsetAttribute\r\n        });\r\n    };\r\n\r\n    var unitEllipsoidGeometry;\r\n\r\n    /**\r\n     * Returns the geometric representation of a unit ellipsoid, including its vertices, indices, and a bounding sphere.\r\n     * @returns {Geometry} The computed vertices and indices.\r\n     *\r\n     * @private\r\n     */\r\n    EllipsoidGeometry.getUnitEllipsoid = function() {\r\n        if (!defined(unitEllipsoidGeometry)) {\r\n            unitEllipsoidGeometry = EllipsoidGeometry.createGeometry((new EllipsoidGeometry({\r\n                radii : new Cartesian3(1.0, 1.0, 1.0),\r\n                vertexFormat : VertexFormat.POSITION_ONLY\r\n            })));\r\n        }\r\n        return unitEllipsoidGeometry;\r\n    };\r\nexport default EllipsoidGeometry;\r\n"],"names":["scratchPosition","Cartesian3","scratchNormal","scratchTangent","scratchBitangent","scratchNormalST","defaultRadii","cos","Math","sin","EllipsoidGeometry","options","defaultValue","EMPTY_OBJECT","radii","innerRadii","minimumClock","maximumClock","CesiumMath","TWO_PI","minimumCone","maximumCone","PI","stackPartitions","round","slicePartitions","vertexFormat","VertexFormat","DEFAULT","DeveloperError","this","_radii","clone","_innerRadii","_minimumClock","_maximumClock","_minimumCone","_maximumCone","_stackPartitions","_slicePartitions","_vertexFormat","_offsetAttribute","offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","defined","unitEllipsoidGeometry","scratchRadii","scratchInnerRadii","scratchVertexFormat","scratchOptions","undefined","unpack","result","createGeometry","ellipsoidGeometry","x","y","z","i","j","abs","index","phis","thetas","push","numPhis","length","numThetas","extraIndices","vertexMultiplier","hasInnerSurface","isTopOpen","isBotOpen","isClockOpen","vertexCount","positions","Float64Array","isInner","arrayFill","Array","negateNormal","indexCount","numIndices","indices","IndexDatatype","createTypedArray","normals","Float32Array","tangents","bitangents","st","sinPhi","cosPhi","sinTheta","cosTheta","topOffset","bottomOffset","outerOffset","innerOffset","vertexIndex","offset","attributes","GeometryAttributes","position","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","ellipsoid","stIndex","normalIndex","tangentIndex","bitangentIndex","vertexCountHalf","ellipsoidOuter","Ellipsoid","fromCartesian3","ellipsoidInner","normal","tangent","bitangent","fromArray","geodeticSurfaceNormal","negate","normalST","Cartesian2","atan2","asin","unit","tangetOffset","UNIT_X","UNIT_Z","cross","normalize","FLOAT","applyOffset","Uint8Array","offsetValue","GeometryOffsetAttribute","NONE","UNSIGNED_BYTE","Geometry","primitiveType","PrimitiveType","TRIANGLES","boundingSphere","BoundingSphere","fromEllipsoid","getUnitEllipsoid","POSITION_ONLY"],"mappings":"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"}