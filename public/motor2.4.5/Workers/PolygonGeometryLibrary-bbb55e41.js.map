{"version":3,"file":"PolygonGeometryLibrary-bbb55e41.js","sources":["../../../../Source/Core/Queue.js","../../../../Source/Core/PolygonGeometryLibrary.js"],"sourcesContent":["\r\n    /**\r\n     * A queue that can enqueue items at the end, and dequeue items from the front.\r\n     *\r\n     * @alias Queue\r\n     * @constructor\r\n     */\r\n    function Queue() {\r\n        this._array = [];\r\n        this._offset = 0;\r\n        this._length = 0;\r\n    }\r\n\r\n    Object.defineProperties(Queue.prototype, {\r\n        /**\r\n         * The length of the queue.\r\n         *\r\n         * @memberof Queue.prototype\r\n         *\r\n         * @type {Number}\r\n         * @readonly\r\n         */\r\n        length : {\r\n            get : function() {\r\n                return this._length;\r\n            }\r\n        }\r\n    });\r\n\r\n    /**\r\n     * Enqueues the specified item.\r\n     *\r\n     * @param {*} item The item to enqueue.\r\n     */\r\n    Queue.prototype.enqueue = function(item) {\r\n        this._array.push(item);\r\n        this._length++;\r\n    };\r\n\r\n    /**\r\n     * Dequeues an item.  Returns undefined if the queue is empty.\r\n     *\r\n     * @returns {*} The the dequeued item.\r\n     */\r\n    Queue.prototype.dequeue = function() {\r\n        if (this._length === 0) {\r\n            return undefined;\r\n        }\r\n\r\n        var array = this._array;\r\n        var offset = this._offset;\r\n        var item = array[offset];\r\n        array[offset] = undefined;\r\n\r\n        offset++;\r\n        if ((offset > 10) && (offset * 2 > array.length)) {\r\n            //compact array\r\n            this._array = array.slice(offset);\r\n            offset = 0;\r\n        }\r\n\r\n        this._offset = offset;\r\n        this._length--;\r\n\r\n        return item;\r\n    };\r\n\r\n    /**\r\n     * Returns the item at the front of the queue.  Returns undefined if the queue is empty.\r\n     *\r\n     * @returns {*} The item at the front of the queue.\r\n     */\r\n    Queue.prototype.peek = function() {\r\n        if (this._length === 0) {\r\n            return undefined;\r\n        }\r\n\r\n        return this._array[this._offset];\r\n    };\r\n\r\n    /**\r\n     * Check whether this queue contains the specified item.\r\n     *\r\n     * @param {*} item The item to search for.\r\n     */\r\n    Queue.prototype.contains = function(item) {\r\n        return this._array.indexOf(item) !== -1;\r\n    };\r\n\r\n    /**\r\n     * Remove all items from the queue.\r\n     */\r\n    Queue.prototype.clear = function() {\r\n        this._array.length = this._offset = this._length = 0;\r\n    };\r\n\r\n    /**\r\n     * Sort the items in the queue in-place.\r\n     *\r\n     * @param {Queue~Comparator} compareFunction A function that defines the sort order.\r\n     */\r\n    Queue.prototype.sort = function(compareFunction) {\r\n        if (this._offset > 0) {\r\n            //compact array\r\n            this._array = this._array.slice(this._offset);\r\n            this._offset = 0;\r\n        }\r\n\r\n        this._array.sort(compareFunction);\r\n    };\r\n\r\n    /**\r\n     * A function used to compare two items while sorting a queue.\r\n     * @callback Queue~Comparator\r\n     *\r\n     * @param {*} a An item in the array.\r\n     * @param {*} b An item in the array.\r\n     * @returns {Number} Returns a negative value if <code>a</code> is less than <code>b</code>,\r\n     *          a positive value if <code>a</code> is greater than <code>b</code>, or\r\n     *          0 if <code>a</code> is equal to <code>b</code>.\r\n     *\r\n     * @example\r\n     * function compareNumbers(a, b) {\r\n     *     return a - b;\r\n     * }\r\n     */\r\nexport default Queue;\r\n","import ArcType from './ArcType.js';\r\nimport arrayRemoveDuplicates from './arrayRemoveDuplicates.js';\r\nimport Cartesian2 from './Cartesian2.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport Cartographic from './Cartographic.js';\r\nimport ComponentDatatype from './ComponentDatatype.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport EllipsoidRhumbLine from './EllipsoidRhumbLine.js';\r\nimport Geometry from './Geometry.js';\r\nimport GeometryAttribute from './GeometryAttribute.js';\r\nimport GeometryAttributes from './GeometryAttributes.js';\r\nimport GeometryPipeline from './GeometryPipeline.js';\r\nimport IndexDatatype from './IndexDatatype.js';\r\nimport CesiumMath from './Math.js';\r\nimport Matrix3 from './Matrix3.js';\r\nimport PolygonPipeline from './PolygonPipeline.js';\r\nimport PrimitiveType from './PrimitiveType.js';\r\nimport Quaternion from './Quaternion.js';\r\nimport Queue from './Queue.js';\r\nimport WindingOrder from './WindingOrder.js';\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    var PolygonGeometryLibrary = {};\r\n\r\n    PolygonGeometryLibrary.computeHierarchyPackedLength = function(polygonHierarchy) {\r\n        var numComponents = 0;\r\n        var stack = [polygonHierarchy];\r\n        while (stack.length > 0) {\r\n            var hierarchy = stack.pop();\r\n            if (!defined(hierarchy)) {\r\n                continue;\r\n            }\r\n\r\n            numComponents += 2;\r\n\r\n            var positions = hierarchy.positions;\r\n            var holes = hierarchy.holes;\r\n\r\n            if (defined(positions)) {\r\n                numComponents += positions.length * Cartesian3.packedLength;\r\n            }\r\n\r\n            if (defined(holes)) {\r\n                var length = holes.length;\r\n                for (var i = 0; i < length; ++i) {\r\n                    stack.push(holes[i]);\r\n                }\r\n            }\r\n        }\r\n\r\n        return numComponents;\r\n    };\r\n\r\n    PolygonGeometryLibrary.packPolygonHierarchy = function(polygonHierarchy, array, startingIndex) {\r\n        var stack = [polygonHierarchy];\r\n        while (stack.length > 0) {\r\n            var hierarchy = stack.pop();\r\n            if (!defined(hierarchy)) {\r\n                continue;\r\n            }\r\n\r\n            var positions = hierarchy.positions;\r\n            var holes = hierarchy.holes;\r\n\r\n            array[startingIndex++] = defined(positions) ? positions.length : 0;\r\n            array[startingIndex++] = defined(holes) ? holes.length : 0;\r\n\r\n            if (defined(positions)) {\r\n                var positionsLength = positions.length;\r\n                for (var i = 0; i < positionsLength; ++i, startingIndex += 3) {\r\n                    Cartesian3.pack(positions[i], array, startingIndex);\r\n                }\r\n            }\r\n\r\n            if (defined(holes)) {\r\n                var holesLength = holes.length;\r\n                for (var j = 0; j < holesLength; ++j) {\r\n                    stack.push(holes[j]);\r\n                }\r\n            }\r\n        }\r\n\r\n        return startingIndex;\r\n    };\r\n\r\n    PolygonGeometryLibrary.unpackPolygonHierarchy = function(array, startingIndex) {\r\n        var positionsLength = array[startingIndex++];\r\n        var holesLength = array[startingIndex++];\r\n\r\n        var positions = new Array(positionsLength);\r\n        var holes = holesLength > 0 ? new Array(holesLength) : undefined;\r\n\r\n        for (var i = 0; i < positionsLength; ++i, startingIndex += Cartesian3.packedLength) {\r\n            positions[i] = Cartesian3.unpack(array, startingIndex);\r\n        }\r\n\r\n        for (var j = 0; j < holesLength; ++j) {\r\n            holes[j] = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex);\r\n            startingIndex = holes[j].startingIndex;\r\n            delete holes[j].startingIndex;\r\n        }\r\n\r\n        return {\r\n            positions : positions,\r\n            holes : holes,\r\n            startingIndex : startingIndex\r\n        };\r\n    };\r\n\r\n    var distanceScratch = new Cartesian3();\r\n    function getPointAtDistance(p0, p1, distance, length) {\r\n        Cartesian3.subtract(p1, p0, distanceScratch);\r\n        Cartesian3.multiplyByScalar(distanceScratch, distance / length, distanceScratch);\r\n        Cartesian3.add(p0, distanceScratch, distanceScratch);\r\n        return [distanceScratch.x, distanceScratch.y, distanceScratch.z];\r\n    }\r\n\r\n    PolygonGeometryLibrary.subdivideLineCount = function(p0, p1, minDistance) {\r\n        var distance = Cartesian3.distance(p0, p1);\r\n        var n = distance / minDistance;\r\n        var countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\r\n        return Math.pow(2, countDivide);\r\n    };\r\n\r\n    var scratchCartographic0 = new Cartographic();\r\n    var scratchCartographic1 = new Cartographic();\r\n    var scratchCartographic2 = new Cartographic();\r\n    var scratchCartesian0 = new Cartesian3();\r\n    PolygonGeometryLibrary.subdivideRhumbLineCount = function(ellipsoid, p0, p1, minDistance) {\r\n        var c0 = ellipsoid.cartesianToCartographic(p0, scratchCartographic0);\r\n        var c1 = ellipsoid.cartesianToCartographic(p1, scratchCartographic1);\r\n        var rhumb = new EllipsoidRhumbLine(c0, c1, ellipsoid);\r\n        var n = rhumb.surfaceDistance / minDistance;\r\n        var countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\r\n        return Math.pow(2, countDivide);\r\n    };\r\n\r\n    PolygonGeometryLibrary.subdivideLine = function(p0, p1, minDistance, result) {\r\n        var numVertices = PolygonGeometryLibrary.subdivideLineCount(p0, p1, minDistance);\r\n        var length = Cartesian3.distance(p0, p1);\r\n        var distanceBetweenVertices = length / numVertices;\r\n\r\n        if (!defined(result)) {\r\n            result = [];\r\n        }\r\n\r\n        var positions = result;\r\n        positions.length = numVertices * 3;\r\n\r\n        var index = 0;\r\n        for ( var i = 0; i < numVertices; i++) {\r\n            var p = getPointAtDistance(p0, p1, i * distanceBetweenVertices, length);\r\n            positions[index++] = p[0];\r\n            positions[index++] = p[1];\r\n            positions[index++] = p[2];\r\n        }\r\n\r\n        return positions;\r\n    };\r\n\r\n    PolygonGeometryLibrary.subdivideRhumbLine = function(ellipsoid, p0, p1, minDistance, result) {\r\n        var c0 = ellipsoid.cartesianToCartographic(p0, scratchCartographic0);\r\n        var c1 = ellipsoid.cartesianToCartographic(p1, scratchCartographic1);\r\n        var rhumb = new EllipsoidRhumbLine(c0, c1, ellipsoid);\r\n\r\n        var n = rhumb.surfaceDistance / minDistance;\r\n        var countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\r\n        var numVertices = Math.pow(2, countDivide);\r\n        var distanceBetweenVertices = rhumb.surfaceDistance / numVertices;\r\n\r\n        if (!defined(result)) {\r\n            result = [];\r\n        }\r\n\r\n        var positions = result;\r\n        positions.length = numVertices * 3;\r\n\r\n        var index = 0;\r\n        for ( var i = 0; i < numVertices; i++) {\r\n            var c = rhumb.interpolateUsingSurfaceDistance(i * distanceBetweenVertices, scratchCartographic2);\r\n            var p = ellipsoid.cartographicToCartesian(c, scratchCartesian0);\r\n            positions[index++] = p.x;\r\n            positions[index++] = p.y;\r\n            positions[index++] = p.z;\r\n        }\r\n\r\n        return positions;\r\n    };\r\n\r\n    var scaleToGeodeticHeightN1 = new Cartesian3();\r\n    var scaleToGeodeticHeightN2 = new Cartesian3();\r\n    var scaleToGeodeticHeightP1 = new Cartesian3();\r\n    var scaleToGeodeticHeightP2 = new Cartesian3();\r\n\r\n    PolygonGeometryLibrary.scaleToGeodeticHeightExtruded = function(geometry, maxHeight, minHeight, ellipsoid, perPositionHeight) {\r\n        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n\r\n        var n1 = scaleToGeodeticHeightN1;\r\n        var n2 = scaleToGeodeticHeightN2;\r\n        var p = scaleToGeodeticHeightP1;\r\n        var p2 = scaleToGeodeticHeightP2;\r\n\r\n        if (defined(geometry) && defined(geometry.attributes) && defined(geometry.attributes.position)) {\r\n            var positions = geometry.attributes.position.values;\r\n            var length = positions.length / 2;\r\n\r\n            for ( var i = 0; i < length; i += 3) {\r\n                Cartesian3.fromArray(positions, i, p);\r\n\r\n                ellipsoid.geodeticSurfaceNormal(p, n1);\r\n                p2 = ellipsoid.scaleToGeodeticSurface(p, p2);\r\n                n2 = Cartesian3.multiplyByScalar(n1, minHeight, n2);\r\n                n2 = Cartesian3.add(p2, n2, n2);\r\n                positions[i + length] = n2.x;\r\n                positions[i + 1 + length] = n2.y;\r\n                positions[i + 2 + length] = n2.z;\r\n\r\n                if (perPositionHeight) {\r\n                    p2 = Cartesian3.clone(p, p2);\r\n                }\r\n                n2 = Cartesian3.multiplyByScalar(n1, maxHeight, n2);\r\n                n2 = Cartesian3.add(p2, n2, n2);\r\n                positions[i] = n2.x;\r\n                positions[i + 1] = n2.y;\r\n                positions[i + 2] = n2.z;\r\n            }\r\n        }\r\n        return geometry;\r\n    };\r\n\r\n    PolygonGeometryLibrary.polygonOutlinesFromHierarchy = function(polygonHierarchy, scaleToEllipsoidSurface, ellipsoid) {\r\n        // create from a polygon hierarchy\r\n        // Algorithm adapted from http://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf\r\n        var polygons = [];\r\n        var queue = new Queue();\r\n        queue.enqueue(polygonHierarchy);\r\n        var i;\r\n        var j;\r\n        var length;\r\n        while (queue.length !== 0) {\r\n            var outerNode = queue.dequeue();\r\n            var outerRing = outerNode.positions;\r\n            if (scaleToEllipsoidSurface) {\r\n                length = outerRing.length;\r\n                for (i = 0; i < length; i++) {\r\n                    ellipsoid.scaleToGeodeticSurface(outerRing[i], outerRing[i]);\r\n                }\r\n            }\r\n            outerRing = arrayRemoveDuplicates(outerRing, Cartesian3.equalsEpsilon, true);\r\n            if (outerRing.length < 3) {\r\n                continue;\r\n            }\r\n\r\n            var numChildren = outerNode.holes ? outerNode.holes.length : 0;\r\n            // The outer polygon contains inner polygons\r\n            for (i = 0; i < numChildren; i++) {\r\n                var hole = outerNode.holes[i];\r\n                var holePositions = hole.positions;\r\n                if (scaleToEllipsoidSurface) {\r\n                    length = holePositions.length;\r\n                    for (j = 0; j < length; ++j) {\r\n                        ellipsoid.scaleToGeodeticSurface(holePositions[j], holePositions[j]);\r\n                    }\r\n                }\r\n                holePositions = arrayRemoveDuplicates(holePositions, Cartesian3.equalsEpsilon, true);\r\n                if (holePositions.length < 3) {\r\n                    continue;\r\n                }\r\n                polygons.push(holePositions);\r\n\r\n                var numGrandchildren = 0;\r\n                if (defined(hole.holes)) {\r\n                    numGrandchildren = hole.holes.length;\r\n                }\r\n\r\n                for (j = 0; j < numGrandchildren; j++) {\r\n                    queue.enqueue(hole.holes[j]);\r\n                }\r\n            }\r\n\r\n            polygons.push(outerRing);\r\n        }\r\n\r\n        return polygons;\r\n    };\r\n\r\n    PolygonGeometryLibrary.polygonsFromHierarchy = function(polygonHierarchy, projectPointsTo2D, scaleToEllipsoidSurface, ellipsoid) {\r\n        // create from a polygon hierarchy\r\n        // Algorithm adapted from http://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf\r\n        var hierarchy = [];\r\n        var polygons = [];\r\n\r\n        var queue = new Queue();\r\n        queue.enqueue(polygonHierarchy);\r\n\r\n        while (queue.length !== 0) {\r\n            var outerNode = queue.dequeue();\r\n            var outerRing = outerNode.positions;\r\n            var holes = outerNode.holes;\r\n\r\n            var i;\r\n            var length;\r\n            if (scaleToEllipsoidSurface) {\r\n                length = outerRing.length;\r\n                for (i = 0; i < length; i++) {\r\n                    ellipsoid.scaleToGeodeticSurface(outerRing[i], outerRing[i]);\r\n                }\r\n            }\r\n\r\n            outerRing = arrayRemoveDuplicates(outerRing, Cartesian3.equalsEpsilon, true);\r\n            if (outerRing.length < 3) {\r\n                continue;\r\n            }\r\n\r\n            var positions2D = projectPointsTo2D(outerRing);\r\n            if (!defined(positions2D)) {\r\n                continue;\r\n            }\r\n            var holeIndices = [];\r\n\r\n            var originalWindingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\r\n            if (originalWindingOrder === WindingOrder.CLOCKWISE) {\r\n                positions2D.reverse();\r\n                outerRing = outerRing.slice().reverse();\r\n            }\r\n\r\n            var positions = outerRing.slice();\r\n            var numChildren = defined(holes) ? holes.length : 0;\r\n            var polygonHoles = [];\r\n            var j;\r\n\r\n            for (i = 0; i < numChildren; i++) {\r\n                var hole = holes[i];\r\n                var holePositions = hole.positions;\r\n                if (scaleToEllipsoidSurface) {\r\n                    length = holePositions.length;\r\n                    for (j = 0; j < length; ++j) {\r\n                        ellipsoid.scaleToGeodeticSurface(holePositions[j], holePositions[j]);\r\n                    }\r\n                }\r\n\r\n                holePositions = arrayRemoveDuplicates(holePositions, Cartesian3.equalsEpsilon, true);\r\n                if (holePositions.length < 3) {\r\n                    continue;\r\n                }\r\n\r\n                var holePositions2D = projectPointsTo2D(holePositions);\r\n                if (!defined(holePositions2D)) {\r\n                    continue;\r\n                }\r\n\r\n                originalWindingOrder = PolygonPipeline.computeWindingOrder2D(holePositions2D);\r\n                if (originalWindingOrder === WindingOrder.CLOCKWISE) {\r\n                    holePositions2D.reverse();\r\n                    holePositions = holePositions.slice().reverse();\r\n                }\r\n\r\n                polygonHoles.push(holePositions);\r\n                holeIndices.push(positions.length);\r\n                positions = positions.concat(holePositions);\r\n                positions2D = positions2D.concat(holePositions2D);\r\n\r\n                var numGrandchildren = 0;\r\n                if (defined(hole.holes)) {\r\n                    numGrandchildren = hole.holes.length;\r\n                }\r\n\r\n                for (j = 0; j < numGrandchildren; j++) {\r\n                    queue.enqueue(hole.holes[j]);\r\n                }\r\n            }\r\n\r\n            hierarchy.push({\r\n                outerRing : outerRing,\r\n                holes : polygonHoles\r\n            });\r\n            polygons.push({\r\n                positions : positions,\r\n                positions2D : positions2D,\r\n                holes : holeIndices\r\n            });\r\n        }\r\n\r\n        return {\r\n            hierarchy : hierarchy,\r\n            polygons : polygons\r\n        };\r\n    };\r\n\r\n    var computeBoundingRectangleCartesian2 = new Cartesian2();\r\n    var computeBoundingRectangleCartesian3 = new Cartesian3();\r\n    var computeBoundingRectangleQuaternion = new Quaternion();\r\n    var computeBoundingRectangleMatrix3 = new Matrix3();\r\n    PolygonGeometryLibrary.computeBoundingRectangle = function (planeNormal, projectPointTo2D, positions, angle, result) {\r\n        var rotation = Quaternion.fromAxisAngle(planeNormal, angle, computeBoundingRectangleQuaternion);\r\n        var textureMatrix = Matrix3.fromQuaternion(rotation, computeBoundingRectangleMatrix3);\r\n\r\n        var minX = Number.POSITIVE_INFINITY;\r\n        var maxX = Number.NEGATIVE_INFINITY;\r\n        var minY = Number.POSITIVE_INFINITY;\r\n        var maxY = Number.NEGATIVE_INFINITY;\r\n\r\n        var length = positions.length;\r\n        for ( var i = 0; i < length; ++i) {\r\n            var p = Cartesian3.clone(positions[i], computeBoundingRectangleCartesian3);\r\n            Matrix3.multiplyByVector(textureMatrix, p, p);\r\n            var st = projectPointTo2D(p, computeBoundingRectangleCartesian2);\r\n\r\n            if (defined(st)) {\r\n                minX = Math.min(minX, st.x);\r\n                maxX = Math.max(maxX, st.x);\r\n\r\n                minY = Math.min(minY, st.y);\r\n                maxY = Math.max(maxY, st.y);\r\n            }\r\n        }\r\n\r\n        result.x = minX;\r\n        result.y = minY;\r\n        result.width = maxX - minX;\r\n        result.height = maxY - minY;\r\n        return result;\r\n    };\r\n\r\n    PolygonGeometryLibrary.createGeometryFromPositions = function(ellipsoid, polygon, granularity, perPositionHeight, vertexFormat, arcType) {\r\n        var indices = PolygonPipeline.triangulate(polygon.positions2D, polygon.holes);\r\n\r\n        /* If polygon is completely unrenderable, just use the first three vertices */\r\n        if (indices.length < 3) {\r\n            indices = [0, 1, 2];\r\n        }\r\n\r\n        var positions = polygon.positions;\r\n\r\n        if (perPositionHeight) {\r\n            var length = positions.length;\r\n            var flattenedPositions = new Array(length * 3);\r\n            var index = 0;\r\n            for ( var i = 0; i < length; i++) {\r\n                var p = positions[i];\r\n                flattenedPositions[index++] = p.x;\r\n                flattenedPositions[index++] = p.y;\r\n                flattenedPositions[index++] = p.z;\r\n            }\r\n            var geometry = new Geometry({\r\n                attributes : {\r\n                    position : new GeometryAttribute({\r\n                        componentDatatype : ComponentDatatype.DOUBLE,\r\n                        componentsPerAttribute : 3,\r\n                        values : flattenedPositions\r\n                    })\r\n                },\r\n                indices : indices,\r\n                primitiveType : PrimitiveType.TRIANGLES\r\n            });\r\n\r\n            if (vertexFormat.normal) {\r\n                return GeometryPipeline.computeNormal(geometry);\r\n            }\r\n\r\n            return geometry;\r\n        }\r\n\r\n        if (arcType === ArcType.GEODESIC) {\r\n            return PolygonPipeline.computeSubdivision(ellipsoid, positions, indices, granularity);\r\n        } else if (arcType === ArcType.RHUMB) {\r\n            return PolygonPipeline.computeRhumbLineSubdivision(ellipsoid, positions, indices, granularity);\r\n        }\r\n    };\r\n\r\n    var computeWallIndicesSubdivided = [];\r\n    var p1Scratch = new Cartesian3();\r\n    var p2Scratch = new Cartesian3();\r\n\r\n    PolygonGeometryLibrary.computeWallGeometry = function(positions, ellipsoid, granularity, perPositionHeight, arcType) {\r\n        var edgePositions;\r\n        var topEdgeLength;\r\n        var i;\r\n        var p1;\r\n        var p2;\r\n\r\n        var length = positions.length;\r\n        var index = 0;\r\n\r\n        if (!perPositionHeight) {\r\n            var minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\r\n\r\n            var numVertices = 0;\r\n            if (arcType === ArcType.GEODESIC) {\r\n                for (i = 0; i < length; i++) {\r\n                    numVertices += PolygonGeometryLibrary.subdivideLineCount(positions[i], positions[(i + 1) % length], minDistance);\r\n                }\r\n            } else if (arcType === ArcType.RHUMB) {\r\n                for (i = 0; i < length; i++) {\r\n                    numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(ellipsoid, positions[i], positions[(i + 1) % length], minDistance);\r\n                }\r\n            }\r\n\r\n            topEdgeLength = (numVertices + length) * 3;\r\n            edgePositions = new Array(topEdgeLength * 2);\r\n            for (i = 0; i < length; i++) {\r\n                p1 = positions[i];\r\n                p2 = positions[(i + 1) % length];\r\n\r\n                var tempPositions;\r\n                if (arcType === ArcType.GEODESIC) {\r\n                    tempPositions = PolygonGeometryLibrary.subdivideLine(p1, p2, minDistance, computeWallIndicesSubdivided);\r\n                } else if (arcType === ArcType.RHUMB) {\r\n                    tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(ellipsoid, p1, p2, minDistance, computeWallIndicesSubdivided);\r\n                }\r\n                var tempPositionsLength = tempPositions.length;\r\n                for (var j = 0; j < tempPositionsLength; ++j, ++index) {\r\n                    edgePositions[index] = tempPositions[j];\r\n                    edgePositions[index + topEdgeLength] = tempPositions[j];\r\n                }\r\n\r\n                edgePositions[index] = p2.x;\r\n                edgePositions[index + topEdgeLength] = p2.x;\r\n                ++index;\r\n\r\n                edgePositions[index] = p2.y;\r\n                edgePositions[index + topEdgeLength] = p2.y;\r\n                ++index;\r\n\r\n                edgePositions[index] = p2.z;\r\n                edgePositions[index + topEdgeLength] = p2.z;\r\n                ++index;\r\n            }\r\n        } else {\r\n            topEdgeLength = length * 3 * 2;\r\n            edgePositions = new Array(topEdgeLength * 2);\r\n            for (i = 0; i < length; i++) {\r\n                p1 = positions[i];\r\n                p2 = positions[(i + 1) % length];\r\n                edgePositions[index] = edgePositions[index + topEdgeLength] = p1.x;\r\n                ++index;\r\n                edgePositions[index] = edgePositions[index + topEdgeLength] = p1.y;\r\n                ++index;\r\n                edgePositions[index] = edgePositions[index + topEdgeLength] = p1.z;\r\n                ++index;\r\n                edgePositions[index] = edgePositions[index + topEdgeLength] = p2.x;\r\n                ++index;\r\n                edgePositions[index] = edgePositions[index + topEdgeLength] = p2.y;\r\n                ++index;\r\n                edgePositions[index] = edgePositions[index + topEdgeLength] = p2.z;\r\n                ++index;\r\n            }\r\n        }\r\n\r\n        length = edgePositions.length;\r\n        var indices = IndexDatatype.createTypedArray(length / 3, length - positions.length * 6);\r\n        var edgeIndex = 0;\r\n        length /= 6;\r\n\r\n        for (i = 0; i < length; i++) {\r\n            var UL = i;\r\n            var UR = UL + 1;\r\n            var LL = UL + length;\r\n            var LR = LL + 1;\r\n\r\n            p1 = Cartesian3.fromArray(edgePositions, UL * 3, p1Scratch);\r\n            p2 = Cartesian3.fromArray(edgePositions, UR * 3, p2Scratch);\r\n            if (Cartesian3.equalsEpsilon(p1, p2, CesiumMath.EPSILON10, CesiumMath.EPSILON10)) {\r\n                //skip corner\r\n                continue;\r\n            }\r\n\r\n            indices[edgeIndex++] = UL;\r\n            indices[edgeIndex++] = LL;\r\n            indices[edgeIndex++] = UR;\r\n            indices[edgeIndex++] = UR;\r\n            indices[edgeIndex++] = LL;\r\n            indices[edgeIndex++] = LR;\r\n        }\r\n\r\n        return new Geometry({\r\n            attributes : new GeometryAttributes({\r\n                position : new GeometryAttribute({\r\n                    componentDatatype : ComponentDatatype.DOUBLE,\r\n                    componentsPerAttribute : 3,\r\n                    values : edgePositions\r\n                })\r\n            }),\r\n            indices : indices,\r\n            primitiveType : PrimitiveType.TRIANGLES\r\n        });\r\n    };\r\nexport default PolygonGeometryLibrary;\r\n"],"names":["Queue","this","_array","_offset","_length","Object","defineProperties","prototype","length","get","enqueue","item","push","dequeue","array","offset","undefined","slice","peek","contains","indexOf","clear","sort","compareFunction","PolygonGeometryLibrary","computeHierarchyPackedLength","polygonHierarchy","numComponents","stack","hierarchy","pop","defined","positions","holes","Cartesian3","packedLength","i","packPolygonHierarchy","startingIndex","positionsLength","pack","holesLength","j","unpackPolygonHierarchy","Array","unpack","distanceScratch","getPointAtDistance","p0","p1","distance","subtract","multiplyByScalar","add","x","y","z","subdivideLineCount","minDistance","n","countDivide","Math","max","ceil","CesiumMath","log2","pow","scratchCartographic0","Cartographic","scratchCartographic1","scratchCartographic2","scratchCartesian0","subdivideRhumbLineCount","ellipsoid","c0","cartesianToCartographic","c1","EllipsoidRhumbLine","surfaceDistance","subdivideLine","result","numVertices","distanceBetweenVertices","index","p","subdivideRhumbLine","rhumb","c","interpolateUsingSurfaceDistance","cartographicToCartesian","scaleToGeodeticHeightN1","scaleToGeodeticHeightN2","scaleToGeodeticHeightP1","scaleToGeodeticHeightP2","scaleToGeodeticHeightExtruded","geometry","maxHeight","minHeight","perPositionHeight","defaultValue","Ellipsoid","WGS84","n1","n2","p2","attributes","position","values","fromArray","geodeticSurfaceNormal","scaleToGeodeticSurface","clone","polygonOutlinesFromHierarchy","scaleToEllipsoidSurface","polygons","queue","outerNode","outerRing","arrayRemoveDuplicates","equalsEpsilon","numChildren","hole","holePositions","numGrandchildren","polygonsFromHierarchy","projectPointsTo2D","positions2D","holeIndices","originalWindingOrder","PolygonPipeline","computeWindingOrder2D","WindingOrder","CLOCKWISE","reverse","polygonHoles","holePositions2D","concat","computeBoundingRectangleCartesian2","Cartesian2","computeBoundingRectangleCartesian3","computeBoundingRectangleQuaternion","Quaternion","computeBoundingRectangleMatrix3","Matrix3","computeBoundingRectangle","planeNormal","projectPointTo2D","angle","rotation","fromAxisAngle","textureMatrix","fromQuaternion","minX","Number","POSITIVE_INFINITY","maxX","NEGATIVE_INFINITY","minY","maxY","multiplyByVector","st","min","width","height","createGeometryFromPositions","polygon","granularity","vertexFormat","arcType","indices","triangulate","flattenedPositions","Geometry","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","primitiveType","PrimitiveType","TRIANGLES","normal","GeometryPipeline","computeNormal","ArcType","GEODESIC","computeSubdivision","RHUMB","computeRhumbLineSubdivision","computeWallIndicesSubdivided","p1Scratch","p2Scratch","computeWallGeometry","edgePositions","topEdgeLength","chordLength","maximumRadius","tempPositions","tempPositionsLength","IndexDatatype","createTypedArray","edgeIndex","UL","UR","LL","LR","EPSILON10","GeometryAttributes"],"mappings":"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"}