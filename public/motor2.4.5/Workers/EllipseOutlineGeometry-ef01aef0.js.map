{"version":3,"file":"EllipseOutlineGeometry-ef01aef0.js","sources":["../../../../Source/Core/EllipseOutlineGeometry.js"],"sourcesContent":["import arrayFill from './arrayFill.js';\r\nimport BoundingSphere from './BoundingSphere.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport ComponentDatatype from './ComponentDatatype.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport EllipseGeometryLibrary from './EllipseGeometryLibrary.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport Geometry from './Geometry.js';\r\nimport GeometryAttribute from './GeometryAttribute.js';\r\nimport GeometryAttributes from './GeometryAttributes.js';\r\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\r\nimport IndexDatatype from './IndexDatatype.js';\r\nimport CesiumMath from './Math.js';\r\nimport PrimitiveType from './PrimitiveType.js';\r\n\r\n    var scratchCartesian1 = new Cartesian3();\r\n    var boundingSphereCenter = new Cartesian3();\r\n\r\n    function computeEllipse(options) {\r\n        var center = options.center;\r\n        boundingSphereCenter = Cartesian3.multiplyByScalar(options.ellipsoid.geodeticSurfaceNormal(center, boundingSphereCenter), options.height, boundingSphereCenter);\r\n        boundingSphereCenter = Cartesian3.add(center, boundingSphereCenter, boundingSphereCenter);\r\n        var boundingSphere = new BoundingSphere(boundingSphereCenter, options.semiMajorAxis);\r\n        var positions = EllipseGeometryLibrary.computeEllipsePositions(options, false, true).outerPositions;\r\n\r\n        var attributes = new GeometryAttributes({\r\n            position: new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.DOUBLE,\r\n                componentsPerAttribute : 3,\r\n                values : EllipseGeometryLibrary.raisePositionsToHeight(positions, options, false)\r\n            })\r\n        });\r\n\r\n        var length = positions.length / 3;\r\n        var indices = IndexDatatype.createTypedArray(length, length * 2);\r\n        var index = 0;\r\n        for ( var i = 0; i < length; ++i) {\r\n            indices[index++] = i;\r\n            indices[index++] = (i + 1) % length;\r\n        }\r\n\r\n        return {\r\n            boundingSphere : boundingSphere,\r\n            attributes : attributes,\r\n            indices : indices\r\n        };\r\n    }\r\n\r\n    var topBoundingSphere = new BoundingSphere();\r\n    var bottomBoundingSphere = new BoundingSphere();\r\n    function computeExtrudedEllipse(options) {\r\n        var center = options.center;\r\n        var ellipsoid = options.ellipsoid;\r\n        var semiMajorAxis = options.semiMajorAxis;\r\n        var scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scratchCartesian1), options.height, scratchCartesian1);\r\n        topBoundingSphere.center = Cartesian3.add(center, scaledNormal, topBoundingSphere.center);\r\n        topBoundingSphere.radius = semiMajorAxis;\r\n\r\n        scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scaledNormal), options.extrudedHeight, scaledNormal);\r\n        bottomBoundingSphere.center = Cartesian3.add(center, scaledNormal, bottomBoundingSphere.center);\r\n        bottomBoundingSphere.radius = semiMajorAxis;\r\n\r\n        var positions = EllipseGeometryLibrary.computeEllipsePositions(options, false, true).outerPositions;\r\n        var attributes = new GeometryAttributes({\r\n            position: new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.DOUBLE,\r\n                componentsPerAttribute : 3,\r\n                values : EllipseGeometryLibrary.raisePositionsToHeight(positions, options, true)\r\n            })\r\n        });\r\n\r\n        positions = attributes.position.values;\r\n        var boundingSphere = BoundingSphere.union(topBoundingSphere, bottomBoundingSphere);\r\n        var length = positions.length/3;\r\n\r\n        if (defined(options.offsetAttribute)) {\r\n            var applyOffset = new Uint8Array(length);\r\n            if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\r\n                applyOffset = arrayFill(applyOffset, 1, 0, length / 2);\r\n            } else {\r\n                var offsetValue = options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\r\n                applyOffset = arrayFill(applyOffset, offsetValue);\r\n            }\r\n\r\n            attributes.applyOffset = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\r\n                componentsPerAttribute : 1,\r\n                values: applyOffset\r\n            });\r\n        }\r\n\r\n        var numberOfVerticalLines = defaultValue(options.numberOfVerticalLines, 16);\r\n        numberOfVerticalLines = CesiumMath.clamp(numberOfVerticalLines, 0, length/2);\r\n\r\n        var indices = IndexDatatype.createTypedArray(length, length * 2 + numberOfVerticalLines * 2);\r\n\r\n        length /= 2;\r\n        var index = 0;\r\n        var i;\r\n        for (i = 0; i < length; ++i) {\r\n            indices[index++] = i;\r\n            indices[index++] = (i + 1) % length;\r\n            indices[index++] = i + length;\r\n            indices[index++] = ((i + 1) % length) + length;\r\n        }\r\n\r\n        var numSide;\r\n        if (numberOfVerticalLines > 0) {\r\n            var numSideLines = Math.min(numberOfVerticalLines, length);\r\n            numSide = Math.round(length / numSideLines);\r\n\r\n            var maxI = Math.min(numSide * numberOfVerticalLines, length);\r\n            for (i = 0; i < maxI; i += numSide) {\r\n                indices[index++] = i;\r\n                indices[index++] = i + length;\r\n            }\r\n        }\r\n\r\n        return {\r\n            boundingSphere : boundingSphere,\r\n            attributes : attributes,\r\n            indices : indices\r\n        };\r\n    }\r\n\r\n    /**\r\n     * A description of the outline of an ellipse on an ellipsoid.\r\n     *\r\n     * @alias EllipseOutlineGeometry\r\n     * @constructor\r\n     *\r\n     * @param {Object} options Object with the following properties:\r\n     * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\r\n     * @param {Number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\r\n     * @param {Number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\r\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.\r\n     * @param {Number} [options.height=0.0] The distance in meters between the ellipse and the ellipsoid surface.\r\n     * @param {Number} [options.extrudedHeight] The distance in meters between the ellipse's extruded face and the ellipsoid surface.\r\n     * @param {Number} [options.rotation=0.0] The angle from north (counter-clockwise) in radians.\r\n     * @param {Number} [options.granularity=0.02] The angular distance between points on the ellipse in radians.\r\n     * @param {Number} [options.numberOfVerticalLines=16] Number of lines to draw between the top and bottom surface of an extruded ellipse.\r\n     *\r\n     * @exception {DeveloperError} semiMajorAxis and semiMinorAxis must be greater than zero.\r\n     * @exception {DeveloperError} semiMajorAxis must be greater than or equal to the semiMinorAxis.\r\n     * @exception {DeveloperError} granularity must be greater than zero.\r\n     *\r\n     * @see EllipseOutlineGeometry.createGeometry\r\n     *\r\n     * @example\r\n     * var ellipse = new Cesium.EllipseOutlineGeometry({\r\n     *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\r\n     *   semiMajorAxis : 500000.0,\r\n     *   semiMinorAxis : 300000.0,\r\n     *   rotation : Cesium.Math.toRadians(60.0)\r\n     * });\r\n     * var geometry = Cesium.EllipseOutlineGeometry.createGeometry(ellipse);\r\n     */\r\n    function EllipseOutlineGeometry(options) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n        var center = options.center;\r\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n        var semiMajorAxis = options.semiMajorAxis;\r\n        var semiMinorAxis = options.semiMinorAxis;\r\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(center)) {\r\n            throw new DeveloperError('center is required.');\r\n        }\r\n        if (!defined(semiMajorAxis)) {\r\n            throw new DeveloperError('semiMajorAxis is required.');\r\n        }\r\n        if (!defined(semiMinorAxis)) {\r\n            throw new DeveloperError('semiMinorAxis is required.');\r\n        }\r\n        if (semiMajorAxis < semiMinorAxis) {\r\n            throw new DeveloperError('semiMajorAxis must be greater than or equal to the semiMinorAxis.');\r\n        }\r\n        if (granularity <= 0.0) {\r\n            throw new DeveloperError('granularity must be greater than zero.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var height = defaultValue(options.height, 0.0);\r\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\r\n\r\n        this._center = Cartesian3.clone(center);\r\n        this._semiMajorAxis = semiMajorAxis;\r\n        this._semiMinorAxis = semiMinorAxis;\r\n        this._ellipsoid = Ellipsoid.clone(ellipsoid);\r\n        this._rotation = defaultValue(options.rotation, 0.0);\r\n        this._height = Math.max(extrudedHeight, height);\r\n        this._granularity = granularity;\r\n        this._extrudedHeight = Math.min(extrudedHeight, height);\r\n        this._numberOfVerticalLines = Math.max(defaultValue(options.numberOfVerticalLines, 16), 0);\r\n        this._offsetAttribute = options.offsetAttribute;\r\n        this._workerName = 'createEllipseOutlineGeometry';\r\n    }\r\n\r\n    /**\r\n     * The number of elements used to pack the object into an array.\r\n     * @type {Number}\r\n     */\r\n    EllipseOutlineGeometry.packedLength = Cartesian3.packedLength + Ellipsoid.packedLength + 8;\r\n\r\n    /**\r\n     * Stores the provided instance into the provided array.\r\n     *\r\n     * @param {EllipseOutlineGeometry} value The value to pack.\r\n     * @param {Number[]} array The array to pack into.\r\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n     *\r\n     * @returns {Number[]} The array that was packed into\r\n     */\r\n    EllipseOutlineGeometry.pack = function(value, array, startingIndex) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(value)) {\r\n            throw new DeveloperError('value is required');\r\n        }\r\n        if (!defined(array)) {\r\n            throw new DeveloperError('array is required');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        Cartesian3.pack(value._center, array, startingIndex);\r\n        startingIndex += Cartesian3.packedLength;\r\n\r\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\r\n        startingIndex += Ellipsoid.packedLength;\r\n\r\n        array[startingIndex++] = value._semiMajorAxis;\r\n        array[startingIndex++] = value._semiMinorAxis;\r\n        array[startingIndex++] = value._rotation;\r\n        array[startingIndex++] = value._height;\r\n        array[startingIndex++] = value._granularity;\r\n        array[startingIndex++] = value._extrudedHeight;\r\n        array[startingIndex++]   = value._numberOfVerticalLines;\r\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\r\n\r\n        return array;\r\n    };\r\n\r\n    var scratchCenter = new Cartesian3();\r\n    var scratchEllipsoid = new Ellipsoid();\r\n    var scratchOptions = {\r\n        center : scratchCenter,\r\n        ellipsoid : scratchEllipsoid,\r\n        semiMajorAxis : undefined,\r\n        semiMinorAxis : undefined,\r\n        rotation : undefined,\r\n        height : undefined,\r\n        granularity : undefined,\r\n        extrudedHeight : undefined,\r\n        numberOfVerticalLines : undefined,\r\n        offsetAttribute: undefined\r\n    };\r\n\r\n    /**\r\n     * Retrieves an instance from a packed array.\r\n     *\r\n     * @param {Number[]} array The packed array.\r\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n     * @param {EllipseOutlineGeometry} [result] The object into which to store the result.\r\n     * @returns {EllipseOutlineGeometry} The modified result parameter or a new EllipseOutlineGeometry instance if one was not provided.\r\n     */\r\n    EllipseOutlineGeometry.unpack = function(array, startingIndex, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(array)) {\r\n            throw new DeveloperError('array is required');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        var center = Cartesian3.unpack(array, startingIndex, scratchCenter);\r\n        startingIndex += Cartesian3.packedLength;\r\n\r\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\r\n        startingIndex += Ellipsoid.packedLength;\r\n\r\n        var semiMajorAxis = array[startingIndex++];\r\n        var semiMinorAxis = array[startingIndex++];\r\n        var rotation = array[startingIndex++];\r\n        var height = array[startingIndex++];\r\n        var granularity = array[startingIndex++];\r\n        var extrudedHeight = array[startingIndex++];\r\n        var numberOfVerticalLines = array[startingIndex++];\r\n        var offsetAttribute = array[startingIndex];\r\n\r\n        if (!defined(result)) {\r\n            scratchOptions.height = height;\r\n            scratchOptions.extrudedHeight = extrudedHeight;\r\n            scratchOptions.granularity = granularity;\r\n            scratchOptions.rotation = rotation;\r\n            scratchOptions.semiMajorAxis = semiMajorAxis;\r\n            scratchOptions.semiMinorAxis = semiMinorAxis;\r\n            scratchOptions.numberOfVerticalLines = numberOfVerticalLines;\r\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\r\n\r\n            return new EllipseOutlineGeometry(scratchOptions);\r\n        }\r\n\r\n        result._center = Cartesian3.clone(center, result._center);\r\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\r\n        result._semiMajorAxis = semiMajorAxis;\r\n        result._semiMinorAxis = semiMinorAxis;\r\n        result._rotation = rotation;\r\n        result._height = height;\r\n        result._granularity = granularity;\r\n        result._extrudedHeight = extrudedHeight;\r\n        result._numberOfVerticalLines = numberOfVerticalLines;\r\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the geometric representation of an outline of an ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.\r\n     *\r\n     * @param {EllipseOutlineGeometry} ellipseGeometry A description of the ellipse.\r\n     * @returns {Geometry|undefined} The computed vertices and indices.\r\n     */\r\n    EllipseOutlineGeometry.createGeometry = function(ellipseGeometry) {\r\n        if ((ellipseGeometry._semiMajorAxis <= 0.0) || (ellipseGeometry._semiMinorAxis <= 0.0)) {\r\n            return;\r\n        }\r\n\r\n        var height = ellipseGeometry._height;\r\n        var extrudedHeight = ellipseGeometry._extrudedHeight;\r\n        var extrude = !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\r\n\r\n        ellipseGeometry._center = ellipseGeometry._ellipsoid.scaleToGeodeticSurface(ellipseGeometry._center, ellipseGeometry._center);\r\n        var options = {\r\n            center : ellipseGeometry._center,\r\n            semiMajorAxis : ellipseGeometry._semiMajorAxis,\r\n            semiMinorAxis : ellipseGeometry._semiMinorAxis,\r\n            ellipsoid : ellipseGeometry._ellipsoid,\r\n            rotation : ellipseGeometry._rotation,\r\n            height : height,\r\n            granularity : ellipseGeometry._granularity,\r\n            numberOfVerticalLines : ellipseGeometry._numberOfVerticalLines\r\n        };\r\n        var geometry;\r\n        if (extrude) {\r\n            options.extrudedHeight = extrudedHeight;\r\n            options.offsetAttribute = ellipseGeometry._offsetAttribute;\r\n            geometry = computeExtrudedEllipse(options);\r\n        } else {\r\n            geometry = computeEllipse(options);\r\n\r\n            if (defined(ellipseGeometry._offsetAttribute)) {\r\n                var length = geometry.attributes.position.values.length;\r\n                var applyOffset = new Uint8Array(length / 3);\r\n                var offsetValue = ellipseGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\r\n                arrayFill(applyOffset, offsetValue);\r\n                geometry.attributes.applyOffset = new GeometryAttribute({\r\n                    componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\r\n                    componentsPerAttribute : 1,\r\n                    values: applyOffset\r\n                });\r\n            }\r\n        }\r\n\r\n        return new Geometry({\r\n            attributes : geometry.attributes,\r\n            indices : geometry.indices,\r\n            primitiveType : PrimitiveType.LINES,\r\n            boundingSphere : geometry.boundingSphere,\r\n            offsetAttribute : ellipseGeometry._offsetAttribute\r\n        });\r\n    };\r\nexport default EllipseOutlineGeometry;\r\n"],"names":["scratchCartesian1","Cartesian3","boundingSphereCenter","topBoundingSphere","BoundingSphere","bottomBoundingSphere","EllipseOutlineGeometry","options","center","defaultValue","EMPTY_OBJECT","ellipsoid","Ellipsoid","WGS84","semiMajorAxis","semiMinorAxis","granularity","CesiumMath","RADIANS_PER_DEGREE","defined","DeveloperError","height","extrudedHeight","this","_center","clone","_semiMajorAxis","_semiMinorAxis","_ellipsoid","_rotation","rotation","_height","Math","max","_granularity","_extrudedHeight","min","_numberOfVerticalLines","numberOfVerticalLines","_offsetAttribute","offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","scratchCenter","scratchEllipsoid","scratchOptions","undefined","unpack","result","createGeometry","ellipseGeometry","extrude","equalsEpsilon","EPSILON2","scaleToGeodeticSurface","geometry","scaledNormal","multiplyByScalar","geodeticSurfaceNormal","add","radius","positions","EllipseGeometryLibrary","computeEllipsePositions","outerPositions","attributes","GeometryAttributes","position","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","raisePositionsToHeight","boundingSphere","union","length","applyOffset","Uint8Array","GeometryOffsetAttribute","TOP","arrayFill","offsetValue","NONE","UNSIGNED_BYTE","clamp","indices","IndexDatatype","createTypedArray","i","numSide","index","numSideLines","round","maxI","computeExtrudedEllipse","computeEllipse","Geometry","primitiveType","PrimitiveType","LINES"],"mappings":"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"}