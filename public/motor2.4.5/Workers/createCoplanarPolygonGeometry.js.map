{"version":3,"file":"createCoplanarPolygonGeometry.js","sources":["../../../../Source/Core/CoplanarPolygonGeometry.js","../../../../Source/WorkersES6/createCoplanarPolygonGeometry.js"],"sourcesContent":["import arrayRemoveDuplicates from './arrayRemoveDuplicates.js';\r\nimport BoundingRectangle from './BoundingRectangle.js';\r\nimport BoundingSphere from './BoundingSphere.js';\r\nimport Cartesian2 from './Cartesian2.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport Check from './Check.js';\r\nimport ComponentDatatype from './ComponentDatatype.js';\r\nimport CoplanarPolygonGeometryLibrary from './CoplanarPolygonGeometryLibrary.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport Geometry from './Geometry.js';\r\nimport GeometryAttribute from './GeometryAttribute.js';\r\nimport GeometryAttributes from './GeometryAttributes.js';\r\nimport GeometryInstance from './GeometryInstance.js';\r\nimport GeometryPipeline from './GeometryPipeline.js';\r\nimport IndexDatatype from './IndexDatatype.js';\r\nimport CesiumMath from './Math.js';\r\nimport Matrix3 from './Matrix3.js';\r\nimport PolygonGeometryLibrary from './PolygonGeometryLibrary.js';\r\nimport PolygonPipeline from './PolygonPipeline.js';\r\nimport PrimitiveType from './PrimitiveType.js';\r\nimport Quaternion from './Quaternion.js';\r\nimport VertexFormat from './VertexFormat.js';\r\n\r\n    var scratchPosition = new Cartesian3();\r\n    var scratchBR = new BoundingRectangle();\r\n    var stScratch = new Cartesian2();\r\n    var textureCoordinatesOrigin = new Cartesian2();\r\n    var scratchNormal = new Cartesian3();\r\n    var scratchTangent = new Cartesian3();\r\n    var scratchBitangent = new Cartesian3();\r\n    var centerScratch = new Cartesian3();\r\n    var axis1Scratch = new Cartesian3();\r\n    var axis2Scratch = new Cartesian3();\r\n    var quaternionScratch = new Quaternion();\r\n    var textureMatrixScratch = new Matrix3();\r\n    var tangentRotationScratch = new Matrix3();\r\n    var surfaceNormalScratch = new Cartesian3();\r\n\r\n    function createGeometryFromPolygon(polygon, vertexFormat, boundingRectangle, stRotation, projectPointTo2D, normal, tangent, bitangent) {\r\n        var positions = polygon.positions;\r\n        var indices = PolygonPipeline.triangulate(polygon.positions2D, polygon.holes);\r\n\r\n        /* If polygon is completely unrenderable, just use the first three vertices */\r\n        if (indices.length < 3) {\r\n            indices = [0, 1, 2];\r\n        }\r\n\r\n        var newIndices = IndexDatatype.createTypedArray(positions.length, indices.length);\r\n        newIndices.set(indices);\r\n\r\n        var textureMatrix = textureMatrixScratch;\r\n        if (stRotation !== 0.0) {\r\n            var rotation = Quaternion.fromAxisAngle(normal, stRotation, quaternionScratch);\r\n            textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\r\n\r\n            if (vertexFormat.tangent || vertexFormat.bitangent) {\r\n                rotation = Quaternion.fromAxisAngle(normal, -stRotation, quaternionScratch);\r\n                var tangentRotation = Matrix3.fromQuaternion(rotation, tangentRotationScratch);\r\n\r\n                tangent = Cartesian3.normalize(Matrix3.multiplyByVector(tangentRotation, tangent, tangent), tangent);\r\n                if (vertexFormat.bitangent) {\r\n                    bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\r\n                }\r\n            }\r\n        } else {\r\n            textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\r\n        }\r\n\r\n        var stOrigin = textureCoordinatesOrigin;\r\n        if (vertexFormat.st) {\r\n            stOrigin.x = boundingRectangle.x;\r\n            stOrigin.y = boundingRectangle.y;\r\n        }\r\n\r\n        var length = positions.length;\r\n        var size = length * 3;\r\n        var flatPositions = new Float64Array(size);\r\n        var normals = vertexFormat.normal ? new Float32Array(size) : undefined;\r\n        var tangents = vertexFormat.tangent ? new Float32Array(size) : undefined;\r\n        var bitangents = vertexFormat.bitangent ? new Float32Array(size) : undefined;\r\n        var textureCoordinates = vertexFormat.st ? new Float32Array(length * 2) : undefined;\r\n\r\n        var positionIndex = 0;\r\n        var normalIndex = 0;\r\n        var bitangentIndex = 0;\r\n        var tangentIndex = 0;\r\n        var stIndex = 0;\r\n\r\n        for (var i = 0; i < length; i++) {\r\n            var position = positions[i];\r\n            flatPositions[positionIndex++] = position.x;\r\n            flatPositions[positionIndex++] = position.y;\r\n            flatPositions[positionIndex++] = position.z;\r\n\r\n            if (vertexFormat.st) {\r\n                var p = Matrix3.multiplyByVector(textureMatrix, position, scratchPosition);\r\n                var st = projectPointTo2D(p, stScratch);\r\n                Cartesian2.subtract(st, stOrigin, st);\r\n\r\n                var stx = CesiumMath.clamp(st.x / boundingRectangle.width, 0, 1);\r\n                var sty = CesiumMath.clamp(st.y / boundingRectangle.height, 0, 1);\r\n                textureCoordinates[stIndex++] = stx;\r\n                textureCoordinates[stIndex++] = sty;\r\n            }\r\n\r\n            if (vertexFormat.normal) {\r\n                normals[normalIndex++] = normal.x;\r\n                normals[normalIndex++] = normal.y;\r\n                normals[normalIndex++] = normal.z;\r\n            }\r\n\r\n            if (vertexFormat.tangent) {\r\n                tangents[tangentIndex++] = tangent.x;\r\n                tangents[tangentIndex++] = tangent.y;\r\n                tangents[tangentIndex++] = tangent.z;\r\n            }\r\n\r\n            if (vertexFormat.bitangent) {\r\n                bitangents[bitangentIndex++] = bitangent.x;\r\n                bitangents[bitangentIndex++] = bitangent.y;\r\n                bitangents[bitangentIndex++] = bitangent.z;\r\n            }\r\n        }\r\n\r\n        var attributes = new GeometryAttributes();\r\n\r\n        if (vertexFormat.position) {\r\n            attributes.position = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.DOUBLE,\r\n                componentsPerAttribute : 3,\r\n                values : flatPositions\r\n            });\r\n        }\r\n\r\n        if (vertexFormat.normal) {\r\n            attributes.normal = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.FLOAT,\r\n                componentsPerAttribute : 3,\r\n                values : normals\r\n            });\r\n        }\r\n\r\n        if (vertexFormat.tangent) {\r\n            attributes.tangent = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.FLOAT,\r\n                componentsPerAttribute : 3,\r\n                values : tangents\r\n            });\r\n        }\r\n\r\n        if (vertexFormat.bitangent) {\r\n            attributes.bitangent = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.FLOAT,\r\n                componentsPerAttribute : 3,\r\n                values : bitangents\r\n            });\r\n        }\r\n\r\n        if (vertexFormat.st) {\r\n            attributes.st = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.FLOAT,\r\n                componentsPerAttribute : 2,\r\n                values : textureCoordinates\r\n            });\r\n        }\r\n\r\n        return new Geometry({\r\n            attributes : attributes,\r\n            indices : newIndices,\r\n            primitiveType : PrimitiveType.TRIANGLES\r\n        });\r\n    }\r\n\r\n    /**\r\n     * A description of a polygon composed of arbitrary coplanar positions.\r\n     *\r\n     * @alias CoplanarPolygonGeometry\r\n     * @constructor\r\n     *\r\n     * @param {Object} options Object with the following properties:\r\n     * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\r\n     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\r\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\r\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\r\n     *\r\n     * @example\r\n     * var polygon = new Cesium.CoplanarPolygonGeometry({\r\n     *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\r\n     *      -90.0, 30.0, 0.0,\r\n     *      -90.0, 30.0, 1000.0,\r\n     *      -80.0, 30.0, 1000.0,\r\n     *      -80.0, 30.0, 0.0\r\n     *   ])\r\n     * });\r\n     * var geometry = Cesium.CoplanarPolygonGeometry.createGeometry(polygon);\r\n     *\r\n     * @see CoplanarPolygonGeometry.createGeometry\r\n     */\r\n    function CoplanarPolygonGeometry(options) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n        var polygonHierarchy = options.polygonHierarchy;\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('options.polygonHierarchy', polygonHierarchy);\r\n        //>>includeEnd('debug');\r\n\r\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\r\n        this._vertexFormat = VertexFormat.clone(vertexFormat);\r\n        this._polygonHierarchy = polygonHierarchy;\r\n        this._stRotation = defaultValue(options.stRotation, 0.0);\r\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\r\n        this._workerName = 'createCoplanarPolygonGeometry';\r\n\r\n        /**\r\n         * The number of elements used to pack the object into an array.\r\n         * @type {Number}\r\n         */\r\n        this.packedLength = PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) + VertexFormat.packedLength + Ellipsoid.packedLength + 2;\r\n    }\r\n\r\n    /**\r\n     * A description of a coplanar polygon from an array of positions.\r\n     *\r\n     * @param {Object} options Object with the following properties:\r\n     * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\r\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\r\n     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\r\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\r\n     * @returns {CoplanarPolygonGeometry}\r\n     *\r\n     * @example\r\n     * // create a polygon from points\r\n     * var polygon = Cesium.CoplanarPolygonGeometry.fromPositions({\r\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\r\n     *     -72.0, 40.0,\r\n     *     -70.0, 35.0,\r\n     *     -75.0, 30.0,\r\n     *     -70.0, 30.0,\r\n     *     -68.0, 40.0\r\n     *   ])\r\n     * });\r\n     * var geometry = Cesium.PolygonGeometry.createGeometry(polygon);\r\n     *\r\n     * @see PolygonGeometry#createGeometry\r\n     */\r\n    CoplanarPolygonGeometry.fromPositions = function(options) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('options.positions', options.positions);\r\n        //>>includeEnd('debug');\r\n\r\n        var newOptions = {\r\n            polygonHierarchy : {\r\n                positions : options.positions\r\n            },\r\n            vertexFormat : options.vertexFormat,\r\n            stRotation : options.stRotation,\r\n            ellipsoid : options.ellipsoid\r\n        };\r\n        return new CoplanarPolygonGeometry(newOptions);\r\n    };\r\n\r\n    /**\r\n     * Stores the provided instance into the provided array.\r\n     *\r\n     * @param {CoplanarPolygonGeometry} value The value to pack.\r\n     * @param {Number[]} array The array to pack into.\r\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n     *\r\n     * @returns {Number[]} The array that was packed into\r\n     */\r\n    CoplanarPolygonGeometry.pack = function(value, array, startingIndex) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('value', value);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._polygonHierarchy, array, startingIndex);\r\n\r\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\r\n        startingIndex += Ellipsoid.packedLength;\r\n\r\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\r\n        startingIndex += VertexFormat.packedLength;\r\n\r\n        array[startingIndex++] = value._stRotation;\r\n        array[startingIndex] = value.packedLength;\r\n\r\n        return array;\r\n    };\r\n\r\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\r\n    var scratchVertexFormat = new VertexFormat();\r\n    var scratchOptions = {\r\n        polygonHierarchy : {}\r\n    };\r\n    /**\r\n     * Retrieves an instance from a packed array.\r\n     *\r\n     * @param {Number[]} array The packed array.\r\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n     * @param {CoplanarPolygonGeometry} [result] The object into which to store the result.\r\n     * @returns {CoplanarPolygonGeometry} The modified result parameter or a new CoplanarPolygonGeometry instance if one was not provided.\r\n     */\r\n    CoplanarPolygonGeometry.unpack = function(array, startingIndex, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex);\r\n        startingIndex = polygonHierarchy.startingIndex;\r\n        delete polygonHierarchy.startingIndex;\r\n\r\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\r\n        startingIndex += Ellipsoid.packedLength;\r\n\r\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\r\n        startingIndex += VertexFormat.packedLength;\r\n\r\n        var stRotation = array[startingIndex++];\r\n        var packedLength = array[startingIndex];\r\n\r\n        if (!defined(result)) {\r\n            result = new CoplanarPolygonGeometry(scratchOptions);\r\n        }\r\n\r\n        result._polygonHierarchy = polygonHierarchy;\r\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\r\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\r\n        result._stRotation = stRotation;\r\n        result.packedLength = packedLength;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the geometric representation of an arbitrary coplanar polygon, including its vertices, indices, and a bounding sphere.\r\n     *\r\n     * @param {CoplanarPolygonGeometry} polygonGeometry A description of the polygon.\r\n     * @returns {Geometry|undefined} The computed vertices and indices.\r\n     */\r\n    CoplanarPolygonGeometry.createGeometry = function(polygonGeometry) {\r\n        var vertexFormat = polygonGeometry._vertexFormat;\r\n        var polygonHierarchy = polygonGeometry._polygonHierarchy;\r\n        var stRotation = polygonGeometry._stRotation;\r\n\r\n        var outerPositions = polygonHierarchy.positions;\r\n        outerPositions = arrayRemoveDuplicates(outerPositions, Cartesian3.equalsEpsilon, true);\r\n        if (outerPositions.length < 3) {\r\n            return;\r\n        }\r\n\r\n        var normal = scratchNormal;\r\n        var tangent = scratchTangent;\r\n        var bitangent = scratchBitangent;\r\n        var axis1 = axis1Scratch;\r\n        var axis2 = axis2Scratch;\r\n\r\n        var validGeometry = CoplanarPolygonGeometryLibrary.computeProjectTo2DArguments(outerPositions, centerScratch, axis1, axis2);\r\n        if (!validGeometry) {\r\n            return undefined;\r\n        }\r\n\r\n        normal = Cartesian3.cross(axis1, axis2, normal);\r\n        normal = Cartesian3.normalize(normal, normal);\r\n\r\n        if (!Cartesian3.equalsEpsilon(centerScratch, Cartesian3.ZERO, CesiumMath.EPSILON6)) {\r\n            var surfaceNormal = polygonGeometry._ellipsoid.geodeticSurfaceNormal(centerScratch, surfaceNormalScratch);\r\n            if (Cartesian3.dot(normal, surfaceNormal) < 0) {\r\n                normal = Cartesian3.negate(normal, normal);\r\n                axis1 = Cartesian3.negate(axis1, axis1);\r\n            }\r\n        }\r\n\r\n        var projectPoints = CoplanarPolygonGeometryLibrary.createProjectPointsTo2DFunction(centerScratch, axis1, axis2);\r\n        var projectPoint = CoplanarPolygonGeometryLibrary.createProjectPointTo2DFunction(centerScratch, axis1, axis2);\r\n\r\n        if (vertexFormat.tangent) {\r\n            tangent = Cartesian3.clone(axis1, tangent);\r\n        }\r\n        if (vertexFormat.bitangent) {\r\n            bitangent = Cartesian3.clone(axis2, bitangent);\r\n        }\r\n\r\n        var results = PolygonGeometryLibrary.polygonsFromHierarchy(polygonHierarchy, projectPoints, false);\r\n        var hierarchy = results.hierarchy;\r\n        var polygons = results.polygons;\r\n\r\n        if (hierarchy.length === 0) {\r\n            return;\r\n        }\r\n        outerPositions = hierarchy[0].outerRing;\r\n\r\n        var boundingSphere = BoundingSphere.fromPoints(outerPositions);\r\n        var boundingRectangle = PolygonGeometryLibrary.computeBoundingRectangle(normal, projectPoint, outerPositions, stRotation, scratchBR);\r\n\r\n        var geometries = [];\r\n        for (var i = 0; i < polygons.length; i++) {\r\n            var geometryInstance = new GeometryInstance({\r\n                geometry : createGeometryFromPolygon(polygons[i], vertexFormat, boundingRectangle, stRotation, projectPoint, normal, tangent, bitangent)\r\n            });\r\n\r\n            geometries.push(geometryInstance);\r\n        }\r\n\r\n        var geometry = GeometryPipeline.combineInstances(geometries)[0];\r\n        geometry.attributes.position.values = new Float64Array(geometry.attributes.position.values);\r\n        geometry.indices = IndexDatatype.createTypedArray(geometry.attributes.position.values.length / 3, geometry.indices);\r\n\r\n        var attributes = geometry.attributes;\r\n        if (!vertexFormat.position) {\r\n            delete attributes.position;\r\n        }\r\n        return new Geometry({\r\n            attributes : attributes,\r\n            indices : geometry.indices,\r\n            primitiveType : geometry.primitiveType,\r\n            boundingSphere : boundingSphere\r\n        });\r\n    };\r\nexport default CoplanarPolygonGeometry;\r\n","import CoplanarPolygonGeometry from '../Core/CoplanarPolygonGeometry.js';\r\nimport defined from '../Core/defined.js';\r\n\r\n    function createCoplanarPolygonGeometry(polygonGeometry, offset) {\r\n        if (defined(offset)) {\r\n            polygonGeometry = CoplanarPolygonGeometry.unpack(polygonGeometry, offset);\r\n        }\r\n        return CoplanarPolygonGeometry.createGeometry(polygonGeometry);\r\n    }\r\nexport default createCoplanarPolygonGeometry;\r\n"],"names":["scratchPosition","Cartesian3","scratchBR","BoundingRectangle","stScratch","Cartesian2","textureCoordinatesOrigin","scratchNormal","scratchTangent","scratchBitangent","centerScratch","axis1Scratch","axis2Scratch","quaternionScratch","Quaternion","textureMatrixScratch","Matrix3","tangentRotationScratch","surfaceNormalScratch","createGeometryFromPolygon","polygon","vertexFormat","boundingRectangle","stRotation","projectPointTo2D","normal","tangent","bitangent","positions","indices","PolygonPipeline","triangulate","positions2D","holes","length","newIndices","IndexDatatype","createTypedArray","set","textureMatrix","rotation","fromAxisAngle","fromQuaternion","tangentRotation","normalize","multiplyByVector","cross","clone","IDENTITY","stOrigin","st","x","y","size","flatPositions","Float64Array","normals","Float32Array","undefined","tangents","bitangents","textureCoordinates","positionIndex","normalIndex","bitangentIndex","tangentIndex","stIndex","i","position","z","subtract","stx","CesiumMath","clamp","width","sty","height","attributes","GeometryAttributes","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","FLOAT","Geometry","primitiveType","PrimitiveType","TRIANGLES","CoplanarPolygonGeometry","options","polygonHierarchy","defaultValue","EMPTY_OBJECT","Check","defined","VertexFormat","DEFAULT","this","_vertexFormat","_polygonHierarchy","_stRotation","_ellipsoid","Ellipsoid","ellipsoid","WGS84","_workerName","packedLength","PolygonGeometryLibrary","computeHierarchyPackedLength","fromPositions","pack","value","array","startingIndex","typeOf","object","packPolygonHierarchy","scratchEllipsoid","UNIT_SPHERE","scratchVertexFormat","scratchOptions","unpack","result","unpackPolygonHierarchy","createGeometry","polygonGeometry","outerPositions","arrayRemoveDuplicates","equalsEpsilon","axis1","axis2","CoplanarPolygonGeometryLibrary","computeProjectTo2DArguments","ZERO","EPSILON6","surfaceNormal","geodeticSurfaceNormal","dot","negate","projectPoints","createProjectPointsTo2DFunction","projectPoint","createProjectPointTo2DFunction","results","polygonsFromHierarchy","hierarchy","polygons","outerRing","boundingSphere","BoundingSphere","fromPoints","computeBoundingRectangle","geometries","geometryInstance","GeometryInstance","geometry","push","GeometryPipeline","combineInstances","offset"],"mappings":"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"}