{"version":3,"file":"EllipsoidGeodesic-2bb1f4ee.js","sources":["../../../../Source/Core/EllipsoidGeodesic.js"],"sourcesContent":["import Cartesian3 from './Cartesian3.js';\r\nimport Cartographic from './Cartographic.js';\r\nimport Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport CesiumMath from './Math.js';\r\n\r\n    function setConstants(ellipsoidGeodesic) {\r\n        var uSquared = ellipsoidGeodesic._uSquared;\r\n        var a = ellipsoidGeodesic._ellipsoid.maximumRadius;\r\n        var b = ellipsoidGeodesic._ellipsoid.minimumRadius;\r\n        var f = (a - b) / a;\r\n\r\n        var cosineHeading = Math.cos(ellipsoidGeodesic._startHeading);\r\n        var sineHeading = Math.sin(ellipsoidGeodesic._startHeading);\r\n\r\n        var tanU = (1 - f) * Math.tan(ellipsoidGeodesic._start.latitude);\r\n\r\n        var cosineU = 1.0 / Math.sqrt(1.0 + tanU * tanU);\r\n        var sineU = cosineU * tanU;\r\n\r\n        var sigma = Math.atan2(tanU, cosineHeading);\r\n\r\n        var sineAlpha = cosineU * sineHeading;\r\n        var sineSquaredAlpha = sineAlpha * sineAlpha;\r\n\r\n        var cosineSquaredAlpha = 1.0 - sineSquaredAlpha;\r\n        var cosineAlpha = Math.sqrt(cosineSquaredAlpha);\r\n\r\n        var u2Over4 = uSquared / 4.0;\r\n        var u4Over16 = u2Over4 * u2Over4;\r\n        var u6Over64 = u4Over16 * u2Over4;\r\n        var u8Over256 = u4Over16 * u4Over16;\r\n\r\n        var a0 = (1.0 + u2Over4 - 3.0 * u4Over16 / 4.0 + 5.0 * u6Over64 / 4.0 - 175.0 * u8Over256 / 64.0);\r\n        var a1 = (1.0 - u2Over4 + 15.0 * u4Over16 / 8.0 - 35.0 * u6Over64 / 8.0);\r\n        var a2 = (1.0 - 3.0 * u2Over4 + 35.0 * u4Over16 / 4.0);\r\n        var a3 = (1.0 - 5.0 * u2Over4);\r\n\r\n        var distanceRatio = a0 * sigma - a1 * Math.sin(2.0 * sigma) * u2Over4 / 2.0 - a2 * Math.sin(4.0 * sigma) * u4Over16 / 16.0 -\r\n                            a3 * Math.sin(6.0 * sigma) * u6Over64 / 48.0 - Math.sin(8.0 * sigma) * 5.0 * u8Over256 / 512;\r\n\r\n        var constants = ellipsoidGeodesic._constants;\r\n\r\n        constants.a = a;\r\n        constants.b = b;\r\n        constants.f = f;\r\n        constants.cosineHeading = cosineHeading;\r\n        constants.sineHeading = sineHeading;\r\n        constants.tanU = tanU;\r\n        constants.cosineU = cosineU;\r\n        constants.sineU = sineU;\r\n        constants.sigma = sigma;\r\n        constants.sineAlpha = sineAlpha;\r\n        constants.sineSquaredAlpha = sineSquaredAlpha;\r\n        constants.cosineSquaredAlpha = cosineSquaredAlpha;\r\n        constants.cosineAlpha = cosineAlpha;\r\n        constants.u2Over4 = u2Over4;\r\n        constants.u4Over16 = u4Over16;\r\n        constants.u6Over64 = u6Over64;\r\n        constants.u8Over256 = u8Over256;\r\n        constants.a0 = a0;\r\n        constants.a1 = a1;\r\n        constants.a2 = a2;\r\n        constants.a3 = a3;\r\n        constants.distanceRatio = distanceRatio;\r\n    }\r\n\r\n    function computeC(f, cosineSquaredAlpha) {\r\n        return f * cosineSquaredAlpha * (4.0 + f * (4.0 - 3.0 * cosineSquaredAlpha)) / 16.0;\r\n    }\r\n\r\n    function computeDeltaLambda(f, sineAlpha, cosineSquaredAlpha, sigma, sineSigma, cosineSigma, cosineTwiceSigmaMidpoint) {\r\n        var C = computeC(f, cosineSquaredAlpha);\r\n\r\n        return (1.0 - C) * f * sineAlpha * (sigma + C * sineSigma * (cosineTwiceSigmaMidpoint +\r\n                C * cosineSigma * (2.0 * cosineTwiceSigmaMidpoint * cosineTwiceSigmaMidpoint - 1.0)));\r\n    }\r\n\r\n    function vincentyInverseFormula(ellipsoidGeodesic, major, minor, firstLongitude, firstLatitude, secondLongitude, secondLatitude) {\r\n        var eff = (major - minor) / major;\r\n        var l = secondLongitude - firstLongitude;\r\n\r\n        var u1 = Math.atan((1 - eff) * Math.tan(firstLatitude));\r\n        var u2 = Math.atan((1 - eff) * Math.tan(secondLatitude));\r\n\r\n        var cosineU1 = Math.cos(u1);\r\n        var sineU1 = Math.sin(u1);\r\n        var cosineU2 = Math.cos(u2);\r\n        var sineU2 = Math.sin(u2);\r\n\r\n        var cc = cosineU1 * cosineU2;\r\n        var cs = cosineU1 * sineU2;\r\n        var ss = sineU1 * sineU2;\r\n        var sc = sineU1 * cosineU2;\r\n\r\n        var lambda = l;\r\n        var lambdaDot = CesiumMath.TWO_PI;\r\n\r\n        var cosineLambda = Math.cos(lambda);\r\n        var sineLambda = Math.sin(lambda);\r\n\r\n        var sigma;\r\n        var cosineSigma;\r\n        var sineSigma;\r\n        var cosineSquaredAlpha;\r\n        var cosineTwiceSigmaMidpoint;\r\n\r\n        do {\r\n            cosineLambda = Math.cos(lambda);\r\n            sineLambda = Math.sin(lambda);\r\n\r\n            var temp = cs - sc * cosineLambda;\r\n            sineSigma = Math.sqrt(cosineU2 * cosineU2 * sineLambda * sineLambda + temp * temp);\r\n            cosineSigma = ss + cc * cosineLambda;\r\n\r\n            sigma = Math.atan2(sineSigma, cosineSigma);\r\n\r\n            var sineAlpha;\r\n\r\n            if (sineSigma === 0.0) {\r\n                sineAlpha = 0.0;\r\n                cosineSquaredAlpha = 1.0;\r\n            } else {\r\n                sineAlpha = cc * sineLambda / sineSigma;\r\n                cosineSquaredAlpha = 1.0 - sineAlpha * sineAlpha;\r\n            }\r\n\r\n            lambdaDot = lambda;\r\n\r\n            cosineTwiceSigmaMidpoint = cosineSigma - 2.0 * ss / cosineSquaredAlpha;\r\n\r\n            if (isNaN(cosineTwiceSigmaMidpoint)) {\r\n                cosineTwiceSigmaMidpoint = 0.0;\r\n            }\r\n\r\n            lambda = l + computeDeltaLambda(eff, sineAlpha, cosineSquaredAlpha,\r\n                                            sigma, sineSigma, cosineSigma, cosineTwiceSigmaMidpoint);\r\n        } while (Math.abs(lambda - lambdaDot) > CesiumMath.EPSILON12);\r\n\r\n        var uSquared = cosineSquaredAlpha * (major * major - minor * minor) / (minor * minor);\r\n        var A = 1.0 + uSquared * (4096.0 + uSquared * (uSquared * (320.0 - 175.0 * uSquared) - 768.0)) / 16384.0;\r\n        var B = uSquared * (256.0 + uSquared * (uSquared * (74.0 - 47.0 * uSquared) - 128.0)) / 1024.0;\r\n\r\n        var cosineSquaredTwiceSigmaMidpoint = cosineTwiceSigmaMidpoint * cosineTwiceSigmaMidpoint;\r\n        var deltaSigma = B * sineSigma * (cosineTwiceSigmaMidpoint + B * (cosineSigma *\r\n                (2.0 * cosineSquaredTwiceSigmaMidpoint - 1.0) - B * cosineTwiceSigmaMidpoint *\r\n                (4.0 * sineSigma * sineSigma - 3.0) * (4.0 * cosineSquaredTwiceSigmaMidpoint - 3.0) / 6.0) / 4.0);\r\n\r\n        var distance = minor * A * (sigma - deltaSigma);\r\n\r\n        var startHeading = Math.atan2(cosineU2 * sineLambda, cs - sc * cosineLambda);\r\n        var endHeading = Math.atan2(cosineU1 * sineLambda, cs * cosineLambda - sc);\r\n\r\n        ellipsoidGeodesic._distance = distance;\r\n        ellipsoidGeodesic._startHeading = startHeading;\r\n        ellipsoidGeodesic._endHeading = endHeading;\r\n        ellipsoidGeodesic._uSquared = uSquared;\r\n    }\r\n\r\n    var scratchCart1 = new Cartesian3();\r\n    var scratchCart2 = new Cartesian3();\r\n    function computeProperties(ellipsoidGeodesic, start, end, ellipsoid) {\r\n        var firstCartesian = Cartesian3.normalize(ellipsoid.cartographicToCartesian(start, scratchCart2), scratchCart1);\r\n        var lastCartesian = Cartesian3.normalize(ellipsoid.cartographicToCartesian(end, scratchCart2), scratchCart2);\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.number.greaterThanOrEquals('value', Math.abs(Math.abs(Cartesian3.angleBetween(firstCartesian, lastCartesian)) - Math.PI), 0.0125);\r\n        //>>includeEnd('debug');\r\n\r\n        vincentyInverseFormula(ellipsoidGeodesic, ellipsoid.maximumRadius, ellipsoid.minimumRadius,\r\n                               start.longitude, start.latitude, end.longitude, end.latitude);\r\n\r\n        ellipsoidGeodesic._start = Cartographic.clone(start, ellipsoidGeodesic._start);\r\n        ellipsoidGeodesic._end = Cartographic.clone(end, ellipsoidGeodesic._end);\r\n        ellipsoidGeodesic._start.height = 0;\r\n        ellipsoidGeodesic._end.height = 0;\r\n\r\n        setConstants(ellipsoidGeodesic);\r\n    }\r\n\r\n    /**\r\n     * Initializes a geodesic on the ellipsoid connecting the two provided planetodetic points.\r\n     *\r\n     * @alias EllipsoidGeodesic\r\n     * @constructor\r\n     *\r\n     * @param {Cartographic} [start] The initial planetodetic point on the path.\r\n     * @param {Cartographic} [end] The final planetodetic point on the path.\r\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the geodesic lies.\r\n     */\r\n    function EllipsoidGeodesic(start, end, ellipsoid) {\r\n        var e = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n        this._ellipsoid = e;\r\n        this._start = new Cartographic();\r\n        this._end = new Cartographic();\r\n\r\n        this._constants = {};\r\n        this._startHeading = undefined;\r\n        this._endHeading = undefined;\r\n        this._distance = undefined;\r\n        this._uSquared = undefined;\r\n\r\n        if (defined(start) && defined(end)) {\r\n            computeProperties(this, start, end, e);\r\n        }\r\n    }\r\n\r\n    Object.defineProperties(EllipsoidGeodesic.prototype, {\r\n        /**\r\n         * Gets the ellipsoid.\r\n         * @memberof EllipsoidGeodesic.prototype\r\n         * @type {Ellipsoid}\r\n         * @readonly\r\n         */\r\n        ellipsoid : {\r\n            get : function() {\r\n                return this._ellipsoid;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Gets the surface distance between the start and end point\r\n         * @memberof EllipsoidGeodesic.prototype\r\n         * @type {Number}\r\n         * @readonly\r\n         */\r\n        surfaceDistance : {\r\n            get : function() {\r\n                //>>includeStart('debug', pragmas.debug);\r\n                Check.defined('distance', this._distance);\r\n                //>>includeEnd('debug');\r\n\r\n                return this._distance;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Gets the initial planetodetic point on the path.\r\n         * @memberof EllipsoidGeodesic.prototype\r\n         * @type {Cartographic}\r\n         * @readonly\r\n         */\r\n        start : {\r\n            get : function() {\r\n                return this._start;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Gets the final planetodetic point on the path.\r\n         * @memberof EllipsoidGeodesic.prototype\r\n         * @type {Cartographic}\r\n         * @readonly\r\n         */\r\n        end : {\r\n            get : function() {\r\n                return this._end;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Gets the heading at the initial point.\r\n         * @memberof EllipsoidGeodesic.prototype\r\n         * @type {Number}\r\n         * @readonly\r\n         */\r\n        startHeading : {\r\n            get : function() {\r\n                //>>includeStart('debug', pragmas.debug);\r\n                Check.defined('distance', this._distance);\r\n                //>>includeEnd('debug');\r\n\r\n                return this._startHeading;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Gets the heading at the final point.\r\n         * @memberof EllipsoidGeodesic.prototype\r\n         * @type {Number}\r\n         * @readonly\r\n         */\r\n        endHeading : {\r\n            get : function() {\r\n                //>>includeStart('debug', pragmas.debug);\r\n                Check.defined('distance', this._distance);\r\n                //>>includeEnd('debug');\r\n\r\n                return this._endHeading;\r\n            }\r\n        }\r\n    });\r\n\r\n    /**\r\n     * Sets the start and end points of the geodesic\r\n     *\r\n     * @param {Cartographic} start The initial planetodetic point on the path.\r\n     * @param {Cartographic} end The final planetodetic point on the path.\r\n     */\r\n    EllipsoidGeodesic.prototype.setEndPoints = function(start, end) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('start', start);\r\n        Check.defined('end', end);\r\n        //>>includeEnd('debug');\r\n\r\n        computeProperties(this, start, end, this._ellipsoid);\r\n    };\r\n\r\n    /**\r\n     * Provides the location of a point at the indicated portion along the geodesic.\r\n     *\r\n     * @param {Number} fraction The portion of the distance between the initial and final points.\r\n     * @param {Cartographic} result The object in which to store the result.\r\n     * @returns {Cartographic} The location of the point along the geodesic.\r\n     */\r\n    EllipsoidGeodesic.prototype.interpolateUsingFraction = function(fraction, result) {\r\n        return this.interpolateUsingSurfaceDistance(this._distance * fraction, result);\r\n    };\r\n\r\n    /**\r\n     * Provides the location of a point at the indicated distance along the geodesic.\r\n     *\r\n     * @param {Number} distance The distance from the inital point to the point of interest along the geodesic\r\n     * @param {Cartographic} result The object in which to store the result.\r\n     * @returns {Cartographic} The location of the point along the geodesic.\r\n     *\r\n     * @exception {DeveloperError} start and end must be set before calling function interpolateUsingSurfaceDistance\r\n     */\r\n    EllipsoidGeodesic.prototype.interpolateUsingSurfaceDistance = function(distance, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('distance', this._distance);\r\n        //>>includeEnd('debug');\r\n\r\n        var constants = this._constants;\r\n\r\n        var s = constants.distanceRatio + distance / constants.b;\r\n\r\n        var cosine2S = Math.cos(2.0 * s);\r\n        var cosine4S = Math.cos(4.0 * s);\r\n        var cosine6S = Math.cos(6.0 * s);\r\n        var sine2S = Math.sin(2.0 * s);\r\n        var sine4S = Math.sin(4.0 * s);\r\n        var sine6S = Math.sin(6.0 * s);\r\n        var sine8S = Math.sin(8.0 * s);\r\n\r\n        var s2 = s * s;\r\n        var s3 = s * s2;\r\n\r\n        var u8Over256 = constants.u8Over256;\r\n        var u2Over4 = constants.u2Over4;\r\n        var u6Over64 = constants.u6Over64;\r\n        var u4Over16 = constants.u4Over16;\r\n        var sigma = 2.0 * s3 * u8Over256 * cosine2S / 3.0 +\r\n            s * (1.0 - u2Over4 + 7.0 * u4Over16 / 4.0 - 15.0 * u6Over64 / 4.0 + 579.0 * u8Over256 / 64.0 -\r\n            (u4Over16 - 15.0 * u6Over64 / 4.0 + 187.0 * u8Over256 / 16.0) * cosine2S -\r\n            (5.0 * u6Over64 / 4.0 - 115.0 * u8Over256 / 16.0) * cosine4S -\r\n            29.0 * u8Over256 * cosine6S / 16.0) +\r\n            (u2Over4 / 2.0 - u4Over16 + 71.0 * u6Over64 / 32.0 - 85.0 * u8Over256 / 16.0) * sine2S +\r\n            (5.0 * u4Over16 / 16.0 - 5.0 * u6Over64 / 4.0 + 383.0 * u8Over256 / 96.0) * sine4S -\r\n            s2 * ((u6Over64 - 11.0 * u8Over256 / 2.0) * sine2S + 5.0 * u8Over256 * sine4S / 2.0) +\r\n            (29.0 * u6Over64 / 96.0 - 29.0 * u8Over256 / 16.0) * sine6S +\r\n            539.0 * u8Over256 * sine8S / 1536.0;\r\n\r\n        var theta = Math.asin(Math.sin(sigma) * constants.cosineAlpha);\r\n        var latitude = Math.atan(constants.a / constants.b * Math.tan(theta));\r\n\r\n        // Redefine in terms of relative argument of latitude.\r\n        sigma = sigma - constants.sigma;\r\n\r\n        var cosineTwiceSigmaMidpoint = Math.cos(2.0 * constants.sigma + sigma);\r\n\r\n        var sineSigma = Math.sin(sigma);\r\n        var cosineSigma = Math.cos(sigma);\r\n\r\n        var cc = constants.cosineU * cosineSigma;\r\n        var ss = constants.sineU * sineSigma;\r\n\r\n        var lambda = Math.atan2(sineSigma * constants.sineHeading, cc - ss * constants.cosineHeading);\r\n\r\n        var l = lambda - computeDeltaLambda(constants.f, constants.sineAlpha, constants.cosineSquaredAlpha,\r\n                                            sigma, sineSigma, cosineSigma, cosineTwiceSigmaMidpoint);\r\n\r\n        if (defined(result)) {\r\n            result.longitude = this._start.longitude + l;\r\n            result.latitude = latitude;\r\n            result.height = 0.0;\r\n            return result;\r\n        }\r\n\r\n        return new Cartographic(this._start.longitude + l, latitude, 0.0);\r\n    };\r\nexport default EllipsoidGeodesic;\r\n"],"names":["computeDeltaLambda","f","sineAlpha","cosineSquaredAlpha","sigma","sineSigma","cosineSigma","cosineTwiceSigmaMidpoint","C","computeC","scratchCart1","Cartesian3","scratchCart2","computeProperties","ellipsoidGeodesic","start","end","ellipsoid","firstCartesian","normalize","cartographicToCartesian","lastCartesian","Check","typeOf","number","greaterThanOrEquals","Math","abs","angleBetween","PI","major","minor","firstLongitude","firstLatitude","secondLongitude","secondLatitude","eff","l","u1","atan","tan","u2","cosineU1","cos","sineU1","sin","cosineU2","sineU2","cc","cs","ss","sc","lambda","lambdaDot","CesiumMath","TWO_PI","cosineLambda","sineLambda","temp","sqrt","atan2","isNaN","EPSILON12","uSquared","B","cosineSquaredTwiceSigmaMidpoint","distance","startHeading","endHeading","_distance","_startHeading","_endHeading","_uSquared","vincentyInverseFormula","maximumRadius","minimumRadius","longitude","latitude","_start","Cartographic","clone","_end","height","a","_ellipsoid","b","cosineHeading","sineHeading","tanU","cosineU","sineU","sineSquaredAlpha","cosineAlpha","u2Over4","u4Over16","u6Over64","u8Over256","a0","a1","a2","a3","distanceRatio","constants","_constants","setConstants","EllipsoidGeodesic","e","defaultValue","Ellipsoid","WGS84","this","undefined","defined","Object","defineProperties","prototype","get","surfaceDistance","setEndPoints","interpolateUsingFraction","fraction","result","interpolateUsingSurfaceDistance","s","cosine2S","cosine4S","cosine6S","sine2S","sine4S","sine6S","sine8S","s2","s3","theta","asin"],"mappings":"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"}